// Generated from ./grammars-v4/cobol85/Cobol85.g4 by ANTLR 4.7.1
import Antlr4

open class Cobol85Parser: Parser {

	internal static var _decisionToDFA: [DFA] = {
          var decisionToDFA = [DFA]()
          let length = Cobol85Parser._ATN.getNumberOfDecisions()
          for i in 0..<length {
            decisionToDFA.append(DFA(Cobol85Parser._ATN.getDecisionState(i)!, i))
           }
           return decisionToDFA
     }()

	internal static let _sharedContextCache = PredictionContextCache()

	public
	enum Tokens: Int {
		case EOF = -1, ABORT = 1, ACCEPT = 2, ACCESS = 3, ADD = 4, ADDRESS = 5, 
                 ADVANCING = 6, AFTER = 7, ALIGNED = 8, ALL = 9, ALPHABET = 10, 
                 ALPHABETIC = 11, ALPHABETIC_LOWER = 12, ALPHABETIC_UPPER = 13, 
                 ALPHANUMERIC = 14, ALPHANUMERIC_EDITED = 15, ALSO = 16, 
                 ALTER = 17, ALTERNATE = 18, AND = 19, ANY = 20, ARE = 21, 
                 AREA = 22, AREAS = 23, AS = 24, ASCENDING = 25, ASCII = 26, 
                 ASSIGN = 27, ASSOCIATED_DATA = 28, ASSOCIATED_DATA_LENGTH = 29, 
                 AT = 30, ATTRIBUTE = 31, AUTHOR = 32, AUTO = 33, AUTO_SKIP = 34, 
                 BACKGROUND_COLOR = 35, BACKGROUND_COLOUR = 36, BASIS = 37, 
                 BEEP = 38, BEFORE = 39, BEGINNING = 40, BELL = 41, BINARY = 42, 
                 BIT = 43, BLANK = 44, BLINK = 45, BLOCK = 46, BOUNDS = 47, 
                 BOTTOM = 48, BY = 49, BYFUNCTION = 50, BYTITLE = 51, CALL = 52, 
                 CANCEL = 53, CAPABLE = 54, CCSVERSION = 55, CD = 56, CF = 57, 
                 CH = 58, CHAINING = 59, CHANGED = 60, CHANNEL = 61, CHARACTER = 62, 
                 CHARACTERS = 63, CLASS = 64, CLASS_ID = 65, CLOCK_UNITS = 66, 
                 CLOSE = 67, CLOSE_DISPOSITION = 68, COBOL = 69, CODE = 70, 
                 CODE_SET = 71, COLLATING = 72, COL = 73, COLUMN = 74, COM_REG = 75, 
                 COMMA = 76, COMMITMENT = 77, COMMON = 78, COMMUNICATION = 79, 
                 COMP = 80, COMP_1 = 81, COMP_2 = 82, COMP_3 = 83, COMP_4 = 84, 
                 COMP_5 = 85, COMPUTATIONAL = 86, COMPUTATIONAL_1 = 87, 
                 COMPUTATIONAL_2 = 88, COMPUTATIONAL_3 = 89, COMPUTATIONAL_4 = 90, 
                 COMPUTATIONAL_5 = 91, COMPUTE = 92, CONFIGURATION = 93, 
                 CONTAINS = 94, CONTENT = 95, CONTINUE = 96, CONTROL = 97, 
                 CONTROL_POINT = 98, CONTROLS = 99, CONVENTION = 100, CONVERTING = 101, 
                 COPY = 102, CORR = 103, CORRESPONDING = 104, COUNT = 105, 
                 CRUNCH = 106, CURRENCY = 107, CURSOR = 108, DATA = 109, 
                 DATA_BASE = 110, DATE = 111, DATE_COMPILED = 112, DATE_WRITTEN = 113, 
                 DAY = 114, DAY_OF_WEEK = 115, DBCS = 116, DE = 117, DEBUG_CONTENTS = 118, 
                 DEBUG_ITEM = 119, DEBUG_LINE = 120, DEBUG_NAME = 121, DEBUG_SUB_1 = 122, 
                 DEBUG_SUB_2 = 123, DEBUG_SUB_3 = 124, DEBUGGING = 125, 
                 DECIMAL_POINT = 126, DECLARATIVES = 127, DEFAULT = 128, 
                 DEFAULT_DISPLAY = 129, DEFINITION = 130, DELETE = 131, 
                 DELIMITED = 132, DELIMITER = 133, DEPENDING = 134, DESCENDING = 135, 
                 DESTINATION = 136, DETAIL = 137, DFHRESP = 138, DFHVALUE = 139, 
                 DISABLE = 140, DISK = 141, DISPLAY = 142, DISPLAY_1 = 143, 
                 DIVIDE = 144, DIVISION = 145, DONTCARE = 146, DOUBLE = 147, 
                 DOWN = 148, DUPLICATES = 149, DYNAMIC = 150, EBCDIC = 151, 
                 EGCS = 152, EGI = 153, ELSE = 154, EMI = 155, EMPTY_CHECK = 156, 
                 ENABLE = 157, END = 158, END_ACCEPT = 159, END_ADD = 160, 
                 END_CALL = 161, END_COMPUTE = 162, END_DELETE = 163, END_DIVIDE = 164, 
                 END_EVALUATE = 165, END_IF = 166, END_MULTIPLY = 167, END_OF_PAGE = 168, 
                 END_PERFORM = 169, END_READ = 170, END_RECEIVE = 171, END_RETURN = 172, 
                 END_REWRITE = 173, END_SEARCH = 174, END_START = 175, END_STRING = 176, 
                 END_SUBTRACT = 177, END_UNSTRING = 178, END_WRITE = 179, 
                 ENDING = 180, ENTER = 181, ENTRY = 182, ENTRY_PROCEDURE = 183, 
                 ENVIRONMENT = 184, EOP = 185, EQUAL = 186, ERASE = 187, 
                 ERROR = 188, EOL = 189, EOS = 190, ESCAPE = 191, ESI = 192, 
                 EVALUATE = 193, EVENT = 194, EVERY = 195, EXCEPTION = 196, 
                 EXCLUSIVE = 197, EXHIBIT = 198, EXIT = 199, EXPORT = 200, 
                 EXTEND = 201, EXTENDED = 202, EXTERNAL = 203, FALSE = 204, 
                 FD = 205, FILE = 206, FILE_CONTROL = 207, FILLER = 208, 
                 FINAL = 209, FIRST = 210, FOOTING = 211, FOR = 212, FOREGROUND_COLOR = 213, 
                 FOREGROUND_COLOUR = 214, FROM = 215, FULL = 216, FUNCTION = 217, 
                 FUNCTIONNAME = 218, FUNCTION_POINTER = 219, GENERATE = 220, 
                 GOBACK = 221, GIVING = 222, GLOBAL = 223, GO = 224, GREATER = 225, 
                 GRID = 226, GROUP = 227, HEADING = 228, HIGHLIGHT = 229, 
                 HIGH_VALUE = 230, HIGH_VALUES = 231, I_O = 232, I_O_CONTROL = 233, 
                 ID = 234, IDENTIFICATION = 235, IF = 236, IMPLICIT = 237, 
                 IMPORT = 238, IN = 239, INDEX = 240, INDEXED = 241, INDICATE = 242, 
                 INITIAL = 243, INITIALIZE = 244, INITIATE = 245, INPUT = 246, 
                 INPUT_OUTPUT = 247, INSPECT = 248, INSTALLATION = 249, 
                 INTEGER = 250, INTO = 251, INVALID = 252, INVOKE = 253, 
                 IS = 254, JUST = 255, JUSTIFIED = 256, KANJI = 257, KEPT = 258, 
                 KEY = 259, KEYBOARD = 260, LABEL = 261, LANGUAGE = 262, 
                 LAST = 263, LB = 264, LD = 265, LEADING = 266, LEFT = 267, 
                 LEFTLINE = 268, LENGTH = 269, LENGTH_CHECK = 270, LESS = 271, 
                 LIBACCESS = 272, LIBPARAMETER = 273, LIBRARY = 274, LIMIT = 275, 
                 LIMITS = 276, LINAGE = 277, LINAGE_COUNTER = 278, LINE = 279, 
                 LINES = 280, LINE_COUNTER = 281, LINKAGE = 282, LIST = 283, 
                 LOCAL = 284, LOCAL_STORAGE = 285, LOCK = 286, LONG_DATE = 287, 
                 LONG_TIME = 288, LOWER = 289, LOWLIGHT = 290, LOW_VALUE = 291, 
                 LOW_VALUES = 292, MEMORY = 293, MERGE = 294, MESSAGE = 295, 
                 MMDDYYYY = 296, MODE = 297, MODULES = 298, MORE_LABELS = 299, 
                 MOVE = 300, MULTIPLE = 301, MULTIPLY = 302, NAMED = 303, 
                 NATIONAL = 304, NATIONAL_EDITED = 305, NATIVE = 306, NEGATIVE = 307, 
                 NETWORK = 308, NEXT = 309, NO = 310, NO_ECHO = 311, NOT = 312, 
                 NULL = 313, NULLS = 314, NUMBER = 315, NUMERIC = 316, NUMERIC_DATE = 317, 
                 NUMERIC_EDITED = 318, NUMERIC_TIME = 319, OBJECT_COMPUTER = 320, 
                 OCCURS = 321, ODT = 322, OF = 323, OFF = 324, OMITTED = 325, 
                 ON = 326, OPEN = 327, OPTIONAL = 328, OR = 329, ORDER = 330, 
                 ORDERLY = 331, ORGANIZATION = 332, OTHER = 333, OUTPUT = 334, 
                 OVERFLOW = 335, OVERLINE = 336, OWN = 337, PACKED_DECIMAL = 338, 
                 PADDING = 339, PAGE = 340, PAGE_COUNTER = 341, PASSWORD = 342, 
                 PERFORM = 343, PF = 344, PH = 345, PIC = 346, PICTURE = 347, 
                 PLUS = 348, POINTER = 349, POSITION = 350, POSITIVE = 351, 
                 PORT = 352, PRINTER = 353, PRINTING = 354, PRIVATE = 355, 
                 PROCEDURE = 356, PROCEDURE_POINTER = 357, PROCEDURES = 358, 
                 PROCEED = 359, PROCESS = 360, PROGRAM = 361, PROGRAM_ID = 362, 
                 PROGRAM_LIBRARY = 363, PROMPT = 364, PURGE = 365, QUEUE = 366, 
                 QUOTE = 367, QUOTES = 368, RANDOM = 369, READER = 370, 
                 REMOTE = 371, RD = 372, REAL = 373, READ = 374, RECEIVE = 375, 
                 RECEIVED = 376, RECORD = 377, RECORDING = 378, RECORDS = 379, 
                 RECURSIVE = 380, REDEFINES = 381, REEL = 382, REF = 383, 
                 REFERENCE = 384, REFERENCES = 385, RELATIVE = 386, RELEASE = 387, 
                 REMAINDER = 388, REMARKS = 389, REMOVAL = 390, REMOVE = 391, 
                 RENAMES = 392, REPLACE = 393, REPLACING = 394, REPORT = 395, 
                 REPORTING = 396, REPORTS = 397, REQUIRED = 398, RERUN = 399, 
                 RESERVE = 400, REVERSE_VIDEO = 401, RESET = 402, RETURN = 403, 
                 RETURN_CODE = 404, RETURNING = 405, REVERSED = 406, REWIND = 407, 
                 REWRITE = 408, RF = 409, RH = 410, RIGHT = 411, ROUNDED = 412, 
                 RUN = 413, SAME = 414, SAVE = 415, SCREEN = 416, SD = 417, 
                 SEARCH = 418, SECTION = 419, SECURE = 420, SECURITY = 421, 
                 SEGMENT = 422, SEGMENT_LIMIT = 423, SELECT = 424, SEND = 425, 
                 SENTENCE = 426, SEPARATE = 427, SEQUENCE = 428, SEQUENTIAL = 429, 
                 SET = 430, SHARED = 431, SHAREDBYALL = 432, SHAREDBYRUNUNIT = 433, 
                 SHARING = 434, SHIFT_IN = 435, SHIFT_OUT = 436, SHORT_DATE = 437, 
                 SIGN = 438, SIZE = 439, SORT = 440, SORT_CONTROL = 441, 
                 SORT_CORE_SIZE = 442, SORT_FILE_SIZE = 443, SORT_MERGE = 444, 
                 SORT_MESSAGE = 445, SORT_MODE_SIZE = 446, SORT_RETURN = 447, 
                 SOURCE = 448, SOURCE_COMPUTER = 449, SPACE = 450, SPACES = 451, 
                 SPECIAL_NAMES = 452, STANDARD = 453, STANDARD_1 = 454, 
                 STANDARD_2 = 455, START = 456, STATUS = 457, STOP = 458, 
                 STRING = 459, SUB_QUEUE_1 = 460, SUB_QUEUE_2 = 461, SUB_QUEUE_3 = 462, 
                 SUBTRACT = 463, SUM = 464, SUPPRESS = 465, SYMBOL = 466, 
                 SYMBOLIC = 467, SYNC = 468, SYNCHRONIZED = 469, TABLE = 470, 
                 TALLY = 471, TALLYING = 472, TASK = 473, TAPE = 474, TERMINAL = 475, 
                 TERMINATE = 476, TEST = 477, TEXT = 478, THAN = 479, THEN = 480, 
                 THREAD = 481, THREAD_LOCAL = 482, THROUGH = 483, THRU = 484, 
                 TIME = 485, TIMER = 486, TIMES = 487, TITLE = 488, TO = 489, 
                 TODAYS_DATE = 490, TODAYS_NAME = 491, TOP = 492, TRAILING = 493, 
                 TRUE = 494, TRUNCATED = 495, TYPE = 496, TYPEDEF = 497, 
                 UNDERLINE = 498, UNIT = 499, UNSTRING = 500, UNTIL = 501, 
                 UP = 502, UPON = 503, USAGE = 504, USE = 505, USING = 506, 
                 VALUE = 507, VALUES = 508, VARYING = 509, VIRTUAL = 510, 
                 WAIT = 511, WHEN = 512, WHEN_COMPILED = 513, WITH = 514, 
                 WORDS = 515, WORKING_STORAGE = 516, WRITE = 517, YEAR = 518, 
                 YYYYMMDD = 519, YYYYDDD = 520, ZERO = 521, ZERO_FILL = 522, 
                 ZEROS = 523, ZEROES = 524, AMPCHAR = 525, ASTERISKCHAR = 526, 
                 DOUBLEASTERISKCHAR = 527, COLONCHAR = 528, COMMACHAR = 529, 
                 COMMENTENTRYTAG = 530, COMMENTTAG = 531, DOLLARCHAR = 532, 
                 DOUBLEQUOTE = 533, DOT_FS = 534, DOT = 535, EQUALCHAR = 536, 
                 EXECCICSTAG = 537, EXECSQLTAG = 538, EXECSQLIMSTAG = 539, 
                 LESSTHANCHAR = 540, LESSTHANOREQUAL = 541, LPARENCHAR = 542, 
                 MINUSCHAR = 543, MORETHANCHAR = 544, MORETHANOREQUAL = 545, 
                 NOTEQUALCHAR = 546, PLUSCHAR = 547, SINGLEQUOTE = 548, 
                 RPARENCHAR = 549, SLASHCHAR = 550, NONNUMERICLITERAL = 551, 
                 LEVEL_NUMBER_66 = 552, LEVEL_NUMBER_77 = 553, LEVEL_NUMBER_88 = 554, 
                 INTEGERLITERAL = 555, NUMERICLITERAL = 556, IDENTIFIER = 557, 
                 NEWLINE = 558, EXECCICSLINE = 559, EXECSQLIMSLINE = 560, 
                 EXECSQLLINE = 561, COMMENTENTRYLINE = 562, COMMENTLINE = 563, 
                 WS = 564, SEPARATOR = 565
	}

	public
	static let RULE_startRule = 0, RULE_compilationUnit = 1, RULE_programUnit = 2, 
            RULE_endProgramStatement = 3, RULE_identificationDivision = 4, 
            RULE_identificationDivisionBody = 5, RULE_programIdParagraph = 6, 
            RULE_authorParagraph = 7, RULE_installationParagraph = 8, RULE_dateWrittenParagraph = 9, 
            RULE_dateCompiledParagraph = 10, RULE_securityParagraph = 11, 
            RULE_remarksParagraph = 12, RULE_environmentDivision = 13, RULE_environmentDivisionBody = 14, 
            RULE_configurationSection = 15, RULE_configurationSectionParagraph = 16, 
            RULE_sourceComputerParagraph = 17, RULE_objectComputerParagraph = 18, 
            RULE_objectComputerClause = 19, RULE_memorySizeClause = 20, 
            RULE_diskSizeClause = 21, RULE_collatingSequenceClause = 22, 
            RULE_collatingSequenceClauseAlphanumeric = 23, RULE_collatingSequenceClauseNational = 24, 
            RULE_segmentLimitClause = 25, RULE_characterSetClause = 26, 
            RULE_specialNamesParagraph = 27, RULE_specialNameClause = 28, 
            RULE_alphabetClause = 29, RULE_alphabetClauseFormat1 = 30, RULE_alphabetLiterals = 31, 
            RULE_alphabetThrough = 32, RULE_alphabetAlso = 33, RULE_alphabetClauseFormat2 = 34, 
            RULE_channelClause = 35, RULE_classClause = 36, RULE_classClauseThrough = 37, 
            RULE_classClauseFrom = 38, RULE_classClauseTo = 39, RULE_currencySignClause = 40, 
            RULE_decimalPointClause = 41, RULE_defaultComputationalSignClause = 42, 
            RULE_defaultDisplaySignClause = 43, RULE_environmentSwitchNameClause = 44, 
            RULE_environmentSwitchNameSpecialNamesStatusPhrase = 45, RULE_odtClause = 46, 
            RULE_reserveNetworkClause = 47, RULE_symbolicCharactersClause = 48, 
            RULE_symbolicCharacters = 49, RULE_inputOutputSection = 50, 
            RULE_inputOutputSectionParagraph = 51, RULE_fileControlParagraph = 52, 
            RULE_fileControlEntry = 53, RULE_selectClause = 54, RULE_fileControlClause = 55, 
            RULE_assignClause = 56, RULE_reserveClause = 57, RULE_organizationClause = 58, 
            RULE_paddingCharacterClause = 59, RULE_recordDelimiterClause = 60, 
            RULE_accessModeClause = 61, RULE_recordKeyClause = 62, RULE_alternateRecordKeyClause = 63, 
            RULE_passwordClause = 64, RULE_fileStatusClause = 65, RULE_relativeKeyClause = 66, 
            RULE_ioControlParagraph = 67, RULE_ioControlClause = 68, RULE_rerunClause = 69, 
            RULE_rerunEveryRecords = 70, RULE_rerunEveryOf = 71, RULE_rerunEveryClock = 72, 
            RULE_sameClause = 73, RULE_multipleFileClause = 74, RULE_multipleFilePosition = 75, 
            RULE_commitmentControlClause = 76, RULE_dataDivision = 77, RULE_dataDivisionSection = 78, 
            RULE_fileSection = 79, RULE_fileDescriptionEntry = 80, RULE_fileDescriptionEntryClause = 81, 
            RULE_externalClause = 82, RULE_globalClause = 83, RULE_blockContainsClause = 84, 
            RULE_blockContainsTo = 85, RULE_recordContainsClause = 86, RULE_recordContainsClauseFormat1 = 87, 
            RULE_recordContainsClauseFormat2 = 88, RULE_recordContainsClauseFormat3 = 89, 
            RULE_recordContainsTo = 90, RULE_labelRecordsClause = 91, RULE_valueOfClause = 92, 
            RULE_valuePair = 93, RULE_dataRecordsClause = 94, RULE_linageClause = 95, 
            RULE_linageAt = 96, RULE_linageFootingAt = 97, RULE_linageLinesAtTop = 98, 
            RULE_linageLinesAtBottom = 99, RULE_recordingModeClause = 100, 
            RULE_modeStatement = 101, RULE_codeSetClause = 102, RULE_reportClause = 103, 
            RULE_dataBaseSection = 104, RULE_dataBaseSectionEntry = 105, 
            RULE_workingStorageSection = 106, RULE_linkageSection = 107, 
            RULE_communicationSection = 108, RULE_communicationDescriptionEntry = 109, 
            RULE_communicationDescriptionEntryFormat1 = 110, RULE_communicationDescriptionEntryFormat2 = 111, 
            RULE_communicationDescriptionEntryFormat3 = 112, RULE_destinationCountClause = 113, 
            RULE_destinationTableClause = 114, RULE_endKeyClause = 115, 
            RULE_errorKeyClause = 116, RULE_messageCountClause = 117, RULE_messageDateClause = 118, 
            RULE_messageTimeClause = 119, RULE_statusKeyClause = 120, RULE_symbolicDestinationClause = 121, 
            RULE_symbolicQueueClause = 122, RULE_symbolicSourceClause = 123, 
            RULE_symbolicTerminalClause = 124, RULE_symbolicSubQueueClause = 125, 
            RULE_textLengthClause = 126, RULE_localStorageSection = 127, 
            RULE_screenSection = 128, RULE_screenDescriptionEntry = 129, 
            RULE_screenDescriptionBlankClause = 130, RULE_screenDescriptionBellClause = 131, 
            RULE_screenDescriptionBlinkClause = 132, RULE_screenDescriptionEraseClause = 133, 
            RULE_screenDescriptionLightClause = 134, RULE_screenDescriptionGridClause = 135, 
            RULE_screenDescriptionReverseVideoClause = 136, RULE_screenDescriptionUnderlineClause = 137, 
            RULE_screenDescriptionSizeClause = 138, RULE_screenDescriptionLineClause = 139, 
            RULE_screenDescriptionColumnClause = 140, RULE_screenDescriptionForegroundColorClause = 141, 
            RULE_screenDescriptionBackgroundColorClause = 142, RULE_screenDescriptionControlClause = 143, 
            RULE_screenDescriptionValueClause = 144, RULE_screenDescriptionPictureClause = 145, 
            RULE_screenDescriptionFromClause = 146, RULE_screenDescriptionToClause = 147, 
            RULE_screenDescriptionUsingClause = 148, RULE_screenDescriptionUsageClause = 149, 
            RULE_screenDescriptionBlankWhenZeroClause = 150, RULE_screenDescriptionJustifiedClause = 151, 
            RULE_screenDescriptionSignClause = 152, RULE_screenDescriptionAutoClause = 153, 
            RULE_screenDescriptionSecureClause = 154, RULE_screenDescriptionRequiredClause = 155, 
            RULE_screenDescriptionPromptClause = 156, RULE_screenDescriptionPromptOccursClause = 157, 
            RULE_screenDescriptionFullClause = 158, RULE_screenDescriptionZeroFillClause = 159, 
            RULE_reportSection = 160, RULE_reportDescription = 161, RULE_reportDescriptionEntry = 162, 
            RULE_reportDescriptionGlobalClause = 163, RULE_reportDescriptionPageLimitClause = 164, 
            RULE_reportDescriptionHeadingClause = 165, RULE_reportDescriptionFirstDetailClause = 166, 
            RULE_reportDescriptionLastDetailClause = 167, RULE_reportDescriptionFootingClause = 168, 
            RULE_reportGroupDescriptionEntry = 169, RULE_reportGroupDescriptionEntryFormat1 = 170, 
            RULE_reportGroupDescriptionEntryFormat2 = 171, RULE_reportGroupDescriptionEntryFormat3 = 172, 
            RULE_reportGroupBlankWhenZeroClause = 173, RULE_reportGroupColumnNumberClause = 174, 
            RULE_reportGroupIndicateClause = 175, RULE_reportGroupJustifiedClause = 176, 
            RULE_reportGroupLineNumberClause = 177, RULE_reportGroupLineNumberNextPage = 178, 
            RULE_reportGroupLineNumberPlus = 179, RULE_reportGroupNextGroupClause = 180, 
            RULE_reportGroupNextGroupPlus = 181, RULE_reportGroupNextGroupNextPage = 182, 
            RULE_reportGroupPictureClause = 183, RULE_reportGroupResetClause = 184, 
            RULE_reportGroupSignClause = 185, RULE_reportGroupSourceClause = 186, 
            RULE_reportGroupSumClause = 187, RULE_reportGroupTypeClause = 188, 
            RULE_reportGroupTypeReportHeading = 189, RULE_reportGroupTypePageHeading = 190, 
            RULE_reportGroupTypeControlHeading = 191, RULE_reportGroupTypeDetail = 192, 
            RULE_reportGroupTypeControlFooting = 193, RULE_reportGroupUsageClause = 194, 
            RULE_reportGroupTypePageFooting = 195, RULE_reportGroupTypeReportFooting = 196, 
            RULE_reportGroupValueClause = 197, RULE_programLibrarySection = 198, 
            RULE_libraryDescriptionEntry = 199, RULE_libraryDescriptionEntryFormat1 = 200, 
            RULE_libraryDescriptionEntryFormat2 = 201, RULE_libraryAttributeClauseFormat1 = 202, 
            RULE_libraryAttributeClauseFormat2 = 203, RULE_libraryAttributeFunction = 204, 
            RULE_libraryAttributeParameter = 205, RULE_libraryAttributeTitle = 206, 
            RULE_libraryEntryProcedureClauseFormat1 = 207, RULE_libraryEntryProcedureClauseFormat2 = 208, 
            RULE_libraryEntryProcedureForClause = 209, RULE_libraryEntryProcedureGivingClause = 210, 
            RULE_libraryEntryProcedureUsingClause = 211, RULE_libraryEntryProcedureUsingName = 212, 
            RULE_libraryEntryProcedureWithClause = 213, RULE_libraryEntryProcedureWithName = 214, 
            RULE_libraryIsCommonClause = 215, RULE_libraryIsGlobalClause = 216, 
            RULE_dataDescriptionEntry = 217, RULE_dataDescriptionEntryFormat1 = 218, 
            RULE_dataDescriptionEntryFormat2 = 219, RULE_dataDescriptionEntryFormat3 = 220, 
            RULE_dataDescriptionEntryExecSql = 221, RULE_dataAlignedClause = 222, 
            RULE_dataBlankWhenZeroClause = 223, RULE_dataCommonOwnLocalClause = 224, 
            RULE_dataExternalClause = 225, RULE_dataGlobalClause = 226, 
            RULE_dataIntegerStringClause = 227, RULE_dataJustifiedClause = 228, 
            RULE_dataOccursClause = 229, RULE_dataOccursTo = 230, RULE_dataOccursSort = 231, 
            RULE_dataPictureClause = 232, RULE_pictureString = 233, RULE_pictureChars = 234, 
            RULE_pictureCardinality = 235, RULE_dataReceivedByClause = 236, 
            RULE_dataRecordAreaClause = 237, RULE_dataRedefinesClause = 238, 
            RULE_dataRenamesClause = 239, RULE_dataSignClause = 240, RULE_dataSynchronizedClause = 241, 
            RULE_dataThreadLocalClause = 242, RULE_dataTypeClause = 243, 
            RULE_dataTypeDefClause = 244, RULE_dataUsageClause = 245, RULE_dataUsingClause = 246, 
            RULE_dataValueClause = 247, RULE_dataValueInterval = 248, RULE_dataValueIntervalFrom = 249, 
            RULE_dataValueIntervalTo = 250, RULE_dataWithLowerBoundsClause = 251, 
            RULE_procedureDivision = 252, RULE_procedureDivisionUsingClause = 253, 
            RULE_procedureDivisionGivingClause = 254, RULE_procedureDivisionUsingParameter = 255, 
            RULE_procedureDivisionByReferencePhrase = 256, RULE_procedureDivisionByReference = 257, 
            RULE_procedureDivisionByValuePhrase = 258, RULE_procedureDivisionByValue = 259, 
            RULE_procedureDeclaratives = 260, RULE_procedureDeclarative = 261, 
            RULE_procedureSectionHeader = 262, RULE_procedureDivisionBody = 263, 
            RULE_procedureSection = 264, RULE_paragraphs = 265, RULE_paragraph = 266, 
            RULE_sentence = 267, RULE_statement = 268, RULE_acceptStatement = 269, 
            RULE_acceptFromDateStatement = 270, RULE_acceptFromMnemonicStatement = 271, 
            RULE_acceptFromEscapeKeyStatement = 272, RULE_acceptMessageCountStatement = 273, 
            RULE_addStatement = 274, RULE_addToStatement = 275, RULE_addToGivingStatement = 276, 
            RULE_addCorrespondingStatement = 277, RULE_addFrom = 278, RULE_addTo = 279, 
            RULE_addToGiving = 280, RULE_addGiving = 281, RULE_alteredGoTo = 282, 
            RULE_alterStatement = 283, RULE_alterProceedTo = 284, RULE_callStatement = 285, 
            RULE_callUsingPhrase = 286, RULE_callUsingParameter = 287, RULE_callByReferencePhrase = 288, 
            RULE_callByReference = 289, RULE_callByValuePhrase = 290, RULE_callByValue = 291, 
            RULE_callByContentPhrase = 292, RULE_callByContent = 293, RULE_callGivingPhrase = 294, 
            RULE_cancelStatement = 295, RULE_cancelCall = 296, RULE_closeStatement = 297, 
            RULE_closeFile = 298, RULE_closeReelUnitStatement = 299, RULE_closeRelativeStatement = 300, 
            RULE_closePortFileIOStatement = 301, RULE_closePortFileIOUsing = 302, 
            RULE_closePortFileIOUsingCloseDisposition = 303, RULE_closePortFileIOUsingAssociatedData = 304, 
            RULE_closePortFileIOUsingAssociatedDataLength = 305, RULE_computeStatement = 306, 
            RULE_computeStore = 307, RULE_continueStatement = 308, RULE_deleteStatement = 309, 
            RULE_disableStatement = 310, RULE_displayStatement = 311, RULE_displayOperand = 312, 
            RULE_displayAt = 313, RULE_displayUpon = 314, RULE_displayWith = 315, 
            RULE_divideStatement = 316, RULE_divideIntoStatement = 317, 
            RULE_divideIntoGivingStatement = 318, RULE_divideByGivingStatement = 319, 
            RULE_divideGivingPhrase = 320, RULE_divideInto = 321, RULE_divideGiving = 322, 
            RULE_divideRemainder = 323, RULE_enableStatement = 324, RULE_entryStatement = 325, 
            RULE_evaluateStatement = 326, RULE_evaluateSelect = 327, RULE_evaluateAlsoSelect = 328, 
            RULE_evaluateWhenPhrase = 329, RULE_evaluateWhen = 330, RULE_evaluateCondition = 331, 
            RULE_evaluateThrough = 332, RULE_evaluateAlsoCondition = 333, 
            RULE_evaluateWhenOther = 334, RULE_evaluateValue = 335, RULE_execCicsStatement = 336, 
            RULE_execSqlStatement = 337, RULE_execSqlImsStatement = 338, 
            RULE_exhibitStatement = 339, RULE_exhibitOperand = 340, RULE_exitStatement = 341, 
            RULE_generateStatement = 342, RULE_gobackStatement = 343, RULE_goToStatement = 344, 
            RULE_goToStatementSimple = 345, RULE_goToDependingOnStatement = 346, 
            RULE_ifStatement = 347, RULE_ifThen = 348, RULE_ifElse = 349, 
            RULE_initializeStatement = 350, RULE_initializeReplacingPhrase = 351, 
            RULE_initializeReplacingBy = 352, RULE_initiateStatement = 353, 
            RULE_inspectStatement = 354, RULE_inspectTallyingPhrase = 355, 
            RULE_inspectReplacingPhrase = 356, RULE_inspectTallyingReplacingPhrase = 357, 
            RULE_inspectConvertingPhrase = 358, RULE_inspectFor = 359, RULE_inspectCharacters = 360, 
            RULE_inspectReplacingCharacters = 361, RULE_inspectAllLeadings = 362, 
            RULE_inspectReplacingAllLeadings = 363, RULE_inspectAllLeading = 364, 
            RULE_inspectReplacingAllLeading = 365, RULE_inspectBy = 366, 
            RULE_inspectTo = 367, RULE_inspectBeforeAfter = 368, RULE_mergeStatement = 369, 
            RULE_mergeOnKeyClause = 370, RULE_mergeCollatingSequencePhrase = 371, 
            RULE_mergeCollatingAlphanumeric = 372, RULE_mergeCollatingNational = 373, 
            RULE_mergeUsing = 374, RULE_mergeOutputProcedurePhrase = 375, 
            RULE_mergeOutputThrough = 376, RULE_mergeGivingPhrase = 377, 
            RULE_mergeGiving = 378, RULE_moveStatement = 379, RULE_moveToStatement = 380, 
            RULE_moveToSendingArea = 381, RULE_moveCorrespondingToStatement = 382, 
            RULE_moveCorrespondingToSendingArea = 383, RULE_multiplyStatement = 384, 
            RULE_multiplyRegular = 385, RULE_multiplyRegularOperand = 386, 
            RULE_multiplyGiving = 387, RULE_multiplyGivingOperand = 388, 
            RULE_multiplyGivingResult = 389, RULE_openStatement = 390, RULE_openInputStatement = 391, 
            RULE_openInput = 392, RULE_openOutputStatement = 393, RULE_openOutput = 394, 
            RULE_openIOStatement = 395, RULE_openExtendStatement = 396, 
            RULE_performStatement = 397, RULE_performInlineStatement = 398, 
            RULE_performProcedureStatement = 399, RULE_performType = 400, 
            RULE_performTimes = 401, RULE_performUntil = 402, RULE_performVarying = 403, 
            RULE_performVaryingClause = 404, RULE_performVaryingPhrase = 405, 
            RULE_performAfter = 406, RULE_performFrom = 407, RULE_performBy = 408, 
            RULE_performTestClause = 409, RULE_purgeStatement = 410, RULE_readStatement = 411, 
            RULE_readInto = 412, RULE_readWith = 413, RULE_readKey = 414, 
            RULE_receiveStatement = 415, RULE_receiveFromStatement = 416, 
            RULE_receiveFrom = 417, RULE_receiveIntoStatement = 418, RULE_receiveNoData = 419, 
            RULE_receiveWithData = 420, RULE_receiveBefore = 421, RULE_receiveWith = 422, 
            RULE_receiveThread = 423, RULE_receiveSize = 424, RULE_receiveStatus = 425, 
            RULE_releaseStatement = 426, RULE_returnStatement = 427, RULE_returnInto = 428, 
            RULE_rewriteStatement = 429, RULE_rewriteFrom = 430, RULE_searchStatement = 431, 
            RULE_searchVarying = 432, RULE_searchWhen = 433, RULE_sendStatement = 434, 
            RULE_sendStatementSync = 435, RULE_sendStatementAsync = 436, 
            RULE_sendFromPhrase = 437, RULE_sendWithPhrase = 438, RULE_sendReplacingPhrase = 439, 
            RULE_sendAdvancingPhrase = 440, RULE_sendAdvancingPage = 441, 
            RULE_sendAdvancingLines = 442, RULE_sendAdvancingMnemonic = 443, 
            RULE_setStatement = 444, RULE_setToStatement = 445, RULE_setUpDownByStatement = 446, 
            RULE_setTo = 447, RULE_setToValue = 448, RULE_setByValue = 449, 
            RULE_sortStatement = 450, RULE_sortOnKeyClause = 451, RULE_sortDuplicatesPhrase = 452, 
            RULE_sortCollatingSequencePhrase = 453, RULE_sortCollatingAlphanumeric = 454, 
            RULE_sortCollatingNational = 455, RULE_sortInputProcedurePhrase = 456, 
            RULE_sortInputThrough = 457, RULE_sortUsing = 458, RULE_sortOutputProcedurePhrase = 459, 
            RULE_sortOutputThrough = 460, RULE_sortGivingPhrase = 461, RULE_sortGiving = 462, 
            RULE_startStatement = 463, RULE_startKey = 464, RULE_stopStatement = 465, 
            RULE_stringStatement = 466, RULE_stringSendingPhrase = 467, 
            RULE_stringSending = 468, RULE_stringDelimitedByPhrase = 469, 
            RULE_stringForPhrase = 470, RULE_stringIntoPhrase = 471, RULE_stringWithPointerPhrase = 472, 
            RULE_subtractStatement = 473, RULE_subtractFromStatement = 474, 
            RULE_subtractFromGivingStatement = 475, RULE_subtractCorrespondingStatement = 476, 
            RULE_subtractSubtrahend = 477, RULE_subtractMinuend = 478, RULE_subtractMinuendGiving = 479, 
            RULE_subtractGiving = 480, RULE_subtractMinuendCorresponding = 481, 
            RULE_terminateStatement = 482, RULE_unstringStatement = 483, 
            RULE_unstringSendingPhrase = 484, RULE_unstringDelimitedByPhrase = 485, 
            RULE_unstringOrAllPhrase = 486, RULE_unstringIntoPhrase = 487, 
            RULE_unstringInto = 488, RULE_unstringDelimiterIn = 489, RULE_unstringCountIn = 490, 
            RULE_unstringWithPointerPhrase = 491, RULE_unstringTallyingPhrase = 492, 
            RULE_useStatement = 493, RULE_useAfterClause = 494, RULE_useAfterOn = 495, 
            RULE_useDebugClause = 496, RULE_useDebugOn = 497, RULE_writeStatement = 498, 
            RULE_writeFromPhrase = 499, RULE_writeAdvancingPhrase = 500, 
            RULE_writeAdvancingPage = 501, RULE_writeAdvancingLines = 502, 
            RULE_writeAdvancingMnemonic = 503, RULE_writeAtEndOfPagePhrase = 504, 
            RULE_writeNotAtEndOfPagePhrase = 505, RULE_atEndPhrase = 506, 
            RULE_notAtEndPhrase = 507, RULE_invalidKeyPhrase = 508, RULE_notInvalidKeyPhrase = 509, 
            RULE_onOverflowPhrase = 510, RULE_notOnOverflowPhrase = 511, 
            RULE_onSizeErrorPhrase = 512, RULE_notOnSizeErrorPhrase = 513, 
            RULE_onExceptionClause = 514, RULE_notOnExceptionClause = 515, 
            RULE_arithmeticExpression = 516, RULE_plusMinus = 517, RULE_multDivs = 518, 
            RULE_multDiv = 519, RULE_powers = 520, RULE_power = 521, RULE_basis = 522, 
            RULE_condition = 523, RULE_andOrCondition = 524, RULE_combinableCondition = 525, 
            RULE_simpleCondition = 526, RULE_classCondition = 527, RULE_conditionNameReference = 528, 
            RULE_conditionNameSubscriptReference = 529, RULE_relationCondition = 530, 
            RULE_relationSignCondition = 531, RULE_relationArithmeticComparison = 532, 
            RULE_relationCombinedComparison = 533, RULE_relationCombinedCondition = 534, 
            RULE_relationalOperator = 535, RULE_abbreviation = 536, RULE_identifier = 537, 
            RULE_tableCall = 538, RULE_functionCall = 539, RULE_referenceModifier = 540, 
            RULE_characterPosition = 541, RULE_length = 542, RULE_subscript = 543, 
            RULE_argument = 544, RULE_qualifiedDataName = 545, RULE_qualifiedDataNameFormat1 = 546, 
            RULE_qualifiedDataNameFormat2 = 547, RULE_qualifiedDataNameFormat3 = 548, 
            RULE_qualifiedDataNameFormat4 = 549, RULE_qualifiedInData = 550, 
            RULE_inData = 551, RULE_inFile = 552, RULE_inMnemonic = 553, 
            RULE_inSection = 554, RULE_inLibrary = 555, RULE_inTable = 556, 
            RULE_alphabetName = 557, RULE_assignmentName = 558, RULE_basisName = 559, 
            RULE_cdName = 560, RULE_className = 561, RULE_computerName = 562, 
            RULE_conditionName = 563, RULE_dataName = 564, RULE_dataDescName = 565, 
            RULE_environmentName = 566, RULE_fileName = 567, RULE_functionName = 568, 
            RULE_indexName = 569, RULE_languageName = 570, RULE_libraryName = 571, 
            RULE_localName = 572, RULE_mnemonicName = 573, RULE_paragraphName = 574, 
            RULE_procedureName = 575, RULE_programName = 576, RULE_recordName = 577, 
            RULE_reportName = 578, RULE_routineName = 579, RULE_screenName = 580, 
            RULE_sectionName = 581, RULE_systemName = 582, RULE_symbolicCharacter = 583, 
            RULE_textName = 584, RULE_cobolWord = 585, RULE_literal = 586, 
            RULE_booleanLiteral = 587, RULE_numericLiteral = 588, RULE_integerLiteral = 589, 
            RULE_cicsDfhRespLiteral = 590, RULE_cicsDfhValueLiteral = 591, 
            RULE_figurativeConstant = 592, RULE_specialRegister = 593, RULE_commentEntry = 594

	public
	static let ruleNames: [String] = [
		"startRule", "compilationUnit", "programUnit", "endProgramStatement", 
		"identificationDivision", "identificationDivisionBody", "programIdParagraph", 
		"authorParagraph", "installationParagraph", "dateWrittenParagraph", "dateCompiledParagraph", 
		"securityParagraph", "remarksParagraph", "environmentDivision", "environmentDivisionBody", 
		"configurationSection", "configurationSectionParagraph", "sourceComputerParagraph", 
		"objectComputerParagraph", "objectComputerClause", "memorySizeClause", 
		"diskSizeClause", "collatingSequenceClause", "collatingSequenceClauseAlphanumeric", 
		"collatingSequenceClauseNational", "segmentLimitClause", "characterSetClause", 
		"specialNamesParagraph", "specialNameClause", "alphabetClause", "alphabetClauseFormat1", 
		"alphabetLiterals", "alphabetThrough", "alphabetAlso", "alphabetClauseFormat2", 
		"channelClause", "classClause", "classClauseThrough", "classClauseFrom", 
		"classClauseTo", "currencySignClause", "decimalPointClause", "defaultComputationalSignClause", 
		"defaultDisplaySignClause", "environmentSwitchNameClause", "environmentSwitchNameSpecialNamesStatusPhrase", 
		"odtClause", "reserveNetworkClause", "symbolicCharactersClause", "symbolicCharacters", 
		"inputOutputSection", "inputOutputSectionParagraph", "fileControlParagraph", 
		"fileControlEntry", "selectClause", "fileControlClause", "assignClause", 
		"reserveClause", "organizationClause", "paddingCharacterClause", "recordDelimiterClause", 
		"accessModeClause", "recordKeyClause", "alternateRecordKeyClause", "passwordClause", 
		"fileStatusClause", "relativeKeyClause", "ioControlParagraph", "ioControlClause", 
		"rerunClause", "rerunEveryRecords", "rerunEveryOf", "rerunEveryClock", 
		"sameClause", "multipleFileClause", "multipleFilePosition", "commitmentControlClause", 
		"dataDivision", "dataDivisionSection", "fileSection", "fileDescriptionEntry", 
		"fileDescriptionEntryClause", "externalClause", "globalClause", "blockContainsClause", 
		"blockContainsTo", "recordContainsClause", "recordContainsClauseFormat1", 
		"recordContainsClauseFormat2", "recordContainsClauseFormat3", "recordContainsTo", 
		"labelRecordsClause", "valueOfClause", "valuePair", "dataRecordsClause", 
		"linageClause", "linageAt", "linageFootingAt", "linageLinesAtTop", "linageLinesAtBottom", 
		"recordingModeClause", "modeStatement", "codeSetClause", "reportClause", 
		"dataBaseSection", "dataBaseSectionEntry", "workingStorageSection", "linkageSection", 
		"communicationSection", "communicationDescriptionEntry", "communicationDescriptionEntryFormat1", 
		"communicationDescriptionEntryFormat2", "communicationDescriptionEntryFormat3", 
		"destinationCountClause", "destinationTableClause", "endKeyClause", "errorKeyClause", 
		"messageCountClause", "messageDateClause", "messageTimeClause", "statusKeyClause", 
		"symbolicDestinationClause", "symbolicQueueClause", "symbolicSourceClause", 
		"symbolicTerminalClause", "symbolicSubQueueClause", "textLengthClause", 
		"localStorageSection", "screenSection", "screenDescriptionEntry", "screenDescriptionBlankClause", 
		"screenDescriptionBellClause", "screenDescriptionBlinkClause", "screenDescriptionEraseClause", 
		"screenDescriptionLightClause", "screenDescriptionGridClause", "screenDescriptionReverseVideoClause", 
		"screenDescriptionUnderlineClause", "screenDescriptionSizeClause", "screenDescriptionLineClause", 
		"screenDescriptionColumnClause", "screenDescriptionForegroundColorClause", 
		"screenDescriptionBackgroundColorClause", "screenDescriptionControlClause", 
		"screenDescriptionValueClause", "screenDescriptionPictureClause", "screenDescriptionFromClause", 
		"screenDescriptionToClause", "screenDescriptionUsingClause", "screenDescriptionUsageClause", 
		"screenDescriptionBlankWhenZeroClause", "screenDescriptionJustifiedClause", 
		"screenDescriptionSignClause", "screenDescriptionAutoClause", "screenDescriptionSecureClause", 
		"screenDescriptionRequiredClause", "screenDescriptionPromptClause", "screenDescriptionPromptOccursClause", 
		"screenDescriptionFullClause", "screenDescriptionZeroFillClause", "reportSection", 
		"reportDescription", "reportDescriptionEntry", "reportDescriptionGlobalClause", 
		"reportDescriptionPageLimitClause", "reportDescriptionHeadingClause", 
		"reportDescriptionFirstDetailClause", "reportDescriptionLastDetailClause", 
		"reportDescriptionFootingClause", "reportGroupDescriptionEntry", "reportGroupDescriptionEntryFormat1", 
		"reportGroupDescriptionEntryFormat2", "reportGroupDescriptionEntryFormat3", 
		"reportGroupBlankWhenZeroClause", "reportGroupColumnNumberClause", "reportGroupIndicateClause", 
		"reportGroupJustifiedClause", "reportGroupLineNumberClause", "reportGroupLineNumberNextPage", 
		"reportGroupLineNumberPlus", "reportGroupNextGroupClause", "reportGroupNextGroupPlus", 
		"reportGroupNextGroupNextPage", "reportGroupPictureClause", "reportGroupResetClause", 
		"reportGroupSignClause", "reportGroupSourceClause", "reportGroupSumClause", 
		"reportGroupTypeClause", "reportGroupTypeReportHeading", "reportGroupTypePageHeading", 
		"reportGroupTypeControlHeading", "reportGroupTypeDetail", "reportGroupTypeControlFooting", 
		"reportGroupUsageClause", "reportGroupTypePageFooting", "reportGroupTypeReportFooting", 
		"reportGroupValueClause", "programLibrarySection", "libraryDescriptionEntry", 
		"libraryDescriptionEntryFormat1", "libraryDescriptionEntryFormat2", "libraryAttributeClauseFormat1", 
		"libraryAttributeClauseFormat2", "libraryAttributeFunction", "libraryAttributeParameter", 
		"libraryAttributeTitle", "libraryEntryProcedureClauseFormat1", "libraryEntryProcedureClauseFormat2", 
		"libraryEntryProcedureForClause", "libraryEntryProcedureGivingClause", 
		"libraryEntryProcedureUsingClause", "libraryEntryProcedureUsingName", 
		"libraryEntryProcedureWithClause", "libraryEntryProcedureWithName", "libraryIsCommonClause", 
		"libraryIsGlobalClause", "dataDescriptionEntry", "dataDescriptionEntryFormat1", 
		"dataDescriptionEntryFormat2", "dataDescriptionEntryFormat3", "dataDescriptionEntryExecSql", 
		"dataAlignedClause", "dataBlankWhenZeroClause", "dataCommonOwnLocalClause", 
		"dataExternalClause", "dataGlobalClause", "dataIntegerStringClause", "dataJustifiedClause", 
		"dataOccursClause", "dataOccursTo", "dataOccursSort", "dataPictureClause", 
		"pictureString", "pictureChars", "pictureCardinality", "dataReceivedByClause", 
		"dataRecordAreaClause", "dataRedefinesClause", "dataRenamesClause", "dataSignClause", 
		"dataSynchronizedClause", "dataThreadLocalClause", "dataTypeClause", "dataTypeDefClause", 
		"dataUsageClause", "dataUsingClause", "dataValueClause", "dataValueInterval", 
		"dataValueIntervalFrom", "dataValueIntervalTo", "dataWithLowerBoundsClause", 
		"procedureDivision", "procedureDivisionUsingClause", "procedureDivisionGivingClause", 
		"procedureDivisionUsingParameter", "procedureDivisionByReferencePhrase", 
		"procedureDivisionByReference", "procedureDivisionByValuePhrase", "procedureDivisionByValue", 
		"procedureDeclaratives", "procedureDeclarative", "procedureSectionHeader", 
		"procedureDivisionBody", "procedureSection", "paragraphs", "paragraph", 
		"sentence", "statement", "acceptStatement", "acceptFromDateStatement", 
		"acceptFromMnemonicStatement", "acceptFromEscapeKeyStatement", "acceptMessageCountStatement", 
		"addStatement", "addToStatement", "addToGivingStatement", "addCorrespondingStatement", 
		"addFrom", "addTo", "addToGiving", "addGiving", "alteredGoTo", "alterStatement", 
		"alterProceedTo", "callStatement", "callUsingPhrase", "callUsingParameter", 
		"callByReferencePhrase", "callByReference", "callByValuePhrase", "callByValue", 
		"callByContentPhrase", "callByContent", "callGivingPhrase", "cancelStatement", 
		"cancelCall", "closeStatement", "closeFile", "closeReelUnitStatement", 
		"closeRelativeStatement", "closePortFileIOStatement", "closePortFileIOUsing", 
		"closePortFileIOUsingCloseDisposition", "closePortFileIOUsingAssociatedData", 
		"closePortFileIOUsingAssociatedDataLength", "computeStatement", "computeStore", 
		"continueStatement", "deleteStatement", "disableStatement", "displayStatement", 
		"displayOperand", "displayAt", "displayUpon", "displayWith", "divideStatement", 
		"divideIntoStatement", "divideIntoGivingStatement", "divideByGivingStatement", 
		"divideGivingPhrase", "divideInto", "divideGiving", "divideRemainder", 
		"enableStatement", "entryStatement", "evaluateStatement", "evaluateSelect", 
		"evaluateAlsoSelect", "evaluateWhenPhrase", "evaluateWhen", "evaluateCondition", 
		"evaluateThrough", "evaluateAlsoCondition", "evaluateWhenOther", "evaluateValue", 
		"execCicsStatement", "execSqlStatement", "execSqlImsStatement", "exhibitStatement", 
		"exhibitOperand", "exitStatement", "generateStatement", "gobackStatement", 
		"goToStatement", "goToStatementSimple", "goToDependingOnStatement", "ifStatement", 
		"ifThen", "ifElse", "initializeStatement", "initializeReplacingPhrase", 
		"initializeReplacingBy", "initiateStatement", "inspectStatement", "inspectTallyingPhrase", 
		"inspectReplacingPhrase", "inspectTallyingReplacingPhrase", "inspectConvertingPhrase", 
		"inspectFor", "inspectCharacters", "inspectReplacingCharacters", "inspectAllLeadings", 
		"inspectReplacingAllLeadings", "inspectAllLeading", "inspectReplacingAllLeading", 
		"inspectBy", "inspectTo", "inspectBeforeAfter", "mergeStatement", "mergeOnKeyClause", 
		"mergeCollatingSequencePhrase", "mergeCollatingAlphanumeric", "mergeCollatingNational", 
		"mergeUsing", "mergeOutputProcedurePhrase", "mergeOutputThrough", "mergeGivingPhrase", 
		"mergeGiving", "moveStatement", "moveToStatement", "moveToSendingArea", 
		"moveCorrespondingToStatement", "moveCorrespondingToSendingArea", "multiplyStatement", 
		"multiplyRegular", "multiplyRegularOperand", "multiplyGiving", "multiplyGivingOperand", 
		"multiplyGivingResult", "openStatement", "openInputStatement", "openInput", 
		"openOutputStatement", "openOutput", "openIOStatement", "openExtendStatement", 
		"performStatement", "performInlineStatement", "performProcedureStatement", 
		"performType", "performTimes", "performUntil", "performVarying", "performVaryingClause", 
		"performVaryingPhrase", "performAfter", "performFrom", "performBy", "performTestClause", 
		"purgeStatement", "readStatement", "readInto", "readWith", "readKey", 
		"receiveStatement", "receiveFromStatement", "receiveFrom", "receiveIntoStatement", 
		"receiveNoData", "receiveWithData", "receiveBefore", "receiveWith", "receiveThread", 
		"receiveSize", "receiveStatus", "releaseStatement", "returnStatement", 
		"returnInto", "rewriteStatement", "rewriteFrom", "searchStatement", "searchVarying", 
		"searchWhen", "sendStatement", "sendStatementSync", "sendStatementAsync", 
		"sendFromPhrase", "sendWithPhrase", "sendReplacingPhrase", "sendAdvancingPhrase", 
		"sendAdvancingPage", "sendAdvancingLines", "sendAdvancingMnemonic", "setStatement", 
		"setToStatement", "setUpDownByStatement", "setTo", "setToValue", "setByValue", 
		"sortStatement", "sortOnKeyClause", "sortDuplicatesPhrase", "sortCollatingSequencePhrase", 
		"sortCollatingAlphanumeric", "sortCollatingNational", "sortInputProcedurePhrase", 
		"sortInputThrough", "sortUsing", "sortOutputProcedurePhrase", "sortOutputThrough", 
		"sortGivingPhrase", "sortGiving", "startStatement", "startKey", "stopStatement", 
		"stringStatement", "stringSendingPhrase", "stringSending", "stringDelimitedByPhrase", 
		"stringForPhrase", "stringIntoPhrase", "stringWithPointerPhrase", "subtractStatement", 
		"subtractFromStatement", "subtractFromGivingStatement", "subtractCorrespondingStatement", 
		"subtractSubtrahend", "subtractMinuend", "subtractMinuendGiving", "subtractGiving", 
		"subtractMinuendCorresponding", "terminateStatement", "unstringStatement", 
		"unstringSendingPhrase", "unstringDelimitedByPhrase", "unstringOrAllPhrase", 
		"unstringIntoPhrase", "unstringInto", "unstringDelimiterIn", "unstringCountIn", 
		"unstringWithPointerPhrase", "unstringTallyingPhrase", "useStatement", 
		"useAfterClause", "useAfterOn", "useDebugClause", "useDebugOn", "writeStatement", 
		"writeFromPhrase", "writeAdvancingPhrase", "writeAdvancingPage", "writeAdvancingLines", 
		"writeAdvancingMnemonic", "writeAtEndOfPagePhrase", "writeNotAtEndOfPagePhrase", 
		"atEndPhrase", "notAtEndPhrase", "invalidKeyPhrase", "notInvalidKeyPhrase", 
		"onOverflowPhrase", "notOnOverflowPhrase", "onSizeErrorPhrase", "notOnSizeErrorPhrase", 
		"onExceptionClause", "notOnExceptionClause", "arithmeticExpression", "plusMinus", 
		"multDivs", "multDiv", "powers", "power", "basis", "condition", "andOrCondition", 
		"combinableCondition", "simpleCondition", "classCondition", "conditionNameReference", 
		"conditionNameSubscriptReference", "relationCondition", "relationSignCondition", 
		"relationArithmeticComparison", "relationCombinedComparison", "relationCombinedCondition", 
		"relationalOperator", "abbreviation", "identifier", "tableCall", "functionCall", 
		"referenceModifier", "characterPosition", "length", "subscript", "argument", 
		"qualifiedDataName", "qualifiedDataNameFormat1", "qualifiedDataNameFormat2", 
		"qualifiedDataNameFormat3", "qualifiedDataNameFormat4", "qualifiedInData", 
		"inData", "inFile", "inMnemonic", "inSection", "inLibrary", "inTable", 
		"alphabetName", "assignmentName", "basisName", "cdName", "className", 
		"computerName", "conditionName", "dataName", "dataDescName", "environmentName", 
		"fileName", "functionName", "indexName", "languageName", "libraryName", 
		"localName", "mnemonicName", "paragraphName", "procedureName", "programName", 
		"recordName", "reportName", "routineName", "screenName", "sectionName", 
		"systemName", "symbolicCharacter", "textName", "cobolWord", "literal", 
		"booleanLiteral", "numericLiteral", "integerLiteral", "cicsDfhRespLiteral", 
		"cicsDfhValueLiteral", "figurativeConstant", "specialRegister", "commentEntry"
	]

	private static let _LITERAL_NAMES: [String?] = [
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, "'&'", "'*'", "'**'", "':'", "','", 
		"'*>CE'", "'*>'", "'$'", "'\"'", nil, "'.'", "'='", "'*>EXECCICS'", "'*>EXECSQL'", 
		"'*>EXECSQLIMS'", "'<'", "'<='", "'('", "'-'", "'>'", "'>='", "'<>'", 
		"'+'", "'''", "')'", "'/'", nil, "'66'", "'77'", "'88'", nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, "', '"
	]
	private static let _SYMBOLIC_NAMES: [String?] = [
		nil, "ABORT", "ACCEPT", "ACCESS", "ADD", "ADDRESS", "ADVANCING", "AFTER", 
		"ALIGNED", "ALL", "ALPHABET", "ALPHABETIC", "ALPHABETIC_LOWER", "ALPHABETIC_UPPER", 
		"ALPHANUMERIC", "ALPHANUMERIC_EDITED", "ALSO", "ALTER", "ALTERNATE", "AND", 
		"ANY", "ARE", "AREA", "AREAS", "AS", "ASCENDING", "ASCII", "ASSIGN", "ASSOCIATED_DATA", 
		"ASSOCIATED_DATA_LENGTH", "AT", "ATTRIBUTE", "AUTHOR", "AUTO", "AUTO_SKIP", 
		"BACKGROUND_COLOR", "BACKGROUND_COLOUR", "BASIS", "BEEP", "BEFORE", "BEGINNING", 
		"BELL", "BINARY", "BIT", "BLANK", "BLINK", "BLOCK", "BOUNDS", "BOTTOM", 
		"BY", "BYFUNCTION", "BYTITLE", "CALL", "CANCEL", "CAPABLE", "CCSVERSION", 
		"CD", "CF", "CH", "CHAINING", "CHANGED", "CHANNEL", "CHARACTER", "CHARACTERS", 
		"CLASS", "CLASS_ID", "CLOCK_UNITS", "CLOSE", "CLOSE_DISPOSITION", "COBOL", 
		"CODE", "CODE_SET", "COLLATING", "COL", "COLUMN", "COM_REG", "COMMA", 
		"COMMITMENT", "COMMON", "COMMUNICATION", "COMP", "COMP_1", "COMP_2", "COMP_3", 
		"COMP_4", "COMP_5", "COMPUTATIONAL", "COMPUTATIONAL_1", "COMPUTATIONAL_2", 
		"COMPUTATIONAL_3", "COMPUTATIONAL_4", "COMPUTATIONAL_5", "COMPUTE", "CONFIGURATION", 
		"CONTAINS", "CONTENT", "CONTINUE", "CONTROL", "CONTROL_POINT", "CONTROLS", 
		"CONVENTION", "CONVERTING", "COPY", "CORR", "CORRESPONDING", "COUNT", 
		"CRUNCH", "CURRENCY", "CURSOR", "DATA", "DATA_BASE", "DATE", "DATE_COMPILED", 
		"DATE_WRITTEN", "DAY", "DAY_OF_WEEK", "DBCS", "DE", "DEBUG_CONTENTS", 
		"DEBUG_ITEM", "DEBUG_LINE", "DEBUG_NAME", "DEBUG_SUB_1", "DEBUG_SUB_2", 
		"DEBUG_SUB_3", "DEBUGGING", "DECIMAL_POINT", "DECLARATIVES", "DEFAULT", 
		"DEFAULT_DISPLAY", "DEFINITION", "DELETE", "DELIMITED", "DELIMITER", "DEPENDING", 
		"DESCENDING", "DESTINATION", "DETAIL", "DFHRESP", "DFHVALUE", "DISABLE", 
		"DISK", "DISPLAY", "DISPLAY_1", "DIVIDE", "DIVISION", "DONTCARE", "DOUBLE", 
		"DOWN", "DUPLICATES", "DYNAMIC", "EBCDIC", "EGCS", "EGI", "ELSE", "EMI", 
		"EMPTY_CHECK", "ENABLE", "END", "END_ACCEPT", "END_ADD", "END_CALL", "END_COMPUTE", 
		"END_DELETE", "END_DIVIDE", "END_EVALUATE", "END_IF", "END_MULTIPLY", 
		"END_OF_PAGE", "END_PERFORM", "END_READ", "END_RECEIVE", "END_RETURN", 
		"END_REWRITE", "END_SEARCH", "END_START", "END_STRING", "END_SUBTRACT", 
		"END_UNSTRING", "END_WRITE", "ENDING", "ENTER", "ENTRY", "ENTRY_PROCEDURE", 
		"ENVIRONMENT", "EOP", "EQUAL", "ERASE", "ERROR", "EOL", "EOS", "ESCAPE", 
		"ESI", "EVALUATE", "EVENT", "EVERY", "EXCEPTION", "EXCLUSIVE", "EXHIBIT", 
		"EXIT", "EXPORT", "EXTEND", "EXTENDED", "EXTERNAL", "FALSE", "FD", "FILE", 
		"FILE_CONTROL", "FILLER", "FINAL", "FIRST", "FOOTING", "FOR", "FOREGROUND_COLOR", 
		"FOREGROUND_COLOUR", "FROM", "FULL", "FUNCTION", "FUNCTIONNAME", "FUNCTION_POINTER", 
		"GENERATE", "GOBACK", "GIVING", "GLOBAL", "GO", "GREATER", "GRID", "GROUP", 
		"HEADING", "HIGHLIGHT", "HIGH_VALUE", "HIGH_VALUES", "I_O", "I_O_CONTROL", 
		"ID", "IDENTIFICATION", "IF", "IMPLICIT", "IMPORT", "IN", "INDEX", "INDEXED", 
		"INDICATE", "INITIAL", "INITIALIZE", "INITIATE", "INPUT", "INPUT_OUTPUT", 
		"INSPECT", "INSTALLATION", "INTEGER", "INTO", "INVALID", "INVOKE", "IS", 
		"JUST", "JUSTIFIED", "KANJI", "KEPT", "KEY", "KEYBOARD", "LABEL", "LANGUAGE", 
		"LAST", "LB", "LD", "LEADING", "LEFT", "LEFTLINE", "LENGTH", "LENGTH_CHECK", 
		"LESS", "LIBACCESS", "LIBPARAMETER", "LIBRARY", "LIMIT", "LIMITS", "LINAGE", 
		"LINAGE_COUNTER", "LINE", "LINES", "LINE_COUNTER", "LINKAGE", "LIST", 
		"LOCAL", "LOCAL_STORAGE", "LOCK", "LONG_DATE", "LONG_TIME", "LOWER", "LOWLIGHT", 
		"LOW_VALUE", "LOW_VALUES", "MEMORY", "MERGE", "MESSAGE", "MMDDYYYY", "MODE", 
		"MODULES", "MORE_LABELS", "MOVE", "MULTIPLE", "MULTIPLY", "NAMED", "NATIONAL", 
		"NATIONAL_EDITED", "NATIVE", "NEGATIVE", "NETWORK", "NEXT", "NO", "NO_ECHO", 
		"NOT", "NULL", "NULLS", "NUMBER", "NUMERIC", "NUMERIC_DATE", "NUMERIC_EDITED", 
		"NUMERIC_TIME", "OBJECT_COMPUTER", "OCCURS", "ODT", "OF", "OFF", "OMITTED", 
		"ON", "OPEN", "OPTIONAL", "OR", "ORDER", "ORDERLY", "ORGANIZATION", "OTHER", 
		"OUTPUT", "OVERFLOW", "OVERLINE", "OWN", "PACKED_DECIMAL", "PADDING", 
		"PAGE", "PAGE_COUNTER", "PASSWORD", "PERFORM", "PF", "PH", "PIC", "PICTURE", 
		"PLUS", "POINTER", "POSITION", "POSITIVE", "PORT", "PRINTER", "PRINTING", 
		"PRIVATE", "PROCEDURE", "PROCEDURE_POINTER", "PROCEDURES", "PROCEED", 
		"PROCESS", "PROGRAM", "PROGRAM_ID", "PROGRAM_LIBRARY", "PROMPT", "PURGE", 
		"QUEUE", "QUOTE", "QUOTES", "RANDOM", "READER", "REMOTE", "RD", "REAL", 
		"READ", "RECEIVE", "RECEIVED", "RECORD", "RECORDING", "RECORDS", "RECURSIVE", 
		"REDEFINES", "REEL", "REF", "REFERENCE", "REFERENCES", "RELATIVE", "RELEASE", 
		"REMAINDER", "REMARKS", "REMOVAL", "REMOVE", "RENAMES", "REPLACE", "REPLACING", 
		"REPORT", "REPORTING", "REPORTS", "REQUIRED", "RERUN", "RESERVE", "REVERSE_VIDEO", 
		"RESET", "RETURN", "RETURN_CODE", "RETURNING", "REVERSED", "REWIND", "REWRITE", 
		"RF", "RH", "RIGHT", "ROUNDED", "RUN", "SAME", "SAVE", "SCREEN", "SD", 
		"SEARCH", "SECTION", "SECURE", "SECURITY", "SEGMENT", "SEGMENT_LIMIT", 
		"SELECT", "SEND", "SENTENCE", "SEPARATE", "SEQUENCE", "SEQUENTIAL", "SET", 
		"SHARED", "SHAREDBYALL", "SHAREDBYRUNUNIT", "SHARING", "SHIFT_IN", "SHIFT_OUT", 
		"SHORT_DATE", "SIGN", "SIZE", "SORT", "SORT_CONTROL", "SORT_CORE_SIZE", 
		"SORT_FILE_SIZE", "SORT_MERGE", "SORT_MESSAGE", "SORT_MODE_SIZE", "SORT_RETURN", 
		"SOURCE", "SOURCE_COMPUTER", "SPACE", "SPACES", "SPECIAL_NAMES", "STANDARD", 
		"STANDARD_1", "STANDARD_2", "START", "STATUS", "STOP", "STRING", "SUB_QUEUE_1", 
		"SUB_QUEUE_2", "SUB_QUEUE_3", "SUBTRACT", "SUM", "SUPPRESS", "SYMBOL", 
		"SYMBOLIC", "SYNC", "SYNCHRONIZED", "TABLE", "TALLY", "TALLYING", "TASK", 
		"TAPE", "TERMINAL", "TERMINATE", "TEST", "TEXT", "THAN", "THEN", "THREAD", 
		"THREAD_LOCAL", "THROUGH", "THRU", "TIME", "TIMER", "TIMES", "TITLE", 
		"TO", "TODAYS_DATE", "TODAYS_NAME", "TOP", "TRAILING", "TRUE", "TRUNCATED", 
		"TYPE", "TYPEDEF", "UNDERLINE", "UNIT", "UNSTRING", "UNTIL", "UP", "UPON", 
		"USAGE", "USE", "USING", "VALUE", "VALUES", "VARYING", "VIRTUAL", "WAIT", 
		"WHEN", "WHEN_COMPILED", "WITH", "WORDS", "WORKING_STORAGE", "WRITE", 
		"YEAR", "YYYYMMDD", "YYYYDDD", "ZERO", "ZERO_FILL", "ZEROS", "ZEROES", 
		"AMPCHAR", "ASTERISKCHAR", "DOUBLEASTERISKCHAR", "COLONCHAR", "COMMACHAR", 
		"COMMENTENTRYTAG", "COMMENTTAG", "DOLLARCHAR", "DOUBLEQUOTE", "DOT_FS", 
		"DOT", "EQUALCHAR", "EXECCICSTAG", "EXECSQLTAG", "EXECSQLIMSTAG", "LESSTHANCHAR", 
		"LESSTHANOREQUAL", "LPARENCHAR", "MINUSCHAR", "MORETHANCHAR", "MORETHANOREQUAL", 
		"NOTEQUALCHAR", "PLUSCHAR", "SINGLEQUOTE", "RPARENCHAR", "SLASHCHAR", 
		"NONNUMERICLITERAL", "LEVEL_NUMBER_66", "LEVEL_NUMBER_77", "LEVEL_NUMBER_88", 
		"INTEGERLITERAL", "NUMERICLITERAL", "IDENTIFIER", "NEWLINE", "EXECCICSLINE", 
		"EXECSQLIMSLINE", "EXECSQLLINE", "COMMENTENTRYLINE", "COMMENTLINE", "WS", 
		"SEPARATOR"
	]
	public
	static let VOCABULARY = Vocabulary(_LITERAL_NAMES, _SYMBOLIC_NAMES)

	override open
	func getGrammarFileName() -> String { return "Cobol85.g4" }

	override open
	func getRuleNames() -> [String] { return Cobol85Parser.ruleNames }

	override open
	func getSerializedATN() -> String { return Cobol85Parser._serializedATN }

	override open
	func getATN() -> ATN { return Cobol85Parser._ATN }

	override open
	func getVocabulary() -> Vocabulary {
	    return Cobol85Parser.VOCABULARY
	}

	override public
	init(_ input:TokenStream) throws {
	    RuntimeMetaData.checkVersion("4.7.1", RuntimeMetaData.VERSION)
		try super.init(input)
		_interp = ParserATNSimulator(self,Cobol85Parser._ATN,Cobol85Parser._decisionToDFA, Cobol85Parser._sharedContextCache)
	}

	public class StartRuleContext: ParserRuleContext {
			open
			func compilationUnit() -> CompilationUnitContext? {
				return getRuleContext(CompilationUnitContext.self, 0)
			}
			open
			func EOF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EOF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_startRule
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStartRule(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStartRule(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStartRule(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStartRule(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func startRule() throws -> StartRuleContext {
		var _localctx: StartRuleContext = StartRuleContext(_ctx, getState())
		try enterRule(_localctx, 0, Cobol85Parser.RULE_startRule)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1190)
		 	try compilationUnit()
		 	setState(1191)
		 	try match(Cobol85Parser.Tokens.EOF.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CompilationUnitContext: ParserRuleContext {
			open
			func programUnit() -> [ProgramUnitContext] {
				return getRuleContexts(ProgramUnitContext.self)
			}
			open
			func programUnit(_ i: Int) -> ProgramUnitContext? {
				return getRuleContext(ProgramUnitContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_compilationUnit
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCompilationUnit(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCompilationUnit(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCompilationUnit(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCompilationUnit(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func compilationUnit() throws -> CompilationUnitContext {
		var _localctx: CompilationUnitContext = CompilationUnitContext(_ctx, getState())
		try enterRule(_localctx, 2, Cobol85Parser.RULE_compilationUnit)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1194) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1193)
		 		try programUnit()


		 		setState(1196); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ID.rawValue || _la == Cobol85Parser.Tokens.IDENTIFICATION.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProgramUnitContext: ParserRuleContext {
			open
			func identificationDivision() -> IdentificationDivisionContext? {
				return getRuleContext(IdentificationDivisionContext.self, 0)
			}
			open
			func environmentDivision() -> EnvironmentDivisionContext? {
				return getRuleContext(EnvironmentDivisionContext.self, 0)
			}
			open
			func dataDivision() -> DataDivisionContext? {
				return getRuleContext(DataDivisionContext.self, 0)
			}
			open
			func procedureDivision() -> ProcedureDivisionContext? {
				return getRuleContext(ProcedureDivisionContext.self, 0)
			}
			open
			func programUnit() -> [ProgramUnitContext] {
				return getRuleContexts(ProgramUnitContext.self)
			}
			open
			func programUnit(_ i: Int) -> ProgramUnitContext? {
				return getRuleContext(ProgramUnitContext.self, i)
			}
			open
			func endProgramStatement() -> EndProgramStatementContext? {
				return getRuleContext(EndProgramStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_programUnit
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProgramUnit(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProgramUnit(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProgramUnit(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProgramUnit(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func programUnit() throws -> ProgramUnitContext {
		var _localctx: ProgramUnitContext = ProgramUnitContext(_ctx, getState())
		try enterRule(_localctx, 4, Cobol85Parser.RULE_programUnit)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1198)
		 	try identificationDivision()
		 	setState(1200)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ENVIRONMENT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1199)
		 		try environmentDivision()

		 	}

		 	setState(1203)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DATA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1202)
		 		try dataDivision()

		 	}

		 	setState(1206)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.PROCEDURE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1205)
		 		try procedureDivision()

		 	}

		 	setState(1211)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,4,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1208)
		 			try programUnit()

		 	 
		 		}
		 		setState(1213)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,4,_ctx)
		 	}
		 	setState(1215)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,5,_ctx)) {
		 	case 1:
		 		setState(1214)
		 		try endProgramStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EndProgramStatementContext: ParserRuleContext {
			open
			func END() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END.rawValue, 0)
			}
			open
			func PROGRAM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROGRAM.rawValue, 0)
			}
			open
			func programName() -> ProgramNameContext? {
				return getRuleContext(ProgramNameContext.self, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_endProgramStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEndProgramStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEndProgramStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEndProgramStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEndProgramStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func endProgramStatement() throws -> EndProgramStatementContext {
		var _localctx: EndProgramStatementContext = EndProgramStatementContext(_ctx, getState())
		try enterRule(_localctx, 6, Cobol85Parser.RULE_endProgramStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1217)
		 	try match(Cobol85Parser.Tokens.END.rawValue)
		 	setState(1218)
		 	try match(Cobol85Parser.Tokens.PROGRAM.rawValue)
		 	setState(1219)
		 	try programName()
		 	setState(1220)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IdentificationDivisionContext: ParserRuleContext {
			open
			func DIVISION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DIVISION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func programIdParagraph() -> ProgramIdParagraphContext? {
				return getRuleContext(ProgramIdParagraphContext.self, 0)
			}
			open
			func IDENTIFICATION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IDENTIFICATION.rawValue, 0)
			}
			open
			func ID() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ID.rawValue, 0)
			}
			open
			func identificationDivisionBody() -> [IdentificationDivisionBodyContext] {
				return getRuleContexts(IdentificationDivisionBodyContext.self)
			}
			open
			func identificationDivisionBody(_ i: Int) -> IdentificationDivisionBodyContext? {
				return getRuleContext(IdentificationDivisionBodyContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_identificationDivision
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterIdentificationDivision(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitIdentificationDivision(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitIdentificationDivision(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitIdentificationDivision(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func identificationDivision() throws -> IdentificationDivisionContext {
		var _localctx: IdentificationDivisionContext = IdentificationDivisionContext(_ctx, getState())
		try enterRule(_localctx, 8, Cobol85Parser.RULE_identificationDivision)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1222)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ID.rawValue || _la == Cobol85Parser.Tokens.IDENTIFICATION.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1223)
		 	try match(Cobol85Parser.Tokens.DIVISION.rawValue)
		 	setState(1224)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1225)
		 	try programIdParagraph()
		 	setState(1229)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.AUTHOR.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.DATE_COMPILED.rawValue || _la == Cobol85Parser.Tokens.DATE_WRITTEN.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.INSTALLATION.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.REMARKS.rawValue || _la == Cobol85Parser.Tokens.SECURITY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1226)
		 		try identificationDivisionBody()


		 		setState(1231)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IdentificationDivisionBodyContext: ParserRuleContext {
			open
			func authorParagraph() -> AuthorParagraphContext? {
				return getRuleContext(AuthorParagraphContext.self, 0)
			}
			open
			func installationParagraph() -> InstallationParagraphContext? {
				return getRuleContext(InstallationParagraphContext.self, 0)
			}
			open
			func dateWrittenParagraph() -> DateWrittenParagraphContext? {
				return getRuleContext(DateWrittenParagraphContext.self, 0)
			}
			open
			func dateCompiledParagraph() -> DateCompiledParagraphContext? {
				return getRuleContext(DateCompiledParagraphContext.self, 0)
			}
			open
			func securityParagraph() -> SecurityParagraphContext? {
				return getRuleContext(SecurityParagraphContext.self, 0)
			}
			open
			func remarksParagraph() -> RemarksParagraphContext? {
				return getRuleContext(RemarksParagraphContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_identificationDivisionBody
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterIdentificationDivisionBody(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitIdentificationDivisionBody(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitIdentificationDivisionBody(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitIdentificationDivisionBody(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func identificationDivisionBody() throws -> IdentificationDivisionBodyContext {
		var _localctx: IdentificationDivisionBodyContext = IdentificationDivisionBodyContext(_ctx, getState())
		try enterRule(_localctx, 10, Cobol85Parser.RULE_identificationDivisionBody)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1238)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .AUTHOR:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1232)
		 		try authorParagraph()

		 		break

		 	case .INSTALLATION:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1233)
		 		try installationParagraph()

		 		break

		 	case .DATE_WRITTEN:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1234)
		 		try dateWrittenParagraph()

		 		break

		 	case .DATE_COMPILED:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1235)
		 		try dateCompiledParagraph()

		 		break

		 	case .SECURITY:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1236)
		 		try securityParagraph()

		 		break

		 	case .REMARKS:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1237)
		 		try remarksParagraph()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProgramIdParagraphContext: ParserRuleContext {
			open
			func PROGRAM_ID() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROGRAM_ID.rawValue, 0)
			}
			open
			func DOT_FS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.DOT_FS.rawValue)
			}
			open
			func DOT_FS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, i)
			}
			open
			func programName() -> ProgramNameContext? {
				return getRuleContext(ProgramNameContext.self, 0)
			}
			open
			func commentEntry() -> CommentEntryContext? {
				return getRuleContext(CommentEntryContext.self, 0)
			}
			open
			func COMMON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMON.rawValue, 0)
			}
			open
			func INITIAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INITIAL.rawValue, 0)
			}
			open
			func LIBRARY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LIBRARY.rawValue, 0)
			}
			open
			func DEFINITION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEFINITION.rawValue, 0)
			}
			open
			func RECURSIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECURSIVE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func PROGRAM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROGRAM.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_programIdParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProgramIdParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProgramIdParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProgramIdParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProgramIdParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func programIdParagraph() throws -> ProgramIdParagraphContext {
		var _localctx: ProgramIdParagraphContext = ProgramIdParagraphContext(_ctx, getState())
		try enterRule(_localctx, 12, Cobol85Parser.RULE_programIdParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1240)
		 	try match(Cobol85Parser.Tokens.PROGRAM_ID.rawValue)
		 	setState(1241)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1242)
		 	try programName()
		 	setState(1250)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.COMMON.rawValue || _la == Cobol85Parser.Tokens.DEFINITION.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.INITIAL.rawValue,Cobol85Parser.Tokens.IS.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 243)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.RECURSIVE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1244)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1243)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}

		 		setState(1246)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.COMMON.rawValue || _la == Cobol85Parser.Tokens.DEFINITION.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.INITIAL.rawValue || _la == Cobol85Parser.Tokens.LIBRARY.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.RECURSIVE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1248)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.PROGRAM.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1247)
		 			try match(Cobol85Parser.Tokens.PROGRAM.rawValue)

		 		}


		 	}

		 	setState(1253)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DOT_FS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1252)
		 		try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		 	}

		 	setState(1256)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMENTENTRYLINE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1255)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AuthorParagraphContext: ParserRuleContext {
			open
			func AUTHOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AUTHOR.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func commentEntry() -> CommentEntryContext? {
				return getRuleContext(CommentEntryContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_authorParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAuthorParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAuthorParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAuthorParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAuthorParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func authorParagraph() throws -> AuthorParagraphContext {
		var _localctx: AuthorParagraphContext = AuthorParagraphContext(_ctx, getState())
		try enterRule(_localctx, 14, Cobol85Parser.RULE_authorParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1258)
		 	try match(Cobol85Parser.Tokens.AUTHOR.rawValue)
		 	setState(1259)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1261)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMENTENTRYLINE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1260)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstallationParagraphContext: ParserRuleContext {
			open
			func INSTALLATION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INSTALLATION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func commentEntry() -> CommentEntryContext? {
				return getRuleContext(CommentEntryContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_installationParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInstallationParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInstallationParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInstallationParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInstallationParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func installationParagraph() throws -> InstallationParagraphContext {
		var _localctx: InstallationParagraphContext = InstallationParagraphContext(_ctx, getState())
		try enterRule(_localctx, 16, Cobol85Parser.RULE_installationParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1263)
		 	try match(Cobol85Parser.Tokens.INSTALLATION.rawValue)
		 	setState(1264)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1266)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMENTENTRYLINE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1265)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DateWrittenParagraphContext: ParserRuleContext {
			open
			func DATE_WRITTEN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATE_WRITTEN.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func commentEntry() -> CommentEntryContext? {
				return getRuleContext(CommentEntryContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dateWrittenParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDateWrittenParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDateWrittenParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDateWrittenParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDateWrittenParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dateWrittenParagraph() throws -> DateWrittenParagraphContext {
		var _localctx: DateWrittenParagraphContext = DateWrittenParagraphContext(_ctx, getState())
		try enterRule(_localctx, 18, Cobol85Parser.RULE_dateWrittenParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1268)
		 	try match(Cobol85Parser.Tokens.DATE_WRITTEN.rawValue)
		 	setState(1269)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1271)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMENTENTRYLINE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1270)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DateCompiledParagraphContext: ParserRuleContext {
			open
			func DATE_COMPILED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATE_COMPILED.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func commentEntry() -> CommentEntryContext? {
				return getRuleContext(CommentEntryContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dateCompiledParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDateCompiledParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDateCompiledParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDateCompiledParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDateCompiledParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dateCompiledParagraph() throws -> DateCompiledParagraphContext {
		var _localctx: DateCompiledParagraphContext = DateCompiledParagraphContext(_ctx, getState())
		try enterRule(_localctx, 20, Cobol85Parser.RULE_dateCompiledParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1273)
		 	try match(Cobol85Parser.Tokens.DATE_COMPILED.rawValue)
		 	setState(1274)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1276)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMENTENTRYLINE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1275)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SecurityParagraphContext: ParserRuleContext {
			open
			func SECURITY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECURITY.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func commentEntry() -> CommentEntryContext? {
				return getRuleContext(CommentEntryContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_securityParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSecurityParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSecurityParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSecurityParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSecurityParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func securityParagraph() throws -> SecurityParagraphContext {
		var _localctx: SecurityParagraphContext = SecurityParagraphContext(_ctx, getState())
		try enterRule(_localctx, 22, Cobol85Parser.RULE_securityParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1278)
		 	try match(Cobol85Parser.Tokens.SECURITY.rawValue)
		 	setState(1279)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1281)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMENTENTRYLINE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1280)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RemarksParagraphContext: ParserRuleContext {
			open
			func REMARKS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REMARKS.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func commentEntry() -> CommentEntryContext? {
				return getRuleContext(CommentEntryContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_remarksParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRemarksParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRemarksParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRemarksParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRemarksParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func remarksParagraph() throws -> RemarksParagraphContext {
		var _localctx: RemarksParagraphContext = RemarksParagraphContext(_ctx, getState())
		try enterRule(_localctx, 24, Cobol85Parser.RULE_remarksParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1283)
		 	try match(Cobol85Parser.Tokens.REMARKS.rawValue)
		 	setState(1284)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1286)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMENTENTRYLINE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1285)
		 		try commentEntry()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EnvironmentDivisionContext: ParserRuleContext {
			open
			func ENVIRONMENT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ENVIRONMENT.rawValue, 0)
			}
			open
			func DIVISION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DIVISION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func environmentDivisionBody() -> [EnvironmentDivisionBodyContext] {
				return getRuleContexts(EnvironmentDivisionBodyContext.self)
			}
			open
			func environmentDivisionBody(_ i: Int) -> EnvironmentDivisionBodyContext? {
				return getRuleContext(EnvironmentDivisionBodyContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_environmentDivision
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEnvironmentDivision(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEnvironmentDivision(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEnvironmentDivision(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEnvironmentDivision(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func environmentDivision() throws -> EnvironmentDivisionContext {
		var _localctx: EnvironmentDivisionContext = EnvironmentDivisionContext(_ctx, getState())
		try enterRule(_localctx, 26, Cobol85Parser.RULE_environmentDivision)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1288)
		 	try match(Cobol85Parser.Tokens.ENVIRONMENT.rawValue)
		 	setState(1289)
		 	try match(Cobol85Parser.Tokens.DIVISION.rawValue)
		 	setState(1290)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1294)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.CONFIGURATION.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.INPUT_OUTPUT.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.SPECIAL_NAMES.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1291)
		 		try environmentDivisionBody()


		 		setState(1296)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EnvironmentDivisionBodyContext: ParserRuleContext {
			open
			func configurationSection() -> ConfigurationSectionContext? {
				return getRuleContext(ConfigurationSectionContext.self, 0)
			}
			open
			func specialNamesParagraph() -> SpecialNamesParagraphContext? {
				return getRuleContext(SpecialNamesParagraphContext.self, 0)
			}
			open
			func inputOutputSection() -> InputOutputSectionContext? {
				return getRuleContext(InputOutputSectionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_environmentDivisionBody
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEnvironmentDivisionBody(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEnvironmentDivisionBody(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEnvironmentDivisionBody(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEnvironmentDivisionBody(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func environmentDivisionBody() throws -> EnvironmentDivisionBodyContext {
		var _localctx: EnvironmentDivisionBodyContext = EnvironmentDivisionBodyContext(_ctx, getState())
		try enterRule(_localctx, 28, Cobol85Parser.RULE_environmentDivisionBody)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1300)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CONFIGURATION:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1297)
		 		try configurationSection()

		 		break

		 	case .SPECIAL_NAMES:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1298)
		 		try specialNamesParagraph()

		 		break

		 	case .INPUT_OUTPUT:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1299)
		 		try inputOutputSection()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConfigurationSectionContext: ParserRuleContext {
			open
			func CONFIGURATION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONFIGURATION.rawValue, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func configurationSectionParagraph() -> [ConfigurationSectionParagraphContext] {
				return getRuleContexts(ConfigurationSectionParagraphContext.self)
			}
			open
			func configurationSectionParagraph(_ i: Int) -> ConfigurationSectionParagraphContext? {
				return getRuleContext(ConfigurationSectionParagraphContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_configurationSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterConfigurationSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitConfigurationSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitConfigurationSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitConfigurationSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func configurationSection() throws -> ConfigurationSectionContext {
		var _localctx: ConfigurationSectionContext = ConfigurationSectionContext(_ctx, getState())
		try enterRule(_localctx, 30, Cobol85Parser.RULE_configurationSection)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1302)
		 	try match(Cobol85Parser.Tokens.CONFIGURATION.rawValue)
		 	setState(1303)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(1304)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1308)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,21,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1305)
		 			try configurationSectionParagraph()

		 	 
		 		}
		 		setState(1310)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,21,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConfigurationSectionParagraphContext: ParserRuleContext {
			open
			func sourceComputerParagraph() -> SourceComputerParagraphContext? {
				return getRuleContext(SourceComputerParagraphContext.self, 0)
			}
			open
			func objectComputerParagraph() -> ObjectComputerParagraphContext? {
				return getRuleContext(ObjectComputerParagraphContext.self, 0)
			}
			open
			func specialNamesParagraph() -> SpecialNamesParagraphContext? {
				return getRuleContext(SpecialNamesParagraphContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_configurationSectionParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterConfigurationSectionParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitConfigurationSectionParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitConfigurationSectionParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitConfigurationSectionParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func configurationSectionParagraph() throws -> ConfigurationSectionParagraphContext {
		var _localctx: ConfigurationSectionParagraphContext = ConfigurationSectionParagraphContext(_ctx, getState())
		try enterRule(_localctx, 32, Cobol85Parser.RULE_configurationSectionParagraph)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1314)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SOURCE_COMPUTER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1311)
		 		try sourceComputerParagraph()

		 		break

		 	case .OBJECT_COMPUTER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1312)
		 		try objectComputerParagraph()

		 		break

		 	case .SPECIAL_NAMES:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1313)
		 		try specialNamesParagraph()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SourceComputerParagraphContext: ParserRuleContext {
			open
			func SOURCE_COMPUTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SOURCE_COMPUTER.rawValue, 0)
			}
			open
			func DOT_FS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.DOT_FS.rawValue)
			}
			open
			func DOT_FS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, i)
			}
			open
			func computerName() -> ComputerNameContext? {
				return getRuleContext(ComputerNameContext.self, 0)
			}
			open
			func DEBUGGING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEBUGGING.rawValue, 0)
			}
			open
			func MODE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MODE.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sourceComputerParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSourceComputerParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSourceComputerParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSourceComputerParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSourceComputerParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sourceComputerParagraph() throws -> SourceComputerParagraphContext {
		var _localctx: SourceComputerParagraphContext = SourceComputerParagraphContext(_ctx, getState())
		try enterRule(_localctx, 34, Cobol85Parser.RULE_sourceComputerParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1316)
		 	try match(Cobol85Parser.Tokens.SOURCE_COMPUTER.rawValue)
		 	setState(1317)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1318)
		 	try computerName()
		 	setState(1324)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.DEBUGGING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1320)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1319)
		 			try match(Cobol85Parser.Tokens.WITH.rawValue)

		 		}

		 		setState(1322)
		 		try match(Cobol85Parser.Tokens.DEBUGGING.rawValue)
		 		setState(1323)
		 		try match(Cobol85Parser.Tokens.MODE.rawValue)

		 	}

		 	setState(1326)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ObjectComputerParagraphContext: ParserRuleContext {
			open
			func OBJECT_COMPUTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OBJECT_COMPUTER.rawValue, 0)
			}
			open
			func DOT_FS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.DOT_FS.rawValue)
			}
			open
			func DOT_FS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, i)
			}
			open
			func computerName() -> ComputerNameContext? {
				return getRuleContext(ComputerNameContext.self, 0)
			}
			open
			func objectComputerClause() -> [ObjectComputerClauseContext] {
				return getRuleContexts(ObjectComputerClauseContext.self)
			}
			open
			func objectComputerClause(_ i: Int) -> ObjectComputerClauseContext? {
				return getRuleContext(ObjectComputerClauseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_objectComputerParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterObjectComputerParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitObjectComputerParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitObjectComputerParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitObjectComputerParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func objectComputerParagraph() throws -> ObjectComputerParagraphContext {
		var _localctx: ObjectComputerParagraphContext = ObjectComputerParagraphContext(_ctx, getState())
		try enterRule(_localctx, 36, Cobol85Parser.RULE_objectComputerParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1328)
		 	try match(Cobol85Parser.Tokens.OBJECT_COMPUTER.rawValue)
		 	setState(1329)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1330)
		 	try computerName()
		 	setState(1334)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTER.rawValue || _la == Cobol85Parser.Tokens.COLLATING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.DISK.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.MEMORY.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.PROGRAM.rawValue || _la == Cobol85Parser.Tokens.SEGMENT_LIMIT.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.SEQUENCE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1331)
		 		try objectComputerClause()


		 		setState(1336)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1337)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ObjectComputerClauseContext: ParserRuleContext {
			open
			func memorySizeClause() -> MemorySizeClauseContext? {
				return getRuleContext(MemorySizeClauseContext.self, 0)
			}
			open
			func diskSizeClause() -> DiskSizeClauseContext? {
				return getRuleContext(DiskSizeClauseContext.self, 0)
			}
			open
			func collatingSequenceClause() -> CollatingSequenceClauseContext? {
				return getRuleContext(CollatingSequenceClauseContext.self, 0)
			}
			open
			func segmentLimitClause() -> SegmentLimitClauseContext? {
				return getRuleContext(SegmentLimitClauseContext.self, 0)
			}
			open
			func characterSetClause() -> CharacterSetClauseContext? {
				return getRuleContext(CharacterSetClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_objectComputerClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterObjectComputerClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitObjectComputerClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitObjectComputerClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitObjectComputerClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func objectComputerClause() throws -> ObjectComputerClauseContext {
		var _localctx: ObjectComputerClauseContext = ObjectComputerClauseContext(_ctx, getState())
		try enterRule(_localctx, 38, Cobol85Parser.RULE_objectComputerClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1344)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .MEMORY:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1339)
		 		try memorySizeClause()

		 		break

		 	case .DISK:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1340)
		 		try diskSizeClause()

		 		break
		 	case .COLLATING:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .SEQUENCE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1341)
		 		try collatingSequenceClause()

		 		break

		 	case .SEGMENT_LIMIT:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1342)
		 		try segmentLimitClause()

		 		break

		 	case .CHARACTER:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1343)
		 		try characterSetClause()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MemorySizeClauseContext: ParserRuleContext {
			open
			func MEMORY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MEMORY.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
			open
			func SIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIZE.rawValue, 0)
			}
			open
			func WORDS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WORDS.rawValue, 0)
			}
			open
			func CHARACTERS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTERS.rawValue, 0)
			}
			open
			func MODULES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MODULES.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_memorySizeClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMemorySizeClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMemorySizeClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMemorySizeClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMemorySizeClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func memorySizeClause() throws -> MemorySizeClauseContext {
		var _localctx: MemorySizeClauseContext = MemorySizeClauseContext(_ctx, getState())
		try enterRule(_localctx, 40, Cobol85Parser.RULE_memorySizeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1346)
		 	try match(Cobol85Parser.Tokens.MEMORY.rawValue)
		 	setState(1348)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SIZE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1347)
		 		try match(Cobol85Parser.Tokens.SIZE.rawValue)

		 	}

		 	setState(1352)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		setState(1350)
		 		try integerLiteral()

		 		break
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		setState(1351)
		 		try cobolWord()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1355)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTERS.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.MODULES.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.WORDS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1354)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTERS.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.MODULES.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.WORDS.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DiskSizeClauseContext: ParserRuleContext {
			open
			func DISK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISK.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
			open
			func SIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIZE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func WORDS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WORDS.rawValue, 0)
			}
			open
			func MODULES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MODULES.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_diskSizeClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDiskSizeClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDiskSizeClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDiskSizeClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDiskSizeClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func diskSizeClause() throws -> DiskSizeClauseContext {
		var _localctx: DiskSizeClauseContext = DiskSizeClauseContext(_ctx, getState())
		try enterRule(_localctx, 42, Cobol85Parser.RULE_diskSizeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1357)
		 	try match(Cobol85Parser.Tokens.DISK.rawValue)
		 	setState(1359)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SIZE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1358)
		 		try match(Cobol85Parser.Tokens.SIZE.rawValue)

		 	}

		 	setState(1362)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1361)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1366)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		setState(1364)
		 		try integerLiteral()

		 		break
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		setState(1365)
		 		try cobolWord()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1369)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.MODULES.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.WORDS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1368)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.MODULES.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.WORDS.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CollatingSequenceClauseContext: ParserRuleContext {
			open
			func SEQUENCE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEQUENCE.rawValue, 0)
			}
			open
			func PROGRAM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROGRAM.rawValue, 0)
			}
			open
			func COLLATING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COLLATING.rawValue, 0)
			}
			open
			func collatingSequenceClauseAlphanumeric() -> CollatingSequenceClauseAlphanumericContext? {
				return getRuleContext(CollatingSequenceClauseAlphanumericContext.self, 0)
			}
			open
			func collatingSequenceClauseNational() -> CollatingSequenceClauseNationalContext? {
				return getRuleContext(CollatingSequenceClauseNationalContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func alphabetName() -> [AlphabetNameContext] {
				return getRuleContexts(AlphabetNameContext.self)
			}
			open
			func alphabetName(_ i: Int) -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_collatingSequenceClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCollatingSequenceClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCollatingSequenceClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCollatingSequenceClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCollatingSequenceClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func collatingSequenceClause() throws -> CollatingSequenceClauseContext {
		var _localctx: CollatingSequenceClauseContext = CollatingSequenceClauseContext(_ctx, getState())
		try enterRule(_localctx, 44, Cobol85Parser.RULE_collatingSequenceClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1372)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.PROGRAM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1371)
		 		try match(Cobol85Parser.Tokens.PROGRAM.rawValue)

		 	}

		 	setState(1375)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COLLATING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1374)
		 		try match(Cobol85Parser.Tokens.COLLATING.rawValue)

		 	}

		 	setState(1377)
		 	try match(Cobol85Parser.Tokens.SEQUENCE.rawValue)

		 	setState(1379)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1378)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1382); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1381)
		 			try alphabetName()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1384); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,37,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 	setState(1387)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,38,_ctx)) {
		 	case 1:
		 		setState(1386)
		 		try collatingSequenceClauseAlphanumeric()

		 		break
		 	default: break
		 	}
		 	setState(1390)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.NATIONAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1389)
		 		try collatingSequenceClauseNational()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CollatingSequenceClauseAlphanumericContext: ParserRuleContext {
			open
			func ALPHANUMERIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHANUMERIC.rawValue, 0)
			}
			open
			func alphabetName() -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_collatingSequenceClauseAlphanumeric
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCollatingSequenceClauseAlphanumeric(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCollatingSequenceClauseAlphanumeric(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCollatingSequenceClauseAlphanumeric(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCollatingSequenceClauseAlphanumeric(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func collatingSequenceClauseAlphanumeric() throws -> CollatingSequenceClauseAlphanumericContext {
		var _localctx: CollatingSequenceClauseAlphanumericContext = CollatingSequenceClauseAlphanumericContext(_ctx, getState())
		try enterRule(_localctx, 46, Cobol85Parser.RULE_collatingSequenceClauseAlphanumeric)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1393)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1392)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(1395)
		 	try match(Cobol85Parser.Tokens.ALPHANUMERIC.rawValue)
		 	setState(1397)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1396)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1399)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CollatingSequenceClauseNationalContext: ParserRuleContext {
			open
			func NATIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIONAL.rawValue, 0)
			}
			open
			func alphabetName() -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_collatingSequenceClauseNational
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCollatingSequenceClauseNational(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCollatingSequenceClauseNational(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCollatingSequenceClauseNational(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCollatingSequenceClauseNational(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func collatingSequenceClauseNational() throws -> CollatingSequenceClauseNationalContext {
		var _localctx: CollatingSequenceClauseNationalContext = CollatingSequenceClauseNationalContext(_ctx, getState())
		try enterRule(_localctx, 48, Cobol85Parser.RULE_collatingSequenceClauseNational)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1402)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1401)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(1404)
		 	try match(Cobol85Parser.Tokens.NATIONAL.rawValue)
		 	setState(1406)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1405)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1408)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SegmentLimitClauseContext: ParserRuleContext {
			open
			func SEGMENT_LIMIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEGMENT_LIMIT.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_segmentLimitClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSegmentLimitClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSegmentLimitClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSegmentLimitClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSegmentLimitClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func segmentLimitClause() throws -> SegmentLimitClauseContext {
		var _localctx: SegmentLimitClauseContext = SegmentLimitClauseContext(_ctx, getState())
		try enterRule(_localctx, 50, Cobol85Parser.RULE_segmentLimitClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1410)
		 	try match(Cobol85Parser.Tokens.SEGMENT_LIMIT.rawValue)
		 	setState(1412)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1411)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1414)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CharacterSetClauseContext: ParserRuleContext {
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SET.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_characterSetClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCharacterSetClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCharacterSetClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCharacterSetClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCharacterSetClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func characterSetClause() throws -> CharacterSetClauseContext {
		var _localctx: CharacterSetClauseContext = CharacterSetClauseContext(_ctx, getState())
		try enterRule(_localctx, 52, Cobol85Parser.RULE_characterSetClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1416)
		 	try match(Cobol85Parser.Tokens.CHARACTER.rawValue)
		 	setState(1417)
		 	try match(Cobol85Parser.Tokens.SET.rawValue)
		 	setState(1418)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SpecialNamesParagraphContext: ParserRuleContext {
			open
			func SPECIAL_NAMES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SPECIAL_NAMES.rawValue, 0)
			}
			open
			func DOT_FS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.DOT_FS.rawValue)
			}
			open
			func DOT_FS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, i)
			}
			open
			func specialNameClause() -> [SpecialNameClauseContext] {
				return getRuleContexts(SpecialNameClauseContext.self)
			}
			open
			func specialNameClause(_ i: Int) -> SpecialNameClauseContext? {
				return getRuleContext(SpecialNameClauseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_specialNamesParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSpecialNamesParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSpecialNamesParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSpecialNamesParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSpecialNamesParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func specialNamesParagraph() throws -> SpecialNamesParagraphContext {
		var _localctx: SpecialNamesParagraphContext = SpecialNamesParagraphContext(_ctx, getState())
		try enterRule(_localctx, 54, Cobol85Parser.RULE_specialNamesParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1420)
		 	try match(Cobol85Parser.Tokens.SPECIAL_NAMES.rawValue)
		 	setState(1421)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1429)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ALPHABET.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLASS.rawValue,Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURRENCY.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DECIMAL_POINT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 64)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue,Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 128)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue,Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue,Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 258)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.OFF.rawValue,Cobol85Parser.Tokens.ON.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue,Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue,Cobol85Parser.Tokens.RESERVE.rawValue,Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 391)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.SYMBOLIC.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1423) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(1422)
		 			try specialNameClause()


		 			setState(1425); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ALPHABET.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLASS.rawValue,Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURRENCY.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DECIMAL_POINT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 64)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue,Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 128)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue,Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 194)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue,Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 258)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.OFF.rawValue,Cobol85Parser.Tokens.ON.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue,Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 322)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue,Cobol85Parser.Tokens.RESERVE.rawValue,Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 391)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.SYMBOLIC.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 466)
		 		          }()
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 		      return testSet
		 		 }())
		 		setState(1427)
		 		try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SpecialNameClauseContext: ParserRuleContext {
			open
			func channelClause() -> ChannelClauseContext? {
				return getRuleContext(ChannelClauseContext.self, 0)
			}
			open
			func odtClause() -> OdtClauseContext? {
				return getRuleContext(OdtClauseContext.self, 0)
			}
			open
			func alphabetClause() -> AlphabetClauseContext? {
				return getRuleContext(AlphabetClauseContext.self, 0)
			}
			open
			func classClause() -> ClassClauseContext? {
				return getRuleContext(ClassClauseContext.self, 0)
			}
			open
			func currencySignClause() -> CurrencySignClauseContext? {
				return getRuleContext(CurrencySignClauseContext.self, 0)
			}
			open
			func decimalPointClause() -> DecimalPointClauseContext? {
				return getRuleContext(DecimalPointClauseContext.self, 0)
			}
			open
			func symbolicCharactersClause() -> SymbolicCharactersClauseContext? {
				return getRuleContext(SymbolicCharactersClauseContext.self, 0)
			}
			open
			func environmentSwitchNameClause() -> EnvironmentSwitchNameClauseContext? {
				return getRuleContext(EnvironmentSwitchNameClauseContext.self, 0)
			}
			open
			func defaultDisplaySignClause() -> DefaultDisplaySignClauseContext? {
				return getRuleContext(DefaultDisplaySignClauseContext.self, 0)
			}
			open
			func defaultComputationalSignClause() -> DefaultComputationalSignClauseContext? {
				return getRuleContext(DefaultComputationalSignClauseContext.self, 0)
			}
			open
			func reserveNetworkClause() -> ReserveNetworkClauseContext? {
				return getRuleContext(ReserveNetworkClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_specialNameClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSpecialNameClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSpecialNameClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSpecialNameClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSpecialNameClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func specialNameClause() throws -> SpecialNameClauseContext {
		var _localctx: SpecialNameClauseContext = SpecialNameClauseContext(_ctx, getState())
		try enterRule(_localctx, 56, Cobol85Parser.RULE_specialNameClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1442)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,47, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1431)
		 		try channelClause()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1432)
		 		try odtClause()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1433)
		 		try alphabetClause()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1434)
		 		try classClause()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1435)
		 		try currencySignClause()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1436)
		 		try decimalPointClause()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1437)
		 		try symbolicCharactersClause()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1438)
		 		try environmentSwitchNameClause()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1439)
		 		try defaultDisplaySignClause()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1440)
		 		try defaultComputationalSignClause()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1441)
		 		try reserveNetworkClause()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlphabetClauseContext: ParserRuleContext {
			open
			func alphabetClauseFormat1() -> AlphabetClauseFormat1Context? {
				return getRuleContext(AlphabetClauseFormat1Context.self, 0)
			}
			open
			func alphabetClauseFormat2() -> AlphabetClauseFormat2Context? {
				return getRuleContext(AlphabetClauseFormat2Context.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_alphabetClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAlphabetClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAlphabetClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAlphabetClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAlphabetClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func alphabetClause() throws -> AlphabetClauseContext {
		var _localctx: AlphabetClauseContext = AlphabetClauseContext(_ctx, getState())
		try enterRule(_localctx, 58, Cobol85Parser.RULE_alphabetClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1446)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,48, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1444)
		 		try alphabetClauseFormat1()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1445)
		 		try alphabetClauseFormat2()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlphabetClauseFormat1Context: ParserRuleContext {
			open
			func ALPHABET() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHABET.rawValue, 0)
			}
			open
			func alphabetName() -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, 0)
			}
			open
			func EBCDIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EBCDIC.rawValue, 0)
			}
			open
			func ASCII() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASCII.rawValue, 0)
			}
			open
			func STANDARD_1() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STANDARD_1.rawValue, 0)
			}
			open
			func STANDARD_2() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STANDARD_2.rawValue, 0)
			}
			open
			func NATIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIVE.rawValue, 0)
			}
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func ALPHANUMERIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHANUMERIC.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func alphabetLiterals() -> [AlphabetLiteralsContext] {
				return getRuleContexts(AlphabetLiteralsContext.self)
			}
			open
			func alphabetLiterals(_ i: Int) -> AlphabetLiteralsContext? {
				return getRuleContext(AlphabetLiteralsContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_alphabetClauseFormat1
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAlphabetClauseFormat1(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAlphabetClauseFormat1(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAlphabetClauseFormat1(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAlphabetClauseFormat1(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func alphabetClauseFormat1() throws -> AlphabetClauseFormat1Context {
		var _localctx: AlphabetClauseFormat1Context = AlphabetClauseFormat1Context(_ctx, getState())
		try enterRule(_localctx, 60, Cobol85Parser.RULE_alphabetClauseFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1448)
		 	try match(Cobol85Parser.Tokens.ALPHABET.rawValue)
		 	setState(1449)
		 	try alphabetName()
		 	setState(1452)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1450)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)
		 		setState(1451)
		 		try match(Cobol85Parser.Tokens.ALPHANUMERIC.rawValue)

		 	}

		 	setState(1455)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1454)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1468)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,52, _ctx)) {
		 	case 1:
		 		setState(1457)
		 		try match(Cobol85Parser.Tokens.EBCDIC.rawValue)

		 		break
		 	case 2:
		 		setState(1458)
		 		try match(Cobol85Parser.Tokens.ASCII.rawValue)

		 		break
		 	case 3:
		 		setState(1459)
		 		try match(Cobol85Parser.Tokens.STANDARD_1.rawValue)

		 		break
		 	case 4:
		 		setState(1460)
		 		try match(Cobol85Parser.Tokens.STANDARD_2.rawValue)

		 		break
		 	case 5:
		 		setState(1461)
		 		try match(Cobol85Parser.Tokens.NATIVE.rawValue)

		 		break
		 	case 6:
		 		setState(1462)
		 		try cobolWord()

		 		break
		 	case 7:
		 		setState(1464); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(1463)
		 				try alphabetLiterals()


		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(1466); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,51,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlphabetLiteralsContext: ParserRuleContext {
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func alphabetThrough() -> AlphabetThroughContext? {
				return getRuleContext(AlphabetThroughContext.self, 0)
			}
			open
			func alphabetAlso() -> [AlphabetAlsoContext] {
				return getRuleContexts(AlphabetAlsoContext.self)
			}
			open
			func alphabetAlso(_ i: Int) -> AlphabetAlsoContext? {
				return getRuleContext(AlphabetAlsoContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_alphabetLiterals
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAlphabetLiterals(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAlphabetLiterals(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAlphabetLiterals(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAlphabetLiterals(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func alphabetLiterals() throws -> AlphabetLiteralsContext {
		var _localctx: AlphabetLiteralsContext = AlphabetLiteralsContext(_ctx, getState())
		try enterRule(_localctx, 62, Cobol85Parser.RULE_alphabetLiterals)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1470)
		 	try literal()
		 	setState(1477)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .THROUGH:fallthrough
		 	case .THRU:
		 	 	setState(1471)
		 	 	try alphabetThrough()

		 		break

		 	case .ALSO:
		 	 	setState(1473) 
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	repeat {
		 	 		setState(1472)
		 	 		try alphabetAlso()


		 	 		setState(1475); 
		 	 		try _errHandler.sync(self)
		 	 		_la = try _input.LA(1)
		 	 	} while (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ALSO.rawValue
		 	 	      return testSet
		 	 	 }())

		 		break
		 	case .ABORT:fallthrough
		 	case .ALL:fallthrough
		 	case .ALPHABET:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLASS:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURRENCY:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DECIMAL_POINT:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FALSE:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .HIGH_VALUE:fallthrough
		 	case .HIGH_VALUES:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .LOW_VALUE:fallthrough
		 	case .LOW_VALUES:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .OFF:fallthrough
		 	case .ON:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .QUOTE:fallthrough
		 	case .QUOTES:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .RESERVE:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SPACE:fallthrough
		 	case .SPACES:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .SYMBOLIC:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .ZEROS:fallthrough
		 	case .ZEROES:fallthrough
		 	case .DOT_FS:fallthrough
		 	case .NONNUMERICLITERAL:fallthrough
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:fallthrough
		 	case .NUMERICLITERAL:fallthrough
		 	case .IDENTIFIER:
		 		break
		 	default:
		 		break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlphabetThroughContext: ParserRuleContext {
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func THROUGH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THROUGH.rawValue, 0)
			}
			open
			func THRU() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THRU.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_alphabetThrough
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAlphabetThrough(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAlphabetThrough(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAlphabetThrough(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAlphabetThrough(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func alphabetThrough() throws -> AlphabetThroughContext {
		var _localctx: AlphabetThroughContext = AlphabetThroughContext(_ctx, getState())
		try enterRule(_localctx, 64, Cobol85Parser.RULE_alphabetThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1479)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1480)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlphabetAlsoContext: ParserRuleContext {
			open
			func ALSO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALSO.rawValue, 0)
			}
			open
			func literal() -> [LiteralContext] {
				return getRuleContexts(LiteralContext.self)
			}
			open
			func literal(_ i: Int) -> LiteralContext? {
				return getRuleContext(LiteralContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_alphabetAlso
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAlphabetAlso(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAlphabetAlso(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAlphabetAlso(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAlphabetAlso(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func alphabetAlso() throws -> AlphabetAlsoContext {
		var _localctx: AlphabetAlsoContext = AlphabetAlsoContext(_ctx, getState())
		try enterRule(_localctx, 66, Cobol85Parser.RULE_alphabetAlso)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1482)
		 	try match(Cobol85Parser.Tokens.ALSO.rawValue)
		 	setState(1484); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1483)
		 			try literal()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1486); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,55,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlphabetClauseFormat2Context: ParserRuleContext {
			open
			func ALPHABET() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHABET.rawValue, 0)
			}
			open
			func alphabetName() -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, 0)
			}
			open
			func NATIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIONAL.rawValue, 0)
			}
			open
			func NATIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIVE.rawValue, 0)
			}
			open
			func CCSVERSION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CCSVERSION.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_alphabetClauseFormat2
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAlphabetClauseFormat2(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAlphabetClauseFormat2(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAlphabetClauseFormat2(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAlphabetClauseFormat2(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func alphabetClauseFormat2() throws -> AlphabetClauseFormat2Context {
		var _localctx: AlphabetClauseFormat2Context = AlphabetClauseFormat2Context(_ctx, getState())
		try enterRule(_localctx, 68, Cobol85Parser.RULE_alphabetClauseFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1488)
		 	try match(Cobol85Parser.Tokens.ALPHABET.rawValue)
		 	setState(1489)
		 	try alphabetName()
		 	setState(1491)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1490)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(1493)
		 	try match(Cobol85Parser.Tokens.NATIONAL.rawValue)
		 	setState(1495)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1494)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1500)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NATIVE:
		 		setState(1497)
		 		try match(Cobol85Parser.Tokens.NATIVE.rawValue)

		 		break

		 	case .CCSVERSION:
		 		setState(1498)
		 		try match(Cobol85Parser.Tokens.CCSVERSION.rawValue)
		 		setState(1499)
		 		try literal()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ChannelClauseContext: ParserRuleContext {
			open
			func CHANNEL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHANNEL.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func mnemonicName() -> MnemonicNameContext? {
				return getRuleContext(MnemonicNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_channelClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterChannelClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitChannelClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitChannelClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitChannelClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func channelClause() throws -> ChannelClauseContext {
		var _localctx: ChannelClauseContext = ChannelClauseContext(_ctx, getState())
		try enterRule(_localctx, 70, Cobol85Parser.RULE_channelClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1502)
		 	try match(Cobol85Parser.Tokens.CHANNEL.rawValue)
		 	setState(1503)
		 	try integerLiteral()
		 	setState(1505)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1504)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1507)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClassClauseContext: ParserRuleContext {
			open
			func CLASS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CLASS.rawValue, 0)
			}
			open
			func className() -> ClassNameContext? {
				return getRuleContext(ClassNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func classClauseThrough() -> [ClassClauseThroughContext] {
				return getRuleContexts(ClassClauseThroughContext.self)
			}
			open
			func classClauseThrough(_ i: Int) -> ClassClauseThroughContext? {
				return getRuleContext(ClassClauseThroughContext.self, i)
			}
			open
			func ALPHANUMERIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHANUMERIC.rawValue, 0)
			}
			open
			func NATIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIONAL.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_classClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterClassClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitClassClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitClassClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitClassClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func classClause() throws -> ClassClauseContext {
		var _localctx: ClassClauseContext = ClassClauseContext(_ctx, getState())
		try enterRule(_localctx, 72, Cobol85Parser.RULE_classClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1509)
		 	try match(Cobol85Parser.Tokens.CLASS.rawValue)
		 	setState(1510)
		 	try className()
		 	setState(1515)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,61,_ctx)) {
		 	case 1:
		 		setState(1512)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1511)
		 			try match(Cobol85Parser.Tokens.FOR.rawValue)

		 		}

		 		setState(1514)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.ALPHANUMERIC.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.NATIONAL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(1518)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1517)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1521); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1520)
		 			try classClauseThrough()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1523); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,63,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClassClauseThroughContext: ParserRuleContext {
			open
			func classClauseFrom() -> ClassClauseFromContext? {
				return getRuleContext(ClassClauseFromContext.self, 0)
			}
			open
			func classClauseTo() -> ClassClauseToContext? {
				return getRuleContext(ClassClauseToContext.self, 0)
			}
			open
			func THROUGH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THROUGH.rawValue, 0)
			}
			open
			func THRU() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THRU.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_classClauseThrough
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterClassClauseThrough(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitClassClauseThrough(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitClassClauseThrough(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitClassClauseThrough(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func classClauseThrough() throws -> ClassClauseThroughContext {
		var _localctx: ClassClauseThroughContext = ClassClauseThroughContext(_ctx, getState())
		try enterRule(_localctx, 74, Cobol85Parser.RULE_classClauseThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1525)
		 	try classClauseFrom()
		 	setState(1528)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1526)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1527)
		 		try classClauseTo()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClassClauseFromContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_classClauseFrom
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterClassClauseFrom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitClassClauseFrom(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitClassClauseFrom(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitClassClauseFrom(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func classClauseFrom() throws -> ClassClauseFromContext {
		var _localctx: ClassClauseFromContext = ClassClauseFromContext(_ctx, getState())
		try enterRule(_localctx, 76, Cobol85Parser.RULE_classClauseFrom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1532)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,65, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1530)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1531)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClassClauseToContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_classClauseTo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterClassClauseTo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitClassClauseTo(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitClassClauseTo(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitClassClauseTo(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func classClauseTo() throws -> ClassClauseToContext {
		var _localctx: ClassClauseToContext = ClassClauseToContext(_ctx, getState())
		try enterRule(_localctx, 78, Cobol85Parser.RULE_classClauseTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1536)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,66, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1534)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1535)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CurrencySignClauseContext: ParserRuleContext {
			open
			func CURRENCY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CURRENCY.rawValue, 0)
			}
			open
			func literal() -> [LiteralContext] {
				return getRuleContexts(LiteralContext.self)
			}
			open
			func literal(_ i: Int) -> LiteralContext? {
				return getRuleContext(LiteralContext.self, i)
			}
			open
			func SIGN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIGN.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func PICTURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PICTURE.rawValue, 0)
			}
			open
			func SYMBOL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SYMBOL.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_currencySignClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCurrencySignClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCurrencySignClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCurrencySignClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCurrencySignClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func currencySignClause() throws -> CurrencySignClauseContext {
		var _localctx: CurrencySignClauseContext = CurrencySignClauseContext(_ctx, getState())
		try enterRule(_localctx, 80, Cobol85Parser.RULE_currencySignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1538)
		 	try match(Cobol85Parser.Tokens.CURRENCY.rawValue)
		 	setState(1540)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SIGN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1539)
		 		try match(Cobol85Parser.Tokens.SIGN.rawValue)

		 	}

		 	setState(1543)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1542)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1545)
		 	try literal()
		 	setState(1552)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.PICTURE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1547)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1546)
		 			try match(Cobol85Parser.Tokens.WITH.rawValue)

		 		}

		 		setState(1549)
		 		try match(Cobol85Parser.Tokens.PICTURE.rawValue)
		 		setState(1550)
		 		try match(Cobol85Parser.Tokens.SYMBOL.rawValue)
		 		setState(1551)
		 		try literal()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DecimalPointClauseContext: ParserRuleContext {
			open
			func DECIMAL_POINT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DECIMAL_POINT.rawValue, 0)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMA.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_decimalPointClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDecimalPointClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDecimalPointClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDecimalPointClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDecimalPointClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func decimalPointClause() throws -> DecimalPointClauseContext {
		var _localctx: DecimalPointClauseContext = DecimalPointClauseContext(_ctx, getState())
		try enterRule(_localctx, 82, Cobol85Parser.RULE_decimalPointClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1554)
		 	try match(Cobol85Parser.Tokens.DECIMAL_POINT.rawValue)
		 	setState(1556)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1555)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1558)
		 	try match(Cobol85Parser.Tokens.COMMA.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DefaultComputationalSignClauseContext: ParserRuleContext {
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func SEPARATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEPARATE.rawValue, 0)
			}
			open
			func SIGN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIGN.rawValue, 0)
			}
			open
			func COMPUTATIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMPUTATIONAL.rawValue, 0)
			}
			open
			func COMP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMP.rawValue, 0)
			}
			open
			func LEADING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEADING.rawValue, 0)
			}
			open
			func TRAILING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TRAILING.rawValue, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_defaultComputationalSignClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDefaultComputationalSignClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDefaultComputationalSignClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDefaultComputationalSignClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDefaultComputationalSignClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func defaultComputationalSignClause() throws -> DefaultComputationalSignClauseContext {
		var _localctx: DefaultComputationalSignClauseContext = DefaultComputationalSignClauseContext(_ctx, getState())
		try enterRule(_localctx, 84, Cobol85Parser.RULE_defaultComputationalSignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1560)
		 	try match(Cobol85Parser.Tokens.DEFAULT.rawValue)
		 	setState(1562)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COMP.rawValue || _la == Cobol85Parser.Tokens.COMPUTATIONAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1561)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.COMP.rawValue || _la == Cobol85Parser.Tokens.COMPUTATIONAL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(1568)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SIGN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1564)
		 		try match(Cobol85Parser.Tokens.SIGN.rawValue)
		 		setState(1566)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1565)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}


		 	}

		 	setState(1571)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.LEADING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.TRAILING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1570)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.LEADING.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.TRAILING.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(1573)
		 	try match(Cobol85Parser.Tokens.SEPARATE.rawValue)
		 	setState(1575)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1574)
		 		try match(Cobol85Parser.Tokens.CHARACTER.rawValue)

		 	}



		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DefaultDisplaySignClauseContext: ParserRuleContext {
			open
			func DEFAULT_DISPLAY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue, 0)
			}
			open
			func LEADING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEADING.rawValue, 0)
			}
			open
			func TRAILING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TRAILING.rawValue, 0)
			}
			open
			func SIGN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIGN.rawValue, 0)
			}
			open
			func SEPARATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEPARATE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_defaultDisplaySignClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDefaultDisplaySignClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDefaultDisplaySignClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDefaultDisplaySignClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDefaultDisplaySignClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func defaultDisplaySignClause() throws -> DefaultDisplaySignClauseContext {
		var _localctx: DefaultDisplaySignClauseContext = DefaultDisplaySignClauseContext(_ctx, getState())
		try enterRule(_localctx, 86, Cobol85Parser.RULE_defaultDisplaySignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1577)
		 	try match(Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue)
		 	setState(1582)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SIGN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1578)
		 		try match(Cobol85Parser.Tokens.SIGN.rawValue)
		 		setState(1580)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1579)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}


		 	}

		 	setState(1584)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.LEADING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.TRAILING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1589)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SEPARATE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1585)
		 		try match(Cobol85Parser.Tokens.SEPARATE.rawValue)
		 		setState(1587)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTER.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1586)
		 			try match(Cobol85Parser.Tokens.CHARACTER.rawValue)

		 		}


		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EnvironmentSwitchNameClauseContext: ParserRuleContext {
			open
			func environmentName() -> EnvironmentNameContext? {
				return getRuleContext(EnvironmentNameContext.self, 0)
			}
			open
			func mnemonicName() -> MnemonicNameContext? {
				return getRuleContext(MnemonicNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func environmentSwitchNameSpecialNamesStatusPhrase() -> EnvironmentSwitchNameSpecialNamesStatusPhraseContext? {
				return getRuleContext(EnvironmentSwitchNameSpecialNamesStatusPhraseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_environmentSwitchNameClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEnvironmentSwitchNameClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEnvironmentSwitchNameClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEnvironmentSwitchNameClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEnvironmentSwitchNameClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func environmentSwitchNameClause() throws -> EnvironmentSwitchNameClauseContext {
		var _localctx: EnvironmentSwitchNameClauseContext = EnvironmentSwitchNameClauseContext(_ctx, getState())
		try enterRule(_localctx, 88, Cobol85Parser.RULE_environmentSwitchNameClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1600)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1591)
		 		try environmentName()
		 		setState(1593)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1592)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}

		 		setState(1595)
		 		try mnemonicName()
		 		setState(1597)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,82,_ctx)) {
		 		case 1:
		 			setState(1596)
		 			try environmentSwitchNameSpecialNamesStatusPhrase()

		 			break
		 		default: break
		 		}

		 		break
		 	case .OFF:fallthrough
		 	case .ON:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1599)
		 		try environmentSwitchNameSpecialNamesStatusPhrase()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EnvironmentSwitchNameSpecialNamesStatusPhraseContext: ParserRuleContext {
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func condition() -> [ConditionContext] {
				return getRuleContexts(ConditionContext.self)
			}
			open
			func condition(_ i: Int) -> ConditionContext? {
				return getRuleContext(ConditionContext.self, i)
			}
			open
			func STATUS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.STATUS.rawValue)
			}
			open
			func STATUS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STATUS.rawValue, i)
			}
			open
			func IS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.IS.rawValue)
			}
			open
			func IS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, i)
			}
			open
			func OFF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OFF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_environmentSwitchNameSpecialNamesStatusPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEnvironmentSwitchNameSpecialNamesStatusPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEnvironmentSwitchNameSpecialNamesStatusPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEnvironmentSwitchNameSpecialNamesStatusPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEnvironmentSwitchNameSpecialNamesStatusPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func environmentSwitchNameSpecialNamesStatusPhrase() throws -> EnvironmentSwitchNameSpecialNamesStatusPhraseContext {
		var _localctx: EnvironmentSwitchNameSpecialNamesStatusPhraseContext = EnvironmentSwitchNameSpecialNamesStatusPhraseContext(_ctx, getState())
		try enterRule(_localctx, 90, Cobol85Parser.RULE_environmentSwitchNameSpecialNamesStatusPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1638)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ON:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1602)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)
		 		setState(1604)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.STATUS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1603)
		 			try match(Cobol85Parser.Tokens.STATUS.rawValue)

		 		}

		 		setState(1607)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1606)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}

		 		setState(1609)
		 		try condition()
		 		setState(1618)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,88,_ctx)) {
		 		case 1:
		 			setState(1610)
		 			try match(Cobol85Parser.Tokens.OFF.rawValue)
		 			setState(1612)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.STATUS.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(1611)
		 				try match(Cobol85Parser.Tokens.STATUS.rawValue)

		 			}

		 			setState(1615)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(1614)
		 				try match(Cobol85Parser.Tokens.IS.rawValue)

		 			}

		 			setState(1617)
		 			try condition()

		 			break
		 		default: break
		 		}

		 		break

		 	case .OFF:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1620)
		 		try match(Cobol85Parser.Tokens.OFF.rawValue)
		 		setState(1622)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.STATUS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1621)
		 			try match(Cobol85Parser.Tokens.STATUS.rawValue)

		 		}

		 		setState(1625)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1624)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}

		 		setState(1627)
		 		try condition()
		 		setState(1636)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,93,_ctx)) {
		 		case 1:
		 			setState(1628)
		 			try match(Cobol85Parser.Tokens.ON.rawValue)
		 			setState(1630)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.STATUS.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(1629)
		 				try match(Cobol85Parser.Tokens.STATUS.rawValue)

		 			}

		 			setState(1633)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(1632)
		 				try match(Cobol85Parser.Tokens.IS.rawValue)

		 			}

		 			setState(1635)
		 			try condition()

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OdtClauseContext: ParserRuleContext {
			open
			func ODT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ODT.rawValue, 0)
			}
			open
			func mnemonicName() -> MnemonicNameContext? {
				return getRuleContext(MnemonicNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_odtClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOdtClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOdtClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOdtClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOdtClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func odtClause() throws -> OdtClauseContext {
		var _localctx: OdtClauseContext = OdtClauseContext(_ctx, getState())
		try enterRule(_localctx, 92, Cobol85Parser.RULE_odtClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1640)
		 	try match(Cobol85Parser.Tokens.ODT.rawValue)
		 	setState(1642)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1641)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1644)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReserveNetworkClauseContext: ParserRuleContext {
			open
			func RESERVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RESERVE.rawValue, 0)
			}
			open
			func NETWORK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NETWORK.rawValue, 0)
			}
			open
			func WORDS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WORDS.rawValue, 0)
			}
			open
			func LIST() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LIST.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func CAPABLE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CAPABLE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reserveNetworkClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReserveNetworkClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReserveNetworkClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReserveNetworkClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReserveNetworkClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reserveNetworkClause() throws -> ReserveNetworkClauseContext {
		var _localctx: ReserveNetworkClauseContext = ReserveNetworkClauseContext(_ctx, getState())
		try enterRule(_localctx, 94, Cobol85Parser.RULE_reserveNetworkClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1646)
		 	try match(Cobol85Parser.Tokens.RESERVE.rawValue)
		 	setState(1648)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WORDS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1647)
		 		try match(Cobol85Parser.Tokens.WORDS.rawValue)

		 	}

		 	setState(1651)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LIST.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1650)
		 		try match(Cobol85Parser.Tokens.LIST.rawValue)

		 	}

		 	setState(1654)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1653)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1656)
		 	try match(Cobol85Parser.Tokens.NETWORK.rawValue)
		 	setState(1658)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,99,_ctx)) {
		 	case 1:
		 		setState(1657)
		 		try match(Cobol85Parser.Tokens.CAPABLE.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolicCharactersClauseContext: ParserRuleContext {
			open
			func SYMBOLIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SYMBOLIC.rawValue, 0)
			}
			open
			func CHARACTERS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTERS.rawValue, 0)
			}
			open
			func symbolicCharacters() -> [SymbolicCharactersContext] {
				return getRuleContexts(SymbolicCharactersContext.self)
			}
			open
			func symbolicCharacters(_ i: Int) -> SymbolicCharactersContext? {
				return getRuleContext(SymbolicCharactersContext.self, i)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
			open
			func alphabetName() -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, 0)
			}
			open
			func ALPHANUMERIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHANUMERIC.rawValue, 0)
			}
			open
			func NATIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIONAL.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_symbolicCharactersClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSymbolicCharactersClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSymbolicCharactersClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSymbolicCharactersClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSymbolicCharactersClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolicCharactersClause() throws -> SymbolicCharactersClauseContext {
		var _localctx: SymbolicCharactersClauseContext = SymbolicCharactersClauseContext(_ctx, getState())
		try enterRule(_localctx, 96, Cobol85Parser.RULE_symbolicCharactersClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1660)
		 	try match(Cobol85Parser.Tokens.SYMBOLIC.rawValue)
		 	setState(1662)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTERS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1661)
		 		try match(Cobol85Parser.Tokens.CHARACTERS.rawValue)

		 	}

		 	setState(1668)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,102,_ctx)) {
		 	case 1:
		 		setState(1665)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1664)
		 			try match(Cobol85Parser.Tokens.FOR.rawValue)

		 		}

		 		setState(1667)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.ALPHANUMERIC.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.NATIONAL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(1671); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1670)
		 			try symbolicCharacters()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1673); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,103,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(1677)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1675)
		 		try match(Cobol85Parser.Tokens.IN.rawValue)
		 		setState(1676)
		 		try alphabetName()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolicCharactersContext: ParserRuleContext {
			open
			func symbolicCharacter() -> [SymbolicCharacterContext] {
				return getRuleContexts(SymbolicCharacterContext.self)
			}
			open
			func symbolicCharacter(_ i: Int) -> SymbolicCharacterContext? {
				return getRuleContext(SymbolicCharacterContext.self, i)
			}
			open
			func integerLiteral() -> [IntegerLiteralContext] {
				return getRuleContexts(IntegerLiteralContext.self)
			}
			open
			func integerLiteral(_ i: Int) -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, i)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func ARE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ARE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_symbolicCharacters
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSymbolicCharacters(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSymbolicCharacters(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSymbolicCharacters(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSymbolicCharacters(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolicCharacters() throws -> SymbolicCharactersContext {
		var _localctx: SymbolicCharactersContext = SymbolicCharactersContext(_ctx, getState())
		try enterRule(_localctx, 98, Cobol85Parser.RULE_symbolicCharacters)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1680) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1679)
		 		try symbolicCharacter()


		 		setState(1682); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())
		 	setState(1685)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ARE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1684)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.ARE.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(1688) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1687)
		 		try integerLiteral()


		 		setState(1690); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 552)
		 	}()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InputOutputSectionContext: ParserRuleContext {
			open
			func INPUT_OUTPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INPUT_OUTPUT.rawValue, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func inputOutputSectionParagraph() -> [InputOutputSectionParagraphContext] {
				return getRuleContexts(InputOutputSectionParagraphContext.self)
			}
			open
			func inputOutputSectionParagraph(_ i: Int) -> InputOutputSectionParagraphContext? {
				return getRuleContext(InputOutputSectionParagraphContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inputOutputSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInputOutputSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInputOutputSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInputOutputSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInputOutputSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inputOutputSection() throws -> InputOutputSectionContext {
		var _localctx: InputOutputSectionContext = InputOutputSectionContext(_ctx, getState())
		try enterRule(_localctx, 100, Cobol85Parser.RULE_inputOutputSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1692)
		 	try match(Cobol85Parser.Tokens.INPUT_OUTPUT.rawValue)
		 	setState(1693)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(1694)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1698)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FILE_CONTROL.rawValue || _la == Cobol85Parser.Tokens.I_O_CONTROL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1695)
		 		try inputOutputSectionParagraph()


		 		setState(1700)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InputOutputSectionParagraphContext: ParserRuleContext {
			open
			func fileControlParagraph() -> FileControlParagraphContext? {
				return getRuleContext(FileControlParagraphContext.self, 0)
			}
			open
			func ioControlParagraph() -> IoControlParagraphContext? {
				return getRuleContext(IoControlParagraphContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inputOutputSectionParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInputOutputSectionParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInputOutputSectionParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInputOutputSectionParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInputOutputSectionParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inputOutputSectionParagraph() throws -> InputOutputSectionParagraphContext {
		var _localctx: InputOutputSectionParagraphContext = InputOutputSectionParagraphContext(_ctx, getState())
		try enterRule(_localctx, 102, Cobol85Parser.RULE_inputOutputSectionParagraph)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1703)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FILE_CONTROL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1701)
		 		try fileControlParagraph()

		 		break

		 	case .I_O_CONTROL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1702)
		 		try ioControlParagraph()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FileControlParagraphContext: ParserRuleContext {
			open
			func FILE_CONTROL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FILE_CONTROL.rawValue, 0)
			}
			open
			func DOT_FS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.DOT_FS.rawValue)
			}
			open
			func DOT_FS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, i)
			}
			open
			func fileControlEntry() -> [FileControlEntryContext] {
				return getRuleContexts(FileControlEntryContext.self)
			}
			open
			func fileControlEntry(_ i: Int) -> FileControlEntryContext? {
				return getRuleContext(FileControlEntryContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_fileControlParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterFileControlParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitFileControlParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitFileControlParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitFileControlParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fileControlParagraph() throws -> FileControlParagraphContext {
		var _localctx: FileControlParagraphContext = FileControlParagraphContext(_ctx, getState())
		try enterRule(_localctx, 104, Cobol85Parser.RULE_fileControlParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1705)
		 	try match(Cobol85Parser.Tokens.FILE_CONTROL.rawValue)
		 	setState(1712)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,111,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1707)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.DOT_FS.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(1706)
		 				try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		 			}

		 			setState(1709)
		 			try fileControlEntry()

		 	 
		 		}
		 		setState(1714)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,111,_ctx)
		 	}
		 	setState(1715)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FileControlEntryContext: ParserRuleContext {
			open
			func selectClause() -> SelectClauseContext? {
				return getRuleContext(SelectClauseContext.self, 0)
			}
			open
			func fileControlClause() -> [FileControlClauseContext] {
				return getRuleContexts(FileControlClauseContext.self)
			}
			open
			func fileControlClause(_ i: Int) -> FileControlClauseContext? {
				return getRuleContext(FileControlClauseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_fileControlEntry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterFileControlEntry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitFileControlEntry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitFileControlEntry(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitFileControlEntry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fileControlEntry() throws -> FileControlEntryContext {
		var _localctx: FileControlEntryContext = FileControlEntryContext(_ctx, getState())
		try enterRule(_localctx, 106, Cobol85Parser.RULE_fileControlEntry)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1717)
		 	try selectClause()
		 	setState(1721)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ACCESS.rawValue,Cobol85Parser.Tokens.ALTERNATE.rawValue,Cobol85Parser.Tokens.ASSIGN.rawValue,Cobol85Parser.Tokens.BINARY.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.FILE.rawValue || _la == Cobol85Parser.Tokens.INDEXED.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LINE.rawValue,Cobol85Parser.Tokens.ORGANIZATION.rawValue,Cobol85Parser.Tokens.PADDING.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 279)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.RECORD.rawValue,Cobol85Parser.Tokens.RELATIVE.rawValue,Cobol85Parser.Tokens.RESERVE.rawValue,Cobol85Parser.Tokens.SEQUENTIAL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 377)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.STATUS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1718)
		 		try fileControlClause()


		 		setState(1723)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SelectClauseContext: ParserRuleContext {
			open
			func SELECT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SELECT.rawValue, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func OPTIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OPTIONAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_selectClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSelectClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSelectClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSelectClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSelectClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func selectClause() throws -> SelectClauseContext {
		var _localctx: SelectClauseContext = SelectClauseContext(_ctx, getState())
		try enterRule(_localctx, 108, Cobol85Parser.RULE_selectClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1724)
		 	try match(Cobol85Parser.Tokens.SELECT.rawValue)
		 	setState(1726)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.OPTIONAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1725)
		 		try match(Cobol85Parser.Tokens.OPTIONAL.rawValue)

		 	}

		 	setState(1728)
		 	try fileName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FileControlClauseContext: ParserRuleContext {
			open
			func assignClause() -> AssignClauseContext? {
				return getRuleContext(AssignClauseContext.self, 0)
			}
			open
			func reserveClause() -> ReserveClauseContext? {
				return getRuleContext(ReserveClauseContext.self, 0)
			}
			open
			func organizationClause() -> OrganizationClauseContext? {
				return getRuleContext(OrganizationClauseContext.self, 0)
			}
			open
			func paddingCharacterClause() -> PaddingCharacterClauseContext? {
				return getRuleContext(PaddingCharacterClauseContext.self, 0)
			}
			open
			func recordDelimiterClause() -> RecordDelimiterClauseContext? {
				return getRuleContext(RecordDelimiterClauseContext.self, 0)
			}
			open
			func accessModeClause() -> AccessModeClauseContext? {
				return getRuleContext(AccessModeClauseContext.self, 0)
			}
			open
			func recordKeyClause() -> RecordKeyClauseContext? {
				return getRuleContext(RecordKeyClauseContext.self, 0)
			}
			open
			func alternateRecordKeyClause() -> AlternateRecordKeyClauseContext? {
				return getRuleContext(AlternateRecordKeyClauseContext.self, 0)
			}
			open
			func fileStatusClause() -> FileStatusClauseContext? {
				return getRuleContext(FileStatusClauseContext.self, 0)
			}
			open
			func passwordClause() -> PasswordClauseContext? {
				return getRuleContext(PasswordClauseContext.self, 0)
			}
			open
			func relativeKeyClause() -> RelativeKeyClauseContext? {
				return getRuleContext(RelativeKeyClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_fileControlClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterFileControlClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitFileControlClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitFileControlClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitFileControlClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fileControlClause() throws -> FileControlClauseContext {
		var _localctx: FileControlClauseContext = FileControlClauseContext(_ctx, getState())
		try enterRule(_localctx, 110, Cobol85Parser.RULE_fileControlClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1741)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,114, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1730)
		 		try assignClause()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1731)
		 		try reserveClause()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1732)
		 		try organizationClause()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1733)
		 		try paddingCharacterClause()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1734)
		 		try recordDelimiterClause()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1735)
		 		try accessModeClause()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1736)
		 		try recordKeyClause()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1737)
		 		try alternateRecordKeyClause()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1738)
		 		try fileStatusClause()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1739)
		 		try passwordClause()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1740)
		 		try relativeKeyClause()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AssignClauseContext: ParserRuleContext {
			open
			func ASSIGN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASSIGN.rawValue, 0)
			}
			open
			func DISK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISK.rawValue, 0)
			}
			open
			func DISPLAY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISPLAY.rawValue, 0)
			}
			open
			func KEYBOARD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEYBOARD.rawValue, 0)
			}
			open
			func PORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PORT.rawValue, 0)
			}
			open
			func PRINTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PRINTER.rawValue, 0)
			}
			open
			func READER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.READER.rawValue, 0)
			}
			open
			func REMOTE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REMOTE.rawValue, 0)
			}
			open
			func TAPE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TAPE.rawValue, 0)
			}
			open
			func VIRTUAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VIRTUAL.rawValue, 0)
			}
			open
			func assignmentName() -> AssignmentNameContext? {
				return getRuleContext(AssignmentNameContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_assignClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAssignClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAssignClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAssignClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAssignClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func assignClause() throws -> AssignClauseContext {
		var _localctx: AssignClauseContext = AssignClauseContext(_ctx, getState())
		try enterRule(_localctx, 112, Cobol85Parser.RULE_assignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1743)
		 	try match(Cobol85Parser.Tokens.ASSIGN.rawValue)
		 	setState(1745)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1744)
		 		try match(Cobol85Parser.Tokens.TO.rawValue)

		 	}

		 	setState(1758)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,116, _ctx)) {
		 	case 1:
		 		setState(1747)
		 		try match(Cobol85Parser.Tokens.DISK.rawValue)

		 		break
		 	case 2:
		 		setState(1748)
		 		try match(Cobol85Parser.Tokens.DISPLAY.rawValue)

		 		break
		 	case 3:
		 		setState(1749)
		 		try match(Cobol85Parser.Tokens.KEYBOARD.rawValue)

		 		break
		 	case 4:
		 		setState(1750)
		 		try match(Cobol85Parser.Tokens.PORT.rawValue)

		 		break
		 	case 5:
		 		setState(1751)
		 		try match(Cobol85Parser.Tokens.PRINTER.rawValue)

		 		break
		 	case 6:
		 		setState(1752)
		 		try match(Cobol85Parser.Tokens.READER.rawValue)

		 		break
		 	case 7:
		 		setState(1753)
		 		try match(Cobol85Parser.Tokens.REMOTE.rawValue)

		 		break
		 	case 8:
		 		setState(1754)
		 		try match(Cobol85Parser.Tokens.TAPE.rawValue)

		 		break
		 	case 9:
		 		setState(1755)
		 		try match(Cobol85Parser.Tokens.VIRTUAL.rawValue)

		 		break
		 	case 10:
		 		setState(1756)
		 		try assignmentName()

		 		break
		 	case 11:
		 		setState(1757)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReserveClauseContext: ParserRuleContext {
			open
			func RESERVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RESERVE.rawValue, 0)
			}
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func ALTERNATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALTERNATE.rawValue, 0)
			}
			open
			func AREA() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AREA.rawValue, 0)
			}
			open
			func AREAS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AREAS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reserveClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReserveClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReserveClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReserveClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReserveClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reserveClause() throws -> ReserveClauseContext {
		var _localctx: ReserveClauseContext = ReserveClauseContext(_ctx, getState())
		try enterRule(_localctx, 114, Cobol85Parser.RULE_reserveClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1760)
		 	try match(Cobol85Parser.Tokens.RESERVE.rawValue)
		 	setState(1763)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NO:
		 		setState(1761)
		 		try match(Cobol85Parser.Tokens.NO.rawValue)

		 		break
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		setState(1762)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1766)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,118,_ctx)) {
		 	case 1:
		 		setState(1765)
		 		try match(Cobol85Parser.Tokens.ALTERNATE.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1769)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AREA.rawValue || _la == Cobol85Parser.Tokens.AREAS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1768)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.AREA.rawValue || _la == Cobol85Parser.Tokens.AREAS.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OrganizationClauseContext: ParserRuleContext {
			open
			func SEQUENTIAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEQUENTIAL.rawValue, 0)
			}
			open
			func RELATIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RELATIVE.rawValue, 0)
			}
			open
			func INDEXED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INDEXED.rawValue, 0)
			}
			open
			func ORGANIZATION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ORGANIZATION.rawValue, 0)
			}
			open
			func LINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINE.rawValue, 0)
			}
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BINARY.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_organizationClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOrganizationClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOrganizationClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOrganizationClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOrganizationClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func organizationClause() throws -> OrganizationClauseContext {
		var _localctx: OrganizationClauseContext = OrganizationClauseContext(_ctx, getState())
		try enterRule(_localctx, 116, Cobol85Parser.RULE_organizationClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1775)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ORGANIZATION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1771)
		 		try match(Cobol85Parser.Tokens.ORGANIZATION.rawValue)
		 		setState(1773)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1772)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}


		 	}

		 	setState(1782)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,122,_ctx)) {
		 	case 1:
		 		setState(1777)
		 		try match(Cobol85Parser.Tokens.LINE.rawValue)

		 		break
		 	case 2:
		 		setState(1778)
		 		try match(Cobol85Parser.Tokens.RECORD.rawValue)
		 		setState(1779)
		 		try match(Cobol85Parser.Tokens.BINARY.rawValue)

		 		break
		 	case 3:
		 		setState(1780)
		 		try match(Cobol85Parser.Tokens.RECORD.rawValue)

		 		break
		 	case 4:
		 		setState(1781)
		 		try match(Cobol85Parser.Tokens.BINARY.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1784)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.INDEXED.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.RELATIVE.rawValue || _la == Cobol85Parser.Tokens.SEQUENTIAL.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PaddingCharacterClauseContext: ParserRuleContext {
			open
			func PADDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PADDING.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_paddingCharacterClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPaddingCharacterClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPaddingCharacterClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPaddingCharacterClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPaddingCharacterClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func paddingCharacterClause() throws -> PaddingCharacterClauseContext {
		var _localctx: PaddingCharacterClauseContext = PaddingCharacterClauseContext(_ctx, getState())
		try enterRule(_localctx, 118, Cobol85Parser.RULE_paddingCharacterClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1786)
		 	try match(Cobol85Parser.Tokens.PADDING.rawValue)
		 	setState(1788)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1787)
		 		try match(Cobol85Parser.Tokens.CHARACTER.rawValue)

		 	}

		 	setState(1791)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1790)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1795)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,125, _ctx)) {
		 	case 1:
		 		setState(1793)
		 		try qualifiedDataName()

		 		break
		 	case 2:
		 		setState(1794)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RecordDelimiterClauseContext: ParserRuleContext {
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func DELIMITER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DELIMITER.rawValue, 0)
			}
			open
			func STANDARD_1() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STANDARD_1.rawValue, 0)
			}
			open
			func IMPLICIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IMPLICIT.rawValue, 0)
			}
			open
			func assignmentName() -> AssignmentNameContext? {
				return getRuleContext(AssignmentNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_recordDelimiterClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRecordDelimiterClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRecordDelimiterClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRecordDelimiterClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRecordDelimiterClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func recordDelimiterClause() throws -> RecordDelimiterClauseContext {
		var _localctx: RecordDelimiterClauseContext = RecordDelimiterClauseContext(_ctx, getState())
		try enterRule(_localctx, 120, Cobol85Parser.RULE_recordDelimiterClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1797)
		 	try match(Cobol85Parser.Tokens.RECORD.rawValue)
		 	setState(1798)
		 	try match(Cobol85Parser.Tokens.DELIMITER.rawValue)
		 	setState(1800)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1799)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1805)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,127, _ctx)) {
		 	case 1:
		 		setState(1802)
		 		try match(Cobol85Parser.Tokens.STANDARD_1.rawValue)

		 		break
		 	case 2:
		 		setState(1803)
		 		try match(Cobol85Parser.Tokens.IMPLICIT.rawValue)

		 		break
		 	case 3:
		 		setState(1804)
		 		try assignmentName()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AccessModeClauseContext: ParserRuleContext {
			open
			func ACCESS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ACCESS.rawValue, 0)
			}
			open
			func SEQUENTIAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEQUENTIAL.rawValue, 0)
			}
			open
			func RANDOM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RANDOM.rawValue, 0)
			}
			open
			func DYNAMIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DYNAMIC.rawValue, 0)
			}
			open
			func EXCLUSIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXCLUSIVE.rawValue, 0)
			}
			open
			func MODE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MODE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_accessModeClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAccessModeClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAccessModeClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAccessModeClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAccessModeClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func accessModeClause() throws -> AccessModeClauseContext {
		var _localctx: AccessModeClauseContext = AccessModeClauseContext(_ctx, getState())
		try enterRule(_localctx, 122, Cobol85Parser.RULE_accessModeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1807)
		 	try match(Cobol85Parser.Tokens.ACCESS.rawValue)
		 	setState(1809)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.MODE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1808)
		 		try match(Cobol85Parser.Tokens.MODE.rawValue)

		 	}

		 	setState(1812)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1811)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1814)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.DYNAMIC.rawValue || _la == Cobol85Parser.Tokens.EXCLUSIVE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.RANDOM.rawValue || _la == Cobol85Parser.Tokens.SEQUENTIAL.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RecordKeyClauseContext: ParserRuleContext {
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func passwordClause() -> PasswordClauseContext? {
				return getRuleContext(PasswordClauseContext.self, 0)
			}
			open
			func DUPLICATES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DUPLICATES.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_recordKeyClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRecordKeyClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRecordKeyClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRecordKeyClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRecordKeyClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func recordKeyClause() throws -> RecordKeyClauseContext {
		var _localctx: RecordKeyClauseContext = RecordKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 124, Cobol85Parser.RULE_recordKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1816)
		 	try match(Cobol85Parser.Tokens.RECORD.rawValue)
		 	setState(1818)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.KEY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1817)
		 		try match(Cobol85Parser.Tokens.KEY.rawValue)

		 	}

		 	setState(1821)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1820)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1823)
		 	try qualifiedDataName()
		 	setState(1825)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,132,_ctx)) {
		 	case 1:
		 		setState(1824)
		 		try passwordClause()

		 		break
		 	default: break
		 	}
		 	setState(1831)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.DUPLICATES.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1828)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1827)
		 			try match(Cobol85Parser.Tokens.WITH.rawValue)

		 		}

		 		setState(1830)
		 		try match(Cobol85Parser.Tokens.DUPLICATES.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlternateRecordKeyClauseContext: ParserRuleContext {
			open
			func ALTERNATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALTERNATE.rawValue, 0)
			}
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func passwordClause() -> PasswordClauseContext? {
				return getRuleContext(PasswordClauseContext.self, 0)
			}
			open
			func DUPLICATES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DUPLICATES.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_alternateRecordKeyClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAlternateRecordKeyClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAlternateRecordKeyClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAlternateRecordKeyClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAlternateRecordKeyClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func alternateRecordKeyClause() throws -> AlternateRecordKeyClauseContext {
		var _localctx: AlternateRecordKeyClauseContext = AlternateRecordKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 126, Cobol85Parser.RULE_alternateRecordKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1833)
		 	try match(Cobol85Parser.Tokens.ALTERNATE.rawValue)
		 	setState(1834)
		 	try match(Cobol85Parser.Tokens.RECORD.rawValue)
		 	setState(1836)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.KEY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1835)
		 		try match(Cobol85Parser.Tokens.KEY.rawValue)

		 	}

		 	setState(1839)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1838)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1841)
		 	try qualifiedDataName()
		 	setState(1843)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,137,_ctx)) {
		 	case 1:
		 		setState(1842)
		 		try passwordClause()

		 		break
		 	default: break
		 	}
		 	setState(1849)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.DUPLICATES.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1846)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1845)
		 			try match(Cobol85Parser.Tokens.WITH.rawValue)

		 		}

		 		setState(1848)
		 		try match(Cobol85Parser.Tokens.DUPLICATES.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PasswordClauseContext: ParserRuleContext {
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PASSWORD.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_passwordClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPasswordClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPasswordClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPasswordClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPasswordClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func passwordClause() throws -> PasswordClauseContext {
		var _localctx: PasswordClauseContext = PasswordClauseContext(_ctx, getState())
		try enterRule(_localctx, 128, Cobol85Parser.RULE_passwordClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1851)
		 	try match(Cobol85Parser.Tokens.PASSWORD.rawValue)
		 	setState(1853)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1852)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1855)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FileStatusClauseContext: ParserRuleContext {
			open
			func STATUS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STATUS.rawValue, 0)
			}
			open
			func qualifiedDataName() -> [QualifiedDataNameContext] {
				return getRuleContexts(QualifiedDataNameContext.self)
			}
			open
			func qualifiedDataName(_ i: Int) -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, i)
			}
			open
			func FILE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FILE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_fileStatusClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterFileStatusClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitFileStatusClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitFileStatusClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitFileStatusClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fileStatusClause() throws -> FileStatusClauseContext {
		var _localctx: FileStatusClauseContext = FileStatusClauseContext(_ctx, getState())
		try enterRule(_localctx, 130, Cobol85Parser.RULE_fileStatusClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1858)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FILE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1857)
		 		try match(Cobol85Parser.Tokens.FILE.rawValue)

		 	}

		 	setState(1860)
		 	try match(Cobol85Parser.Tokens.STATUS.rawValue)
		 	setState(1862)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1861)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1864)
		 	try qualifiedDataName()
		 	setState(1866)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,143,_ctx)) {
		 	case 1:
		 		setState(1865)
		 		try qualifiedDataName()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RelativeKeyClauseContext: ParserRuleContext {
			open
			func RELATIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RELATIVE.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_relativeKeyClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRelativeKeyClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRelativeKeyClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRelativeKeyClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRelativeKeyClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func relativeKeyClause() throws -> RelativeKeyClauseContext {
		var _localctx: RelativeKeyClauseContext = RelativeKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 132, Cobol85Parser.RULE_relativeKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1868)
		 	try match(Cobol85Parser.Tokens.RELATIVE.rawValue)
		 	setState(1870)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.KEY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1869)
		 		try match(Cobol85Parser.Tokens.KEY.rawValue)

		 	}

		 	setState(1873)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1872)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(1875)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IoControlParagraphContext: ParserRuleContext {
			open
			func I_O_CONTROL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.I_O_CONTROL.rawValue, 0)
			}
			open
			func DOT_FS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.DOT_FS.rawValue)
			}
			open
			func DOT_FS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, i)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func ioControlClause() -> [IoControlClauseContext] {
				return getRuleContexts(IoControlClauseContext.self)
			}
			open
			func ioControlClause(_ i: Int) -> IoControlClauseContext? {
				return getRuleContext(IoControlClauseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_ioControlParagraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterIoControlParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitIoControlParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitIoControlParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitIoControlParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ioControlParagraph() throws -> IoControlParagraphContext {
		var _localctx: IoControlParagraphContext = IoControlParagraphContext(_ctx, getState())
		try enterRule(_localctx, 134, Cobol85Parser.RULE_ioControlParagraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1877)
		 	try match(Cobol85Parser.Tokens.I_O_CONTROL.rawValue)
		 	setState(1878)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1882)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,146,_ctx)) {
		 	case 1:
		 		setState(1879)
		 		try fileName()
		 		setState(1880)
		 		try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1891)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.COMMITMENT.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.MULTIPLE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.RERUN.rawValue || _la == Cobol85Parser.Tokens.SAME.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.DOT_FS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1887)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.COMMITMENT.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.MULTIPLE.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.RERUN.rawValue || _la == Cobol85Parser.Tokens.SAME.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1884)
		 			try ioControlClause()


		 			setState(1889)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1890)
		 		try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IoControlClauseContext: ParserRuleContext {
			open
			func rerunClause() -> RerunClauseContext? {
				return getRuleContext(RerunClauseContext.self, 0)
			}
			open
			func sameClause() -> SameClauseContext? {
				return getRuleContext(SameClauseContext.self, 0)
			}
			open
			func multipleFileClause() -> MultipleFileClauseContext? {
				return getRuleContext(MultipleFileClauseContext.self, 0)
			}
			open
			func commitmentControlClause() -> CommitmentControlClauseContext? {
				return getRuleContext(CommitmentControlClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_ioControlClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterIoControlClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitIoControlClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitIoControlClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitIoControlClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ioControlClause() throws -> IoControlClauseContext {
		var _localctx: IoControlClauseContext = IoControlClauseContext(_ctx, getState())
		try enterRule(_localctx, 136, Cobol85Parser.RULE_ioControlClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1897)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .RERUN:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1893)
		 		try rerunClause()

		 		break

		 	case .SAME:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1894)
		 		try sameClause()

		 		break

		 	case .MULTIPLE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1895)
		 		try multipleFileClause()

		 		break

		 	case .COMMITMENT:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1896)
		 		try commitmentControlClause()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RerunClauseContext: ParserRuleContext {
			open
			func RERUN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RERUN.rawValue, 0)
			}
			open
			func EVERY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EVERY.rawValue, 0)
			}
			open
			func rerunEveryRecords() -> RerunEveryRecordsContext? {
				return getRuleContext(RerunEveryRecordsContext.self, 0)
			}
			open
			func rerunEveryOf() -> RerunEveryOfContext? {
				return getRuleContext(RerunEveryOfContext.self, 0)
			}
			open
			func rerunEveryClock() -> RerunEveryClockContext? {
				return getRuleContext(RerunEveryClockContext.self, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func assignmentName() -> AssignmentNameContext? {
				return getRuleContext(AssignmentNameContext.self, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_rerunClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRerunClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRerunClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRerunClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRerunClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func rerunClause() throws -> RerunClauseContext {
		var _localctx: RerunClauseContext = RerunClauseContext(_ctx, getState())
		try enterRule(_localctx, 138, Cobol85Parser.RULE_rerunClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1899)
		 	try match(Cobol85Parser.Tokens.RERUN.rawValue)
		 	setState(1905)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1900)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)
		 		setState(1903)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,150, _ctx)) {
		 		case 1:
		 			setState(1901)
		 			try assignmentName()

		 			break
		 		case 2:
		 			setState(1902)
		 			try fileName()

		 			break
		 		default: break
		 		}

		 	}

		 	setState(1907)
		 	try match(Cobol85Parser.Tokens.EVERY.rawValue)
		 	setState(1911)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,152, _ctx)) {
		 	case 1:
		 		setState(1908)
		 		try rerunEveryRecords()

		 		break
		 	case 2:
		 		setState(1909)
		 		try rerunEveryOf()

		 		break
		 	case 3:
		 		setState(1910)
		 		try rerunEveryClock()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RerunEveryRecordsContext: ParserRuleContext {
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func RECORDS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORDS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_rerunEveryRecords
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRerunEveryRecords(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRerunEveryRecords(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRerunEveryRecords(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRerunEveryRecords(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func rerunEveryRecords() throws -> RerunEveryRecordsContext {
		var _localctx: RerunEveryRecordsContext = RerunEveryRecordsContext(_ctx, getState())
		try enterRule(_localctx, 140, Cobol85Parser.RULE_rerunEveryRecords)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1913)
		 	try integerLiteral()
		 	setState(1914)
		 	try match(Cobol85Parser.Tokens.RECORDS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RerunEveryOfContext: ParserRuleContext {
			open
			func OF() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.OF.rawValue)
			}
			open
			func OF(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, i)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func REEL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REEL.rawValue, 0)
			}
			open
			func UNIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.UNIT.rawValue, 0)
			}
			open
			func END() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_rerunEveryOf
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRerunEveryOf(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRerunEveryOf(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRerunEveryOf(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRerunEveryOf(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func rerunEveryOf() throws -> RerunEveryOfContext {
		var _localctx: RerunEveryOfContext = RerunEveryOfContext(_ctx, getState())
		try enterRule(_localctx, 142, Cobol85Parser.RULE_rerunEveryOf)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1917)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.END.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1916)
		 		try match(Cobol85Parser.Tokens.END.rawValue)

		 	}

		 	setState(1920)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.OF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1919)
		 		try match(Cobol85Parser.Tokens.OF.rawValue)

		 	}

		 	setState(1922)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.REEL.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.UNIT.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1923)
		 	try match(Cobol85Parser.Tokens.OF.rawValue)
		 	setState(1924)
		 	try fileName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RerunEveryClockContext: ParserRuleContext {
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func CLOCK_UNITS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CLOCK_UNITS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_rerunEveryClock
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRerunEveryClock(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRerunEveryClock(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRerunEveryClock(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRerunEveryClock(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func rerunEveryClock() throws -> RerunEveryClockContext {
		var _localctx: RerunEveryClockContext = RerunEveryClockContext(_ctx, getState())
		try enterRule(_localctx, 144, Cobol85Parser.RULE_rerunEveryClock)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1926)
		 	try integerLiteral()
		 	setState(1928)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CLOCK_UNITS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1927)
		 		try match(Cobol85Parser.Tokens.CLOCK_UNITS.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SameClauseContext: ParserRuleContext {
			open
			func SAME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SAME.rawValue, 0)
			}
			open
			func AREA() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AREA.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func fileName() -> [FileNameContext] {
				return getRuleContexts(FileNameContext.self)
			}
			open
			func fileName(_ i: Int) -> FileNameContext? {
				return getRuleContext(FileNameContext.self, i)
			}
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func SORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SORT.rawValue, 0)
			}
			open
			func SORT_MERGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SORT_MERGE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sameClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSameClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSameClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSameClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSameClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sameClause() throws -> SameClauseContext {
		var _localctx: SameClauseContext = SameClauseContext(_ctx, getState())
		try enterRule(_localctx, 146, Cobol85Parser.RULE_sameClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1930)
		 	try match(Cobol85Parser.Tokens.SAME.rawValue)
		 	setState(1932)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.RECORD.rawValue || _la == Cobol85Parser.Tokens.SORT.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.SORT_MERGE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1931)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.RECORD.rawValue || _la == Cobol85Parser.Tokens.SORT.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.SORT_MERGE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(1935)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AREA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1934)
		 		try match(Cobol85Parser.Tokens.AREA.rawValue)

		 	}

		 	setState(1938)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1937)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(1941); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1940)
		 			try fileName()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1943); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,159,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultipleFileClauseContext: ParserRuleContext {
			open
			func MULTIPLE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MULTIPLE.rawValue, 0)
			}
			open
			func FILE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FILE.rawValue, 0)
			}
			open
			func TAPE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TAPE.rawValue, 0)
			}
			open
			func CONTAINS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTAINS.rawValue, 0)
			}
			open
			func multipleFilePosition() -> [MultipleFilePositionContext] {
				return getRuleContexts(MultipleFilePositionContext.self)
			}
			open
			func multipleFilePosition(_ i: Int) -> MultipleFilePositionContext? {
				return getRuleContext(MultipleFilePositionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_multipleFileClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMultipleFileClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMultipleFileClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMultipleFileClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMultipleFileClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func multipleFileClause() throws -> MultipleFileClauseContext {
		var _localctx: MultipleFileClauseContext = MultipleFileClauseContext(_ctx, getState())
		try enterRule(_localctx, 148, Cobol85Parser.RULE_multipleFileClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1945)
		 	try match(Cobol85Parser.Tokens.MULTIPLE.rawValue)
		 	setState(1946)
		 	try match(Cobol85Parser.Tokens.FILE.rawValue)
		 	setState(1948)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TAPE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1947)
		 		try match(Cobol85Parser.Tokens.TAPE.rawValue)

		 	}

		 	setState(1951)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CONTAINS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1950)
		 		try match(Cobol85Parser.Tokens.CONTAINS.rawValue)

		 	}

		 	setState(1954); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1953)
		 			try multipleFilePosition()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1956); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,162,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultipleFilePositionContext: ParserRuleContext {
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func POSITION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.POSITION.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_multipleFilePosition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMultipleFilePosition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMultipleFilePosition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMultipleFilePosition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMultipleFilePosition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func multipleFilePosition() throws -> MultipleFilePositionContext {
		var _localctx: MultipleFilePositionContext = MultipleFilePositionContext(_ctx, getState())
		try enterRule(_localctx, 150, Cobol85Parser.RULE_multipleFilePosition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1958)
		 	try fileName()
		 	setState(1961)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.POSITION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1959)
		 		try match(Cobol85Parser.Tokens.POSITION.rawValue)
		 		setState(1960)
		 		try integerLiteral()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CommitmentControlClauseContext: ParserRuleContext {
			open
			func COMMITMENT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMITMENT.rawValue, 0)
			}
			open
			func CONTROL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTROL.rawValue, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_commitmentControlClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCommitmentControlClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCommitmentControlClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCommitmentControlClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCommitmentControlClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func commitmentControlClause() throws -> CommitmentControlClauseContext {
		var _localctx: CommitmentControlClauseContext = CommitmentControlClauseContext(_ctx, getState())
		try enterRule(_localctx, 152, Cobol85Parser.RULE_commitmentControlClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1963)
		 	try match(Cobol85Parser.Tokens.COMMITMENT.rawValue)
		 	setState(1964)
		 	try match(Cobol85Parser.Tokens.CONTROL.rawValue)
		 	setState(1966)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1965)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(1968)
		 	try fileName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataDivisionContext: ParserRuleContext {
			open
			func DATA() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATA.rawValue, 0)
			}
			open
			func DIVISION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DIVISION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func dataDivisionSection() -> [DataDivisionSectionContext] {
				return getRuleContexts(DataDivisionSectionContext.self)
			}
			open
			func dataDivisionSection(_ i: Int) -> DataDivisionSectionContext? {
				return getRuleContext(DataDivisionSectionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataDivision
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataDivision(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataDivision(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataDivision(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataDivision(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataDivision() throws -> DataDivisionContext {
		var _localctx: DataDivisionContext = DataDivisionContext(_ctx, getState())
		try enterRule(_localctx, 154, Cobol85Parser.RULE_dataDivision)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1970)
		 	try match(Cobol85Parser.Tokens.DATA.rawValue)
		 	setState(1971)
		 	try match(Cobol85Parser.Tokens.DIVISION.rawValue)
		 	setState(1972)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1976)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.COMMUNICATION.rawValue || _la == Cobol85Parser.Tokens.DATA_BASE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.FILE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.LINKAGE.rawValue || _la == Cobol85Parser.Tokens.LOCAL_STORAGE.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.PROGRAM_LIBRARY.rawValue,Cobol85Parser.Tokens.REPORT.rawValue,Cobol85Parser.Tokens.SCREEN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 363)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.WORKING_STORAGE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1973)
		 		try dataDivisionSection()


		 		setState(1978)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataDivisionSectionContext: ParserRuleContext {
			open
			func fileSection() -> FileSectionContext? {
				return getRuleContext(FileSectionContext.self, 0)
			}
			open
			func dataBaseSection() -> DataBaseSectionContext? {
				return getRuleContext(DataBaseSectionContext.self, 0)
			}
			open
			func workingStorageSection() -> WorkingStorageSectionContext? {
				return getRuleContext(WorkingStorageSectionContext.self, 0)
			}
			open
			func linkageSection() -> LinkageSectionContext? {
				return getRuleContext(LinkageSectionContext.self, 0)
			}
			open
			func communicationSection() -> CommunicationSectionContext? {
				return getRuleContext(CommunicationSectionContext.self, 0)
			}
			open
			func localStorageSection() -> LocalStorageSectionContext? {
				return getRuleContext(LocalStorageSectionContext.self, 0)
			}
			open
			func screenSection() -> ScreenSectionContext? {
				return getRuleContext(ScreenSectionContext.self, 0)
			}
			open
			func reportSection() -> ReportSectionContext? {
				return getRuleContext(ReportSectionContext.self, 0)
			}
			open
			func programLibrarySection() -> ProgramLibrarySectionContext? {
				return getRuleContext(ProgramLibrarySectionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataDivisionSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataDivisionSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataDivisionSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataDivisionSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataDivisionSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataDivisionSection() throws -> DataDivisionSectionContext {
		var _localctx: DataDivisionSectionContext = DataDivisionSectionContext(_ctx, getState())
		try enterRule(_localctx, 156, Cobol85Parser.RULE_dataDivisionSection)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1988)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FILE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1979)
		 		try fileSection()

		 		break

		 	case .DATA_BASE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1980)
		 		try dataBaseSection()

		 		break

		 	case .WORKING_STORAGE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1981)
		 		try workingStorageSection()

		 		break

		 	case .LINKAGE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1982)
		 		try linkageSection()

		 		break

		 	case .COMMUNICATION:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1983)
		 		try communicationSection()

		 		break

		 	case .LOCAL_STORAGE:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1984)
		 		try localStorageSection()

		 		break

		 	case .SCREEN:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1985)
		 		try screenSection()

		 		break

		 	case .REPORT:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1986)
		 		try reportSection()

		 		break

		 	case .PROGRAM_LIBRARY:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1987)
		 		try programLibrarySection()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FileSectionContext: ParserRuleContext {
			open
			func FILE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FILE.rawValue, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func fileDescriptionEntry() -> [FileDescriptionEntryContext] {
				return getRuleContexts(FileDescriptionEntryContext.self)
			}
			open
			func fileDescriptionEntry(_ i: Int) -> FileDescriptionEntryContext? {
				return getRuleContext(FileDescriptionEntryContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_fileSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterFileSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitFileSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitFileSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitFileSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fileSection() throws -> FileSectionContext {
		var _localctx: FileSectionContext = FileSectionContext(_ctx, getState())
		try enterRule(_localctx, 158, Cobol85Parser.RULE_fileSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1990)
		 	try match(Cobol85Parser.Tokens.FILE.rawValue)
		 	setState(1991)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(1992)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(1996)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.FD.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.SD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1993)
		 		try fileDescriptionEntry()


		 		setState(1998)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FileDescriptionEntryContext: ParserRuleContext {
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func DOT_FS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.DOT_FS.rawValue)
			}
			open
			func DOT_FS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, i)
			}
			open
			func FD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FD.rawValue, 0)
			}
			open
			func SD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SD.rawValue, 0)
			}
			open
			func fileDescriptionEntryClause() -> [FileDescriptionEntryClauseContext] {
				return getRuleContexts(FileDescriptionEntryClauseContext.self)
			}
			open
			func fileDescriptionEntryClause(_ i: Int) -> FileDescriptionEntryClauseContext? {
				return getRuleContext(FileDescriptionEntryClauseContext.self, i)
			}
			open
			func dataDescriptionEntry() -> [DataDescriptionEntryContext] {
				return getRuleContexts(DataDescriptionEntryContext.self)
			}
			open
			func dataDescriptionEntry(_ i: Int) -> DataDescriptionEntryContext? {
				return getRuleContext(DataDescriptionEntryContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_fileDescriptionEntry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterFileDescriptionEntry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitFileDescriptionEntry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitFileDescriptionEntry(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitFileDescriptionEntry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fileDescriptionEntry() throws -> FileDescriptionEntryContext {
		var _localctx: FileDescriptionEntryContext = FileDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 160, Cobol85Parser.RULE_fileDescriptionEntry)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1999)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.FD.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.SD.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2000)
		 	try fileName()
		 	setState(2007)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,169,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2002)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.DOT_FS.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(2001)
		 				try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		 			}

		 			setState(2004)
		 			try fileDescriptionEntryClause()

		 	 
		 		}
		 		setState(2009)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,169,_ctx)
		 	}
		 	setState(2010)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(2014)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.EXECSQLLINE.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 552)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(2011)
		 		try dataDescriptionEntry()


		 		setState(2016)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FileDescriptionEntryClauseContext: ParserRuleContext {
			open
			func externalClause() -> ExternalClauseContext? {
				return getRuleContext(ExternalClauseContext.self, 0)
			}
			open
			func globalClause() -> GlobalClauseContext? {
				return getRuleContext(GlobalClauseContext.self, 0)
			}
			open
			func blockContainsClause() -> BlockContainsClauseContext? {
				return getRuleContext(BlockContainsClauseContext.self, 0)
			}
			open
			func recordContainsClause() -> RecordContainsClauseContext? {
				return getRuleContext(RecordContainsClauseContext.self, 0)
			}
			open
			func labelRecordsClause() -> LabelRecordsClauseContext? {
				return getRuleContext(LabelRecordsClauseContext.self, 0)
			}
			open
			func valueOfClause() -> ValueOfClauseContext? {
				return getRuleContext(ValueOfClauseContext.self, 0)
			}
			open
			func dataRecordsClause() -> DataRecordsClauseContext? {
				return getRuleContext(DataRecordsClauseContext.self, 0)
			}
			open
			func linageClause() -> LinageClauseContext? {
				return getRuleContext(LinageClauseContext.self, 0)
			}
			open
			func codeSetClause() -> CodeSetClauseContext? {
				return getRuleContext(CodeSetClauseContext.self, 0)
			}
			open
			func reportClause() -> ReportClauseContext? {
				return getRuleContext(ReportClauseContext.self, 0)
			}
			open
			func recordingModeClause() -> RecordingModeClauseContext? {
				return getRuleContext(RecordingModeClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_fileDescriptionEntryClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterFileDescriptionEntryClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitFileDescriptionEntryClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitFileDescriptionEntryClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitFileDescriptionEntryClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fileDescriptionEntryClause() throws -> FileDescriptionEntryClauseContext {
		var _localctx: FileDescriptionEntryClauseContext = FileDescriptionEntryClauseContext(_ctx, getState())
		try enterRule(_localctx, 162, Cobol85Parser.RULE_fileDescriptionEntryClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2028)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,171, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2017)
		 		try externalClause()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2018)
		 		try globalClause()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2019)
		 		try blockContainsClause()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2020)
		 		try recordContainsClause()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2021)
		 		try labelRecordsClause()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2022)
		 		try valueOfClause()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2023)
		 		try dataRecordsClause()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(2024)
		 		try linageClause()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(2025)
		 		try codeSetClause()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(2026)
		 		try reportClause()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(2027)
		 		try recordingModeClause()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExternalClauseContext: ParserRuleContext {
			open
			func EXTERNAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXTERNAL.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_externalClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterExternalClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitExternalClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitExternalClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitExternalClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func externalClause() throws -> ExternalClauseContext {
		var _localctx: ExternalClauseContext = ExternalClauseContext(_ctx, getState())
		try enterRule(_localctx, 164, Cobol85Parser.RULE_externalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2031)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2030)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2033)
		 	try match(Cobol85Parser.Tokens.EXTERNAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalClauseContext: ParserRuleContext {
			open
			func GLOBAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GLOBAL.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_globalClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterGlobalClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitGlobalClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitGlobalClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitGlobalClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalClause() throws -> GlobalClauseContext {
		var _localctx: GlobalClauseContext = GlobalClauseContext(_ctx, getState())
		try enterRule(_localctx, 166, Cobol85Parser.RULE_globalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2036)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2035)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2038)
		 	try match(Cobol85Parser.Tokens.GLOBAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BlockContainsClauseContext: ParserRuleContext {
			open
			func BLOCK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BLOCK.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func CONTAINS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTAINS.rawValue, 0)
			}
			open
			func blockContainsTo() -> BlockContainsToContext? {
				return getRuleContext(BlockContainsToContext.self, 0)
			}
			open
			func RECORDS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORDS.rawValue, 0)
			}
			open
			func CHARACTERS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTERS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_blockContainsClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterBlockContainsClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitBlockContainsClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitBlockContainsClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitBlockContainsClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func blockContainsClause() throws -> BlockContainsClauseContext {
		var _localctx: BlockContainsClauseContext = BlockContainsClauseContext(_ctx, getState())
		try enterRule(_localctx, 168, Cobol85Parser.RULE_blockContainsClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2040)
		 	try match(Cobol85Parser.Tokens.BLOCK.rawValue)
		 	setState(2042)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CONTAINS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2041)
		 		try match(Cobol85Parser.Tokens.CONTAINS.rawValue)

		 	}

		 	setState(2044)
		 	try integerLiteral()
		 	setState(2046)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2045)
		 		try blockContainsTo()

		 	}

		 	setState(2049)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTERS.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.RECORDS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2048)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTERS.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.RECORDS.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BlockContainsToContext: ParserRuleContext {
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_blockContainsTo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterBlockContainsTo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitBlockContainsTo(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitBlockContainsTo(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitBlockContainsTo(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func blockContainsTo() throws -> BlockContainsToContext {
		var _localctx: BlockContainsToContext = BlockContainsToContext(_ctx, getState())
		try enterRule(_localctx, 170, Cobol85Parser.RULE_blockContainsTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2051)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(2052)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RecordContainsClauseContext: ParserRuleContext {
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func recordContainsClauseFormat1() -> RecordContainsClauseFormat1Context? {
				return getRuleContext(RecordContainsClauseFormat1Context.self, 0)
			}
			open
			func recordContainsClauseFormat2() -> RecordContainsClauseFormat2Context? {
				return getRuleContext(RecordContainsClauseFormat2Context.self, 0)
			}
			open
			func recordContainsClauseFormat3() -> RecordContainsClauseFormat3Context? {
				return getRuleContext(RecordContainsClauseFormat3Context.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_recordContainsClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRecordContainsClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRecordContainsClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRecordContainsClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRecordContainsClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func recordContainsClause() throws -> RecordContainsClauseContext {
		var _localctx: RecordContainsClauseContext = RecordContainsClauseContext(_ctx, getState())
		try enterRule(_localctx, 172, Cobol85Parser.RULE_recordContainsClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2054)
		 	try match(Cobol85Parser.Tokens.RECORD.rawValue)
		 	setState(2058)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,177, _ctx)) {
		 	case 1:
		 		setState(2055)
		 		try recordContainsClauseFormat1()

		 		break
		 	case 2:
		 		setState(2056)
		 		try recordContainsClauseFormat2()

		 		break
		 	case 3:
		 		setState(2057)
		 		try recordContainsClauseFormat3()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RecordContainsClauseFormat1Context: ParserRuleContext {
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func CONTAINS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTAINS.rawValue, 0)
			}
			open
			func CHARACTERS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTERS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_recordContainsClauseFormat1
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRecordContainsClauseFormat1(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRecordContainsClauseFormat1(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRecordContainsClauseFormat1(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRecordContainsClauseFormat1(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func recordContainsClauseFormat1() throws -> RecordContainsClauseFormat1Context {
		var _localctx: RecordContainsClauseFormat1Context = RecordContainsClauseFormat1Context(_ctx, getState())
		try enterRule(_localctx, 174, Cobol85Parser.RULE_recordContainsClauseFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2061)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CONTAINS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2060)
		 		try match(Cobol85Parser.Tokens.CONTAINS.rawValue)

		 	}

		 	setState(2063)
		 	try integerLiteral()
		 	setState(2065)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTERS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2064)
		 		try match(Cobol85Parser.Tokens.CHARACTERS.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RecordContainsClauseFormat2Context: ParserRuleContext {
			open
			func VARYING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VARYING.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
			open
			func SIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIZE.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func DEPENDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEPENDING.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func recordContainsTo() -> RecordContainsToContext? {
				return getRuleContext(RecordContainsToContext.self, 0)
			}
			open
			func CHARACTERS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTERS.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_recordContainsClauseFormat2
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRecordContainsClauseFormat2(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRecordContainsClauseFormat2(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRecordContainsClauseFormat2(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRecordContainsClauseFormat2(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func recordContainsClauseFormat2() throws -> RecordContainsClauseFormat2Context {
		var _localctx: RecordContainsClauseFormat2Context = RecordContainsClauseFormat2Context(_ctx, getState())
		try enterRule(_localctx, 176, Cobol85Parser.RULE_recordContainsClauseFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2068)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2067)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2070)
		 	try match(Cobol85Parser.Tokens.VARYING.rawValue)
		 	setState(2072)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2071)
		 		try match(Cobol85Parser.Tokens.IN.rawValue)

		 	}

		 	setState(2075)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SIZE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2074)
		 		try match(Cobol85Parser.Tokens.SIZE.rawValue)

		 	}

		 	setState(2087)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.FROM.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2078)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.FROM.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2077)
		 			try match(Cobol85Parser.Tokens.FROM.rawValue)

		 		}

		 		setState(2080)
		 		try integerLiteral()
		 		setState(2082)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2081)
		 			try recordContainsTo()

		 		}

		 		setState(2085)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTERS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2084)
		 			try match(Cobol85Parser.Tokens.CHARACTERS.rawValue)

		 		}


		 	}

		 	setState(2094)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DEPENDING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2089)
		 		try match(Cobol85Parser.Tokens.DEPENDING.rawValue)
		 		setState(2091)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2090)
		 			try match(Cobol85Parser.Tokens.ON.rawValue)

		 		}

		 		setState(2093)
		 		try qualifiedDataName()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RecordContainsClauseFormat3Context: ParserRuleContext {
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func recordContainsTo() -> RecordContainsToContext? {
				return getRuleContext(RecordContainsToContext.self, 0)
			}
			open
			func CONTAINS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTAINS.rawValue, 0)
			}
			open
			func CHARACTERS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTERS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_recordContainsClauseFormat3
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRecordContainsClauseFormat3(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRecordContainsClauseFormat3(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRecordContainsClauseFormat3(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRecordContainsClauseFormat3(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func recordContainsClauseFormat3() throws -> RecordContainsClauseFormat3Context {
		var _localctx: RecordContainsClauseFormat3Context = RecordContainsClauseFormat3Context(_ctx, getState())
		try enterRule(_localctx, 178, Cobol85Parser.RULE_recordContainsClauseFormat3)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2097)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CONTAINS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2096)
		 		try match(Cobol85Parser.Tokens.CONTAINS.rawValue)

		 	}

		 	setState(2099)
		 	try integerLiteral()
		 	setState(2100)
		 	try recordContainsTo()
		 	setState(2102)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTERS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2101)
		 		try match(Cobol85Parser.Tokens.CHARACTERS.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RecordContainsToContext: ParserRuleContext {
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_recordContainsTo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRecordContainsTo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRecordContainsTo(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRecordContainsTo(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRecordContainsTo(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func recordContainsTo() throws -> RecordContainsToContext {
		var _localctx: RecordContainsToContext = RecordContainsToContext(_ctx, getState())
		try enterRule(_localctx, 180, Cobol85Parser.RULE_recordContainsTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2104)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(2105)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LabelRecordsClauseContext: ParserRuleContext {
			open
			func LABEL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LABEL.rawValue, 0)
			}
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func RECORDS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORDS.rawValue, 0)
			}
			open
			func OMITTED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OMITTED.rawValue, 0)
			}
			open
			func STANDARD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STANDARD.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func ARE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ARE.rawValue, 0)
			}
			open
			func dataName() -> [DataNameContext] {
				return getRuleContexts(DataNameContext.self)
			}
			open
			func dataName(_ i: Int) -> DataNameContext? {
				return getRuleContext(DataNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_labelRecordsClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLabelRecordsClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLabelRecordsClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLabelRecordsClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLabelRecordsClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func labelRecordsClause() throws -> LabelRecordsClauseContext {
		var _localctx: LabelRecordsClauseContext = LabelRecordsClauseContext(_ctx, getState())
		try enterRule(_localctx, 182, Cobol85Parser.RULE_labelRecordsClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2107)
		 	try match(Cobol85Parser.Tokens.LABEL.rawValue)
		 	setState(2116)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .RECORD:
		 		setState(2108)
		 		try match(Cobol85Parser.Tokens.RECORD.rawValue)
		 		setState(2110)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2109)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}


		 		break

		 	case .RECORDS:
		 		setState(2112)
		 		try match(Cobol85Parser.Tokens.RECORDS.rawValue)
		 		setState(2114)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.ARE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2113)
		 			try match(Cobol85Parser.Tokens.ARE.rawValue)

		 		}


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2125)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .OMITTED:
		 		setState(2118)
		 		try match(Cobol85Parser.Tokens.OMITTED.rawValue)

		 		break

		 	case .STANDARD:
		 		setState(2119)
		 		try match(Cobol85Parser.Tokens.STANDARD.rawValue)

		 		break
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		setState(2121) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2120)
		 			try dataName()


		 			setState(2123); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 68)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 138)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 202)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 268)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 401)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 466)
		 		          }()
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 		      return testSet
		 		 }())

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ValueOfClauseContext: ParserRuleContext {
			open
			func VALUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VALUE.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
			open
			func valuePair() -> [ValuePairContext] {
				return getRuleContexts(ValuePairContext.self)
			}
			open
			func valuePair(_ i: Int) -> ValuePairContext? {
				return getRuleContext(ValuePairContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_valueOfClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterValueOfClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitValueOfClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitValueOfClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitValueOfClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func valueOfClause() throws -> ValueOfClauseContext {
		var _localctx: ValueOfClauseContext = ValueOfClauseContext(_ctx, getState())
		try enterRule(_localctx, 184, Cobol85Parser.RULE_valueOfClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2127)
		 	try match(Cobol85Parser.Tokens.VALUE.rawValue)
		 	setState(2128)
		 	try match(Cobol85Parser.Tokens.OF.rawValue)
		 	setState(2130) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(2129)
		 		try valuePair()


		 		setState(2132); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ValuePairContext: ParserRuleContext {
			open
			func systemName() -> SystemNameContext? {
				return getRuleContext(SystemNameContext.self, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_valuePair
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterValuePair(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitValuePair(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitValuePair(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitValuePair(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func valuePair() throws -> ValuePairContext {
		var _localctx: ValuePairContext = ValuePairContext(_ctx, getState())
		try enterRule(_localctx, 186, Cobol85Parser.RULE_valuePair)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2134)
		 	try systemName()
		 	setState(2136)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2135)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2140)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,198, _ctx)) {
		 	case 1:
		 		setState(2138)
		 		try qualifiedDataName()

		 		break
		 	case 2:
		 		setState(2139)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataRecordsClauseContext: ParserRuleContext {
			open
			func DATA() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATA.rawValue, 0)
			}
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func RECORDS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORDS.rawValue, 0)
			}
			open
			func dataName() -> [DataNameContext] {
				return getRuleContexts(DataNameContext.self)
			}
			open
			func dataName(_ i: Int) -> DataNameContext? {
				return getRuleContext(DataNameContext.self, i)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func ARE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ARE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataRecordsClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataRecordsClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataRecordsClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataRecordsClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataRecordsClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataRecordsClause() throws -> DataRecordsClauseContext {
		var _localctx: DataRecordsClauseContext = DataRecordsClauseContext(_ctx, getState())
		try enterRule(_localctx, 188, Cobol85Parser.RULE_dataRecordsClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2142)
		 	try match(Cobol85Parser.Tokens.DATA.rawValue)
		 	setState(2151)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .RECORD:
		 		setState(2143)
		 		try match(Cobol85Parser.Tokens.RECORD.rawValue)
		 		setState(2145)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2144)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}


		 		break

		 	case .RECORDS:
		 		setState(2147)
		 		try match(Cobol85Parser.Tokens.RECORDS.rawValue)
		 		setState(2149)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.ARE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2148)
		 			try match(Cobol85Parser.Tokens.ARE.rawValue)

		 		}


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2154) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(2153)
		 		try dataName()


		 		setState(2156); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LinageClauseContext: ParserRuleContext {
			open
			func LINAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINAGE.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func LINES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINES.rawValue, 0)
			}
			open
			func linageAt() -> [LinageAtContext] {
				return getRuleContexts(LinageAtContext.self)
			}
			open
			func linageAt(_ i: Int) -> LinageAtContext? {
				return getRuleContext(LinageAtContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_linageClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLinageClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLinageClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLinageClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLinageClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func linageClause() throws -> LinageClauseContext {
		var _localctx: LinageClauseContext = LinageClauseContext(_ctx, getState())
		try enterRule(_localctx, 190, Cobol85Parser.RULE_linageClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2158)
		 	try match(Cobol85Parser.Tokens.LINAGE.rawValue)
		 	setState(2160)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2159)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2164)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		setState(2162)
		 		try dataName()

		 		break
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		setState(2163)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2167)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,205,_ctx)) {
		 	case 1:
		 		setState(2166)
		 		try match(Cobol85Parser.Tokens.LINES.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(2172)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.AT.rawValue || _la == Cobol85Parser.Tokens.BOTTOM.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.FOOTING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.LINES.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.TOP.rawValue || _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2169)
		 		try linageAt()


		 		setState(2174)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LinageAtContext: ParserRuleContext {
			open
			func linageFootingAt() -> LinageFootingAtContext? {
				return getRuleContext(LinageFootingAtContext.self, 0)
			}
			open
			func linageLinesAtTop() -> LinageLinesAtTopContext? {
				return getRuleContext(LinageLinesAtTopContext.self, 0)
			}
			open
			func linageLinesAtBottom() -> LinageLinesAtBottomContext? {
				return getRuleContext(LinageLinesAtBottomContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_linageAt
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLinageAt(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLinageAt(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLinageAt(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLinageAt(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func linageAt() throws -> LinageAtContext {
		var _localctx: LinageAtContext = LinageAtContext(_ctx, getState())
		try enterRule(_localctx, 192, Cobol85Parser.RULE_linageAt)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2178)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,207, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2175)
		 		try linageFootingAt()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2176)
		 		try linageLinesAtTop()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2177)
		 		try linageLinesAtBottom()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LinageFootingAtContext: ParserRuleContext {
			open
			func FOOTING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOOTING.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
			open
			func AT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_linageFootingAt
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLinageFootingAt(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLinageFootingAt(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLinageFootingAt(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLinageFootingAt(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func linageFootingAt() throws -> LinageFootingAtContext {
		var _localctx: LinageFootingAtContext = LinageFootingAtContext(_ctx, getState())
		try enterRule(_localctx, 194, Cobol85Parser.RULE_linageFootingAt)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2181)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2180)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(2183)
		 	try match(Cobol85Parser.Tokens.FOOTING.rawValue)
		 	setState(2185)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2184)
		 		try match(Cobol85Parser.Tokens.AT.rawValue)

		 	}

		 	setState(2189)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		setState(2187)
		 		try dataName()

		 		break
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		setState(2188)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LinageLinesAtTopContext: ParserRuleContext {
			open
			func TOP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TOP.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func LINES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINES.rawValue, 0)
			}
			open
			func AT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_linageLinesAtTop
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLinageLinesAtTop(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLinageLinesAtTop(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLinageLinesAtTop(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLinageLinesAtTop(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func linageLinesAtTop() throws -> LinageLinesAtTopContext {
		var _localctx: LinageLinesAtTopContext = LinageLinesAtTopContext(_ctx, getState())
		try enterRule(_localctx, 196, Cobol85Parser.RULE_linageLinesAtTop)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2192)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LINES.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2191)
		 		try match(Cobol85Parser.Tokens.LINES.rawValue)

		 	}

		 	setState(2195)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2194)
		 		try match(Cobol85Parser.Tokens.AT.rawValue)

		 	}

		 	setState(2197)
		 	try match(Cobol85Parser.Tokens.TOP.rawValue)
		 	setState(2200)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		setState(2198)
		 		try dataName()

		 		break
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		setState(2199)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LinageLinesAtBottomContext: ParserRuleContext {
			open
			func BOTTOM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BOTTOM.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func LINES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINES.rawValue, 0)
			}
			open
			func AT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_linageLinesAtBottom
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLinageLinesAtBottom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLinageLinesAtBottom(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLinageLinesAtBottom(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLinageLinesAtBottom(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func linageLinesAtBottom() throws -> LinageLinesAtBottomContext {
		var _localctx: LinageLinesAtBottomContext = LinageLinesAtBottomContext(_ctx, getState())
		try enterRule(_localctx, 198, Cobol85Parser.RULE_linageLinesAtBottom)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2203)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LINES.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2202)
		 		try match(Cobol85Parser.Tokens.LINES.rawValue)

		 	}

		 	setState(2206)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2205)
		 		try match(Cobol85Parser.Tokens.AT.rawValue)

		 	}

		 	setState(2208)
		 	try match(Cobol85Parser.Tokens.BOTTOM.rawValue)
		 	setState(2211)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		setState(2209)
		 		try dataName()

		 		break
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		setState(2210)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RecordingModeClauseContext: ParserRuleContext {
			open
			func RECORDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORDING.rawValue, 0)
			}
			open
			func modeStatement() -> ModeStatementContext? {
				return getRuleContext(ModeStatementContext.self, 0)
			}
			open
			func MODE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MODE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_recordingModeClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRecordingModeClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRecordingModeClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRecordingModeClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRecordingModeClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func recordingModeClause() throws -> RecordingModeClauseContext {
		var _localctx: RecordingModeClauseContext = RecordingModeClauseContext(_ctx, getState())
		try enterRule(_localctx, 200, Cobol85Parser.RULE_recordingModeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2213)
		 	try match(Cobol85Parser.Tokens.RECORDING.rawValue)
		 	setState(2215)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.MODE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2214)
		 		try match(Cobol85Parser.Tokens.MODE.rawValue)

		 	}

		 	setState(2218)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2217)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2220)
		 	try modeStatement()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ModeStatementContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_modeStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterModeStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitModeStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitModeStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitModeStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func modeStatement() throws -> ModeStatementContext {
		var _localctx: ModeStatementContext = ModeStatementContext(_ctx, getState())
		try enterRule(_localctx, 202, Cobol85Parser.RULE_modeStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2222)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CodeSetClauseContext: ParserRuleContext {
			open
			func CODE_SET() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CODE_SET.rawValue, 0)
			}
			open
			func alphabetName() -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_codeSetClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCodeSetClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCodeSetClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCodeSetClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCodeSetClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func codeSetClause() throws -> CodeSetClauseContext {
		var _localctx: CodeSetClauseContext = CodeSetClauseContext(_ctx, getState())
		try enterRule(_localctx, 204, Cobol85Parser.RULE_codeSetClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2224)
		 	try match(Cobol85Parser.Tokens.CODE_SET.rawValue)
		 	setState(2226)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2225)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2228)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportClauseContext: ParserRuleContext {
			open
			func REPORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REPORT.rawValue, 0)
			}
			open
			func REPORTS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REPORTS.rawValue, 0)
			}
			open
			func reportName() -> [ReportNameContext] {
				return getRuleContexts(ReportNameContext.self)
			}
			open
			func reportName(_ i: Int) -> ReportNameContext? {
				return getRuleContext(ReportNameContext.self, i)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func ARE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ARE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportClause() throws -> ReportClauseContext {
		var _localctx: ReportClauseContext = ReportClauseContext(_ctx, getState())
		try enterRule(_localctx, 206, Cobol85Parser.RULE_reportClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2238)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .REPORT:
		 		setState(2230)
		 		try match(Cobol85Parser.Tokens.REPORT.rawValue)
		 		setState(2232)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2231)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}


		 		break

		 	case .REPORTS:
		 		setState(2234)
		 		try match(Cobol85Parser.Tokens.REPORTS.rawValue)
		 		setState(2236)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.ARE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2235)
		 			try match(Cobol85Parser.Tokens.ARE.rawValue)

		 		}


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2241) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(2240)
		 		try reportName()


		 		setState(2243); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataBaseSectionContext: ParserRuleContext {
			open
			func DATA_BASE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATA_BASE.rawValue, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func dataBaseSectionEntry() -> [DataBaseSectionEntryContext] {
				return getRuleContexts(DataBaseSectionEntryContext.self)
			}
			open
			func dataBaseSectionEntry(_ i: Int) -> DataBaseSectionEntryContext? {
				return getRuleContext(DataBaseSectionEntryContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataBaseSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataBaseSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataBaseSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataBaseSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataBaseSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataBaseSection() throws -> DataBaseSectionContext {
		var _localctx: DataBaseSectionContext = DataBaseSectionContext(_ctx, getState())
		try enterRule(_localctx, 208, Cobol85Parser.RULE_dataBaseSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2245)
		 	try match(Cobol85Parser.Tokens.DATA_BASE.rawValue)
		 	setState(2246)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(2247)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(2251)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 552)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(2248)
		 		try dataBaseSectionEntry()


		 		setState(2253)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataBaseSectionEntryContext: ParserRuleContext {
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func literal() -> [LiteralContext] {
				return getRuleContexts(LiteralContext.self)
			}
			open
			func literal(_ i: Int) -> LiteralContext? {
				return getRuleContext(LiteralContext.self, i)
			}
			open
			func INVOKE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INVOKE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataBaseSectionEntry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataBaseSectionEntry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataBaseSectionEntry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataBaseSectionEntry(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataBaseSectionEntry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataBaseSectionEntry() throws -> DataBaseSectionEntryContext {
		var _localctx: DataBaseSectionEntryContext = DataBaseSectionEntryContext(_ctx, getState())
		try enterRule(_localctx, 210, Cobol85Parser.RULE_dataBaseSectionEntry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2254)
		 	try integerLiteral()
		 	setState(2255)
		 	try literal()
		 	setState(2256)
		 	try match(Cobol85Parser.Tokens.INVOKE.rawValue)
		 	setState(2257)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WorkingStorageSectionContext: ParserRuleContext {
			open
			func WORKING_STORAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WORKING_STORAGE.rawValue, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func dataDescriptionEntry() -> [DataDescriptionEntryContext] {
				return getRuleContexts(DataDescriptionEntryContext.self)
			}
			open
			func dataDescriptionEntry(_ i: Int) -> DataDescriptionEntryContext? {
				return getRuleContext(DataDescriptionEntryContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_workingStorageSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterWorkingStorageSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitWorkingStorageSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitWorkingStorageSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitWorkingStorageSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func workingStorageSection() throws -> WorkingStorageSectionContext {
		var _localctx: WorkingStorageSectionContext = WorkingStorageSectionContext(_ctx, getState())
		try enterRule(_localctx, 212, Cobol85Parser.RULE_workingStorageSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2259)
		 	try match(Cobol85Parser.Tokens.WORKING_STORAGE.rawValue)
		 	setState(2260)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(2261)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(2265)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.EXECSQLLINE.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 552)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(2262)
		 		try dataDescriptionEntry()


		 		setState(2267)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LinkageSectionContext: ParserRuleContext {
			open
			func LINKAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINKAGE.rawValue, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func dataDescriptionEntry() -> [DataDescriptionEntryContext] {
				return getRuleContexts(DataDescriptionEntryContext.self)
			}
			open
			func dataDescriptionEntry(_ i: Int) -> DataDescriptionEntryContext? {
				return getRuleContext(DataDescriptionEntryContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_linkageSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLinkageSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLinkageSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLinkageSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLinkageSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func linkageSection() throws -> LinkageSectionContext {
		var _localctx: LinkageSectionContext = LinkageSectionContext(_ctx, getState())
		try enterRule(_localctx, 214, Cobol85Parser.RULE_linkageSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2268)
		 	try match(Cobol85Parser.Tokens.LINKAGE.rawValue)
		 	setState(2269)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(2270)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(2274)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.EXECSQLLINE.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 552)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(2271)
		 		try dataDescriptionEntry()


		 		setState(2276)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CommunicationSectionContext: ParserRuleContext {
			open
			func COMMUNICATION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMUNICATION.rawValue, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func communicationDescriptionEntry() -> [CommunicationDescriptionEntryContext] {
				return getRuleContexts(CommunicationDescriptionEntryContext.self)
			}
			open
			func communicationDescriptionEntry(_ i: Int) -> CommunicationDescriptionEntryContext? {
				return getRuleContext(CommunicationDescriptionEntryContext.self, i)
			}
			open
			func dataDescriptionEntry() -> [DataDescriptionEntryContext] {
				return getRuleContexts(DataDescriptionEntryContext.self)
			}
			open
			func dataDescriptionEntry(_ i: Int) -> DataDescriptionEntryContext? {
				return getRuleContext(DataDescriptionEntryContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_communicationSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCommunicationSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCommunicationSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCommunicationSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCommunicationSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func communicationSection() throws -> CommunicationSectionContext {
		var _localctx: CommunicationSectionContext = CommunicationSectionContext(_ctx, getState())
		try enterRule(_localctx, 216, Cobol85Parser.RULE_communicationSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2277)
		 	try match(Cobol85Parser.Tokens.COMMUNICATION.rawValue)
		 	setState(2278)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(2279)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(2284)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.CD.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.EXECSQLLINE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2282)
		 		try _errHandler.sync(self)
		 		switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CD:
		 			setState(2280)
		 			try communicationDescriptionEntry()

		 			break
		 		case .LEVEL_NUMBER_66:fallthrough
		 		case .LEVEL_NUMBER_77:fallthrough
		 		case .LEVEL_NUMBER_88:fallthrough
		 		case .INTEGERLITERAL:fallthrough
		 		case .EXECSQLLINE:
		 			setState(2281)
		 			try dataDescriptionEntry()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2286)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CommunicationDescriptionEntryContext: ParserRuleContext {
			open
			func communicationDescriptionEntryFormat1() -> CommunicationDescriptionEntryFormat1Context? {
				return getRuleContext(CommunicationDescriptionEntryFormat1Context.self, 0)
			}
			open
			func communicationDescriptionEntryFormat2() -> CommunicationDescriptionEntryFormat2Context? {
				return getRuleContext(CommunicationDescriptionEntryFormat2Context.self, 0)
			}
			open
			func communicationDescriptionEntryFormat3() -> CommunicationDescriptionEntryFormat3Context? {
				return getRuleContext(CommunicationDescriptionEntryFormat3Context.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_communicationDescriptionEntry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCommunicationDescriptionEntry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCommunicationDescriptionEntry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCommunicationDescriptionEntry(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCommunicationDescriptionEntry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func communicationDescriptionEntry() throws -> CommunicationDescriptionEntryContext {
		var _localctx: CommunicationDescriptionEntryContext = CommunicationDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 218, Cobol85Parser.RULE_communicationDescriptionEntry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2290)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,229, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2287)
		 		try communicationDescriptionEntryFormat1()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2288)
		 		try communicationDescriptionEntryFormat2()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2289)
		 		try communicationDescriptionEntryFormat3()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CommunicationDescriptionEntryFormat1Context: ParserRuleContext {
			open
			func CD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CD.rawValue, 0)
			}
			open
			func cdName() -> CdNameContext? {
				return getRuleContext(CdNameContext.self, 0)
			}
			open
			func INPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INPUT.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func INITIAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INITIAL.rawValue, 0)
			}
			open
			func dataDescName() -> [DataDescNameContext] {
				return getRuleContexts(DataDescNameContext.self)
			}
			open
			func dataDescName(_ i: Int) -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, i)
			}
			open
			func symbolicQueueClause() -> [SymbolicQueueClauseContext] {
				return getRuleContexts(SymbolicQueueClauseContext.self)
			}
			open
			func symbolicQueueClause(_ i: Int) -> SymbolicQueueClauseContext? {
				return getRuleContext(SymbolicQueueClauseContext.self, i)
			}
			open
			func symbolicSubQueueClause() -> [SymbolicSubQueueClauseContext] {
				return getRuleContexts(SymbolicSubQueueClauseContext.self)
			}
			open
			func symbolicSubQueueClause(_ i: Int) -> SymbolicSubQueueClauseContext? {
				return getRuleContext(SymbolicSubQueueClauseContext.self, i)
			}
			open
			func messageDateClause() -> [MessageDateClauseContext] {
				return getRuleContexts(MessageDateClauseContext.self)
			}
			open
			func messageDateClause(_ i: Int) -> MessageDateClauseContext? {
				return getRuleContext(MessageDateClauseContext.self, i)
			}
			open
			func messageTimeClause() -> [MessageTimeClauseContext] {
				return getRuleContexts(MessageTimeClauseContext.self)
			}
			open
			func messageTimeClause(_ i: Int) -> MessageTimeClauseContext? {
				return getRuleContext(MessageTimeClauseContext.self, i)
			}
			open
			func symbolicSourceClause() -> [SymbolicSourceClauseContext] {
				return getRuleContexts(SymbolicSourceClauseContext.self)
			}
			open
			func symbolicSourceClause(_ i: Int) -> SymbolicSourceClauseContext? {
				return getRuleContext(SymbolicSourceClauseContext.self, i)
			}
			open
			func textLengthClause() -> [TextLengthClauseContext] {
				return getRuleContexts(TextLengthClauseContext.self)
			}
			open
			func textLengthClause(_ i: Int) -> TextLengthClauseContext? {
				return getRuleContext(TextLengthClauseContext.self, i)
			}
			open
			func endKeyClause() -> [EndKeyClauseContext] {
				return getRuleContexts(EndKeyClauseContext.self)
			}
			open
			func endKeyClause(_ i: Int) -> EndKeyClauseContext? {
				return getRuleContext(EndKeyClauseContext.self, i)
			}
			open
			func statusKeyClause() -> [StatusKeyClauseContext] {
				return getRuleContexts(StatusKeyClauseContext.self)
			}
			open
			func statusKeyClause(_ i: Int) -> StatusKeyClauseContext? {
				return getRuleContext(StatusKeyClauseContext.self, i)
			}
			open
			func messageCountClause() -> [MessageCountClauseContext] {
				return getRuleContexts(MessageCountClauseContext.self)
			}
			open
			func messageCountClause(_ i: Int) -> MessageCountClauseContext? {
				return getRuleContext(MessageCountClauseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_communicationDescriptionEntryFormat1
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCommunicationDescriptionEntryFormat1(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCommunicationDescriptionEntryFormat1(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCommunicationDescriptionEntryFormat1(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCommunicationDescriptionEntryFormat1(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func communicationDescriptionEntryFormat1() throws -> CommunicationDescriptionEntryFormat1Context {
		var _localctx: CommunicationDescriptionEntryFormat1Context = CommunicationDescriptionEntryFormat1Context(_ctx, getState())
		try enterRule(_localctx, 220, Cobol85Parser.RULE_communicationDescriptionEntryFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2292)
		 	try match(Cobol85Parser.Tokens.CD.rawValue)
		 	setState(2293)
		 	try cdName()
		 	setState(2295)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2294)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(2298)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.INITIAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2297)
		 		try match(Cobol85Parser.Tokens.INITIAL.rawValue)

		 	}

		 	setState(2300)
		 	try match(Cobol85Parser.Tokens.INPUT.rawValue)
		 	setState(2315)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.COUNT.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.END.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FILLER.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MESSAGE.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUEUE.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SOURCE.rawValue,Cobol85Parser.Tokens.STATUS.rawValue,Cobol85Parser.Tokens.SUB_QUEUE_1.rawValue,Cobol85Parser.Tokens.SUB_QUEUE_2.rawValue,Cobol85Parser.Tokens.SUB_QUEUE_3.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.SYMBOLIC.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.TEXT.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2313)
		 		try _errHandler.sync(self)
		 		switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .COUNT:fallthrough
		 		case .END:fallthrough
		 		case .MESSAGE:fallthrough
		 		case .QUEUE:fallthrough
		 		case .SOURCE:fallthrough
		 		case .STATUS:fallthrough
		 		case .SUB_QUEUE_1:fallthrough
		 		case .SUB_QUEUE_2:fallthrough
		 		case .SUB_QUEUE_3:fallthrough
		 		case .SYMBOLIC:fallthrough
		 		case .TEXT:
		 			setState(2310)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,232, _ctx)) {
		 			case 1:
		 				setState(2301)
		 				try symbolicQueueClause()

		 				break
		 			case 2:
		 				setState(2302)
		 				try symbolicSubQueueClause()

		 				break
		 			case 3:
		 				setState(2303)
		 				try messageDateClause()

		 				break
		 			case 4:
		 				setState(2304)
		 				try messageTimeClause()

		 				break
		 			case 5:
		 				setState(2305)
		 				try symbolicSourceClause()

		 				break
		 			case 6:
		 				setState(2306)
		 				try textLengthClause()

		 				break
		 			case 7:
		 				setState(2307)
		 				try endKeyClause()

		 				break
		 			case 8:
		 				setState(2308)
		 				try statusKeyClause()

		 				break
		 			case 9:
		 				setState(2309)
		 				try messageCountClause()

		 				break
		 			default: break
		 			}

		 			break
		 		case .ABORT:fallthrough
		 		case .AS:fallthrough
		 		case .ASCII:fallthrough
		 		case .ASSOCIATED_DATA:fallthrough
		 		case .ASSOCIATED_DATA_LENGTH:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .AUTO:fallthrough
		 		case .AUTO_SKIP:fallthrough
		 		case .BACKGROUND_COLOR:fallthrough
		 		case .BACKGROUND_COLOUR:fallthrough
		 		case .BEEP:fallthrough
		 		case .BELL:fallthrough
		 		case .BINARY:fallthrough
		 		case .BIT:fallthrough
		 		case .BLINK:fallthrough
		 		case .BOUNDS:fallthrough
		 		case .CAPABLE:fallthrough
		 		case .CCSVERSION:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CLOSE_DISPOSITION:fallthrough
		 		case .COBOL:fallthrough
		 		case .COMMITMENT:fallthrough
		 		case .CONTROL_POINT:fallthrough
		 		case .CONVENTION:fallthrough
		 		case .CRUNCH:fallthrough
		 		case .CURSOR:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DEFAULT_DISPLAY:fallthrough
		 		case .DEFINITION:fallthrough
		 		case .DFHRESP:fallthrough
		 		case .DFHVALUE:fallthrough
		 		case .DISK:fallthrough
		 		case .DONTCARE:fallthrough
		 		case .DOUBLE:fallthrough
		 		case .EBCDIC:fallthrough
		 		case .EMPTY_CHECK:fallthrough
		 		case .ENTER:fallthrough
		 		case .ENTRY_PROCEDURE:fallthrough
		 		case .ERASE:fallthrough
		 		case .EOL:fallthrough
		 		case .EOS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVENT:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .FILLER:fallthrough
		 		case .FOREGROUND_COLOR:fallthrough
		 		case .FOREGROUND_COLOUR:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTIONNAME:fallthrough
		 		case .FUNCTION_POINTER:fallthrough
		 		case .GRID:fallthrough
		 		case .HIGHLIGHT:fallthrough
		 		case .IMPLICIT:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INTEGER:fallthrough
		 		case .KEPT:fallthrough
		 		case .KEYBOARD:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LB:fallthrough
		 		case .LD:fallthrough
		 		case .LEFTLINE:fallthrough
		 		case .LENGTH_CHECK:fallthrough
		 		case .LIBACCESS:fallthrough
		 		case .LIBPARAMETER:fallthrough
		 		case .LIBRARY:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LONG_DATE:fallthrough
		 		case .LONG_TIME:fallthrough
		 		case .LOWER:fallthrough
		 		case .LOWLIGHT:fallthrough
		 		case .MMDDYYYY:fallthrough
		 		case .NAMED:fallthrough
		 		case .NATIONAL:fallthrough
		 		case .NATIONAL_EDITED:fallthrough
		 		case .NETWORK:fallthrough
		 		case .NO_ECHO:fallthrough
		 		case .NUMERIC_DATE:fallthrough
		 		case .NUMERIC_TIME:fallthrough
		 		case .ODT:fallthrough
		 		case .ORDERLY:fallthrough
		 		case .OVERLINE:fallthrough
		 		case .OWN:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PORT:fallthrough
		 		case .PRINTER:fallthrough
		 		case .PRIVATE:fallthrough
		 		case .PROCESS:fallthrough
		 		case .PROGRAM:fallthrough
		 		case .PROMPT:fallthrough
		 		case .READER:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REAL:fallthrough
		 		case .RECEIVED:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REF:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REQUIRED:fallthrough
		 		case .REVERSE_VIDEO:fallthrough
		 		case .SAVE:fallthrough
		 		case .SECURE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SHAREDBYALL:fallthrough
		 		case .SHAREDBYRUNUNIT:fallthrough
		 		case .SHARING:fallthrough
		 		case .SHORT_DATE:fallthrough
		 		case .SYMBOL:fallthrough
		 		case .TASK:fallthrough
		 		case .THREAD:fallthrough
		 		case .THREAD_LOCAL:fallthrough
		 		case .TIMER:fallthrough
		 		case .TODAYS_DATE:fallthrough
		 		case .TODAYS_NAME:fallthrough
		 		case .TRUNCATED:fallthrough
		 		case .TYPEDEF:fallthrough
		 		case .UNDERLINE:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .WAIT:fallthrough
		 		case .YEAR:fallthrough
		 		case .YYYYMMDD:fallthrough
		 		case .YYYYDDD:fallthrough
		 		case .ZERO_FILL:fallthrough
		 		case .IDENTIFIER:
		 			setState(2312)
		 			try dataDescName()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2317)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2318)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CommunicationDescriptionEntryFormat2Context: ParserRuleContext {
			open
			func CD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CD.rawValue, 0)
			}
			open
			func cdName() -> CdNameContext? {
				return getRuleContext(CdNameContext.self, 0)
			}
			open
			func OUTPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OUTPUT.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func destinationCountClause() -> [DestinationCountClauseContext] {
				return getRuleContexts(DestinationCountClauseContext.self)
			}
			open
			func destinationCountClause(_ i: Int) -> DestinationCountClauseContext? {
				return getRuleContext(DestinationCountClauseContext.self, i)
			}
			open
			func textLengthClause() -> [TextLengthClauseContext] {
				return getRuleContexts(TextLengthClauseContext.self)
			}
			open
			func textLengthClause(_ i: Int) -> TextLengthClauseContext? {
				return getRuleContext(TextLengthClauseContext.self, i)
			}
			open
			func statusKeyClause() -> [StatusKeyClauseContext] {
				return getRuleContexts(StatusKeyClauseContext.self)
			}
			open
			func statusKeyClause(_ i: Int) -> StatusKeyClauseContext? {
				return getRuleContext(StatusKeyClauseContext.self, i)
			}
			open
			func destinationTableClause() -> [DestinationTableClauseContext] {
				return getRuleContexts(DestinationTableClauseContext.self)
			}
			open
			func destinationTableClause(_ i: Int) -> DestinationTableClauseContext? {
				return getRuleContext(DestinationTableClauseContext.self, i)
			}
			open
			func errorKeyClause() -> [ErrorKeyClauseContext] {
				return getRuleContexts(ErrorKeyClauseContext.self)
			}
			open
			func errorKeyClause(_ i: Int) -> ErrorKeyClauseContext? {
				return getRuleContext(ErrorKeyClauseContext.self, i)
			}
			open
			func symbolicDestinationClause() -> [SymbolicDestinationClauseContext] {
				return getRuleContexts(SymbolicDestinationClauseContext.self)
			}
			open
			func symbolicDestinationClause(_ i: Int) -> SymbolicDestinationClauseContext? {
				return getRuleContext(SymbolicDestinationClauseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_communicationDescriptionEntryFormat2
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCommunicationDescriptionEntryFormat2(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCommunicationDescriptionEntryFormat2(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCommunicationDescriptionEntryFormat2(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCommunicationDescriptionEntryFormat2(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func communicationDescriptionEntryFormat2() throws -> CommunicationDescriptionEntryFormat2Context {
		var _localctx: CommunicationDescriptionEntryFormat2Context = CommunicationDescriptionEntryFormat2Context(_ctx, getState())
		try enterRule(_localctx, 222, Cobol85Parser.RULE_communicationDescriptionEntryFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2320)
		 	try match(Cobol85Parser.Tokens.CD.rawValue)
		 	setState(2321)
		 	try cdName()
		 	setState(2323)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2322)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(2325)
		 	try match(Cobol85Parser.Tokens.OUTPUT.rawValue)
		 	setState(2334)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.DESTINATION.rawValue || _la == Cobol85Parser.Tokens.ERROR.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.STATUS.rawValue,Cobol85Parser.Tokens.SYMBOLIC.rawValue,Cobol85Parser.Tokens.TEXT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 457)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2332)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,236, _ctx)) {
		 		case 1:
		 			setState(2326)
		 			try destinationCountClause()

		 			break
		 		case 2:
		 			setState(2327)
		 			try textLengthClause()

		 			break
		 		case 3:
		 			setState(2328)
		 			try statusKeyClause()

		 			break
		 		case 4:
		 			setState(2329)
		 			try destinationTableClause()

		 			break
		 		case 5:
		 			setState(2330)
		 			try errorKeyClause()

		 			break
		 		case 6:
		 			setState(2331)
		 			try symbolicDestinationClause()

		 			break
		 		default: break
		 		}

		 		setState(2336)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2337)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CommunicationDescriptionEntryFormat3Context: ParserRuleContext {
			open
			func CD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CD.rawValue, 0)
			}
			open
			func cdName() -> CdNameContext? {
				return getRuleContext(CdNameContext.self, 0)
			}
			open
			func INITIAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INITIAL.rawValue, 0)
			}
			open
			func I_O() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.I_O.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func dataDescName() -> [DataDescNameContext] {
				return getRuleContexts(DataDescNameContext.self)
			}
			open
			func dataDescName(_ i: Int) -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, i)
			}
			open
			func messageDateClause() -> [MessageDateClauseContext] {
				return getRuleContexts(MessageDateClauseContext.self)
			}
			open
			func messageDateClause(_ i: Int) -> MessageDateClauseContext? {
				return getRuleContext(MessageDateClauseContext.self, i)
			}
			open
			func messageTimeClause() -> [MessageTimeClauseContext] {
				return getRuleContexts(MessageTimeClauseContext.self)
			}
			open
			func messageTimeClause(_ i: Int) -> MessageTimeClauseContext? {
				return getRuleContext(MessageTimeClauseContext.self, i)
			}
			open
			func symbolicTerminalClause() -> [SymbolicTerminalClauseContext] {
				return getRuleContexts(SymbolicTerminalClauseContext.self)
			}
			open
			func symbolicTerminalClause(_ i: Int) -> SymbolicTerminalClauseContext? {
				return getRuleContext(SymbolicTerminalClauseContext.self, i)
			}
			open
			func textLengthClause() -> [TextLengthClauseContext] {
				return getRuleContexts(TextLengthClauseContext.self)
			}
			open
			func textLengthClause(_ i: Int) -> TextLengthClauseContext? {
				return getRuleContext(TextLengthClauseContext.self, i)
			}
			open
			func endKeyClause() -> [EndKeyClauseContext] {
				return getRuleContexts(EndKeyClauseContext.self)
			}
			open
			func endKeyClause(_ i: Int) -> EndKeyClauseContext? {
				return getRuleContext(EndKeyClauseContext.self, i)
			}
			open
			func statusKeyClause() -> [StatusKeyClauseContext] {
				return getRuleContexts(StatusKeyClauseContext.self)
			}
			open
			func statusKeyClause(_ i: Int) -> StatusKeyClauseContext? {
				return getRuleContext(StatusKeyClauseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_communicationDescriptionEntryFormat3
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCommunicationDescriptionEntryFormat3(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCommunicationDescriptionEntryFormat3(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCommunicationDescriptionEntryFormat3(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCommunicationDescriptionEntryFormat3(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func communicationDescriptionEntryFormat3() throws -> CommunicationDescriptionEntryFormat3Context {
		var _localctx: CommunicationDescriptionEntryFormat3Context = CommunicationDescriptionEntryFormat3Context(_ctx, getState())
		try enterRule(_localctx, 224, Cobol85Parser.RULE_communicationDescriptionEntryFormat3)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2339)
		 	try match(Cobol85Parser.Tokens.CD.rawValue)
		 	setState(2340)
		 	try cdName()
		 	setState(2342)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2341)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(2344)
		 	try match(Cobol85Parser.Tokens.INITIAL.rawValue)
		 	setState(2345)
		 	try match(Cobol85Parser.Tokens.I_O.rawValue)
		 	setState(2357)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.END.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FILLER.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MESSAGE.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.STATUS.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.SYMBOLIC.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.TERMINAL.rawValue,Cobol85Parser.Tokens.TEXT.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2355)
		 		try _errHandler.sync(self)
		 		switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .END:fallthrough
		 		case .MESSAGE:fallthrough
		 		case .STATUS:fallthrough
		 		case .SYMBOLIC:fallthrough
		 		case .TERMINAL:fallthrough
		 		case .TEXT:
		 			setState(2352)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,239, _ctx)) {
		 			case 1:
		 				setState(2346)
		 				try messageDateClause()

		 				break
		 			case 2:
		 				setState(2347)
		 				try messageTimeClause()

		 				break
		 			case 3:
		 				setState(2348)
		 				try symbolicTerminalClause()

		 				break
		 			case 4:
		 				setState(2349)
		 				try textLengthClause()

		 				break
		 			case 5:
		 				setState(2350)
		 				try endKeyClause()

		 				break
		 			case 6:
		 				setState(2351)
		 				try statusKeyClause()

		 				break
		 			default: break
		 			}

		 			break
		 		case .ABORT:fallthrough
		 		case .AS:fallthrough
		 		case .ASCII:fallthrough
		 		case .ASSOCIATED_DATA:fallthrough
		 		case .ASSOCIATED_DATA_LENGTH:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .AUTO:fallthrough
		 		case .AUTO_SKIP:fallthrough
		 		case .BACKGROUND_COLOR:fallthrough
		 		case .BACKGROUND_COLOUR:fallthrough
		 		case .BEEP:fallthrough
		 		case .BELL:fallthrough
		 		case .BINARY:fallthrough
		 		case .BIT:fallthrough
		 		case .BLINK:fallthrough
		 		case .BOUNDS:fallthrough
		 		case .CAPABLE:fallthrough
		 		case .CCSVERSION:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CLOSE_DISPOSITION:fallthrough
		 		case .COBOL:fallthrough
		 		case .COMMITMENT:fallthrough
		 		case .CONTROL_POINT:fallthrough
		 		case .CONVENTION:fallthrough
		 		case .CRUNCH:fallthrough
		 		case .CURSOR:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DEFAULT_DISPLAY:fallthrough
		 		case .DEFINITION:fallthrough
		 		case .DFHRESP:fallthrough
		 		case .DFHVALUE:fallthrough
		 		case .DISK:fallthrough
		 		case .DONTCARE:fallthrough
		 		case .DOUBLE:fallthrough
		 		case .EBCDIC:fallthrough
		 		case .EMPTY_CHECK:fallthrough
		 		case .ENTER:fallthrough
		 		case .ENTRY_PROCEDURE:fallthrough
		 		case .ERASE:fallthrough
		 		case .EOL:fallthrough
		 		case .EOS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVENT:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .FILLER:fallthrough
		 		case .FOREGROUND_COLOR:fallthrough
		 		case .FOREGROUND_COLOUR:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTIONNAME:fallthrough
		 		case .FUNCTION_POINTER:fallthrough
		 		case .GRID:fallthrough
		 		case .HIGHLIGHT:fallthrough
		 		case .IMPLICIT:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INTEGER:fallthrough
		 		case .KEPT:fallthrough
		 		case .KEYBOARD:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LB:fallthrough
		 		case .LD:fallthrough
		 		case .LEFTLINE:fallthrough
		 		case .LENGTH_CHECK:fallthrough
		 		case .LIBACCESS:fallthrough
		 		case .LIBPARAMETER:fallthrough
		 		case .LIBRARY:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LONG_DATE:fallthrough
		 		case .LONG_TIME:fallthrough
		 		case .LOWER:fallthrough
		 		case .LOWLIGHT:fallthrough
		 		case .MMDDYYYY:fallthrough
		 		case .NAMED:fallthrough
		 		case .NATIONAL:fallthrough
		 		case .NATIONAL_EDITED:fallthrough
		 		case .NETWORK:fallthrough
		 		case .NO_ECHO:fallthrough
		 		case .NUMERIC_DATE:fallthrough
		 		case .NUMERIC_TIME:fallthrough
		 		case .ODT:fallthrough
		 		case .ORDERLY:fallthrough
		 		case .OVERLINE:fallthrough
		 		case .OWN:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PORT:fallthrough
		 		case .PRINTER:fallthrough
		 		case .PRIVATE:fallthrough
		 		case .PROCESS:fallthrough
		 		case .PROGRAM:fallthrough
		 		case .PROMPT:fallthrough
		 		case .READER:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REAL:fallthrough
		 		case .RECEIVED:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REF:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REQUIRED:fallthrough
		 		case .REVERSE_VIDEO:fallthrough
		 		case .SAVE:fallthrough
		 		case .SECURE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SHAREDBYALL:fallthrough
		 		case .SHAREDBYRUNUNIT:fallthrough
		 		case .SHARING:fallthrough
		 		case .SHORT_DATE:fallthrough
		 		case .SYMBOL:fallthrough
		 		case .TASK:fallthrough
		 		case .THREAD:fallthrough
		 		case .THREAD_LOCAL:fallthrough
		 		case .TIMER:fallthrough
		 		case .TODAYS_DATE:fallthrough
		 		case .TODAYS_NAME:fallthrough
		 		case .TRUNCATED:fallthrough
		 		case .TYPEDEF:fallthrough
		 		case .UNDERLINE:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .WAIT:fallthrough
		 		case .YEAR:fallthrough
		 		case .YYYYMMDD:fallthrough
		 		case .YYYYDDD:fallthrough
		 		case .ZERO_FILL:fallthrough
		 		case .IDENTIFIER:
		 			setState(2354)
		 			try dataDescName()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2359)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2360)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DestinationCountClauseContext: ParserRuleContext {
			open
			func DESTINATION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DESTINATION.rawValue, 0)
			}
			open
			func COUNT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COUNT.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_destinationCountClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDestinationCountClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDestinationCountClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDestinationCountClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDestinationCountClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func destinationCountClause() throws -> DestinationCountClauseContext {
		var _localctx: DestinationCountClauseContext = DestinationCountClauseContext(_ctx, getState())
		try enterRule(_localctx, 226, Cobol85Parser.RULE_destinationCountClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2362)
		 	try match(Cobol85Parser.Tokens.DESTINATION.rawValue)
		 	setState(2363)
		 	try match(Cobol85Parser.Tokens.COUNT.rawValue)
		 	setState(2365)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2364)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2367)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DestinationTableClauseContext: ParserRuleContext {
			open
			func DESTINATION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DESTINATION.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TABLE.rawValue, 0)
			}
			open
			func OCCURS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OCCURS.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func TIMES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TIMES.rawValue, 0)
			}
			open
			func INDEXED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INDEXED.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func indexName() -> [IndexNameContext] {
				return getRuleContexts(IndexNameContext.self)
			}
			open
			func indexName(_ i: Int) -> IndexNameContext? {
				return getRuleContext(IndexNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_destinationTableClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDestinationTableClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDestinationTableClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDestinationTableClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDestinationTableClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func destinationTableClause() throws -> DestinationTableClauseContext {
		var _localctx: DestinationTableClauseContext = DestinationTableClauseContext(_ctx, getState())
		try enterRule(_localctx, 228, Cobol85Parser.RULE_destinationTableClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2369)
		 	try match(Cobol85Parser.Tokens.DESTINATION.rawValue)
		 	setState(2370)
		 	try match(Cobol85Parser.Tokens.TABLE.rawValue)
		 	setState(2371)
		 	try match(Cobol85Parser.Tokens.OCCURS.rawValue)
		 	setState(2372)
		 	try integerLiteral()
		 	setState(2373)
		 	try match(Cobol85Parser.Tokens.TIMES.rawValue)
		 	setState(2381)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.INDEXED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2374)
		 		try match(Cobol85Parser.Tokens.INDEXED.rawValue)
		 		setState(2375)
		 		try match(Cobol85Parser.Tokens.BY.rawValue)
		 		setState(2377) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2376)
		 			try indexName()


		 			setState(2379); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 68)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 138)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 202)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 268)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 401)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 466)
		 		          }()
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 		      return testSet
		 		 }())

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EndKeyClauseContext: ParserRuleContext {
			open
			func END() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_endKeyClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEndKeyClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEndKeyClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEndKeyClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEndKeyClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func endKeyClause() throws -> EndKeyClauseContext {
		var _localctx: EndKeyClauseContext = EndKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 230, Cobol85Parser.RULE_endKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2383)
		 	try match(Cobol85Parser.Tokens.END.rawValue)
		 	setState(2384)
		 	try match(Cobol85Parser.Tokens.KEY.rawValue)
		 	setState(2386)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2385)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2388)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ErrorKeyClauseContext: ParserRuleContext {
			open
			func ERROR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ERROR.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_errorKeyClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterErrorKeyClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitErrorKeyClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitErrorKeyClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitErrorKeyClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func errorKeyClause() throws -> ErrorKeyClauseContext {
		var _localctx: ErrorKeyClauseContext = ErrorKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 232, Cobol85Parser.RULE_errorKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2390)
		 	try match(Cobol85Parser.Tokens.ERROR.rawValue)
		 	setState(2391)
		 	try match(Cobol85Parser.Tokens.KEY.rawValue)
		 	setState(2393)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2392)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2395)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MessageCountClauseContext: ParserRuleContext {
			open
			func COUNT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COUNT.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func MESSAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MESSAGE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_messageCountClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMessageCountClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMessageCountClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMessageCountClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMessageCountClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func messageCountClause() throws -> MessageCountClauseContext {
		var _localctx: MessageCountClauseContext = MessageCountClauseContext(_ctx, getState())
		try enterRule(_localctx, 234, Cobol85Parser.RULE_messageCountClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2398)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.MESSAGE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2397)
		 		try match(Cobol85Parser.Tokens.MESSAGE.rawValue)

		 	}

		 	setState(2400)
		 	try match(Cobol85Parser.Tokens.COUNT.rawValue)
		 	setState(2402)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2401)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2404)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MessageDateClauseContext: ParserRuleContext {
			open
			func MESSAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MESSAGE.rawValue, 0)
			}
			open
			func DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATE.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_messageDateClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMessageDateClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMessageDateClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMessageDateClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMessageDateClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func messageDateClause() throws -> MessageDateClauseContext {
		var _localctx: MessageDateClauseContext = MessageDateClauseContext(_ctx, getState())
		try enterRule(_localctx, 236, Cobol85Parser.RULE_messageDateClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2406)
		 	try match(Cobol85Parser.Tokens.MESSAGE.rawValue)
		 	setState(2407)
		 	try match(Cobol85Parser.Tokens.DATE.rawValue)
		 	setState(2409)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2408)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2411)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MessageTimeClauseContext: ParserRuleContext {
			open
			func MESSAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MESSAGE.rawValue, 0)
			}
			open
			func TIME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TIME.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_messageTimeClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMessageTimeClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMessageTimeClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMessageTimeClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMessageTimeClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func messageTimeClause() throws -> MessageTimeClauseContext {
		var _localctx: MessageTimeClauseContext = MessageTimeClauseContext(_ctx, getState())
		try enterRule(_localctx, 238, Cobol85Parser.RULE_messageTimeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2413)
		 	try match(Cobol85Parser.Tokens.MESSAGE.rawValue)
		 	setState(2414)
		 	try match(Cobol85Parser.Tokens.TIME.rawValue)
		 	setState(2416)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2415)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2418)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StatusKeyClauseContext: ParserRuleContext {
			open
			func STATUS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STATUS.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_statusKeyClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStatusKeyClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStatusKeyClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStatusKeyClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStatusKeyClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func statusKeyClause() throws -> StatusKeyClauseContext {
		var _localctx: StatusKeyClauseContext = StatusKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 240, Cobol85Parser.RULE_statusKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2420)
		 	try match(Cobol85Parser.Tokens.STATUS.rawValue)
		 	setState(2421)
		 	try match(Cobol85Parser.Tokens.KEY.rawValue)
		 	setState(2423)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2422)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2425)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolicDestinationClauseContext: ParserRuleContext {
			open
			func DESTINATION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DESTINATION.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func SYMBOLIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SYMBOLIC.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_symbolicDestinationClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSymbolicDestinationClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSymbolicDestinationClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSymbolicDestinationClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSymbolicDestinationClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolicDestinationClause() throws -> SymbolicDestinationClauseContext {
		var _localctx: SymbolicDestinationClauseContext = SymbolicDestinationClauseContext(_ctx, getState())
		try enterRule(_localctx, 242, Cobol85Parser.RULE_symbolicDestinationClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2428)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SYMBOLIC.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2427)
		 		try match(Cobol85Parser.Tokens.SYMBOLIC.rawValue)

		 	}

		 	setState(2430)
		 	try match(Cobol85Parser.Tokens.DESTINATION.rawValue)
		 	setState(2432)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2431)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2434)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolicQueueClauseContext: ParserRuleContext {
			open
			func QUEUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.QUEUE.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func SYMBOLIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SYMBOLIC.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_symbolicQueueClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSymbolicQueueClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSymbolicQueueClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSymbolicQueueClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSymbolicQueueClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolicQueueClause() throws -> SymbolicQueueClauseContext {
		var _localctx: SymbolicQueueClauseContext = SymbolicQueueClauseContext(_ctx, getState())
		try enterRule(_localctx, 244, Cobol85Parser.RULE_symbolicQueueClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2437)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SYMBOLIC.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2436)
		 		try match(Cobol85Parser.Tokens.SYMBOLIC.rawValue)

		 	}

		 	setState(2439)
		 	try match(Cobol85Parser.Tokens.QUEUE.rawValue)
		 	setState(2441)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2440)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2443)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolicSourceClauseContext: ParserRuleContext {
			open
			func SOURCE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SOURCE.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func SYMBOLIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SYMBOLIC.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_symbolicSourceClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSymbolicSourceClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSymbolicSourceClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSymbolicSourceClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSymbolicSourceClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolicSourceClause() throws -> SymbolicSourceClauseContext {
		var _localctx: SymbolicSourceClauseContext = SymbolicSourceClauseContext(_ctx, getState())
		try enterRule(_localctx, 246, Cobol85Parser.RULE_symbolicSourceClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2446)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SYMBOLIC.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2445)
		 		try match(Cobol85Parser.Tokens.SYMBOLIC.rawValue)

		 	}

		 	setState(2448)
		 	try match(Cobol85Parser.Tokens.SOURCE.rawValue)
		 	setState(2450)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2449)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2452)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolicTerminalClauseContext: ParserRuleContext {
			open
			func TERMINAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TERMINAL.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func SYMBOLIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SYMBOLIC.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_symbolicTerminalClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSymbolicTerminalClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSymbolicTerminalClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSymbolicTerminalClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSymbolicTerminalClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolicTerminalClause() throws -> SymbolicTerminalClauseContext {
		var _localctx: SymbolicTerminalClauseContext = SymbolicTerminalClauseContext(_ctx, getState())
		try enterRule(_localctx, 248, Cobol85Parser.RULE_symbolicTerminalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2455)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SYMBOLIC.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2454)
		 		try match(Cobol85Parser.Tokens.SYMBOLIC.rawValue)

		 	}

		 	setState(2457)
		 	try match(Cobol85Parser.Tokens.TERMINAL.rawValue)
		 	setState(2459)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2458)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2461)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolicSubQueueClauseContext: ParserRuleContext {
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func SUB_QUEUE_1() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SUB_QUEUE_1.rawValue, 0)
			}
			open
			func SUB_QUEUE_2() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SUB_QUEUE_2.rawValue, 0)
			}
			open
			func SUB_QUEUE_3() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SUB_QUEUE_3.rawValue, 0)
			}
			open
			func SYMBOLIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SYMBOLIC.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_symbolicSubQueueClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSymbolicSubQueueClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSymbolicSubQueueClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSymbolicSubQueueClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSymbolicSubQueueClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolicSubQueueClause() throws -> SymbolicSubQueueClauseContext {
		var _localctx: SymbolicSubQueueClauseContext = SymbolicSubQueueClauseContext(_ctx, getState())
		try enterRule(_localctx, 250, Cobol85Parser.RULE_symbolicSubQueueClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2464)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SYMBOLIC.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2463)
		 		try match(Cobol85Parser.Tokens.SYMBOLIC.rawValue)

		 	}

		 	setState(2466)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.SUB_QUEUE_1.rawValue,Cobol85Parser.Tokens.SUB_QUEUE_2.rawValue,Cobol85Parser.Tokens.SUB_QUEUE_3.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 460)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2468)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2467)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2470)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TextLengthClauseContext: ParserRuleContext {
			open
			func TEXT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TEXT.rawValue, 0)
			}
			open
			func LENGTH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LENGTH.rawValue, 0)
			}
			open
			func dataDescName() -> DataDescNameContext? {
				return getRuleContext(DataDescNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_textLengthClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterTextLengthClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitTextLengthClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitTextLengthClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitTextLengthClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func textLengthClause() throws -> TextLengthClauseContext {
		var _localctx: TextLengthClauseContext = TextLengthClauseContext(_ctx, getState())
		try enterRule(_localctx, 252, Cobol85Parser.RULE_textLengthClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2472)
		 	try match(Cobol85Parser.Tokens.TEXT.rawValue)
		 	setState(2473)
		 	try match(Cobol85Parser.Tokens.LENGTH.rawValue)
		 	setState(2475)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2474)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2477)
		 	try dataDescName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LocalStorageSectionContext: ParserRuleContext {
			open
			func LOCAL_STORAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOCAL_STORAGE.rawValue, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func DOT_FS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.DOT_FS.rawValue)
			}
			open
			func DOT_FS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, i)
			}
			open
			func LD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LD.rawValue, 0)
			}
			open
			func localName() -> LocalNameContext? {
				return getRuleContext(LocalNameContext.self, 0)
			}
			open
			func dataDescriptionEntry() -> [DataDescriptionEntryContext] {
				return getRuleContexts(DataDescriptionEntryContext.self)
			}
			open
			func dataDescriptionEntry(_ i: Int) -> DataDescriptionEntryContext? {
				return getRuleContext(DataDescriptionEntryContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_localStorageSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLocalStorageSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLocalStorageSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLocalStorageSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLocalStorageSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func localStorageSection() throws -> LocalStorageSectionContext {
		var _localctx: LocalStorageSectionContext = LocalStorageSectionContext(_ctx, getState())
		try enterRule(_localctx, 254, Cobol85Parser.RULE_localStorageSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2479)
		 	try match(Cobol85Parser.Tokens.LOCAL_STORAGE.rawValue)
		 	setState(2480)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(2481)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(2486)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2482)
		 		try match(Cobol85Parser.Tokens.LD.rawValue)
		 		setState(2483)
		 		try localName()
		 		setState(2484)
		 		try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		 	}

		 	setState(2491)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.EXECSQLLINE.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 552)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(2488)
		 		try dataDescriptionEntry()


		 		setState(2493)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenSectionContext: ParserRuleContext {
			open
			func SCREEN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SCREEN.rawValue, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func screenDescriptionEntry() -> [ScreenDescriptionEntryContext] {
				return getRuleContexts(ScreenDescriptionEntryContext.self)
			}
			open
			func screenDescriptionEntry(_ i: Int) -> ScreenDescriptionEntryContext? {
				return getRuleContext(ScreenDescriptionEntryContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenSection() throws -> ScreenSectionContext {
		var _localctx: ScreenSectionContext = ScreenSectionContext(_ctx, getState())
		try enterRule(_localctx, 256, Cobol85Parser.RULE_screenSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2494)
		 	try match(Cobol85Parser.Tokens.SCREEN.rawValue)
		 	setState(2495)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(2496)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(2500)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.INTEGERLITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2497)
		 		try screenDescriptionEntry()


		 		setState(2502)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionEntryContext: ParserRuleContext {
			open
			func INTEGERLITERAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTEGERLITERAL.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func FILLER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FILLER.rawValue, 0)
			}
			open
			func screenName() -> ScreenNameContext? {
				return getRuleContext(ScreenNameContext.self, 0)
			}
			open
			func screenDescriptionBlankClause() -> [ScreenDescriptionBlankClauseContext] {
				return getRuleContexts(ScreenDescriptionBlankClauseContext.self)
			}
			open
			func screenDescriptionBlankClause(_ i: Int) -> ScreenDescriptionBlankClauseContext? {
				return getRuleContext(ScreenDescriptionBlankClauseContext.self, i)
			}
			open
			func screenDescriptionBellClause() -> [ScreenDescriptionBellClauseContext] {
				return getRuleContexts(ScreenDescriptionBellClauseContext.self)
			}
			open
			func screenDescriptionBellClause(_ i: Int) -> ScreenDescriptionBellClauseContext? {
				return getRuleContext(ScreenDescriptionBellClauseContext.self, i)
			}
			open
			func screenDescriptionBlinkClause() -> [ScreenDescriptionBlinkClauseContext] {
				return getRuleContexts(ScreenDescriptionBlinkClauseContext.self)
			}
			open
			func screenDescriptionBlinkClause(_ i: Int) -> ScreenDescriptionBlinkClauseContext? {
				return getRuleContext(ScreenDescriptionBlinkClauseContext.self, i)
			}
			open
			func screenDescriptionEraseClause() -> [ScreenDescriptionEraseClauseContext] {
				return getRuleContexts(ScreenDescriptionEraseClauseContext.self)
			}
			open
			func screenDescriptionEraseClause(_ i: Int) -> ScreenDescriptionEraseClauseContext? {
				return getRuleContext(ScreenDescriptionEraseClauseContext.self, i)
			}
			open
			func screenDescriptionLightClause() -> [ScreenDescriptionLightClauseContext] {
				return getRuleContexts(ScreenDescriptionLightClauseContext.self)
			}
			open
			func screenDescriptionLightClause(_ i: Int) -> ScreenDescriptionLightClauseContext? {
				return getRuleContext(ScreenDescriptionLightClauseContext.self, i)
			}
			open
			func screenDescriptionGridClause() -> [ScreenDescriptionGridClauseContext] {
				return getRuleContexts(ScreenDescriptionGridClauseContext.self)
			}
			open
			func screenDescriptionGridClause(_ i: Int) -> ScreenDescriptionGridClauseContext? {
				return getRuleContext(ScreenDescriptionGridClauseContext.self, i)
			}
			open
			func screenDescriptionReverseVideoClause() -> [ScreenDescriptionReverseVideoClauseContext] {
				return getRuleContexts(ScreenDescriptionReverseVideoClauseContext.self)
			}
			open
			func screenDescriptionReverseVideoClause(_ i: Int) -> ScreenDescriptionReverseVideoClauseContext? {
				return getRuleContext(ScreenDescriptionReverseVideoClauseContext.self, i)
			}
			open
			func screenDescriptionUnderlineClause() -> [ScreenDescriptionUnderlineClauseContext] {
				return getRuleContexts(ScreenDescriptionUnderlineClauseContext.self)
			}
			open
			func screenDescriptionUnderlineClause(_ i: Int) -> ScreenDescriptionUnderlineClauseContext? {
				return getRuleContext(ScreenDescriptionUnderlineClauseContext.self, i)
			}
			open
			func screenDescriptionSizeClause() -> [ScreenDescriptionSizeClauseContext] {
				return getRuleContexts(ScreenDescriptionSizeClauseContext.self)
			}
			open
			func screenDescriptionSizeClause(_ i: Int) -> ScreenDescriptionSizeClauseContext? {
				return getRuleContext(ScreenDescriptionSizeClauseContext.self, i)
			}
			open
			func screenDescriptionLineClause() -> [ScreenDescriptionLineClauseContext] {
				return getRuleContexts(ScreenDescriptionLineClauseContext.self)
			}
			open
			func screenDescriptionLineClause(_ i: Int) -> ScreenDescriptionLineClauseContext? {
				return getRuleContext(ScreenDescriptionLineClauseContext.self, i)
			}
			open
			func screenDescriptionColumnClause() -> [ScreenDescriptionColumnClauseContext] {
				return getRuleContexts(ScreenDescriptionColumnClauseContext.self)
			}
			open
			func screenDescriptionColumnClause(_ i: Int) -> ScreenDescriptionColumnClauseContext? {
				return getRuleContext(ScreenDescriptionColumnClauseContext.self, i)
			}
			open
			func screenDescriptionForegroundColorClause() -> [ScreenDescriptionForegroundColorClauseContext] {
				return getRuleContexts(ScreenDescriptionForegroundColorClauseContext.self)
			}
			open
			func screenDescriptionForegroundColorClause(_ i: Int) -> ScreenDescriptionForegroundColorClauseContext? {
				return getRuleContext(ScreenDescriptionForegroundColorClauseContext.self, i)
			}
			open
			func screenDescriptionBackgroundColorClause() -> [ScreenDescriptionBackgroundColorClauseContext] {
				return getRuleContexts(ScreenDescriptionBackgroundColorClauseContext.self)
			}
			open
			func screenDescriptionBackgroundColorClause(_ i: Int) -> ScreenDescriptionBackgroundColorClauseContext? {
				return getRuleContext(ScreenDescriptionBackgroundColorClauseContext.self, i)
			}
			open
			func screenDescriptionControlClause() -> [ScreenDescriptionControlClauseContext] {
				return getRuleContexts(ScreenDescriptionControlClauseContext.self)
			}
			open
			func screenDescriptionControlClause(_ i: Int) -> ScreenDescriptionControlClauseContext? {
				return getRuleContext(ScreenDescriptionControlClauseContext.self, i)
			}
			open
			func screenDescriptionValueClause() -> [ScreenDescriptionValueClauseContext] {
				return getRuleContexts(ScreenDescriptionValueClauseContext.self)
			}
			open
			func screenDescriptionValueClause(_ i: Int) -> ScreenDescriptionValueClauseContext? {
				return getRuleContext(ScreenDescriptionValueClauseContext.self, i)
			}
			open
			func screenDescriptionPictureClause() -> [ScreenDescriptionPictureClauseContext] {
				return getRuleContexts(ScreenDescriptionPictureClauseContext.self)
			}
			open
			func screenDescriptionPictureClause(_ i: Int) -> ScreenDescriptionPictureClauseContext? {
				return getRuleContext(ScreenDescriptionPictureClauseContext.self, i)
			}
			open
			func screenDescriptionUsageClause() -> [ScreenDescriptionUsageClauseContext] {
				return getRuleContexts(ScreenDescriptionUsageClauseContext.self)
			}
			open
			func screenDescriptionUsageClause(_ i: Int) -> ScreenDescriptionUsageClauseContext? {
				return getRuleContext(ScreenDescriptionUsageClauseContext.self, i)
			}
			open
			func screenDescriptionBlankWhenZeroClause() -> [ScreenDescriptionBlankWhenZeroClauseContext] {
				return getRuleContexts(ScreenDescriptionBlankWhenZeroClauseContext.self)
			}
			open
			func screenDescriptionBlankWhenZeroClause(_ i: Int) -> ScreenDescriptionBlankWhenZeroClauseContext? {
				return getRuleContext(ScreenDescriptionBlankWhenZeroClauseContext.self, i)
			}
			open
			func screenDescriptionJustifiedClause() -> [ScreenDescriptionJustifiedClauseContext] {
				return getRuleContexts(ScreenDescriptionJustifiedClauseContext.self)
			}
			open
			func screenDescriptionJustifiedClause(_ i: Int) -> ScreenDescriptionJustifiedClauseContext? {
				return getRuleContext(ScreenDescriptionJustifiedClauseContext.self, i)
			}
			open
			func screenDescriptionSignClause() -> [ScreenDescriptionSignClauseContext] {
				return getRuleContexts(ScreenDescriptionSignClauseContext.self)
			}
			open
			func screenDescriptionSignClause(_ i: Int) -> ScreenDescriptionSignClauseContext? {
				return getRuleContext(ScreenDescriptionSignClauseContext.self, i)
			}
			open
			func screenDescriptionAutoClause() -> [ScreenDescriptionAutoClauseContext] {
				return getRuleContexts(ScreenDescriptionAutoClauseContext.self)
			}
			open
			func screenDescriptionAutoClause(_ i: Int) -> ScreenDescriptionAutoClauseContext? {
				return getRuleContext(ScreenDescriptionAutoClauseContext.self, i)
			}
			open
			func screenDescriptionSecureClause() -> [ScreenDescriptionSecureClauseContext] {
				return getRuleContexts(ScreenDescriptionSecureClauseContext.self)
			}
			open
			func screenDescriptionSecureClause(_ i: Int) -> ScreenDescriptionSecureClauseContext? {
				return getRuleContext(ScreenDescriptionSecureClauseContext.self, i)
			}
			open
			func screenDescriptionRequiredClause() -> [ScreenDescriptionRequiredClauseContext] {
				return getRuleContexts(ScreenDescriptionRequiredClauseContext.self)
			}
			open
			func screenDescriptionRequiredClause(_ i: Int) -> ScreenDescriptionRequiredClauseContext? {
				return getRuleContext(ScreenDescriptionRequiredClauseContext.self, i)
			}
			open
			func screenDescriptionPromptClause() -> [ScreenDescriptionPromptClauseContext] {
				return getRuleContexts(ScreenDescriptionPromptClauseContext.self)
			}
			open
			func screenDescriptionPromptClause(_ i: Int) -> ScreenDescriptionPromptClauseContext? {
				return getRuleContext(ScreenDescriptionPromptClauseContext.self, i)
			}
			open
			func screenDescriptionFullClause() -> [ScreenDescriptionFullClauseContext] {
				return getRuleContexts(ScreenDescriptionFullClauseContext.self)
			}
			open
			func screenDescriptionFullClause(_ i: Int) -> ScreenDescriptionFullClauseContext? {
				return getRuleContext(ScreenDescriptionFullClauseContext.self, i)
			}
			open
			func screenDescriptionZeroFillClause() -> [ScreenDescriptionZeroFillClauseContext] {
				return getRuleContexts(ScreenDescriptionZeroFillClauseContext.self)
			}
			open
			func screenDescriptionZeroFillClause(_ i: Int) -> ScreenDescriptionZeroFillClauseContext? {
				return getRuleContext(ScreenDescriptionZeroFillClauseContext.self, i)
			}
			open
			func screenDescriptionFromClause() -> [ScreenDescriptionFromClauseContext] {
				return getRuleContexts(ScreenDescriptionFromClauseContext.self)
			}
			open
			func screenDescriptionFromClause(_ i: Int) -> ScreenDescriptionFromClauseContext? {
				return getRuleContext(ScreenDescriptionFromClauseContext.self, i)
			}
			open
			func screenDescriptionUsingClause() -> [ScreenDescriptionUsingClauseContext] {
				return getRuleContexts(ScreenDescriptionUsingClauseContext.self)
			}
			open
			func screenDescriptionUsingClause(_ i: Int) -> ScreenDescriptionUsingClauseContext? {
				return getRuleContext(ScreenDescriptionUsingClauseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionEntry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionEntry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionEntry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionEntry(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionEntry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionEntry() throws -> ScreenDescriptionEntryContext {
		var _localctx: ScreenDescriptionEntryContext = ScreenDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 258, Cobol85Parser.RULE_screenDescriptionEntry)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2503)
		 	try match(Cobol85Parser.Tokens.INTEGERLITERAL.rawValue)
		 	setState(2506)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,266,_ctx)) {
		 	case 1:
		 		setState(2504)
		 		try match(Cobol85Parser.Tokens.FILLER.rawValue)

		 		break
		 	case 2:
		 		setState(2505)
		 		try screenName()

		 		break
		 	default: break
		 	}
		 	setState(2540)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BLANK.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.COL.rawValue,Cobol85Parser.Tokens.COLUMN.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 33)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.CONTROL.rawValue || _la == Cobol85Parser.Tokens.EMPTY_CHECK.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FROM.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 187)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.JUST.rawValue,Cobol85Parser.Tokens.JUSTIFIED.rawValue,Cobol85Parser.Tokens.LEADING.rawValue,Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LINE.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 255)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.PIC.rawValue,Cobol85Parser.Tokens.PICTURE.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SIGN.rawValue,Cobol85Parser.Tokens.SIZE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.TRAILING.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.USAGE.rawValue,Cobol85Parser.Tokens.USING.rawValue,Cobol85Parser.Tokens.VALUE.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 493)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2538)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,268, _ctx)) {
		 		case 1:
		 			setState(2508)
		 			try screenDescriptionBlankClause()

		 			break
		 		case 2:
		 			setState(2509)
		 			try screenDescriptionBellClause()

		 			break
		 		case 3:
		 			setState(2510)
		 			try screenDescriptionBlinkClause()

		 			break
		 		case 4:
		 			setState(2511)
		 			try screenDescriptionEraseClause()

		 			break
		 		case 5:
		 			setState(2512)
		 			try screenDescriptionLightClause()

		 			break
		 		case 6:
		 			setState(2513)
		 			try screenDescriptionGridClause()

		 			break
		 		case 7:
		 			setState(2514)
		 			try screenDescriptionReverseVideoClause()

		 			break
		 		case 8:
		 			setState(2515)
		 			try screenDescriptionUnderlineClause()

		 			break
		 		case 9:
		 			setState(2516)
		 			try screenDescriptionSizeClause()

		 			break
		 		case 10:
		 			setState(2517)
		 			try screenDescriptionLineClause()

		 			break
		 		case 11:
		 			setState(2518)
		 			try screenDescriptionColumnClause()

		 			break
		 		case 12:
		 			setState(2519)
		 			try screenDescriptionForegroundColorClause()

		 			break
		 		case 13:
		 			setState(2520)
		 			try screenDescriptionBackgroundColorClause()

		 			break
		 		case 14:
		 			setState(2521)
		 			try screenDescriptionControlClause()

		 			break
		 		case 15:
		 			setState(2522)
		 			try screenDescriptionValueClause()

		 			break
		 		case 16:
		 			setState(2523)
		 			try screenDescriptionPictureClause()

		 			break
		 		case 17:
		 			setState(2526)
		 			try _errHandler.sync(self)
		 			switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .FROM:
		 				setState(2524)
		 				try screenDescriptionFromClause()

		 				break

		 			case .USING:
		 				setState(2525)
		 				try screenDescriptionUsingClause()

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			break
		 		case 18:
		 			setState(2528)
		 			try screenDescriptionUsageClause()

		 			break
		 		case 19:
		 			setState(2529)
		 			try screenDescriptionBlankWhenZeroClause()

		 			break
		 		case 20:
		 			setState(2530)
		 			try screenDescriptionJustifiedClause()

		 			break
		 		case 21:
		 			setState(2531)
		 			try screenDescriptionSignClause()

		 			break
		 		case 22:
		 			setState(2532)
		 			try screenDescriptionAutoClause()

		 			break
		 		case 23:
		 			setState(2533)
		 			try screenDescriptionSecureClause()

		 			break
		 		case 24:
		 			setState(2534)
		 			try screenDescriptionRequiredClause()

		 			break
		 		case 25:
		 			setState(2535)
		 			try screenDescriptionPromptClause()

		 			break
		 		case 26:
		 			setState(2536)
		 			try screenDescriptionFullClause()

		 			break
		 		case 27:
		 			setState(2537)
		 			try screenDescriptionZeroFillClause()

		 			break
		 		default: break
		 		}

		 		setState(2542)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2543)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionBlankClauseContext: ParserRuleContext {
			open
			func BLANK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BLANK.rawValue, 0)
			}
			open
			func SCREEN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SCREEN.rawValue, 0)
			}
			open
			func LINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionBlankClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionBlankClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionBlankClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionBlankClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionBlankClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionBlankClause() throws -> ScreenDescriptionBlankClauseContext {
		var _localctx: ScreenDescriptionBlankClauseContext = ScreenDescriptionBlankClauseContext(_ctx, getState())
		try enterRule(_localctx, 260, Cobol85Parser.RULE_screenDescriptionBlankClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2545)
		 	try match(Cobol85Parser.Tokens.BLANK.rawValue)
		 	setState(2546)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.LINE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.SCREEN.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionBellClauseContext: ParserRuleContext {
			open
			func BELL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BELL.rawValue, 0)
			}
			open
			func BEEP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BEEP.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionBellClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionBellClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionBellClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionBellClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionBellClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionBellClause() throws -> ScreenDescriptionBellClauseContext {
		var _localctx: ScreenDescriptionBellClauseContext = ScreenDescriptionBellClauseContext(_ctx, getState())
		try enterRule(_localctx, 262, Cobol85Parser.RULE_screenDescriptionBellClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2548)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.BEEP.rawValue || _la == Cobol85Parser.Tokens.BELL.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionBlinkClauseContext: ParserRuleContext {
			open
			func BLINK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BLINK.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionBlinkClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionBlinkClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionBlinkClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionBlinkClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionBlinkClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionBlinkClause() throws -> ScreenDescriptionBlinkClauseContext {
		var _localctx: ScreenDescriptionBlinkClauseContext = ScreenDescriptionBlinkClauseContext(_ctx, getState())
		try enterRule(_localctx, 264, Cobol85Parser.RULE_screenDescriptionBlinkClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2550)
		 	try match(Cobol85Parser.Tokens.BLINK.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionEraseClauseContext: ParserRuleContext {
			open
			func ERASE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ERASE.rawValue, 0)
			}
			open
			func EOL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EOL.rawValue, 0)
			}
			open
			func EOS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EOS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionEraseClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionEraseClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionEraseClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionEraseClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionEraseClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionEraseClause() throws -> ScreenDescriptionEraseClauseContext {
		var _localctx: ScreenDescriptionEraseClauseContext = ScreenDescriptionEraseClauseContext(_ctx, getState())
		try enterRule(_localctx, 266, Cobol85Parser.RULE_screenDescriptionEraseClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2552)
		 	try match(Cobol85Parser.Tokens.ERASE.rawValue)
		 	setState(2553)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.EOL.rawValue || _la == Cobol85Parser.Tokens.EOS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionLightClauseContext: ParserRuleContext {
			open
			func HIGHLIGHT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.HIGHLIGHT.rawValue, 0)
			}
			open
			func LOWLIGHT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOWLIGHT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionLightClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionLightClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionLightClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionLightClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionLightClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionLightClause() throws -> ScreenDescriptionLightClauseContext {
		var _localctx: ScreenDescriptionLightClauseContext = ScreenDescriptionLightClauseContext(_ctx, getState())
		try enterRule(_localctx, 268, Cobol85Parser.RULE_screenDescriptionLightClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2555)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.HIGHLIGHT.rawValue || _la == Cobol85Parser.Tokens.LOWLIGHT.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionGridClauseContext: ParserRuleContext {
			open
			func GRID() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GRID.rawValue, 0)
			}
			open
			func LEFTLINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEFTLINE.rawValue, 0)
			}
			open
			func OVERLINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OVERLINE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionGridClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionGridClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionGridClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionGridClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionGridClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionGridClause() throws -> ScreenDescriptionGridClauseContext {
		var _localctx: ScreenDescriptionGridClauseContext = ScreenDescriptionGridClauseContext(_ctx, getState())
		try enterRule(_localctx, 270, Cobol85Parser.RULE_screenDescriptionGridClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2557)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.GRID.rawValue || _la == Cobol85Parser.Tokens.LEFTLINE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.OVERLINE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionReverseVideoClauseContext: ParserRuleContext {
			open
			func REVERSE_VIDEO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionReverseVideoClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionReverseVideoClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionReverseVideoClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionReverseVideoClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionReverseVideoClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionReverseVideoClause() throws -> ScreenDescriptionReverseVideoClauseContext {
		var _localctx: ScreenDescriptionReverseVideoClauseContext = ScreenDescriptionReverseVideoClauseContext(_ctx, getState())
		try enterRule(_localctx, 272, Cobol85Parser.RULE_screenDescriptionReverseVideoClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2559)
		 	try match(Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionUnderlineClauseContext: ParserRuleContext {
			open
			func UNDERLINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.UNDERLINE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionUnderlineClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionUnderlineClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionUnderlineClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionUnderlineClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionUnderlineClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionUnderlineClause() throws -> ScreenDescriptionUnderlineClauseContext {
		var _localctx: ScreenDescriptionUnderlineClauseContext = ScreenDescriptionUnderlineClauseContext(_ctx, getState())
		try enterRule(_localctx, 274, Cobol85Parser.RULE_screenDescriptionUnderlineClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2561)
		 	try match(Cobol85Parser.Tokens.UNDERLINE.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionSizeClauseContext: ParserRuleContext {
			open
			func SIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIZE.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionSizeClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionSizeClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionSizeClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionSizeClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionSizeClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionSizeClause() throws -> ScreenDescriptionSizeClauseContext {
		var _localctx: ScreenDescriptionSizeClauseContext = ScreenDescriptionSizeClauseContext(_ctx, getState())
		try enterRule(_localctx, 276, Cobol85Parser.RULE_screenDescriptionSizeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2563)
		 	try match(Cobol85Parser.Tokens.SIZE.rawValue)
		 	setState(2565)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2564)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2569)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,271, _ctx)) {
		 	case 1:
		 		setState(2567)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2568)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionLineClauseContext: ParserRuleContext {
			open
			func LINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINE.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func PLUS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PLUS.rawValue, 0)
			}
			open
			func PLUSCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PLUSCHAR.rawValue, 0)
			}
			open
			func MINUSCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MINUSCHAR.rawValue, 0)
			}
			open
			func NUMBER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMBER.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionLineClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionLineClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionLineClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionLineClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionLineClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionLineClause() throws -> ScreenDescriptionLineClauseContext {
		var _localctx: ScreenDescriptionLineClauseContext = ScreenDescriptionLineClauseContext(_ctx, getState())
		try enterRule(_localctx, 278, Cobol85Parser.RULE_screenDescriptionLineClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2571)
		 	try match(Cobol85Parser.Tokens.LINE.rawValue)
		 	setState(2579)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue || _la == Cobol85Parser.Tokens.NUMBER.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.PLUS.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.MINUSCHAR.rawValue || _la == Cobol85Parser.Tokens.PLUSCHAR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2573)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.NUMBER.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2572)
		 			try match(Cobol85Parser.Tokens.NUMBER.rawValue)

		 		}

		 		setState(2576)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2575)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}

		 		setState(2578)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.PLUS.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.MINUSCHAR.rawValue || _la == Cobol85Parser.Tokens.PLUSCHAR.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(2583)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,275, _ctx)) {
		 	case 1:
		 		setState(2581)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2582)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionColumnClauseContext: ParserRuleContext {
			open
			func COLUMN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COLUMN.rawValue, 0)
			}
			open
			func COL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COL.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func PLUS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PLUS.rawValue, 0)
			}
			open
			func PLUSCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PLUSCHAR.rawValue, 0)
			}
			open
			func MINUSCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MINUSCHAR.rawValue, 0)
			}
			open
			func NUMBER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMBER.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionColumnClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionColumnClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionColumnClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionColumnClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionColumnClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionColumnClause() throws -> ScreenDescriptionColumnClauseContext {
		var _localctx: ScreenDescriptionColumnClauseContext = ScreenDescriptionColumnClauseContext(_ctx, getState())
		try enterRule(_localctx, 280, Cobol85Parser.RULE_screenDescriptionColumnClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2585)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COL.rawValue || _la == Cobol85Parser.Tokens.COLUMN.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2593)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue || _la == Cobol85Parser.Tokens.NUMBER.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.PLUS.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.MINUSCHAR.rawValue || _la == Cobol85Parser.Tokens.PLUSCHAR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2587)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.NUMBER.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2586)
		 			try match(Cobol85Parser.Tokens.NUMBER.rawValue)

		 		}

		 		setState(2590)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2589)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}

		 		setState(2592)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.PLUS.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.MINUSCHAR.rawValue || _la == Cobol85Parser.Tokens.PLUSCHAR.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(2597)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,279, _ctx)) {
		 	case 1:
		 		setState(2595)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2596)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionForegroundColorClauseContext: ParserRuleContext {
			open
			func FOREGROUND_COLOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue, 0)
			}
			open
			func FOREGROUND_COLOUR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionForegroundColorClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionForegroundColorClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionForegroundColorClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionForegroundColorClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionForegroundColorClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionForegroundColorClause() throws -> ScreenDescriptionForegroundColorClauseContext {
		var _localctx: ScreenDescriptionForegroundColorClauseContext = ScreenDescriptionForegroundColorClauseContext(_ctx, getState())
		try enterRule(_localctx, 282, Cobol85Parser.RULE_screenDescriptionForegroundColorClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2599)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue || _la == Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2601)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2600)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2605)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,281, _ctx)) {
		 	case 1:
		 		setState(2603)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2604)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionBackgroundColorClauseContext: ParserRuleContext {
			open
			func BACKGROUND_COLOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue, 0)
			}
			open
			func BACKGROUND_COLOUR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionBackgroundColorClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionBackgroundColorClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionBackgroundColorClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionBackgroundColorClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionBackgroundColorClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionBackgroundColorClause() throws -> ScreenDescriptionBackgroundColorClauseContext {
		var _localctx: ScreenDescriptionBackgroundColorClauseContext = ScreenDescriptionBackgroundColorClauseContext(_ctx, getState())
		try enterRule(_localctx, 284, Cobol85Parser.RULE_screenDescriptionBackgroundColorClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2607)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue || _la == Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2609)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2608)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2613)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,283, _ctx)) {
		 	case 1:
		 		setState(2611)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2612)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionControlClauseContext: ParserRuleContext {
			open
			func CONTROL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTROL.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionControlClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionControlClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionControlClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionControlClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionControlClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionControlClause() throws -> ScreenDescriptionControlClauseContext {
		var _localctx: ScreenDescriptionControlClauseContext = ScreenDescriptionControlClauseContext(_ctx, getState())
		try enterRule(_localctx, 286, Cobol85Parser.RULE_screenDescriptionControlClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2615)
		 	try match(Cobol85Parser.Tokens.CONTROL.rawValue)
		 	setState(2617)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2616)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2619)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionValueClauseContext: ParserRuleContext {
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func VALUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VALUE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionValueClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionValueClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionValueClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionValueClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionValueClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionValueClause() throws -> ScreenDescriptionValueClauseContext {
		var _localctx: ScreenDescriptionValueClauseContext = ScreenDescriptionValueClauseContext(_ctx, getState())
		try enterRule(_localctx, 288, Cobol85Parser.RULE_screenDescriptionValueClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2621)
		 	try match(Cobol85Parser.Tokens.VALUE.rawValue)
		 	setState(2623)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2622)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}


		 	setState(2625)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionPictureClauseContext: ParserRuleContext {
			open
			func pictureString() -> PictureStringContext? {
				return getRuleContext(PictureStringContext.self, 0)
			}
			open
			func PICTURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PICTURE.rawValue, 0)
			}
			open
			func PIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PIC.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionPictureClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionPictureClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionPictureClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionPictureClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionPictureClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionPictureClause() throws -> ScreenDescriptionPictureClauseContext {
		var _localctx: ScreenDescriptionPictureClauseContext = ScreenDescriptionPictureClauseContext(_ctx, getState())
		try enterRule(_localctx, 290, Cobol85Parser.RULE_screenDescriptionPictureClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2627)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.PIC.rawValue || _la == Cobol85Parser.Tokens.PICTURE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2629)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2628)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2631)
		 	try pictureString()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionFromClauseContext: ParserRuleContext {
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func screenDescriptionToClause() -> ScreenDescriptionToClauseContext? {
				return getRuleContext(ScreenDescriptionToClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionFromClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionFromClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionFromClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionFromClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionFromClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionFromClause() throws -> ScreenDescriptionFromClauseContext {
		var _localctx: ScreenDescriptionFromClauseContext = ScreenDescriptionFromClauseContext(_ctx, getState())
		try enterRule(_localctx, 292, Cobol85Parser.RULE_screenDescriptionFromClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2633)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(2636)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,287, _ctx)) {
		 	case 1:
		 		setState(2634)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2635)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(2639)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2638)
		 		try screenDescriptionToClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionToClauseContext: ParserRuleContext {
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionToClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionToClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionToClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionToClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionToClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionToClause() throws -> ScreenDescriptionToClauseContext {
		var _localctx: ScreenDescriptionToClauseContext = ScreenDescriptionToClauseContext(_ctx, getState())
		try enterRule(_localctx, 294, Cobol85Parser.RULE_screenDescriptionToClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2641)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(2642)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionUsingClauseContext: ParserRuleContext {
			open
			func USING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USING.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionUsingClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionUsingClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionUsingClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionUsingClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionUsingClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionUsingClause() throws -> ScreenDescriptionUsingClauseContext {
		var _localctx: ScreenDescriptionUsingClauseContext = ScreenDescriptionUsingClauseContext(_ctx, getState())
		try enterRule(_localctx, 296, Cobol85Parser.RULE_screenDescriptionUsingClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2644)
		 	try match(Cobol85Parser.Tokens.USING.rawValue)
		 	setState(2645)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionUsageClauseContext: ParserRuleContext {
			open
			func DISPLAY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISPLAY.rawValue, 0)
			}
			open
			func DISPLAY_1() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISPLAY_1.rawValue, 0)
			}
			open
			func USAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USAGE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionUsageClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionUsageClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionUsageClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionUsageClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionUsageClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionUsageClause() throws -> ScreenDescriptionUsageClauseContext {
		var _localctx: ScreenDescriptionUsageClauseContext = ScreenDescriptionUsageClauseContext(_ctx, getState())
		try enterRule(_localctx, 298, Cobol85Parser.RULE_screenDescriptionUsageClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2647)
		 	try match(Cobol85Parser.Tokens.USAGE.rawValue)
		 	setState(2649)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2648)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}


		 	setState(2651)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DISPLAY.rawValue || _la == Cobol85Parser.Tokens.DISPLAY_1.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionBlankWhenZeroClauseContext: ParserRuleContext {
			open
			func BLANK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BLANK.rawValue, 0)
			}
			open
			func ZERO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZERO.rawValue, 0)
			}
			open
			func WHEN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WHEN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionBlankWhenZeroClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionBlankWhenZeroClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionBlankWhenZeroClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionBlankWhenZeroClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionBlankWhenZeroClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionBlankWhenZeroClause() throws -> ScreenDescriptionBlankWhenZeroClauseContext {
		var _localctx: ScreenDescriptionBlankWhenZeroClauseContext = ScreenDescriptionBlankWhenZeroClauseContext(_ctx, getState())
		try enterRule(_localctx, 300, Cobol85Parser.RULE_screenDescriptionBlankWhenZeroClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2653)
		 	try match(Cobol85Parser.Tokens.BLANK.rawValue)
		 	setState(2655)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WHEN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2654)
		 		try match(Cobol85Parser.Tokens.WHEN.rawValue)

		 	}

		 	setState(2657)
		 	try match(Cobol85Parser.Tokens.ZERO.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionJustifiedClauseContext: ParserRuleContext {
			open
			func JUSTIFIED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.JUSTIFIED.rawValue, 0)
			}
			open
			func JUST() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.JUST.rawValue, 0)
			}
			open
			func RIGHT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RIGHT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionJustifiedClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionJustifiedClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionJustifiedClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionJustifiedClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionJustifiedClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionJustifiedClause() throws -> ScreenDescriptionJustifiedClauseContext {
		var _localctx: ScreenDescriptionJustifiedClauseContext = ScreenDescriptionJustifiedClauseContext(_ctx, getState())
		try enterRule(_localctx, 302, Cobol85Parser.RULE_screenDescriptionJustifiedClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2659)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.JUST.rawValue || _la == Cobol85Parser.Tokens.JUSTIFIED.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2661)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.RIGHT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2660)
		 		try match(Cobol85Parser.Tokens.RIGHT.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionSignClauseContext: ParserRuleContext {
			open
			func LEADING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEADING.rawValue, 0)
			}
			open
			func TRAILING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TRAILING.rawValue, 0)
			}
			open
			func SIGN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIGN.rawValue, 0)
			}
			open
			func SEPARATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEPARATE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionSignClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionSignClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionSignClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionSignClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionSignClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionSignClause() throws -> ScreenDescriptionSignClauseContext {
		var _localctx: ScreenDescriptionSignClauseContext = ScreenDescriptionSignClauseContext(_ctx, getState())
		try enterRule(_localctx, 304, Cobol85Parser.RULE_screenDescriptionSignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2667)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SIGN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2663)
		 		try match(Cobol85Parser.Tokens.SIGN.rawValue)
		 		setState(2665)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2664)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}


		 	}

		 	setState(2669)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.LEADING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.TRAILING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2674)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SEPARATE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2670)
		 		try match(Cobol85Parser.Tokens.SEPARATE.rawValue)
		 		setState(2672)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTER.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2671)
		 			try match(Cobol85Parser.Tokens.CHARACTER.rawValue)

		 		}


		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionAutoClauseContext: ParserRuleContext {
			open
			func AUTO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AUTO.rawValue, 0)
			}
			open
			func AUTO_SKIP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AUTO_SKIP.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionAutoClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionAutoClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionAutoClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionAutoClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionAutoClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionAutoClause() throws -> ScreenDescriptionAutoClauseContext {
		var _localctx: ScreenDescriptionAutoClauseContext = ScreenDescriptionAutoClauseContext(_ctx, getState())
		try enterRule(_localctx, 306, Cobol85Parser.RULE_screenDescriptionAutoClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2676)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AUTO.rawValue || _la == Cobol85Parser.Tokens.AUTO_SKIP.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionSecureClauseContext: ParserRuleContext {
			open
			func SECURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECURE.rawValue, 0)
			}
			open
			func NO_ECHO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO_ECHO.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionSecureClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionSecureClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionSecureClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionSecureClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionSecureClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionSecureClause() throws -> ScreenDescriptionSecureClauseContext {
		var _localctx: ScreenDescriptionSecureClauseContext = ScreenDescriptionSecureClauseContext(_ctx, getState())
		try enterRule(_localctx, 308, Cobol85Parser.RULE_screenDescriptionSecureClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2678)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.NO_ECHO.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.SECURE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionRequiredClauseContext: ParserRuleContext {
			open
			func REQUIRED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REQUIRED.rawValue, 0)
			}
			open
			func EMPTY_CHECK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EMPTY_CHECK.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionRequiredClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionRequiredClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionRequiredClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionRequiredClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionRequiredClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionRequiredClause() throws -> ScreenDescriptionRequiredClauseContext {
		var _localctx: ScreenDescriptionRequiredClauseContext = ScreenDescriptionRequiredClauseContext(_ctx, getState())
		try enterRule(_localctx, 310, Cobol85Parser.RULE_screenDescriptionRequiredClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2680)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.EMPTY_CHECK.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.REQUIRED.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionPromptClauseContext: ParserRuleContext {
			open
			func PROMPT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROMPT.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func screenDescriptionPromptOccursClause() -> ScreenDescriptionPromptOccursClauseContext? {
				return getRuleContext(ScreenDescriptionPromptOccursClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionPromptClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionPromptClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionPromptClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionPromptClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionPromptClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionPromptClause() throws -> ScreenDescriptionPromptClauseContext {
		var _localctx: ScreenDescriptionPromptClauseContext = ScreenDescriptionPromptClauseContext(_ctx, getState())
		try enterRule(_localctx, 312, Cobol85Parser.RULE_screenDescriptionPromptClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2682)
		 	try match(Cobol85Parser.Tokens.PROMPT.rawValue)
		 	setState(2684)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2683)
		 		try match(Cobol85Parser.Tokens.CHARACTER.rawValue)

		 	}

		 	setState(2687)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2686)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2691)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,298, _ctx)) {
		 	case 1:
		 		setState(2689)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(2690)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(2694)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.OCCURS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2693)
		 		try screenDescriptionPromptOccursClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionPromptOccursClauseContext: ParserRuleContext {
			open
			func OCCURS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OCCURS.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func TIMES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TIMES.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionPromptOccursClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionPromptOccursClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionPromptOccursClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionPromptOccursClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionPromptOccursClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionPromptOccursClause() throws -> ScreenDescriptionPromptOccursClauseContext {
		var _localctx: ScreenDescriptionPromptOccursClauseContext = ScreenDescriptionPromptOccursClauseContext(_ctx, getState())
		try enterRule(_localctx, 314, Cobol85Parser.RULE_screenDescriptionPromptOccursClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2696)
		 	try match(Cobol85Parser.Tokens.OCCURS.rawValue)
		 	setState(2697)
		 	try integerLiteral()
		 	setState(2699)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TIMES.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2698)
		 		try match(Cobol85Parser.Tokens.TIMES.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionFullClauseContext: ParserRuleContext {
			open
			func FULL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FULL.rawValue, 0)
			}
			open
			func LENGTH_CHECK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LENGTH_CHECK.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionFullClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionFullClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionFullClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionFullClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionFullClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionFullClause() throws -> ScreenDescriptionFullClauseContext {
		var _localctx: ScreenDescriptionFullClauseContext = ScreenDescriptionFullClauseContext(_ctx, getState())
		try enterRule(_localctx, 316, Cobol85Parser.RULE_screenDescriptionFullClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2701)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FULL.rawValue || _la == Cobol85Parser.Tokens.LENGTH_CHECK.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenDescriptionZeroFillClauseContext: ParserRuleContext {
			open
			func ZERO_FILL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZERO_FILL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenDescriptionZeroFillClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenDescriptionZeroFillClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenDescriptionZeroFillClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenDescriptionZeroFillClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenDescriptionZeroFillClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenDescriptionZeroFillClause() throws -> ScreenDescriptionZeroFillClauseContext {
		var _localctx: ScreenDescriptionZeroFillClauseContext = ScreenDescriptionZeroFillClauseContext(_ctx, getState())
		try enterRule(_localctx, 318, Cobol85Parser.RULE_screenDescriptionZeroFillClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2703)
		 	try match(Cobol85Parser.Tokens.ZERO_FILL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportSectionContext: ParserRuleContext {
			open
			func REPORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REPORT.rawValue, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func reportDescription() -> [ReportDescriptionContext] {
				return getRuleContexts(ReportDescriptionContext.self)
			}
			open
			func reportDescription(_ i: Int) -> ReportDescriptionContext? {
				return getRuleContext(ReportDescriptionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportSection() throws -> ReportSectionContext {
		var _localctx: ReportSectionContext = ReportSectionContext(_ctx, getState())
		try enterRule(_localctx, 320, Cobol85Parser.RULE_reportSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2705)
		 	try match(Cobol85Parser.Tokens.REPORT.rawValue)
		 	setState(2706)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(2707)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(2711)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.RD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2708)
		 		try reportDescription()


		 		setState(2713)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportDescriptionContext: ParserRuleContext {
			open
			func reportDescriptionEntry() -> ReportDescriptionEntryContext? {
				return getRuleContext(ReportDescriptionEntryContext.self, 0)
			}
			open
			func reportGroupDescriptionEntry() -> [ReportGroupDescriptionEntryContext] {
				return getRuleContexts(ReportGroupDescriptionEntryContext.self)
			}
			open
			func reportGroupDescriptionEntry(_ i: Int) -> ReportGroupDescriptionEntryContext? {
				return getRuleContext(ReportGroupDescriptionEntryContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportDescription
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportDescription(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportDescription(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportDescription(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportDescription(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportDescription() throws -> ReportDescriptionContext {
		var _localctx: ReportDescriptionContext = ReportDescriptionContext(_ctx, getState())
		try enterRule(_localctx, 322, Cobol85Parser.RULE_reportDescription)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2714)
		 	try reportDescriptionEntry()
		 	setState(2716) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(2715)
		 		try reportGroupDescriptionEntry()


		 		setState(2718); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 552)
		 	}()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportDescriptionEntryContext: ParserRuleContext {
			open
			func RD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RD.rawValue, 0)
			}
			open
			func reportName() -> ReportNameContext? {
				return getRuleContext(ReportNameContext.self, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func reportDescriptionGlobalClause() -> ReportDescriptionGlobalClauseContext? {
				return getRuleContext(ReportDescriptionGlobalClauseContext.self, 0)
			}
			open
			func reportDescriptionPageLimitClause() -> ReportDescriptionPageLimitClauseContext? {
				return getRuleContext(ReportDescriptionPageLimitClauseContext.self, 0)
			}
			open
			func reportDescriptionHeadingClause() -> ReportDescriptionHeadingClauseContext? {
				return getRuleContext(ReportDescriptionHeadingClauseContext.self, 0)
			}
			open
			func reportDescriptionFirstDetailClause() -> ReportDescriptionFirstDetailClauseContext? {
				return getRuleContext(ReportDescriptionFirstDetailClauseContext.self, 0)
			}
			open
			func reportDescriptionLastDetailClause() -> ReportDescriptionLastDetailClauseContext? {
				return getRuleContext(ReportDescriptionLastDetailClauseContext.self, 0)
			}
			open
			func reportDescriptionFootingClause() -> ReportDescriptionFootingClauseContext? {
				return getRuleContext(ReportDescriptionFootingClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportDescriptionEntry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportDescriptionEntry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportDescriptionEntry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportDescriptionEntry(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportDescriptionEntry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportDescriptionEntry() throws -> ReportDescriptionEntryContext {
		var _localctx: ReportDescriptionEntryContext = ReportDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 324, Cobol85Parser.RULE_reportDescriptionEntry)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2720)
		 	try match(Cobol85Parser.Tokens.RD.rawValue)
		 	setState(2721)
		 	try reportName()
		 	setState(2723)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.GLOBAL.rawValue || _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2722)
		 		try reportDescriptionGlobalClause()

		 	}

		 	setState(2738)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.PAGE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2725)
		 		try reportDescriptionPageLimitClause()
		 		setState(2727)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.HEADING.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2726)
		 			try reportDescriptionHeadingClause()

		 		}

		 		setState(2730)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.FIRST.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2729)
		 			try reportDescriptionFirstDetailClause()

		 		}

		 		setState(2733)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.LAST.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2732)
		 			try reportDescriptionLastDetailClause()

		 		}

		 		setState(2736)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.FOOTING.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2735)
		 			try reportDescriptionFootingClause()

		 		}


		 	}

		 	setState(2740)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportDescriptionGlobalClauseContext: ParserRuleContext {
			open
			func GLOBAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GLOBAL.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportDescriptionGlobalClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportDescriptionGlobalClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportDescriptionGlobalClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportDescriptionGlobalClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportDescriptionGlobalClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportDescriptionGlobalClause() throws -> ReportDescriptionGlobalClauseContext {
		var _localctx: ReportDescriptionGlobalClauseContext = ReportDescriptionGlobalClauseContext(_ctx, getState())
		try enterRule(_localctx, 326, Cobol85Parser.RULE_reportDescriptionGlobalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2743)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2742)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2745)
		 	try match(Cobol85Parser.Tokens.GLOBAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportDescriptionPageLimitClauseContext: ParserRuleContext {
			open
			func PAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PAGE.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func LIMIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LIMIT.rawValue, 0)
			}
			open
			func LIMITS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LIMITS.rawValue, 0)
			}
			open
			func LINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINE.rawValue, 0)
			}
			open
			func LINES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINES.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func ARE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ARE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportDescriptionPageLimitClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportDescriptionPageLimitClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportDescriptionPageLimitClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportDescriptionPageLimitClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportDescriptionPageLimitClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportDescriptionPageLimitClause() throws -> ReportDescriptionPageLimitClauseContext {
		var _localctx: ReportDescriptionPageLimitClauseContext = ReportDescriptionPageLimitClauseContext(_ctx, getState())
		try enterRule(_localctx, 328, Cobol85Parser.RULE_reportDescriptionPageLimitClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2747)
		 	try match(Cobol85Parser.Tokens.PAGE.rawValue)
		 	setState(2756)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LIMIT:
		 	 	setState(2748)
		 	 	try match(Cobol85Parser.Tokens.LIMIT.rawValue)
		 	 	setState(2750)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(2749)
		 	 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	 	}


		 		break

		 	case .LIMITS:
		 	 	setState(2752)
		 	 	try match(Cobol85Parser.Tokens.LIMITS.rawValue)
		 	 	setState(2754)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ARE.rawValue
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(2753)
		 	 		try match(Cobol85Parser.Tokens.ARE.rawValue)

		 	 	}


		 		break
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		break
		 	default:
		 		break
		 	}
		 	setState(2758)
		 	try integerLiteral()
		 	setState(2760)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LINE.rawValue || _la == Cobol85Parser.Tokens.LINES.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2759)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.LINE.rawValue || _la == Cobol85Parser.Tokens.LINES.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportDescriptionHeadingClauseContext: ParserRuleContext {
			open
			func HEADING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.HEADING.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportDescriptionHeadingClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportDescriptionHeadingClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportDescriptionHeadingClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportDescriptionHeadingClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportDescriptionHeadingClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportDescriptionHeadingClause() throws -> ReportDescriptionHeadingClauseContext {
		var _localctx: ReportDescriptionHeadingClauseContext = ReportDescriptionHeadingClauseContext(_ctx, getState())
		try enterRule(_localctx, 330, Cobol85Parser.RULE_reportDescriptionHeadingClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2762)
		 	try match(Cobol85Parser.Tokens.HEADING.rawValue)
		 	setState(2763)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportDescriptionFirstDetailClauseContext: ParserRuleContext {
			open
			func FIRST() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FIRST.rawValue, 0)
			}
			open
			func DETAIL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DETAIL.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportDescriptionFirstDetailClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportDescriptionFirstDetailClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportDescriptionFirstDetailClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportDescriptionFirstDetailClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportDescriptionFirstDetailClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportDescriptionFirstDetailClause() throws -> ReportDescriptionFirstDetailClauseContext {
		var _localctx: ReportDescriptionFirstDetailClauseContext = ReportDescriptionFirstDetailClauseContext(_ctx, getState())
		try enterRule(_localctx, 332, Cobol85Parser.RULE_reportDescriptionFirstDetailClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2765)
		 	try match(Cobol85Parser.Tokens.FIRST.rawValue)
		 	setState(2766)
		 	try match(Cobol85Parser.Tokens.DETAIL.rawValue)
		 	setState(2767)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportDescriptionLastDetailClauseContext: ParserRuleContext {
			open
			func LAST() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LAST.rawValue, 0)
			}
			open
			func DETAIL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DETAIL.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportDescriptionLastDetailClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportDescriptionLastDetailClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportDescriptionLastDetailClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportDescriptionLastDetailClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportDescriptionLastDetailClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportDescriptionLastDetailClause() throws -> ReportDescriptionLastDetailClauseContext {
		var _localctx: ReportDescriptionLastDetailClauseContext = ReportDescriptionLastDetailClauseContext(_ctx, getState())
		try enterRule(_localctx, 334, Cobol85Parser.RULE_reportDescriptionLastDetailClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2769)
		 	try match(Cobol85Parser.Tokens.LAST.rawValue)
		 	setState(2770)
		 	try match(Cobol85Parser.Tokens.DETAIL.rawValue)
		 	setState(2771)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportDescriptionFootingClauseContext: ParserRuleContext {
			open
			func FOOTING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOOTING.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportDescriptionFootingClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportDescriptionFootingClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportDescriptionFootingClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportDescriptionFootingClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportDescriptionFootingClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportDescriptionFootingClause() throws -> ReportDescriptionFootingClauseContext {
		var _localctx: ReportDescriptionFootingClauseContext = ReportDescriptionFootingClauseContext(_ctx, getState())
		try enterRule(_localctx, 336, Cobol85Parser.RULE_reportDescriptionFootingClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2773)
		 	try match(Cobol85Parser.Tokens.FOOTING.rawValue)
		 	setState(2774)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupDescriptionEntryContext: ParserRuleContext {
			open
			func reportGroupDescriptionEntryFormat1() -> ReportGroupDescriptionEntryFormat1Context? {
				return getRuleContext(ReportGroupDescriptionEntryFormat1Context.self, 0)
			}
			open
			func reportGroupDescriptionEntryFormat2() -> ReportGroupDescriptionEntryFormat2Context? {
				return getRuleContext(ReportGroupDescriptionEntryFormat2Context.self, 0)
			}
			open
			func reportGroupDescriptionEntryFormat3() -> ReportGroupDescriptionEntryFormat3Context? {
				return getRuleContext(ReportGroupDescriptionEntryFormat3Context.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupDescriptionEntry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupDescriptionEntry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupDescriptionEntry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupDescriptionEntry(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupDescriptionEntry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupDescriptionEntry() throws -> ReportGroupDescriptionEntryContext {
		var _localctx: ReportGroupDescriptionEntryContext = ReportGroupDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 338, Cobol85Parser.RULE_reportGroupDescriptionEntry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2779)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,314, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2776)
		 		try reportGroupDescriptionEntryFormat1()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2777)
		 		try reportGroupDescriptionEntryFormat2()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2778)
		 		try reportGroupDescriptionEntryFormat3()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupDescriptionEntryFormat1Context: ParserRuleContext {
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func reportGroupTypeClause() -> ReportGroupTypeClauseContext? {
				return getRuleContext(ReportGroupTypeClauseContext.self, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func reportGroupLineNumberClause() -> ReportGroupLineNumberClauseContext? {
				return getRuleContext(ReportGroupLineNumberClauseContext.self, 0)
			}
			open
			func reportGroupNextGroupClause() -> ReportGroupNextGroupClauseContext? {
				return getRuleContext(ReportGroupNextGroupClauseContext.self, 0)
			}
			open
			func reportGroupUsageClause() -> ReportGroupUsageClauseContext? {
				return getRuleContext(ReportGroupUsageClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupDescriptionEntryFormat1
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupDescriptionEntryFormat1(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupDescriptionEntryFormat1(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupDescriptionEntryFormat1(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupDescriptionEntryFormat1(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupDescriptionEntryFormat1() throws -> ReportGroupDescriptionEntryFormat1Context {
		var _localctx: ReportGroupDescriptionEntryFormat1Context = ReportGroupDescriptionEntryFormat1Context(_ctx, getState())
		try enterRule(_localctx, 340, Cobol85Parser.RULE_reportGroupDescriptionEntryFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2781)
		 	try integerLiteral()
		 	setState(2782)
		 	try dataName()
		 	setState(2784)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.IS.rawValue,Cobol85Parser.Tokens.LINE.rawValue,Cobol85Parser.Tokens.NUMBER.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 254)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.PLUS.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2783)
		 		try reportGroupLineNumberClause()

		 	}

		 	setState(2787)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.NEXT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2786)
		 		try reportGroupNextGroupClause()

		 	}

		 	setState(2789)
		 	try reportGroupTypeClause()
		 	setState(2791)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.DISPLAY.rawValue || _la == Cobol85Parser.Tokens.DISPLAY_1.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.USAGE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2790)
		 		try reportGroupUsageClause()

		 	}

		 	setState(2793)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupDescriptionEntryFormat2Context: ParserRuleContext {
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func reportGroupUsageClause() -> ReportGroupUsageClauseContext? {
				return getRuleContext(ReportGroupUsageClauseContext.self, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func reportGroupLineNumberClause() -> ReportGroupLineNumberClauseContext? {
				return getRuleContext(ReportGroupLineNumberClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupDescriptionEntryFormat2
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupDescriptionEntryFormat2(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupDescriptionEntryFormat2(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupDescriptionEntryFormat2(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupDescriptionEntryFormat2(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupDescriptionEntryFormat2() throws -> ReportGroupDescriptionEntryFormat2Context {
		var _localctx: ReportGroupDescriptionEntryFormat2Context = ReportGroupDescriptionEntryFormat2Context(_ctx, getState())
		try enterRule(_localctx, 342, Cobol85Parser.RULE_reportGroupDescriptionEntryFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2795)
		 	try integerLiteral()
		 	setState(2797)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2796)
		 		try dataName()

		 	}

		 	setState(2800)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.IS.rawValue,Cobol85Parser.Tokens.LINE.rawValue,Cobol85Parser.Tokens.NUMBER.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 254)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.PLUS.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2799)
		 		try reportGroupLineNumberClause()

		 	}

		 	setState(2802)
		 	try reportGroupUsageClause()
		 	setState(2803)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupDescriptionEntryFormat3Context: ParserRuleContext {
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func reportGroupPictureClause() -> [ReportGroupPictureClauseContext] {
				return getRuleContexts(ReportGroupPictureClauseContext.self)
			}
			open
			func reportGroupPictureClause(_ i: Int) -> ReportGroupPictureClauseContext? {
				return getRuleContext(ReportGroupPictureClauseContext.self, i)
			}
			open
			func reportGroupUsageClause() -> [ReportGroupUsageClauseContext] {
				return getRuleContexts(ReportGroupUsageClauseContext.self)
			}
			open
			func reportGroupUsageClause(_ i: Int) -> ReportGroupUsageClauseContext? {
				return getRuleContext(ReportGroupUsageClauseContext.self, i)
			}
			open
			func reportGroupSignClause() -> [ReportGroupSignClauseContext] {
				return getRuleContexts(ReportGroupSignClauseContext.self)
			}
			open
			func reportGroupSignClause(_ i: Int) -> ReportGroupSignClauseContext? {
				return getRuleContext(ReportGroupSignClauseContext.self, i)
			}
			open
			func reportGroupJustifiedClause() -> [ReportGroupJustifiedClauseContext] {
				return getRuleContexts(ReportGroupJustifiedClauseContext.self)
			}
			open
			func reportGroupJustifiedClause(_ i: Int) -> ReportGroupJustifiedClauseContext? {
				return getRuleContext(ReportGroupJustifiedClauseContext.self, i)
			}
			open
			func reportGroupBlankWhenZeroClause() -> [ReportGroupBlankWhenZeroClauseContext] {
				return getRuleContexts(ReportGroupBlankWhenZeroClauseContext.self)
			}
			open
			func reportGroupBlankWhenZeroClause(_ i: Int) -> ReportGroupBlankWhenZeroClauseContext? {
				return getRuleContext(ReportGroupBlankWhenZeroClauseContext.self, i)
			}
			open
			func reportGroupLineNumberClause() -> [ReportGroupLineNumberClauseContext] {
				return getRuleContexts(ReportGroupLineNumberClauseContext.self)
			}
			open
			func reportGroupLineNumberClause(_ i: Int) -> ReportGroupLineNumberClauseContext? {
				return getRuleContext(ReportGroupLineNumberClauseContext.self, i)
			}
			open
			func reportGroupColumnNumberClause() -> [ReportGroupColumnNumberClauseContext] {
				return getRuleContexts(ReportGroupColumnNumberClauseContext.self)
			}
			open
			func reportGroupColumnNumberClause(_ i: Int) -> ReportGroupColumnNumberClauseContext? {
				return getRuleContext(ReportGroupColumnNumberClauseContext.self, i)
			}
			open
			func reportGroupIndicateClause() -> [ReportGroupIndicateClauseContext] {
				return getRuleContexts(ReportGroupIndicateClauseContext.self)
			}
			open
			func reportGroupIndicateClause(_ i: Int) -> ReportGroupIndicateClauseContext? {
				return getRuleContext(ReportGroupIndicateClauseContext.self, i)
			}
			open
			func reportGroupSourceClause() -> [ReportGroupSourceClauseContext] {
				return getRuleContexts(ReportGroupSourceClauseContext.self)
			}
			open
			func reportGroupSourceClause(_ i: Int) -> ReportGroupSourceClauseContext? {
				return getRuleContext(ReportGroupSourceClauseContext.self, i)
			}
			open
			func reportGroupValueClause() -> [ReportGroupValueClauseContext] {
				return getRuleContexts(ReportGroupValueClauseContext.self)
			}
			open
			func reportGroupValueClause(_ i: Int) -> ReportGroupValueClauseContext? {
				return getRuleContext(ReportGroupValueClauseContext.self, i)
			}
			open
			func reportGroupSumClause() -> [ReportGroupSumClauseContext] {
				return getRuleContexts(ReportGroupSumClauseContext.self)
			}
			open
			func reportGroupSumClause(_ i: Int) -> ReportGroupSumClauseContext? {
				return getRuleContext(ReportGroupSumClauseContext.self, i)
			}
			open
			func reportGroupResetClause() -> [ReportGroupResetClauseContext] {
				return getRuleContexts(ReportGroupResetClauseContext.self)
			}
			open
			func reportGroupResetClause(_ i: Int) -> ReportGroupResetClauseContext? {
				return getRuleContext(ReportGroupResetClauseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupDescriptionEntryFormat3
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupDescriptionEntryFormat3(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupDescriptionEntryFormat3(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupDescriptionEntryFormat3(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupDescriptionEntryFormat3(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupDescriptionEntryFormat3() throws -> ReportGroupDescriptionEntryFormat3Context {
		var _localctx: ReportGroupDescriptionEntryFormat3Context = ReportGroupDescriptionEntryFormat3Context(_ctx, getState())
		try enterRule(_localctx, 344, Cobol85Parser.RULE_reportGroupDescriptionEntryFormat3)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2805)
		 	try integerLiteral()
		 	setState(2807)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2806)
		 		try dataName()

		 	}

		 	setState(2825)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.BLANK.rawValue || _la == Cobol85Parser.Tokens.COLUMN.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.DISPLAY.rawValue || _la == Cobol85Parser.Tokens.DISPLAY_1.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.GROUP.rawValue,Cobol85Parser.Tokens.IS.rawValue,Cobol85Parser.Tokens.JUST.rawValue,Cobol85Parser.Tokens.JUSTIFIED.rawValue,Cobol85Parser.Tokens.LINE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 227)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NUMBER.rawValue,Cobol85Parser.Tokens.PIC.rawValue,Cobol85Parser.Tokens.PICTURE.rawValue,Cobol85Parser.Tokens.PLUS.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 315)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.RESET.rawValue,Cobol85Parser.Tokens.SIGN.rawValue,Cobol85Parser.Tokens.SOURCE.rawValue,Cobol85Parser.Tokens.SUM.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 402)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.USAGE.rawValue,Cobol85Parser.Tokens.VALUE.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 504)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2823)
		 		try _errHandler.sync(self)
		 		switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .PIC:fallthrough
		 		case .PICTURE:
		 			setState(2809)
		 			try reportGroupPictureClause()

		 			break
		 		case .DISPLAY:fallthrough
		 		case .DISPLAY_1:fallthrough
		 		case .USAGE:
		 			setState(2810)
		 			try reportGroupUsageClause()

		 			break

		 		case .SIGN:
		 			setState(2811)
		 			try reportGroupSignClause()

		 			break
		 		case .JUST:fallthrough
		 		case .JUSTIFIED:
		 			setState(2812)
		 			try reportGroupJustifiedClause()

		 			break

		 		case .BLANK:
		 			setState(2813)
		 			try reportGroupBlankWhenZeroClause()

		 			break
		 		case .IS:fallthrough
		 		case .LINE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .PLUS:fallthrough
		 		case .LEVEL_NUMBER_66:fallthrough
		 		case .LEVEL_NUMBER_77:fallthrough
		 		case .LEVEL_NUMBER_88:fallthrough
		 		case .INTEGERLITERAL:
		 			setState(2814)
		 			try reportGroupLineNumberClause()

		 			break

		 		case .COLUMN:
		 			setState(2815)
		 			try reportGroupColumnNumberClause()

		 			break
		 		case .RESET:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SUM:fallthrough
		 		case .VALUE:
		 			setState(2820)
		 			try _errHandler.sync(self)
		 			switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .SOURCE:
		 				setState(2816)
		 				try reportGroupSourceClause()

		 				break

		 			case .VALUE:
		 				setState(2817)
		 				try reportGroupValueClause()

		 				break

		 			case .SUM:
		 				setState(2818)
		 				try reportGroupSumClause()

		 				break

		 			case .RESET:
		 				setState(2819)
		 				try reportGroupResetClause()

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			break

		 		case .GROUP:
		 			setState(2822)
		 			try reportGroupIndicateClause()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2827)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2828)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupBlankWhenZeroClauseContext: ParserRuleContext {
			open
			func BLANK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BLANK.rawValue, 0)
			}
			open
			func ZERO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZERO.rawValue, 0)
			}
			open
			func WHEN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WHEN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupBlankWhenZeroClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupBlankWhenZeroClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupBlankWhenZeroClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupBlankWhenZeroClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupBlankWhenZeroClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupBlankWhenZeroClause() throws -> ReportGroupBlankWhenZeroClauseContext {
		var _localctx: ReportGroupBlankWhenZeroClauseContext = ReportGroupBlankWhenZeroClauseContext(_ctx, getState())
		try enterRule(_localctx, 346, Cobol85Parser.RULE_reportGroupBlankWhenZeroClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2830)
		 	try match(Cobol85Parser.Tokens.BLANK.rawValue)
		 	setState(2832)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WHEN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2831)
		 		try match(Cobol85Parser.Tokens.WHEN.rawValue)

		 	}

		 	setState(2834)
		 	try match(Cobol85Parser.Tokens.ZERO.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupColumnNumberClauseContext: ParserRuleContext {
			open
			func COLUMN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COLUMN.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func NUMBER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMBER.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupColumnNumberClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupColumnNumberClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupColumnNumberClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupColumnNumberClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupColumnNumberClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupColumnNumberClause() throws -> ReportGroupColumnNumberClauseContext {
		var _localctx: ReportGroupColumnNumberClauseContext = ReportGroupColumnNumberClauseContext(_ctx, getState())
		try enterRule(_localctx, 348, Cobol85Parser.RULE_reportGroupColumnNumberClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2836)
		 	try match(Cobol85Parser.Tokens.COLUMN.rawValue)
		 	setState(2838)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.NUMBER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2837)
		 		try match(Cobol85Parser.Tokens.NUMBER.rawValue)

		 	}

		 	setState(2841)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2840)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2843)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupIndicateClauseContext: ParserRuleContext {
			open
			func GROUP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GROUP.rawValue, 0)
			}
			open
			func INDICATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INDICATE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupIndicateClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupIndicateClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupIndicateClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupIndicateClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupIndicateClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupIndicateClause() throws -> ReportGroupIndicateClauseContext {
		var _localctx: ReportGroupIndicateClauseContext = ReportGroupIndicateClauseContext(_ctx, getState())
		try enterRule(_localctx, 350, Cobol85Parser.RULE_reportGroupIndicateClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2845)
		 	try match(Cobol85Parser.Tokens.GROUP.rawValue)
		 	setState(2847)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.INDICATE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2846)
		 		try match(Cobol85Parser.Tokens.INDICATE.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupJustifiedClauseContext: ParserRuleContext {
			open
			func JUSTIFIED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.JUSTIFIED.rawValue, 0)
			}
			open
			func JUST() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.JUST.rawValue, 0)
			}
			open
			func RIGHT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RIGHT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupJustifiedClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupJustifiedClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupJustifiedClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupJustifiedClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupJustifiedClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupJustifiedClause() throws -> ReportGroupJustifiedClauseContext {
		var _localctx: ReportGroupJustifiedClauseContext = ReportGroupJustifiedClauseContext(_ctx, getState())
		try enterRule(_localctx, 352, Cobol85Parser.RULE_reportGroupJustifiedClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2849)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.JUST.rawValue || _la == Cobol85Parser.Tokens.JUSTIFIED.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2851)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.RIGHT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2850)
		 		try match(Cobol85Parser.Tokens.RIGHT.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupLineNumberClauseContext: ParserRuleContext {
			open
			func reportGroupLineNumberNextPage() -> ReportGroupLineNumberNextPageContext? {
				return getRuleContext(ReportGroupLineNumberNextPageContext.self, 0)
			}
			open
			func reportGroupLineNumberPlus() -> ReportGroupLineNumberPlusContext? {
				return getRuleContext(ReportGroupLineNumberPlusContext.self, 0)
			}
			open
			func LINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINE.rawValue, 0)
			}
			open
			func NUMBER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMBER.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupLineNumberClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupLineNumberClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupLineNumberClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupLineNumberClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupLineNumberClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupLineNumberClause() throws -> ReportGroupLineNumberClauseContext {
		var _localctx: ReportGroupLineNumberClauseContext = ReportGroupLineNumberClauseContext(_ctx, getState())
		try enterRule(_localctx, 354, Cobol85Parser.RULE_reportGroupLineNumberClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2854)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LINE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2853)
		 		try match(Cobol85Parser.Tokens.LINE.rawValue)

		 	}

		 	setState(2857)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.NUMBER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2856)
		 		try match(Cobol85Parser.Tokens.NUMBER.rawValue)

		 	}

		 	setState(2860)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2859)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2864)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		setState(2862)
		 		try reportGroupLineNumberNextPage()

		 		break

		 	case .PLUS:
		 		setState(2863)
		 		try reportGroupLineNumberPlus()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupLineNumberNextPageContext: ParserRuleContext {
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func NEXT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NEXT.rawValue, 0)
			}
			open
			func PAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PAGE.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupLineNumberNextPage
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupLineNumberNextPage(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupLineNumberNextPage(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupLineNumberNextPage(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupLineNumberNextPage(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupLineNumberNextPage() throws -> ReportGroupLineNumberNextPageContext {
		var _localctx: ReportGroupLineNumberNextPageContext = ReportGroupLineNumberNextPageContext(_ctx, getState())
		try enterRule(_localctx, 356, Cobol85Parser.RULE_reportGroupLineNumberNextPage)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2866)
		 	try integerLiteral()
		 	setState(2872)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,334,_ctx)) {
		 	case 1:
		 		setState(2868)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2867)
		 			try match(Cobol85Parser.Tokens.ON.rawValue)

		 		}

		 		setState(2870)
		 		try match(Cobol85Parser.Tokens.NEXT.rawValue)
		 		setState(2871)
		 		try match(Cobol85Parser.Tokens.PAGE.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupLineNumberPlusContext: ParserRuleContext {
			open
			func PLUS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PLUS.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupLineNumberPlus
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupLineNumberPlus(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupLineNumberPlus(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupLineNumberPlus(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupLineNumberPlus(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupLineNumberPlus() throws -> ReportGroupLineNumberPlusContext {
		var _localctx: ReportGroupLineNumberPlusContext = ReportGroupLineNumberPlusContext(_ctx, getState())
		try enterRule(_localctx, 358, Cobol85Parser.RULE_reportGroupLineNumberPlus)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2874)
		 	try match(Cobol85Parser.Tokens.PLUS.rawValue)
		 	setState(2875)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupNextGroupClauseContext: ParserRuleContext {
			open
			func NEXT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NEXT.rawValue, 0)
			}
			open
			func GROUP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GROUP.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func reportGroupNextGroupNextPage() -> ReportGroupNextGroupNextPageContext? {
				return getRuleContext(ReportGroupNextGroupNextPageContext.self, 0)
			}
			open
			func reportGroupNextGroupPlus() -> ReportGroupNextGroupPlusContext? {
				return getRuleContext(ReportGroupNextGroupPlusContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupNextGroupClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupNextGroupClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupNextGroupClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupNextGroupClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupNextGroupClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupNextGroupClause() throws -> ReportGroupNextGroupClauseContext {
		var _localctx: ReportGroupNextGroupClauseContext = ReportGroupNextGroupClauseContext(_ctx, getState())
		try enterRule(_localctx, 360, Cobol85Parser.RULE_reportGroupNextGroupClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2877)
		 	try match(Cobol85Parser.Tokens.NEXT.rawValue)
		 	setState(2878)
		 	try match(Cobol85Parser.Tokens.GROUP.rawValue)
		 	setState(2880)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2879)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2885)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		setState(2882)
		 		try integerLiteral()

		 		break

		 	case .NEXT:
		 		setState(2883)
		 		try reportGroupNextGroupNextPage()

		 		break

		 	case .PLUS:
		 		setState(2884)
		 		try reportGroupNextGroupPlus()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupNextGroupPlusContext: ParserRuleContext {
			open
			func PLUS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PLUS.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupNextGroupPlus
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupNextGroupPlus(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupNextGroupPlus(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupNextGroupPlus(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupNextGroupPlus(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupNextGroupPlus() throws -> ReportGroupNextGroupPlusContext {
		var _localctx: ReportGroupNextGroupPlusContext = ReportGroupNextGroupPlusContext(_ctx, getState())
		try enterRule(_localctx, 362, Cobol85Parser.RULE_reportGroupNextGroupPlus)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2887)
		 	try match(Cobol85Parser.Tokens.PLUS.rawValue)
		 	setState(2888)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupNextGroupNextPageContext: ParserRuleContext {
			open
			func NEXT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NEXT.rawValue, 0)
			}
			open
			func PAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PAGE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupNextGroupNextPage
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupNextGroupNextPage(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupNextGroupNextPage(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupNextGroupNextPage(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupNextGroupNextPage(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupNextGroupNextPage() throws -> ReportGroupNextGroupNextPageContext {
		var _localctx: ReportGroupNextGroupNextPageContext = ReportGroupNextGroupNextPageContext(_ctx, getState())
		try enterRule(_localctx, 364, Cobol85Parser.RULE_reportGroupNextGroupNextPage)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2890)
		 	try match(Cobol85Parser.Tokens.NEXT.rawValue)
		 	setState(2891)
		 	try match(Cobol85Parser.Tokens.PAGE.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupPictureClauseContext: ParserRuleContext {
			open
			func pictureString() -> PictureStringContext? {
				return getRuleContext(PictureStringContext.self, 0)
			}
			open
			func PICTURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PICTURE.rawValue, 0)
			}
			open
			func PIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PIC.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupPictureClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupPictureClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupPictureClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupPictureClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupPictureClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupPictureClause() throws -> ReportGroupPictureClauseContext {
		var _localctx: ReportGroupPictureClauseContext = ReportGroupPictureClauseContext(_ctx, getState())
		try enterRule(_localctx, 366, Cobol85Parser.RULE_reportGroupPictureClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2893)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.PIC.rawValue || _la == Cobol85Parser.Tokens.PICTURE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2895)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2894)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2897)
		 	try pictureString()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupResetClauseContext: ParserRuleContext {
			open
			func RESET() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RESET.rawValue, 0)
			}
			open
			func FINAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FINAL.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupResetClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupResetClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupResetClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupResetClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupResetClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupResetClause() throws -> ReportGroupResetClauseContext {
		var _localctx: ReportGroupResetClauseContext = ReportGroupResetClauseContext(_ctx, getState())
		try enterRule(_localctx, 368, Cobol85Parser.RULE_reportGroupResetClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2899)
		 	try match(Cobol85Parser.Tokens.RESET.rawValue)
		 	setState(2901)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2900)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 	}

		 	setState(2905)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FINAL:
		 		setState(2903)
		 		try match(Cobol85Parser.Tokens.FINAL.rawValue)

		 		break
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		setState(2904)
		 		try dataName()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupSignClauseContext: ParserRuleContext {
			open
			func SIGN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIGN.rawValue, 0)
			}
			open
			func SEPARATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEPARATE.rawValue, 0)
			}
			open
			func LEADING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEADING.rawValue, 0)
			}
			open
			func TRAILING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TRAILING.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupSignClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupSignClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupSignClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupSignClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupSignClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupSignClause() throws -> ReportGroupSignClauseContext {
		var _localctx: ReportGroupSignClauseContext = ReportGroupSignClauseContext(_ctx, getState())
		try enterRule(_localctx, 370, Cobol85Parser.RULE_reportGroupSignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2907)
		 	try match(Cobol85Parser.Tokens.SIGN.rawValue)
		 	setState(2909)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2908)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2911)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.LEADING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.TRAILING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2912)
		 	try match(Cobol85Parser.Tokens.SEPARATE.rawValue)
		 	setState(2914)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2913)
		 		try match(Cobol85Parser.Tokens.CHARACTER.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupSourceClauseContext: ParserRuleContext {
			open
			func SOURCE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SOURCE.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupSourceClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupSourceClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupSourceClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupSourceClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupSourceClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupSourceClause() throws -> ReportGroupSourceClauseContext {
		var _localctx: ReportGroupSourceClauseContext = ReportGroupSourceClauseContext(_ctx, getState())
		try enterRule(_localctx, 372, Cobol85Parser.RULE_reportGroupSourceClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2916)
		 	try match(Cobol85Parser.Tokens.SOURCE.rawValue)
		 	setState(2918)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2917)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2920)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupSumClauseContext: ParserRuleContext {
			open
			func SUM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SUM.rawValue, 0)
			}
			open
			func identifier() -> [IdentifierContext] {
				return getRuleContexts(IdentifierContext.self)
			}
			open
			func identifier(_ i: Int) -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, i)
			}
			open
			func UPON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.UPON.rawValue, 0)
			}
			open
			func dataName() -> [DataNameContext] {
				return getRuleContexts(DataNameContext.self)
			}
			open
			func dataName(_ i: Int) -> DataNameContext? {
				return getRuleContext(DataNameContext.self, i)
			}
			open
			func COMMACHAR() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.COMMACHAR.rawValue)
			}
			open
			func COMMACHAR(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMACHAR.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupSumClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupSumClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupSumClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupSumClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupSumClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupSumClause() throws -> ReportGroupSumClauseContext {
		var _localctx: ReportGroupSumClauseContext = ReportGroupSumClauseContext(_ctx, getState())
		try enterRule(_localctx, 374, Cobol85Parser.RULE_reportGroupSumClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2922)
		 	try match(Cobol85Parser.Tokens.SUM.rawValue)
		 	setState(2923)
		 	try identifier()
		 	setState(2930)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,344,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2925)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMACHAR.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(2924)
		 				try match(Cobol85Parser.Tokens.COMMACHAR.rawValue)

		 			}

		 			setState(2927)
		 			try identifier()

		 	 
		 		}
		 		setState(2932)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,344,_ctx)
		 	}
		 	setState(2944)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.UPON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2933)
		 		try match(Cobol85Parser.Tokens.UPON.rawValue)
		 		setState(2934)
		 		try dataName()
		 		setState(2941)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 68)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 138)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 202)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 268)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 401)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.COMMACHAR.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 466)
		 		          }()
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2936)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMACHAR.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(2935)
		 				try match(Cobol85Parser.Tokens.COMMACHAR.rawValue)

		 			}

		 			setState(2938)
		 			try dataName()


		 			setState(2943)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupTypeClauseContext: ParserRuleContext {
			open
			func TYPE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TYPE.rawValue, 0)
			}
			open
			func reportGroupTypeReportHeading() -> ReportGroupTypeReportHeadingContext? {
				return getRuleContext(ReportGroupTypeReportHeadingContext.self, 0)
			}
			open
			func reportGroupTypePageHeading() -> ReportGroupTypePageHeadingContext? {
				return getRuleContext(ReportGroupTypePageHeadingContext.self, 0)
			}
			open
			func reportGroupTypeControlHeading() -> ReportGroupTypeControlHeadingContext? {
				return getRuleContext(ReportGroupTypeControlHeadingContext.self, 0)
			}
			open
			func reportGroupTypeDetail() -> ReportGroupTypeDetailContext? {
				return getRuleContext(ReportGroupTypeDetailContext.self, 0)
			}
			open
			func reportGroupTypeControlFooting() -> ReportGroupTypeControlFootingContext? {
				return getRuleContext(ReportGroupTypeControlFootingContext.self, 0)
			}
			open
			func reportGroupTypePageFooting() -> ReportGroupTypePageFootingContext? {
				return getRuleContext(ReportGroupTypePageFootingContext.self, 0)
			}
			open
			func reportGroupTypeReportFooting() -> ReportGroupTypeReportFootingContext? {
				return getRuleContext(ReportGroupTypeReportFootingContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupTypeClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupTypeClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupTypeClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupTypeClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupTypeClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupTypeClause() throws -> ReportGroupTypeClauseContext {
		var _localctx: ReportGroupTypeClauseContext = ReportGroupTypeClauseContext(_ctx, getState())
		try enterRule(_localctx, 376, Cobol85Parser.RULE_reportGroupTypeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2946)
		 	try match(Cobol85Parser.Tokens.TYPE.rawValue)
		 	setState(2948)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2947)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(2957)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,349, _ctx)) {
		 	case 1:
		 		setState(2950)
		 		try reportGroupTypeReportHeading()

		 		break
		 	case 2:
		 		setState(2951)
		 		try reportGroupTypePageHeading()

		 		break
		 	case 3:
		 		setState(2952)
		 		try reportGroupTypeControlHeading()

		 		break
		 	case 4:
		 		setState(2953)
		 		try reportGroupTypeDetail()

		 		break
		 	case 5:
		 		setState(2954)
		 		try reportGroupTypeControlFooting()

		 		break
		 	case 6:
		 		setState(2955)
		 		try reportGroupTypePageFooting()

		 		break
		 	case 7:
		 		setState(2956)
		 		try reportGroupTypeReportFooting()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupTypeReportHeadingContext: ParserRuleContext {
			open
			func REPORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REPORT.rawValue, 0)
			}
			open
			func HEADING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.HEADING.rawValue, 0)
			}
			open
			func RH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupTypeReportHeading
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupTypeReportHeading(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupTypeReportHeading(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupTypeReportHeading(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupTypeReportHeading(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupTypeReportHeading() throws -> ReportGroupTypeReportHeadingContext {
		var _localctx: ReportGroupTypeReportHeadingContext = ReportGroupTypeReportHeadingContext(_ctx, getState())
		try enterRule(_localctx, 378, Cobol85Parser.RULE_reportGroupTypeReportHeading)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2962)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .REPORT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2959)
		 		try match(Cobol85Parser.Tokens.REPORT.rawValue)
		 		setState(2960)
		 		try match(Cobol85Parser.Tokens.HEADING.rawValue)

		 		break

		 	case .RH:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2961)
		 		try match(Cobol85Parser.Tokens.RH.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupTypePageHeadingContext: ParserRuleContext {
			open
			func PAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PAGE.rawValue, 0)
			}
			open
			func HEADING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.HEADING.rawValue, 0)
			}
			open
			func PH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupTypePageHeading
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupTypePageHeading(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupTypePageHeading(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupTypePageHeading(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupTypePageHeading(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupTypePageHeading() throws -> ReportGroupTypePageHeadingContext {
		var _localctx: ReportGroupTypePageHeadingContext = ReportGroupTypePageHeadingContext(_ctx, getState())
		try enterRule(_localctx, 380, Cobol85Parser.RULE_reportGroupTypePageHeading)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2967)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .PAGE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2964)
		 		try match(Cobol85Parser.Tokens.PAGE.rawValue)
		 		setState(2965)
		 		try match(Cobol85Parser.Tokens.HEADING.rawValue)

		 		break

		 	case .PH:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2966)
		 		try match(Cobol85Parser.Tokens.PH.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupTypeControlHeadingContext: ParserRuleContext {
			open
			func CONTROL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTROL.rawValue, 0)
			}
			open
			func HEADING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.HEADING.rawValue, 0)
			}
			open
			func CH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CH.rawValue, 0)
			}
			open
			func FINAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FINAL.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupTypeControlHeading
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupTypeControlHeading(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupTypeControlHeading(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupTypeControlHeading(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupTypeControlHeading(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupTypeControlHeading() throws -> ReportGroupTypeControlHeadingContext {
		var _localctx: ReportGroupTypeControlHeadingContext = ReportGroupTypeControlHeadingContext(_ctx, getState())
		try enterRule(_localctx, 382, Cobol85Parser.RULE_reportGroupTypeControlHeading)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2972)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CONTROL:
		 		setState(2969)
		 		try match(Cobol85Parser.Tokens.CONTROL.rawValue)
		 		setState(2970)
		 		try match(Cobol85Parser.Tokens.HEADING.rawValue)

		 		break

		 	case .CH:
		 		setState(2971)
		 		try match(Cobol85Parser.Tokens.CH.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2976)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FINAL:
		 		setState(2974)
		 		try match(Cobol85Parser.Tokens.FINAL.rawValue)

		 		break
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		setState(2975)
		 		try dataName()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupTypeDetailContext: ParserRuleContext {
			open
			func DETAIL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DETAIL.rawValue, 0)
			}
			open
			func DE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupTypeDetail
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupTypeDetail(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupTypeDetail(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupTypeDetail(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupTypeDetail(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupTypeDetail() throws -> ReportGroupTypeDetailContext {
		var _localctx: ReportGroupTypeDetailContext = ReportGroupTypeDetailContext(_ctx, getState())
		try enterRule(_localctx, 384, Cobol85Parser.RULE_reportGroupTypeDetail)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2978)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DE.rawValue || _la == Cobol85Parser.Tokens.DETAIL.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupTypeControlFootingContext: ParserRuleContext {
			open
			func CONTROL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTROL.rawValue, 0)
			}
			open
			func FOOTING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOOTING.rawValue, 0)
			}
			open
			func CF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CF.rawValue, 0)
			}
			open
			func FINAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FINAL.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupTypeControlFooting
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupTypeControlFooting(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupTypeControlFooting(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupTypeControlFooting(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupTypeControlFooting(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupTypeControlFooting() throws -> ReportGroupTypeControlFootingContext {
		var _localctx: ReportGroupTypeControlFootingContext = ReportGroupTypeControlFootingContext(_ctx, getState())
		try enterRule(_localctx, 386, Cobol85Parser.RULE_reportGroupTypeControlFooting)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2983)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CONTROL:
		 		setState(2980)
		 		try match(Cobol85Parser.Tokens.CONTROL.rawValue)
		 		setState(2981)
		 		try match(Cobol85Parser.Tokens.FOOTING.rawValue)

		 		break

		 	case .CF:
		 		setState(2982)
		 		try match(Cobol85Parser.Tokens.CF.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2987)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FINAL:
		 		setState(2985)
		 		try match(Cobol85Parser.Tokens.FINAL.rawValue)

		 		break
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		setState(2986)
		 		try dataName()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupUsageClauseContext: ParserRuleContext {
			open
			func DISPLAY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISPLAY.rawValue, 0)
			}
			open
			func DISPLAY_1() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISPLAY_1.rawValue, 0)
			}
			open
			func USAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USAGE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupUsageClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupUsageClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupUsageClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupUsageClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupUsageClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupUsageClause() throws -> ReportGroupUsageClauseContext {
		var _localctx: ReportGroupUsageClauseContext = ReportGroupUsageClauseContext(_ctx, getState())
		try enterRule(_localctx, 388, Cobol85Parser.RULE_reportGroupUsageClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2993)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.USAGE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2989)
		 		try match(Cobol85Parser.Tokens.USAGE.rawValue)
		 		setState(2991)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2990)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}


		 	}

		 	setState(2995)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DISPLAY.rawValue || _la == Cobol85Parser.Tokens.DISPLAY_1.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupTypePageFootingContext: ParserRuleContext {
			open
			func PAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PAGE.rawValue, 0)
			}
			open
			func FOOTING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOOTING.rawValue, 0)
			}
			open
			func PF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupTypePageFooting
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupTypePageFooting(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupTypePageFooting(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupTypePageFooting(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupTypePageFooting(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupTypePageFooting() throws -> ReportGroupTypePageFootingContext {
		var _localctx: ReportGroupTypePageFootingContext = ReportGroupTypePageFootingContext(_ctx, getState())
		try enterRule(_localctx, 390, Cobol85Parser.RULE_reportGroupTypePageFooting)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3000)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .PAGE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2997)
		 		try match(Cobol85Parser.Tokens.PAGE.rawValue)
		 		setState(2998)
		 		try match(Cobol85Parser.Tokens.FOOTING.rawValue)

		 		break

		 	case .PF:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2999)
		 		try match(Cobol85Parser.Tokens.PF.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupTypeReportFootingContext: ParserRuleContext {
			open
			func REPORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REPORT.rawValue, 0)
			}
			open
			func FOOTING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOOTING.rawValue, 0)
			}
			open
			func RF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupTypeReportFooting
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupTypeReportFooting(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupTypeReportFooting(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupTypeReportFooting(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupTypeReportFooting(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupTypeReportFooting() throws -> ReportGroupTypeReportFootingContext {
		var _localctx: ReportGroupTypeReportFootingContext = ReportGroupTypeReportFootingContext(_ctx, getState())
		try enterRule(_localctx, 392, Cobol85Parser.RULE_reportGroupTypeReportFooting)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3005)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .REPORT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3002)
		 		try match(Cobol85Parser.Tokens.REPORT.rawValue)
		 		setState(3003)
		 		try match(Cobol85Parser.Tokens.FOOTING.rawValue)

		 		break

		 	case .RF:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3004)
		 		try match(Cobol85Parser.Tokens.RF.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportGroupValueClauseContext: ParserRuleContext {
			open
			func VALUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VALUE.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportGroupValueClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportGroupValueClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportGroupValueClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportGroupValueClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportGroupValueClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportGroupValueClause() throws -> ReportGroupValueClauseContext {
		var _localctx: ReportGroupValueClauseContext = ReportGroupValueClauseContext(_ctx, getState())
		try enterRule(_localctx, 394, Cobol85Parser.RULE_reportGroupValueClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3007)
		 	try match(Cobol85Parser.Tokens.VALUE.rawValue)
		 	setState(3009)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3008)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3011)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProgramLibrarySectionContext: ParserRuleContext {
			open
			func PROGRAM_LIBRARY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROGRAM_LIBRARY.rawValue, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func libraryDescriptionEntry() -> [LibraryDescriptionEntryContext] {
				return getRuleContexts(LibraryDescriptionEntryContext.self)
			}
			open
			func libraryDescriptionEntry(_ i: Int) -> LibraryDescriptionEntryContext? {
				return getRuleContext(LibraryDescriptionEntryContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_programLibrarySection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProgramLibrarySection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProgramLibrarySection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProgramLibrarySection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProgramLibrarySection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func programLibrarySection() throws -> ProgramLibrarySectionContext {
		var _localctx: ProgramLibrarySectionContext = ProgramLibrarySectionContext(_ctx, getState())
		try enterRule(_localctx, 396, Cobol85Parser.RULE_programLibrarySection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3013)
		 	try match(Cobol85Parser.Tokens.PROGRAM_LIBRARY.rawValue)
		 	setState(3014)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(3015)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(3019)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LB.rawValue || _la == Cobol85Parser.Tokens.LD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3016)
		 		try libraryDescriptionEntry()


		 		setState(3021)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryDescriptionEntryContext: ParserRuleContext {
			open
			func libraryDescriptionEntryFormat1() -> LibraryDescriptionEntryFormat1Context? {
				return getRuleContext(LibraryDescriptionEntryFormat1Context.self, 0)
			}
			open
			func libraryDescriptionEntryFormat2() -> LibraryDescriptionEntryFormat2Context? {
				return getRuleContext(LibraryDescriptionEntryFormat2Context.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryDescriptionEntry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryDescriptionEntry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryDescriptionEntry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryDescriptionEntry(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryDescriptionEntry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryDescriptionEntry() throws -> LibraryDescriptionEntryContext {
		var _localctx: LibraryDescriptionEntryContext = LibraryDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 398, Cobol85Parser.RULE_libraryDescriptionEntry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3024)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LD:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3022)
		 		try libraryDescriptionEntryFormat1()

		 		break

		 	case .LB:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3023)
		 		try libraryDescriptionEntryFormat2()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryDescriptionEntryFormat1Context: ParserRuleContext {
			open
			func LD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LD.rawValue, 0)
			}
			open
			func libraryName() -> LibraryNameContext? {
				return getRuleContext(LibraryNameContext.self, 0)
			}
			open
			func EXPORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXPORT.rawValue, 0)
			}
			open
			func libraryAttributeClauseFormat1() -> LibraryAttributeClauseFormat1Context? {
				return getRuleContext(LibraryAttributeClauseFormat1Context.self, 0)
			}
			open
			func libraryEntryProcedureClauseFormat1() -> LibraryEntryProcedureClauseFormat1Context? {
				return getRuleContext(LibraryEntryProcedureClauseFormat1Context.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryDescriptionEntryFormat1
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryDescriptionEntryFormat1(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryDescriptionEntryFormat1(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryDescriptionEntryFormat1(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryDescriptionEntryFormat1(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryDescriptionEntryFormat1() throws -> LibraryDescriptionEntryFormat1Context {
		var _localctx: LibraryDescriptionEntryFormat1Context = LibraryDescriptionEntryFormat1Context(_ctx, getState())
		try enterRule(_localctx, 400, Cobol85Parser.RULE_libraryDescriptionEntryFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3026)
		 	try match(Cobol85Parser.Tokens.LD.rawValue)
		 	setState(3027)
		 	try libraryName()
		 	setState(3028)
		 	try match(Cobol85Parser.Tokens.EXPORT.rawValue)
		 	setState(3030)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ATTRIBUTE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3029)
		 		try libraryAttributeClauseFormat1()

		 	}

		 	setState(3033)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3032)
		 		try libraryEntryProcedureClauseFormat1()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryDescriptionEntryFormat2Context: ParserRuleContext {
			open
			func LB() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LB.rawValue, 0)
			}
			open
			func libraryName() -> LibraryNameContext? {
				return getRuleContext(LibraryNameContext.self, 0)
			}
			open
			func IMPORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IMPORT.rawValue, 0)
			}
			open
			func libraryIsGlobalClause() -> LibraryIsGlobalClauseContext? {
				return getRuleContext(LibraryIsGlobalClauseContext.self, 0)
			}
			open
			func libraryIsCommonClause() -> LibraryIsCommonClauseContext? {
				return getRuleContext(LibraryIsCommonClauseContext.self, 0)
			}
			open
			func libraryAttributeClauseFormat2() -> [LibraryAttributeClauseFormat2Context] {
				return getRuleContexts(LibraryAttributeClauseFormat2Context.self)
			}
			open
			func libraryAttributeClauseFormat2(_ i: Int) -> LibraryAttributeClauseFormat2Context? {
				return getRuleContext(LibraryAttributeClauseFormat2Context.self, i)
			}
			open
			func libraryEntryProcedureClauseFormat2() -> [LibraryEntryProcedureClauseFormat2Context] {
				return getRuleContexts(LibraryEntryProcedureClauseFormat2Context.self)
			}
			open
			func libraryEntryProcedureClauseFormat2(_ i: Int) -> LibraryEntryProcedureClauseFormat2Context? {
				return getRuleContext(LibraryEntryProcedureClauseFormat2Context.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryDescriptionEntryFormat2
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryDescriptionEntryFormat2(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryDescriptionEntryFormat2(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryDescriptionEntryFormat2(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryDescriptionEntryFormat2(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryDescriptionEntryFormat2() throws -> LibraryDescriptionEntryFormat2Context {
		var _localctx: LibraryDescriptionEntryFormat2Context = LibraryDescriptionEntryFormat2Context(_ctx, getState())
		try enterRule(_localctx, 402, Cobol85Parser.RULE_libraryDescriptionEntryFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3035)
		 	try match(Cobol85Parser.Tokens.LB.rawValue)
		 	setState(3036)
		 	try libraryName()
		 	setState(3037)
		 	try match(Cobol85Parser.Tokens.IMPORT.rawValue)
		 	setState(3039)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,365,_ctx)) {
		 	case 1:
		 		setState(3038)
		 		try libraryIsGlobalClause()

		 		break
		 	default: break
		 	}
		 	setState(3042)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.COMMON.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3041)
		 		try libraryIsCommonClause()

		 	}

		 	setState(3048)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ATTRIBUTE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3046)
		 		try _errHandler.sync(self)
		 		switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ATTRIBUTE:
		 			setState(3044)
		 			try libraryAttributeClauseFormat2()

		 			break

		 		case .ENTRY_PROCEDURE:
		 			setState(3045)
		 			try libraryEntryProcedureClauseFormat2()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3050)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryAttributeClauseFormat1Context: ParserRuleContext {
			open
			func ATTRIBUTE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ATTRIBUTE.rawValue, 0)
			}
			open
			func SHARING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SHARING.rawValue, 0)
			}
			open
			func DONTCARE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DONTCARE.rawValue, 0)
			}
			open
			func PRIVATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PRIVATE.rawValue, 0)
			}
			open
			func SHAREDBYRUNUNIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue, 0)
			}
			open
			func SHAREDBYALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SHAREDBYALL.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryAttributeClauseFormat1
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryAttributeClauseFormat1(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryAttributeClauseFormat1(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryAttributeClauseFormat1(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryAttributeClauseFormat1(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryAttributeClauseFormat1() throws -> LibraryAttributeClauseFormat1Context {
		var _localctx: LibraryAttributeClauseFormat1Context = LibraryAttributeClauseFormat1Context(_ctx, getState())
		try enterRule(_localctx, 404, Cobol85Parser.RULE_libraryAttributeClauseFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3051)
		 	try match(Cobol85Parser.Tokens.ATTRIBUTE.rawValue)
		 	setState(3057)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SHARING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3052)
		 		try match(Cobol85Parser.Tokens.SHARING.rawValue)
		 		setState(3054)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3053)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}

		 		setState(3056)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.DONTCARE.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.PRIVATE.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.SHAREDBYALL.rawValue || _la == Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryAttributeClauseFormat2Context: ParserRuleContext {
			open
			func ATTRIBUTE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ATTRIBUTE.rawValue, 0)
			}
			open
			func libraryAttributeFunction() -> LibraryAttributeFunctionContext? {
				return getRuleContext(LibraryAttributeFunctionContext.self, 0)
			}
			open
			func LIBACCESS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LIBACCESS.rawValue, 0)
			}
			open
			func libraryAttributeParameter() -> LibraryAttributeParameterContext? {
				return getRuleContext(LibraryAttributeParameterContext.self, 0)
			}
			open
			func libraryAttributeTitle() -> LibraryAttributeTitleContext? {
				return getRuleContext(LibraryAttributeTitleContext.self, 0)
			}
			open
			func BYFUNCTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BYFUNCTION.rawValue, 0)
			}
			open
			func BYTITLE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BYTITLE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryAttributeClauseFormat2
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryAttributeClauseFormat2(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryAttributeClauseFormat2(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryAttributeClauseFormat2(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryAttributeClauseFormat2(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryAttributeClauseFormat2() throws -> LibraryAttributeClauseFormat2Context {
		var _localctx: LibraryAttributeClauseFormat2Context = LibraryAttributeClauseFormat2Context(_ctx, getState())
		try enterRule(_localctx, 406, Cobol85Parser.RULE_libraryAttributeClauseFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3059)
		 	try match(Cobol85Parser.Tokens.ATTRIBUTE.rawValue)
		 	setState(3061)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FUNCTIONNAME.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3060)
		 		try libraryAttributeFunction()

		 	}

		 	setState(3068)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LIBACCESS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3063)
		 		try match(Cobol85Parser.Tokens.LIBACCESS.rawValue)
		 		setState(3065)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3064)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}

		 		setState(3067)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.BYFUNCTION.rawValue || _la == Cobol85Parser.Tokens.BYTITLE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3071)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LIBPARAMETER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3070)
		 		try libraryAttributeParameter()

		 	}

		 	setState(3074)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TITLE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3073)
		 		try libraryAttributeTitle()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryAttributeFunctionContext: ParserRuleContext {
			open
			func FUNCTIONNAME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FUNCTIONNAME.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryAttributeFunction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryAttributeFunction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryAttributeFunction(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryAttributeFunction(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryAttributeFunction(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryAttributeFunction() throws -> LibraryAttributeFunctionContext {
		var _localctx: LibraryAttributeFunctionContext = LibraryAttributeFunctionContext(_ctx, getState())
		try enterRule(_localctx, 408, Cobol85Parser.RULE_libraryAttributeFunction)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3076)
		 	try match(Cobol85Parser.Tokens.FUNCTIONNAME.rawValue)
		 	setState(3077)
		 	try match(Cobol85Parser.Tokens.IS.rawValue)
		 	setState(3078)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryAttributeParameterContext: ParserRuleContext {
			open
			func LIBPARAMETER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LIBPARAMETER.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryAttributeParameter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryAttributeParameter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryAttributeParameter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryAttributeParameter(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryAttributeParameter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryAttributeParameter() throws -> LibraryAttributeParameterContext {
		var _localctx: LibraryAttributeParameterContext = LibraryAttributeParameterContext(_ctx, getState())
		try enterRule(_localctx, 410, Cobol85Parser.RULE_libraryAttributeParameter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3080)
		 	try match(Cobol85Parser.Tokens.LIBPARAMETER.rawValue)
		 	setState(3082)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3081)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3084)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryAttributeTitleContext: ParserRuleContext {
			open
			func TITLE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TITLE.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryAttributeTitle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryAttributeTitle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryAttributeTitle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryAttributeTitle(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryAttributeTitle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryAttributeTitle() throws -> LibraryAttributeTitleContext {
		var _localctx: LibraryAttributeTitleContext = LibraryAttributeTitleContext(_ctx, getState())
		try enterRule(_localctx, 412, Cobol85Parser.RULE_libraryAttributeTitle)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3086)
		 	try match(Cobol85Parser.Tokens.TITLE.rawValue)
		 	setState(3088)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3087)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3090)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryEntryProcedureClauseFormat1Context: ParserRuleContext {
			open
			func ENTRY_PROCEDURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue, 0)
			}
			open
			func programName() -> ProgramNameContext? {
				return getRuleContext(ProgramNameContext.self, 0)
			}
			open
			func libraryEntryProcedureForClause() -> LibraryEntryProcedureForClauseContext? {
				return getRuleContext(LibraryEntryProcedureForClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryEntryProcedureClauseFormat1
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryEntryProcedureClauseFormat1(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryEntryProcedureClauseFormat1(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryEntryProcedureClauseFormat1(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryEntryProcedureClauseFormat1(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryEntryProcedureClauseFormat1() throws -> LibraryEntryProcedureClauseFormat1Context {
		var _localctx: LibraryEntryProcedureClauseFormat1Context = LibraryEntryProcedureClauseFormat1Context(_ctx, getState())
		try enterRule(_localctx, 414, Cobol85Parser.RULE_libraryEntryProcedureClauseFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3092)
		 	try match(Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue)
		 	setState(3093)
		 	try programName()
		 	setState(3095)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3094)
		 		try libraryEntryProcedureForClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryEntryProcedureClauseFormat2Context: ParserRuleContext {
			open
			func ENTRY_PROCEDURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue, 0)
			}
			open
			func programName() -> ProgramNameContext? {
				return getRuleContext(ProgramNameContext.self, 0)
			}
			open
			func libraryEntryProcedureForClause() -> LibraryEntryProcedureForClauseContext? {
				return getRuleContext(LibraryEntryProcedureForClauseContext.self, 0)
			}
			open
			func libraryEntryProcedureWithClause() -> LibraryEntryProcedureWithClauseContext? {
				return getRuleContext(LibraryEntryProcedureWithClauseContext.self, 0)
			}
			open
			func libraryEntryProcedureUsingClause() -> LibraryEntryProcedureUsingClauseContext? {
				return getRuleContext(LibraryEntryProcedureUsingClauseContext.self, 0)
			}
			open
			func libraryEntryProcedureGivingClause() -> LibraryEntryProcedureGivingClauseContext? {
				return getRuleContext(LibraryEntryProcedureGivingClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryEntryProcedureClauseFormat2
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryEntryProcedureClauseFormat2(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryEntryProcedureClauseFormat2(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryEntryProcedureClauseFormat2(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryEntryProcedureClauseFormat2(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryEntryProcedureClauseFormat2() throws -> LibraryEntryProcedureClauseFormat2Context {
		var _localctx: LibraryEntryProcedureClauseFormat2Context = LibraryEntryProcedureClauseFormat2Context(_ctx, getState())
		try enterRule(_localctx, 416, Cobol85Parser.RULE_libraryEntryProcedureClauseFormat2)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3097)
		 	try match(Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue)
		 	setState(3098)
		 	try programName()
		 	setState(3100)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3099)
		 		try libraryEntryProcedureForClause()

		 	}

		 	setState(3103)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3102)
		 		try libraryEntryProcedureWithClause()

		 	}

		 	setState(3106)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.USING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3105)
		 		try libraryEntryProcedureUsingClause()

		 	}

		 	setState(3109)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.GIVING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3108)
		 		try libraryEntryProcedureGivingClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryEntryProcedureForClauseContext: ParserRuleContext {
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryEntryProcedureForClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryEntryProcedureForClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryEntryProcedureForClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryEntryProcedureForClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryEntryProcedureForClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryEntryProcedureForClause() throws -> LibraryEntryProcedureForClauseContext {
		var _localctx: LibraryEntryProcedureForClauseContext = LibraryEntryProcedureForClauseContext(_ctx, getState())
		try enterRule(_localctx, 418, Cobol85Parser.RULE_libraryEntryProcedureForClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3111)
		 	try match(Cobol85Parser.Tokens.FOR.rawValue)
		 	setState(3112)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryEntryProcedureGivingClauseContext: ParserRuleContext {
			open
			func GIVING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GIVING.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryEntryProcedureGivingClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryEntryProcedureGivingClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryEntryProcedureGivingClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryEntryProcedureGivingClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryEntryProcedureGivingClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryEntryProcedureGivingClause() throws -> LibraryEntryProcedureGivingClauseContext {
		var _localctx: LibraryEntryProcedureGivingClauseContext = LibraryEntryProcedureGivingClauseContext(_ctx, getState())
		try enterRule(_localctx, 420, Cobol85Parser.RULE_libraryEntryProcedureGivingClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3114)
		 	try match(Cobol85Parser.Tokens.GIVING.rawValue)
		 	setState(3115)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryEntryProcedureUsingClauseContext: ParserRuleContext {
			open
			func USING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USING.rawValue, 0)
			}
			open
			func libraryEntryProcedureUsingName() -> [LibraryEntryProcedureUsingNameContext] {
				return getRuleContexts(LibraryEntryProcedureUsingNameContext.self)
			}
			open
			func libraryEntryProcedureUsingName(_ i: Int) -> LibraryEntryProcedureUsingNameContext? {
				return getRuleContext(LibraryEntryProcedureUsingNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryEntryProcedureUsingClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryEntryProcedureUsingClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryEntryProcedureUsingClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryEntryProcedureUsingClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryEntryProcedureUsingClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryEntryProcedureUsingClause() throws -> LibraryEntryProcedureUsingClauseContext {
		var _localctx: LibraryEntryProcedureUsingClauseContext = LibraryEntryProcedureUsingClauseContext(_ctx, getState())
		try enterRule(_localctx, 422, Cobol85Parser.RULE_libraryEntryProcedureUsingClause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3117)
		 	try match(Cobol85Parser.Tokens.USING.rawValue)
		 	setState(3119); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3118)
		 			try libraryEntryProcedureUsingName()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3121); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,383,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryEntryProcedureUsingNameContext: ParserRuleContext {
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryEntryProcedureUsingName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryEntryProcedureUsingName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryEntryProcedureUsingName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryEntryProcedureUsingName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryEntryProcedureUsingName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryEntryProcedureUsingName() throws -> LibraryEntryProcedureUsingNameContext {
		var _localctx: LibraryEntryProcedureUsingNameContext = LibraryEntryProcedureUsingNameContext(_ctx, getState())
		try enterRule(_localctx, 424, Cobol85Parser.RULE_libraryEntryProcedureUsingName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3125)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,384, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3123)
		 		try dataName()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3124)
		 		try fileName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryEntryProcedureWithClauseContext: ParserRuleContext {
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
			open
			func libraryEntryProcedureWithName() -> [LibraryEntryProcedureWithNameContext] {
				return getRuleContexts(LibraryEntryProcedureWithNameContext.self)
			}
			open
			func libraryEntryProcedureWithName(_ i: Int) -> LibraryEntryProcedureWithNameContext? {
				return getRuleContext(LibraryEntryProcedureWithNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryEntryProcedureWithClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryEntryProcedureWithClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryEntryProcedureWithClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryEntryProcedureWithClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryEntryProcedureWithClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryEntryProcedureWithClause() throws -> LibraryEntryProcedureWithClauseContext {
		var _localctx: LibraryEntryProcedureWithClauseContext = LibraryEntryProcedureWithClauseContext(_ctx, getState())
		try enterRule(_localctx, 426, Cobol85Parser.RULE_libraryEntryProcedureWithClause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3127)
		 	try match(Cobol85Parser.Tokens.WITH.rawValue)
		 	setState(3129); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3128)
		 			try libraryEntryProcedureWithName()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3131); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,385,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryEntryProcedureWithNameContext: ParserRuleContext {
			open
			func localName() -> LocalNameContext? {
				return getRuleContext(LocalNameContext.self, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryEntryProcedureWithName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryEntryProcedureWithName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryEntryProcedureWithName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryEntryProcedureWithName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryEntryProcedureWithName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryEntryProcedureWithName() throws -> LibraryEntryProcedureWithNameContext {
		var _localctx: LibraryEntryProcedureWithNameContext = LibraryEntryProcedureWithNameContext(_ctx, getState())
		try enterRule(_localctx, 428, Cobol85Parser.RULE_libraryEntryProcedureWithName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3135)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,386, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3133)
		 		try localName()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3134)
		 		try fileName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryIsCommonClauseContext: ParserRuleContext {
			open
			func COMMON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMON.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryIsCommonClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryIsCommonClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryIsCommonClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryIsCommonClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryIsCommonClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryIsCommonClause() throws -> LibraryIsCommonClauseContext {
		var _localctx: LibraryIsCommonClauseContext = LibraryIsCommonClauseContext(_ctx, getState())
		try enterRule(_localctx, 430, Cobol85Parser.RULE_libraryIsCommonClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3138)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3137)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3140)
		 	try match(Cobol85Parser.Tokens.COMMON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryIsGlobalClauseContext: ParserRuleContext {
			open
			func GLOBAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GLOBAL.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryIsGlobalClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryIsGlobalClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryIsGlobalClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryIsGlobalClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryIsGlobalClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryIsGlobalClause() throws -> LibraryIsGlobalClauseContext {
		var _localctx: LibraryIsGlobalClauseContext = LibraryIsGlobalClauseContext(_ctx, getState())
		try enterRule(_localctx, 432, Cobol85Parser.RULE_libraryIsGlobalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3143)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3142)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3145)
		 	try match(Cobol85Parser.Tokens.GLOBAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataDescriptionEntryContext: ParserRuleContext {
			open
			func dataDescriptionEntryFormat1() -> DataDescriptionEntryFormat1Context? {
				return getRuleContext(DataDescriptionEntryFormat1Context.self, 0)
			}
			open
			func dataDescriptionEntryFormat2() -> DataDescriptionEntryFormat2Context? {
				return getRuleContext(DataDescriptionEntryFormat2Context.self, 0)
			}
			open
			func dataDescriptionEntryFormat3() -> DataDescriptionEntryFormat3Context? {
				return getRuleContext(DataDescriptionEntryFormat3Context.self, 0)
			}
			open
			func dataDescriptionEntryExecSql() -> DataDescriptionEntryExecSqlContext? {
				return getRuleContext(DataDescriptionEntryExecSqlContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataDescriptionEntry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataDescriptionEntry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataDescriptionEntry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataDescriptionEntry(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataDescriptionEntry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataDescriptionEntry() throws -> DataDescriptionEntryContext {
		var _localctx: DataDescriptionEntryContext = DataDescriptionEntryContext(_ctx, getState())
		try enterRule(_localctx, 434, Cobol85Parser.RULE_dataDescriptionEntry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3151)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .INTEGERLITERAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3147)
		 		try dataDescriptionEntryFormat1()

		 		break

		 	case .LEVEL_NUMBER_66:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3148)
		 		try dataDescriptionEntryFormat2()

		 		break

		 	case .LEVEL_NUMBER_88:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3149)
		 		try dataDescriptionEntryFormat3()

		 		break

		 	case .EXECSQLLINE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3150)
		 		try dataDescriptionEntryExecSql()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataDescriptionEntryFormat1Context: ParserRuleContext {
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func INTEGERLITERAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTEGERLITERAL.rawValue, 0)
			}
			open
			func LEVEL_NUMBER_77() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue, 0)
			}
			open
			func FILLER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FILLER.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func dataRedefinesClause() -> [DataRedefinesClauseContext] {
				return getRuleContexts(DataRedefinesClauseContext.self)
			}
			open
			func dataRedefinesClause(_ i: Int) -> DataRedefinesClauseContext? {
				return getRuleContext(DataRedefinesClauseContext.self, i)
			}
			open
			func dataIntegerStringClause() -> [DataIntegerStringClauseContext] {
				return getRuleContexts(DataIntegerStringClauseContext.self)
			}
			open
			func dataIntegerStringClause(_ i: Int) -> DataIntegerStringClauseContext? {
				return getRuleContext(DataIntegerStringClauseContext.self, i)
			}
			open
			func dataExternalClause() -> [DataExternalClauseContext] {
				return getRuleContexts(DataExternalClauseContext.self)
			}
			open
			func dataExternalClause(_ i: Int) -> DataExternalClauseContext? {
				return getRuleContext(DataExternalClauseContext.self, i)
			}
			open
			func dataGlobalClause() -> [DataGlobalClauseContext] {
				return getRuleContexts(DataGlobalClauseContext.self)
			}
			open
			func dataGlobalClause(_ i: Int) -> DataGlobalClauseContext? {
				return getRuleContext(DataGlobalClauseContext.self, i)
			}
			open
			func dataTypeDefClause() -> [DataTypeDefClauseContext] {
				return getRuleContexts(DataTypeDefClauseContext.self)
			}
			open
			func dataTypeDefClause(_ i: Int) -> DataTypeDefClauseContext? {
				return getRuleContext(DataTypeDefClauseContext.self, i)
			}
			open
			func dataThreadLocalClause() -> [DataThreadLocalClauseContext] {
				return getRuleContexts(DataThreadLocalClauseContext.self)
			}
			open
			func dataThreadLocalClause(_ i: Int) -> DataThreadLocalClauseContext? {
				return getRuleContext(DataThreadLocalClauseContext.self, i)
			}
			open
			func dataPictureClause() -> [DataPictureClauseContext] {
				return getRuleContexts(DataPictureClauseContext.self)
			}
			open
			func dataPictureClause(_ i: Int) -> DataPictureClauseContext? {
				return getRuleContext(DataPictureClauseContext.self, i)
			}
			open
			func dataCommonOwnLocalClause() -> [DataCommonOwnLocalClauseContext] {
				return getRuleContexts(DataCommonOwnLocalClauseContext.self)
			}
			open
			func dataCommonOwnLocalClause(_ i: Int) -> DataCommonOwnLocalClauseContext? {
				return getRuleContext(DataCommonOwnLocalClauseContext.self, i)
			}
			open
			func dataTypeClause() -> [DataTypeClauseContext] {
				return getRuleContexts(DataTypeClauseContext.self)
			}
			open
			func dataTypeClause(_ i: Int) -> DataTypeClauseContext? {
				return getRuleContext(DataTypeClauseContext.self, i)
			}
			open
			func dataUsingClause() -> [DataUsingClauseContext] {
				return getRuleContexts(DataUsingClauseContext.self)
			}
			open
			func dataUsingClause(_ i: Int) -> DataUsingClauseContext? {
				return getRuleContext(DataUsingClauseContext.self, i)
			}
			open
			func dataUsageClause() -> [DataUsageClauseContext] {
				return getRuleContexts(DataUsageClauseContext.self)
			}
			open
			func dataUsageClause(_ i: Int) -> DataUsageClauseContext? {
				return getRuleContext(DataUsageClauseContext.self, i)
			}
			open
			func dataValueClause() -> [DataValueClauseContext] {
				return getRuleContexts(DataValueClauseContext.self)
			}
			open
			func dataValueClause(_ i: Int) -> DataValueClauseContext? {
				return getRuleContext(DataValueClauseContext.self, i)
			}
			open
			func dataReceivedByClause() -> [DataReceivedByClauseContext] {
				return getRuleContexts(DataReceivedByClauseContext.self)
			}
			open
			func dataReceivedByClause(_ i: Int) -> DataReceivedByClauseContext? {
				return getRuleContext(DataReceivedByClauseContext.self, i)
			}
			open
			func dataOccursClause() -> [DataOccursClauseContext] {
				return getRuleContexts(DataOccursClauseContext.self)
			}
			open
			func dataOccursClause(_ i: Int) -> DataOccursClauseContext? {
				return getRuleContext(DataOccursClauseContext.self, i)
			}
			open
			func dataSignClause() -> [DataSignClauseContext] {
				return getRuleContexts(DataSignClauseContext.self)
			}
			open
			func dataSignClause(_ i: Int) -> DataSignClauseContext? {
				return getRuleContext(DataSignClauseContext.self, i)
			}
			open
			func dataSynchronizedClause() -> [DataSynchronizedClauseContext] {
				return getRuleContexts(DataSynchronizedClauseContext.self)
			}
			open
			func dataSynchronizedClause(_ i: Int) -> DataSynchronizedClauseContext? {
				return getRuleContext(DataSynchronizedClauseContext.self, i)
			}
			open
			func dataJustifiedClause() -> [DataJustifiedClauseContext] {
				return getRuleContexts(DataJustifiedClauseContext.self)
			}
			open
			func dataJustifiedClause(_ i: Int) -> DataJustifiedClauseContext? {
				return getRuleContext(DataJustifiedClauseContext.self, i)
			}
			open
			func dataBlankWhenZeroClause() -> [DataBlankWhenZeroClauseContext] {
				return getRuleContexts(DataBlankWhenZeroClauseContext.self)
			}
			open
			func dataBlankWhenZeroClause(_ i: Int) -> DataBlankWhenZeroClauseContext? {
				return getRuleContext(DataBlankWhenZeroClauseContext.self, i)
			}
			open
			func dataWithLowerBoundsClause() -> [DataWithLowerBoundsClauseContext] {
				return getRuleContexts(DataWithLowerBoundsClauseContext.self)
			}
			open
			func dataWithLowerBoundsClause(_ i: Int) -> DataWithLowerBoundsClauseContext? {
				return getRuleContext(DataWithLowerBoundsClauseContext.self, i)
			}
			open
			func dataAlignedClause() -> [DataAlignedClauseContext] {
				return getRuleContexts(DataAlignedClauseContext.self)
			}
			open
			func dataAlignedClause(_ i: Int) -> DataAlignedClauseContext? {
				return getRuleContext(DataAlignedClauseContext.self, i)
			}
			open
			func dataRecordAreaClause() -> [DataRecordAreaClauseContext] {
				return getRuleContexts(DataRecordAreaClauseContext.self)
			}
			open
			func dataRecordAreaClause(_ i: Int) -> DataRecordAreaClauseContext? {
				return getRuleContext(DataRecordAreaClauseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataDescriptionEntryFormat1
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataDescriptionEntryFormat1(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataDescriptionEntryFormat1(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataDescriptionEntryFormat1(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataDescriptionEntryFormat1(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataDescriptionEntryFormat1() throws -> DataDescriptionEntryFormat1Context {
		var _localctx: DataDescriptionEntryFormat1Context = DataDescriptionEntryFormat1Context(_ctx, getState())
		try enterRule(_localctx, 436, Cobol85Parser.RULE_dataDescriptionEntryFormat1)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3153)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue || _la == Cobol85Parser.Tokens.INTEGERLITERAL.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3156)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,390,_ctx)) {
		 	case 1:
		 		setState(3154)
		 		try match(Cobol85Parser.Tokens.FILLER.rawValue)

		 		break
		 	case 2:
		 		setState(3155)
		 		try dataName()

		 		break
		 	default: break
		 	}
		 	setState(3181)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ALIGNED.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLANK.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.BY.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.COMMON.rawValue,Cobol85Parser.Tokens.COMP.rawValue,Cobol85Parser.Tokens.COMP_1.rawValue,Cobol85Parser.Tokens.COMP_2.rawValue,Cobol85Parser.Tokens.COMP_3.rawValue,Cobol85Parser.Tokens.COMP_4.rawValue,Cobol85Parser.Tokens.COMP_5.rawValue,Cobol85Parser.Tokens.COMPUTATIONAL.rawValue,Cobol85Parser.Tokens.COMPUTATIONAL_1.rawValue,Cobol85Parser.Tokens.COMPUTATIONAL_2.rawValue,Cobol85Parser.Tokens.COMPUTATIONAL_3.rawValue,Cobol85Parser.Tokens.COMPUTATIONAL_4.rawValue,Cobol85Parser.Tokens.COMPUTATIONAL_5.rawValue,Cobol85Parser.Tokens.CONTENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DISPLAY.rawValue,Cobol85Parser.Tokens.DISPLAY_1.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.EXTERNAL.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GLOBAL.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INDEX.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.IS.rawValue,Cobol85Parser.Tokens.JUST.rawValue,Cobol85Parser.Tokens.JUSTIFIED.rawValue,Cobol85Parser.Tokens.KANJI.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEADING.rawValue,Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LOCK.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.OCCURS.rawValue,Cobol85Parser.Tokens.ODT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 266)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.ORDERLY.rawValue,Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PACKED_DECIMAL.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PIC.rawValue,Cobol85Parser.Tokens.PICTURE.rawValue,Cobol85Parser.Tokens.POINTER.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCEDURE_POINTER.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECORD.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REDEFINES.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REFERENCE.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 331)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REQUIRED.rawValue,Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SIGN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue,Cobol85Parser.Tokens.STRING.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 398)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.SYNC.rawValue,Cobol85Parser.Tokens.SYNCHRONIZED.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRAILING.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPE.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.USAGE.rawValue,Cobol85Parser.Tokens.USING.rawValue,Cobol85Parser.Tokens.VALUE.rawValue,Cobol85Parser.Tokens.VALUES.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WITH.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 551)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(3179)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,391, _ctx)) {
		 		case 1:
		 			setState(3158)
		 			try dataRedefinesClause()

		 			break
		 		case 2:
		 			setState(3159)
		 			try dataIntegerStringClause()

		 			break
		 		case 3:
		 			setState(3160)
		 			try dataExternalClause()

		 			break
		 		case 4:
		 			setState(3161)
		 			try dataGlobalClause()

		 			break
		 		case 5:
		 			setState(3162)
		 			try dataTypeDefClause()

		 			break
		 		case 6:
		 			setState(3163)
		 			try dataThreadLocalClause()

		 			break
		 		case 7:
		 			setState(3164)
		 			try dataPictureClause()

		 			break
		 		case 8:
		 			setState(3165)
		 			try dataCommonOwnLocalClause()

		 			break
		 		case 9:
		 			setState(3166)
		 			try dataTypeClause()

		 			break
		 		case 10:
		 			setState(3167)
		 			try dataUsingClause()

		 			break
		 		case 11:
		 			setState(3168)
		 			try dataUsageClause()

		 			break
		 		case 12:
		 			setState(3169)
		 			try dataValueClause()

		 			break
		 		case 13:
		 			setState(3170)
		 			try dataReceivedByClause()

		 			break
		 		case 14:
		 			setState(3171)
		 			try dataOccursClause()

		 			break
		 		case 15:
		 			setState(3172)
		 			try dataSignClause()

		 			break
		 		case 16:
		 			setState(3173)
		 			try dataSynchronizedClause()

		 			break
		 		case 17:
		 			setState(3174)
		 			try dataJustifiedClause()

		 			break
		 		case 18:
		 			setState(3175)
		 			try dataBlankWhenZeroClause()

		 			break
		 		case 19:
		 			setState(3176)
		 			try dataWithLowerBoundsClause()

		 			break
		 		case 20:
		 			setState(3177)
		 			try dataAlignedClause()

		 			break
		 		case 21:
		 			setState(3178)
		 			try dataRecordAreaClause()

		 			break
		 		default: break
		 		}

		 		setState(3183)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3184)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataDescriptionEntryFormat2Context: ParserRuleContext {
			open
			func LEVEL_NUMBER_66() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func dataRenamesClause() -> DataRenamesClauseContext? {
				return getRuleContext(DataRenamesClauseContext.self, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataDescriptionEntryFormat2
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataDescriptionEntryFormat2(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataDescriptionEntryFormat2(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataDescriptionEntryFormat2(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataDescriptionEntryFormat2(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataDescriptionEntryFormat2() throws -> DataDescriptionEntryFormat2Context {
		var _localctx: DataDescriptionEntryFormat2Context = DataDescriptionEntryFormat2Context(_ctx, getState())
		try enterRule(_localctx, 438, Cobol85Parser.RULE_dataDescriptionEntryFormat2)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3186)
		 	try match(Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue)
		 	setState(3187)
		 	try dataName()
		 	setState(3188)
		 	try dataRenamesClause()
		 	setState(3189)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataDescriptionEntryFormat3Context: ParserRuleContext {
			open
			func LEVEL_NUMBER_88() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue, 0)
			}
			open
			func conditionName() -> ConditionNameContext? {
				return getRuleContext(ConditionNameContext.self, 0)
			}
			open
			func dataValueClause() -> DataValueClauseContext? {
				return getRuleContext(DataValueClauseContext.self, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataDescriptionEntryFormat3
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataDescriptionEntryFormat3(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataDescriptionEntryFormat3(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataDescriptionEntryFormat3(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataDescriptionEntryFormat3(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataDescriptionEntryFormat3() throws -> DataDescriptionEntryFormat3Context {
		var _localctx: DataDescriptionEntryFormat3Context = DataDescriptionEntryFormat3Context(_ctx, getState())
		try enterRule(_localctx, 440, Cobol85Parser.RULE_dataDescriptionEntryFormat3)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3191)
		 	try match(Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue)
		 	setState(3192)
		 	try conditionName()
		 	setState(3193)
		 	try dataValueClause()
		 	setState(3194)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataDescriptionEntryExecSqlContext: ParserRuleContext {
			open
			func EXECSQLLINE() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.EXECSQLLINE.rawValue)
			}
			open
			func EXECSQLLINE(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXECSQLLINE.rawValue, i)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataDescriptionEntryExecSql
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataDescriptionEntryExecSql(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataDescriptionEntryExecSql(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataDescriptionEntryExecSql(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataDescriptionEntryExecSql(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataDescriptionEntryExecSql() throws -> DataDescriptionEntryExecSqlContext {
		var _localctx: DataDescriptionEntryExecSqlContext = DataDescriptionEntryExecSqlContext(_ctx, getState())
		try enterRule(_localctx, 442, Cobol85Parser.RULE_dataDescriptionEntryExecSql)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3197); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3196)
		 			try match(Cobol85Parser.Tokens.EXECSQLLINE.rawValue)


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3199); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,393,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(3202)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DOT_FS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3201)
		 		try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataAlignedClauseContext: ParserRuleContext {
			open
			func ALIGNED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALIGNED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataAlignedClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataAlignedClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataAlignedClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataAlignedClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataAlignedClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataAlignedClause() throws -> DataAlignedClauseContext {
		var _localctx: DataAlignedClauseContext = DataAlignedClauseContext(_ctx, getState())
		try enterRule(_localctx, 444, Cobol85Parser.RULE_dataAlignedClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3204)
		 	try match(Cobol85Parser.Tokens.ALIGNED.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataBlankWhenZeroClauseContext: ParserRuleContext {
			open
			func BLANK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BLANK.rawValue, 0)
			}
			open
			func ZERO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZERO.rawValue, 0)
			}
			open
			func ZEROS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZEROS.rawValue, 0)
			}
			open
			func ZEROES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZEROES.rawValue, 0)
			}
			open
			func WHEN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WHEN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataBlankWhenZeroClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataBlankWhenZeroClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataBlankWhenZeroClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataBlankWhenZeroClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataBlankWhenZeroClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataBlankWhenZeroClause() throws -> DataBlankWhenZeroClauseContext {
		var _localctx: DataBlankWhenZeroClauseContext = DataBlankWhenZeroClauseContext(_ctx, getState())
		try enterRule(_localctx, 446, Cobol85Parser.RULE_dataBlankWhenZeroClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3206)
		 	try match(Cobol85Parser.Tokens.BLANK.rawValue)
		 	setState(3208)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WHEN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3207)
		 		try match(Cobol85Parser.Tokens.WHEN.rawValue)

		 	}

		 	setState(3210)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 521)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataCommonOwnLocalClauseContext: ParserRuleContext {
			open
			func COMMON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMON.rawValue, 0)
			}
			open
			func OWN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OWN.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOCAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataCommonOwnLocalClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataCommonOwnLocalClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataCommonOwnLocalClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataCommonOwnLocalClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataCommonOwnLocalClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataCommonOwnLocalClause() throws -> DataCommonOwnLocalClauseContext {
		var _localctx: DataCommonOwnLocalClauseContext = DataCommonOwnLocalClauseContext(_ctx, getState())
		try enterRule(_localctx, 448, Cobol85Parser.RULE_dataCommonOwnLocalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3212)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.COMMON.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.LOCAL.rawValue || _la == Cobol85Parser.Tokens.OWN.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataExternalClauseContext: ParserRuleContext {
			open
			func EXTERNAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXTERNAL.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataExternalClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataExternalClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataExternalClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataExternalClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataExternalClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataExternalClause() throws -> DataExternalClauseContext {
		var _localctx: DataExternalClauseContext = DataExternalClauseContext(_ctx, getState())
		try enterRule(_localctx, 450, Cobol85Parser.RULE_dataExternalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3215)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3214)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3217)
		 	try match(Cobol85Parser.Tokens.EXTERNAL.rawValue)
		 	setState(3220)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,397,_ctx)) {
		 	case 1:
		 		setState(3218)
		 		try match(Cobol85Parser.Tokens.BY.rawValue)
		 		setState(3219)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataGlobalClauseContext: ParserRuleContext {
			open
			func GLOBAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GLOBAL.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataGlobalClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataGlobalClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataGlobalClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataGlobalClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataGlobalClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataGlobalClause() throws -> DataGlobalClauseContext {
		var _localctx: DataGlobalClauseContext = DataGlobalClauseContext(_ctx, getState())
		try enterRule(_localctx, 452, Cobol85Parser.RULE_dataGlobalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3223)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3222)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3225)
		 	try match(Cobol85Parser.Tokens.GLOBAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataIntegerStringClauseContext: ParserRuleContext {
			open
			func INTEGER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTEGER.rawValue, 0)
			}
			open
			func STRING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STRING.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataIntegerStringClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataIntegerStringClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataIntegerStringClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataIntegerStringClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataIntegerStringClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataIntegerStringClause() throws -> DataIntegerStringClauseContext {
		var _localctx: DataIntegerStringClauseContext = DataIntegerStringClauseContext(_ctx, getState())
		try enterRule(_localctx, 454, Cobol85Parser.RULE_dataIntegerStringClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3227)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.INTEGER.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.STRING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataJustifiedClauseContext: ParserRuleContext {
			open
			func JUSTIFIED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.JUSTIFIED.rawValue, 0)
			}
			open
			func JUST() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.JUST.rawValue, 0)
			}
			open
			func RIGHT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RIGHT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataJustifiedClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataJustifiedClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataJustifiedClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataJustifiedClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataJustifiedClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataJustifiedClause() throws -> DataJustifiedClauseContext {
		var _localctx: DataJustifiedClauseContext = DataJustifiedClauseContext(_ctx, getState())
		try enterRule(_localctx, 456, Cobol85Parser.RULE_dataJustifiedClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3229)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.JUST.rawValue || _la == Cobol85Parser.Tokens.JUSTIFIED.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3231)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.RIGHT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3230)
		 		try match(Cobol85Parser.Tokens.RIGHT.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataOccursClauseContext: ParserRuleContext {
			open
			func OCCURS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OCCURS.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func dataOccursTo() -> DataOccursToContext? {
				return getRuleContext(DataOccursToContext.self, 0)
			}
			open
			func TIMES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TIMES.rawValue, 0)
			}
			open
			func DEPENDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEPENDING.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func dataOccursSort() -> [DataOccursSortContext] {
				return getRuleContexts(DataOccursSortContext.self)
			}
			open
			func dataOccursSort(_ i: Int) -> DataOccursSortContext? {
				return getRuleContext(DataOccursSortContext.self, i)
			}
			open
			func INDEXED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INDEXED.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOCAL.rawValue, 0)
			}
			open
			func indexName() -> [IndexNameContext] {
				return getRuleContexts(IndexNameContext.self)
			}
			open
			func indexName(_ i: Int) -> IndexNameContext? {
				return getRuleContext(IndexNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataOccursClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataOccursClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataOccursClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataOccursClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataOccursClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataOccursClause() throws -> DataOccursClauseContext {
		var _localctx: DataOccursClauseContext = DataOccursClauseContext(_ctx, getState())
		try enterRule(_localctx, 458, Cobol85Parser.RULE_dataOccursClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3233)
		 	try match(Cobol85Parser.Tokens.OCCURS.rawValue)
		 	setState(3234)
		 	try integerLiteral()
		 	setState(3236)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3235)
		 		try dataOccursTo()

		 	}

		 	setState(3239)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TIMES.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3238)
		 		try match(Cobol85Parser.Tokens.TIMES.rawValue)

		 	}

		 	setState(3246)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DEPENDING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3241)
		 		try match(Cobol85Parser.Tokens.DEPENDING.rawValue)
		 		setState(3243)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3242)
		 			try match(Cobol85Parser.Tokens.ON.rawValue)

		 		}

		 		setState(3245)
		 		try qualifiedDataName()

		 	}

		 	setState(3251)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ASCENDING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.DESCENDING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3248)
		 		try dataOccursSort()


		 		setState(3253)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3266)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.INDEXED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3254)
		 		try match(Cobol85Parser.Tokens.INDEXED.rawValue)
		 		setState(3256)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.BY.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3255)
		 			try match(Cobol85Parser.Tokens.BY.rawValue)

		 		}

		 		setState(3259)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,406,_ctx)) {
		 		case 1:
		 			setState(3258)
		 			try match(Cobol85Parser.Tokens.LOCAL.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(3262); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(3261)
		 				try indexName()


		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(3264); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,407,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataOccursToContext: ParserRuleContext {
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataOccursTo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataOccursTo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataOccursTo(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataOccursTo(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataOccursTo(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataOccursTo() throws -> DataOccursToContext {
		var _localctx: DataOccursToContext = DataOccursToContext(_ctx, getState())
		try enterRule(_localctx, 460, Cobol85Parser.RULE_dataOccursTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3268)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(3269)
		 	try integerLiteral()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataOccursSortContext: ParserRuleContext {
			open
			func ASCENDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASCENDING.rawValue, 0)
			}
			open
			func DESCENDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DESCENDING.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func qualifiedDataName() -> [QualifiedDataNameContext] {
				return getRuleContexts(QualifiedDataNameContext.self)
			}
			open
			func qualifiedDataName(_ i: Int) -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataOccursSort
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataOccursSort(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataOccursSort(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataOccursSort(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataOccursSort(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataOccursSort() throws -> DataOccursSortContext {
		var _localctx: DataOccursSortContext = DataOccursSortContext(_ctx, getState())
		try enterRule(_localctx, 462, Cobol85Parser.RULE_dataOccursSort)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3271)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ASCENDING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.DESCENDING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3273)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.KEY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3272)
		 		try match(Cobol85Parser.Tokens.KEY.rawValue)

		 	}

		 	setState(3276)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3275)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3279); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3278)
		 			try qualifiedDataName()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3281); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,411,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataPictureClauseContext: ParserRuleContext {
			open
			func pictureString() -> PictureStringContext? {
				return getRuleContext(PictureStringContext.self, 0)
			}
			open
			func PICTURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PICTURE.rawValue, 0)
			}
			open
			func PIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PIC.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataPictureClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataPictureClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataPictureClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataPictureClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataPictureClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataPictureClause() throws -> DataPictureClauseContext {
		var _localctx: DataPictureClauseContext = DataPictureClauseContext(_ctx, getState())
		try enterRule(_localctx, 464, Cobol85Parser.RULE_dataPictureClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3283)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.PIC.rawValue || _la == Cobol85Parser.Tokens.PICTURE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3285)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3284)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3287)
		 	try pictureString()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PictureStringContext: ParserRuleContext {
			open
			func pictureChars() -> [PictureCharsContext] {
				return getRuleContexts(PictureCharsContext.self)
			}
			open
			func pictureChars(_ i: Int) -> PictureCharsContext? {
				return getRuleContext(PictureCharsContext.self, i)
			}
			open
			func pictureCardinality() -> [PictureCardinalityContext] {
				return getRuleContexts(PictureCardinalityContext.self)
			}
			open
			func pictureCardinality(_ i: Int) -> PictureCardinalityContext? {
				return getRuleContext(PictureCardinalityContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_pictureString
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPictureString(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPictureString(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPictureString(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPictureString(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pictureString() throws -> PictureStringContext {
		var _localctx: PictureStringContext = PictureStringContext(_ctx, getState())
		try enterRule(_localctx, 466, Cobol85Parser.RULE_pictureString)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3297); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3290); 
		 			try _errHandler.sync(self)
		 			_alt = 1;
		 			repeat {
		 				switch (_alt) {
		 				case 1:
		 					setState(3289)
		 					try pictureChars()


		 					break
		 				default:
		 					throw ANTLRException.recognition(e: NoViableAltException(self))
		 				}
		 				setState(3292); 
		 				try _errHandler.sync(self)
		 				_alt = try getInterpreter().adaptivePredict(_input,413,_ctx)
		 			} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 			setState(3295)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,414,_ctx)) {
		 			case 1:
		 				setState(3294)
		 				try pictureCardinality()

		 				break
		 			default: break
		 			}


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3299); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,415,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PictureCharsContext: ParserRuleContext {
			open
			func DOLLARCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOLLARCHAR.rawValue, 0)
			}
			open
			func IDENTIFIER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IDENTIFIER.rawValue, 0)
			}
			open
			func NUMERICLITERAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMERICLITERAL.rawValue, 0)
			}
			open
			func SLASHCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SLASHCHAR.rawValue, 0)
			}
			open
			func COMMACHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMACHAR.rawValue, 0)
			}
			open
			func DOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT.rawValue, 0)
			}
			open
			func COLONCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COLONCHAR.rawValue, 0)
			}
			open
			func ASTERISKCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASTERISKCHAR.rawValue, 0)
			}
			open
			func DOUBLEASTERISKCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOUBLEASTERISKCHAR.rawValue, 0)
			}
			open
			func LPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, 0)
			}
			open
			func RPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, 0)
			}
			open
			func PLUSCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PLUSCHAR.rawValue, 0)
			}
			open
			func MINUSCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MINUSCHAR.rawValue, 0)
			}
			open
			func LESSTHANCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LESSTHANCHAR.rawValue, 0)
			}
			open
			func MORETHANCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MORETHANCHAR.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_pictureChars
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPictureChars(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPictureChars(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPictureChars(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPictureChars(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pictureChars() throws -> PictureCharsContext {
		var _localctx: PictureCharsContext = PictureCharsContext(_ctx, getState())
		try enterRule(_localctx, 468, Cobol85Parser.RULE_pictureChars)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3317)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DOLLARCHAR:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3301)
		 		try match(Cobol85Parser.Tokens.DOLLARCHAR.rawValue)

		 		break

		 	case .IDENTIFIER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3302)
		 		try match(Cobol85Parser.Tokens.IDENTIFIER.rawValue)

		 		break

		 	case .NUMERICLITERAL:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3303)
		 		try match(Cobol85Parser.Tokens.NUMERICLITERAL.rawValue)

		 		break

		 	case .SLASHCHAR:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3304)
		 		try match(Cobol85Parser.Tokens.SLASHCHAR.rawValue)

		 		break

		 	case .COMMACHAR:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3305)
		 		try match(Cobol85Parser.Tokens.COMMACHAR.rawValue)

		 		break

		 	case .DOT:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3306)
		 		try match(Cobol85Parser.Tokens.DOT.rawValue)

		 		break

		 	case .COLONCHAR:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(3307)
		 		try match(Cobol85Parser.Tokens.COLONCHAR.rawValue)

		 		break

		 	case .ASTERISKCHAR:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(3308)
		 		try match(Cobol85Parser.Tokens.ASTERISKCHAR.rawValue)

		 		break

		 	case .DOUBLEASTERISKCHAR:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(3309)
		 		try match(Cobol85Parser.Tokens.DOUBLEASTERISKCHAR.rawValue)

		 		break

		 	case .LPARENCHAR:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(3310)
		 		try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)

		 		break

		 	case .RPARENCHAR:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(3311)
		 		try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		 		break

		 	case .PLUSCHAR:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(3312)
		 		try match(Cobol85Parser.Tokens.PLUSCHAR.rawValue)

		 		break

		 	case .MINUSCHAR:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(3313)
		 		try match(Cobol85Parser.Tokens.MINUSCHAR.rawValue)

		 		break

		 	case .LESSTHANCHAR:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(3314)
		 		try match(Cobol85Parser.Tokens.LESSTHANCHAR.rawValue)

		 		break

		 	case .MORETHANCHAR:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(3315)
		 		try match(Cobol85Parser.Tokens.MORETHANCHAR.rawValue)

		 		break
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(3316)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PictureCardinalityContext: ParserRuleContext {
			open
			func LPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func RPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_pictureCardinality
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPictureCardinality(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPictureCardinality(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPictureCardinality(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPictureCardinality(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pictureCardinality() throws -> PictureCardinalityContext {
		var _localctx: PictureCardinalityContext = PictureCardinalityContext(_ctx, getState())
		try enterRule(_localctx, 470, Cobol85Parser.RULE_pictureCardinality)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3319)
		 	try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
		 	setState(3320)
		 	try integerLiteral()
		 	setState(3321)
		 	try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataReceivedByClauseContext: ParserRuleContext {
			open
			func CONTENT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTENT.rawValue, 0)
			}
			open
			func REFERENCE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REFERENCE.rawValue, 0)
			}
			open
			func REF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REF.rawValue, 0)
			}
			open
			func RECEIVED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECEIVED.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataReceivedByClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataReceivedByClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataReceivedByClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataReceivedByClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataReceivedByClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataReceivedByClause() throws -> DataReceivedByClauseContext {
		var _localctx: DataReceivedByClauseContext = DataReceivedByClauseContext(_ctx, getState())
		try enterRule(_localctx, 472, Cobol85Parser.RULE_dataReceivedByClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3324)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.RECEIVED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3323)
		 		try match(Cobol85Parser.Tokens.RECEIVED.rawValue)

		 	}

		 	setState(3327)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.BY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3326)
		 		try match(Cobol85Parser.Tokens.BY.rawValue)

		 	}

		 	setState(3329)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.CONTENT.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.REF.rawValue || _la == Cobol85Parser.Tokens.REFERENCE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataRecordAreaClauseContext: ParserRuleContext {
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func AREA() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AREA.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataRecordAreaClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataRecordAreaClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataRecordAreaClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataRecordAreaClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataRecordAreaClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataRecordAreaClause() throws -> DataRecordAreaClauseContext {
		var _localctx: DataRecordAreaClauseContext = DataRecordAreaClauseContext(_ctx, getState())
		try enterRule(_localctx, 474, Cobol85Parser.RULE_dataRecordAreaClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3331)
		 	try match(Cobol85Parser.Tokens.RECORD.rawValue)
		 	setState(3332)
		 	try match(Cobol85Parser.Tokens.AREA.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataRedefinesClauseContext: ParserRuleContext {
			open
			func REDEFINES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REDEFINES.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataRedefinesClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataRedefinesClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataRedefinesClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataRedefinesClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataRedefinesClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataRedefinesClause() throws -> DataRedefinesClauseContext {
		var _localctx: DataRedefinesClauseContext = DataRedefinesClauseContext(_ctx, getState())
		try enterRule(_localctx, 476, Cobol85Parser.RULE_dataRedefinesClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3334)
		 	try match(Cobol85Parser.Tokens.REDEFINES.rawValue)
		 	setState(3335)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataRenamesClauseContext: ParserRuleContext {
			open
			func RENAMES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RENAMES.rawValue, 0)
			}
			open
			func qualifiedDataName() -> [QualifiedDataNameContext] {
				return getRuleContexts(QualifiedDataNameContext.self)
			}
			open
			func qualifiedDataName(_ i: Int) -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, i)
			}
			open
			func THROUGH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THROUGH.rawValue, 0)
			}
			open
			func THRU() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THRU.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataRenamesClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataRenamesClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataRenamesClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataRenamesClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataRenamesClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataRenamesClause() throws -> DataRenamesClauseContext {
		var _localctx: DataRenamesClauseContext = DataRenamesClauseContext(_ctx, getState())
		try enterRule(_localctx, 478, Cobol85Parser.RULE_dataRenamesClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3337)
		 	try match(Cobol85Parser.Tokens.RENAMES.rawValue)
		 	setState(3338)
		 	try qualifiedDataName()
		 	setState(3341)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3339)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3340)
		 		try qualifiedDataName()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataSignClauseContext: ParserRuleContext {
			open
			func LEADING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEADING.rawValue, 0)
			}
			open
			func TRAILING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TRAILING.rawValue, 0)
			}
			open
			func SIGN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIGN.rawValue, 0)
			}
			open
			func SEPARATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEPARATE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataSignClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataSignClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataSignClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataSignClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataSignClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataSignClause() throws -> DataSignClauseContext {
		var _localctx: DataSignClauseContext = DataSignClauseContext(_ctx, getState())
		try enterRule(_localctx, 480, Cobol85Parser.RULE_dataSignClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3347)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SIGN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3343)
		 		try match(Cobol85Parser.Tokens.SIGN.rawValue)
		 		setState(3345)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3344)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}


		 	}

		 	setState(3349)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.LEADING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.TRAILING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3354)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SEPARATE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3350)
		 		try match(Cobol85Parser.Tokens.SEPARATE.rawValue)
		 		setState(3352)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.CHARACTER.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3351)
		 			try match(Cobol85Parser.Tokens.CHARACTER.rawValue)

		 		}


		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataSynchronizedClauseContext: ParserRuleContext {
			open
			func SYNCHRONIZED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SYNCHRONIZED.rawValue, 0)
			}
			open
			func SYNC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SYNC.rawValue, 0)
			}
			open
			func LEFT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEFT.rawValue, 0)
			}
			open
			func RIGHT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RIGHT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataSynchronizedClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataSynchronizedClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataSynchronizedClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataSynchronizedClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataSynchronizedClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataSynchronizedClause() throws -> DataSynchronizedClauseContext {
		var _localctx: DataSynchronizedClauseContext = DataSynchronizedClauseContext(_ctx, getState())
		try enterRule(_localctx, 482, Cobol85Parser.RULE_dataSynchronizedClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3356)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.SYNC.rawValue || _la == Cobol85Parser.Tokens.SYNCHRONIZED.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3358)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.LEFT.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.RIGHT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3357)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.LEFT.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.RIGHT.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataThreadLocalClauseContext: ParserRuleContext {
			open
			func THREAD_LOCAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THREAD_LOCAL.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataThreadLocalClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataThreadLocalClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataThreadLocalClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataThreadLocalClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataThreadLocalClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataThreadLocalClause() throws -> DataThreadLocalClauseContext {
		var _localctx: DataThreadLocalClauseContext = DataThreadLocalClauseContext(_ctx, getState())
		try enterRule(_localctx, 484, Cobol85Parser.RULE_dataThreadLocalClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3361)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3360)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3363)
		 	try match(Cobol85Parser.Tokens.THREAD_LOCAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataTypeClauseContext: ParserRuleContext {
			open
			func TYPE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TYPE.rawValue, 0)
			}
			open
			func SHORT_DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SHORT_DATE.rawValue, 0)
			}
			open
			func LONG_DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LONG_DATE.rawValue, 0)
			}
			open
			func NUMERIC_DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMERIC_DATE.rawValue, 0)
			}
			open
			func NUMERIC_TIME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMERIC_TIME.rawValue, 0)
			}
			open
			func LONG_TIME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LONG_TIME.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataTypeClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataTypeClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataTypeClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataTypeClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataTypeClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataTypeClause() throws -> DataTypeClauseContext {
		var _localctx: DataTypeClauseContext = DataTypeClauseContext(_ctx, getState())
		try enterRule(_localctx, 486, Cobol85Parser.RULE_dataTypeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3365)
		 	try match(Cobol85Parser.Tokens.TYPE.rawValue)
		 	setState(3367)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3366)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3369)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 287)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.SHORT_DATE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataTypeDefClauseContext: ParserRuleContext {
			open
			func TYPEDEF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TYPEDEF.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataTypeDefClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataTypeDefClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataTypeDefClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataTypeDefClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataTypeDefClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataTypeDefClause() throws -> DataTypeDefClauseContext {
		var _localctx: DataTypeDefClauseContext = DataTypeDefClauseContext(_ctx, getState())
		try enterRule(_localctx, 488, Cobol85Parser.RULE_dataTypeDefClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3372)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3371)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(3374)
		 	try match(Cobol85Parser.Tokens.TYPEDEF.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataUsageClauseContext: ParserRuleContext {
			open
			func BINARY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BINARY.rawValue, 0)
			}
			open
			func BIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BIT.rawValue, 0)
			}
			open
			func COMP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMP.rawValue, 0)
			}
			open
			func COMP_1() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMP_1.rawValue, 0)
			}
			open
			func COMP_2() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMP_2.rawValue, 0)
			}
			open
			func COMP_3() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMP_3.rawValue, 0)
			}
			open
			func COMP_4() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMP_4.rawValue, 0)
			}
			open
			func COMP_5() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMP_5.rawValue, 0)
			}
			open
			func COMPUTATIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMPUTATIONAL.rawValue, 0)
			}
			open
			func COMPUTATIONAL_1() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMPUTATIONAL_1.rawValue, 0)
			}
			open
			func COMPUTATIONAL_2() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMPUTATIONAL_2.rawValue, 0)
			}
			open
			func COMPUTATIONAL_3() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMPUTATIONAL_3.rawValue, 0)
			}
			open
			func COMPUTATIONAL_4() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMPUTATIONAL_4.rawValue, 0)
			}
			open
			func COMPUTATIONAL_5() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMPUTATIONAL_5.rawValue, 0)
			}
			open
			func CONTROL_POINT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTROL_POINT.rawValue, 0)
			}
			open
			func DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATE.rawValue, 0)
			}
			open
			func DISPLAY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISPLAY.rawValue, 0)
			}
			open
			func DISPLAY_1() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISPLAY_1.rawValue, 0)
			}
			open
			func DOUBLE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOUBLE.rawValue, 0)
			}
			open
			func EVENT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EVENT.rawValue, 0)
			}
			open
			func FUNCTION_POINTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KANJI() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KANJI.rawValue, 0)
			}
			open
			func LOCK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOCK.rawValue, 0)
			}
			open
			func NATIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIONAL.rawValue, 0)
			}
			open
			func PACKED_DECIMAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PACKED_DECIMAL.rawValue, 0)
			}
			open
			func POINTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.POINTER.rawValue, 0)
			}
			open
			func PROCEDURE_POINTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROCEDURE_POINTER.rawValue, 0)
			}
			open
			func REAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REAL.rawValue, 0)
			}
			open
			func TASK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TASK.rawValue, 0)
			}
			open
			func USAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USAGE.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func TRUNCATED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TRUNCATED.rawValue, 0)
			}
			open
			func EXTENDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXTENDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataUsageClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataUsageClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataUsageClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataUsageClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataUsageClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataUsageClause() throws -> DataUsageClauseContext {
		var _localctx: DataUsageClauseContext = DataUsageClauseContext(_ctx, getState())
		try enterRule(_localctx, 490, Cobol85Parser.RULE_dataUsageClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3380)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.USAGE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3376)
		 		try match(Cobol85Parser.Tokens.USAGE.rawValue)
		 		setState(3378)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3377)
		 			try match(Cobol85Parser.Tokens.IS.rawValue)

		 		}


		 	}

		 	setState(3415)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .BINARY:
		 		setState(3382)
		 		try match(Cobol85Parser.Tokens.BINARY.rawValue)
		 		setState(3384)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,430,_ctx)) {
		 		case 1:
		 			setState(3383)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == Cobol85Parser.Tokens.EXTENDED.rawValue
		 			          testSet = testSet || _la == Cobol85Parser.Tokens.TRUNCATED.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}

		 		break

		 	case .BIT:
		 		setState(3386)
		 		try match(Cobol85Parser.Tokens.BIT.rawValue)

		 		break

		 	case .COMP:
		 		setState(3387)
		 		try match(Cobol85Parser.Tokens.COMP.rawValue)

		 		break

		 	case .COMP_1:
		 		setState(3388)
		 		try match(Cobol85Parser.Tokens.COMP_1.rawValue)

		 		break

		 	case .COMP_2:
		 		setState(3389)
		 		try match(Cobol85Parser.Tokens.COMP_2.rawValue)

		 		break

		 	case .COMP_3:
		 		setState(3390)
		 		try match(Cobol85Parser.Tokens.COMP_3.rawValue)

		 		break

		 	case .COMP_4:
		 		setState(3391)
		 		try match(Cobol85Parser.Tokens.COMP_4.rawValue)

		 		break

		 	case .COMP_5:
		 		setState(3392)
		 		try match(Cobol85Parser.Tokens.COMP_5.rawValue)

		 		break

		 	case .COMPUTATIONAL:
		 		setState(3393)
		 		try match(Cobol85Parser.Tokens.COMPUTATIONAL.rawValue)

		 		break

		 	case .COMPUTATIONAL_1:
		 		setState(3394)
		 		try match(Cobol85Parser.Tokens.COMPUTATIONAL_1.rawValue)

		 		break

		 	case .COMPUTATIONAL_2:
		 		setState(3395)
		 		try match(Cobol85Parser.Tokens.COMPUTATIONAL_2.rawValue)

		 		break

		 	case .COMPUTATIONAL_3:
		 		setState(3396)
		 		try match(Cobol85Parser.Tokens.COMPUTATIONAL_3.rawValue)

		 		break

		 	case .COMPUTATIONAL_4:
		 		setState(3397)
		 		try match(Cobol85Parser.Tokens.COMPUTATIONAL_4.rawValue)

		 		break

		 	case .COMPUTATIONAL_5:
		 		setState(3398)
		 		try match(Cobol85Parser.Tokens.COMPUTATIONAL_5.rawValue)

		 		break

		 	case .CONTROL_POINT:
		 		setState(3399)
		 		try match(Cobol85Parser.Tokens.CONTROL_POINT.rawValue)

		 		break

		 	case .DATE:
		 		setState(3400)
		 		try match(Cobol85Parser.Tokens.DATE.rawValue)

		 		break

		 	case .DISPLAY:
		 		setState(3401)
		 		try match(Cobol85Parser.Tokens.DISPLAY.rawValue)

		 		break

		 	case .DISPLAY_1:
		 		setState(3402)
		 		try match(Cobol85Parser.Tokens.DISPLAY_1.rawValue)

		 		break

		 	case .DOUBLE:
		 		setState(3403)
		 		try match(Cobol85Parser.Tokens.DOUBLE.rawValue)

		 		break

		 	case .EVENT:
		 		setState(3404)
		 		try match(Cobol85Parser.Tokens.EVENT.rawValue)

		 		break

		 	case .FUNCTION_POINTER:
		 		setState(3405)
		 		try match(Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue)

		 		break

		 	case .INDEX:
		 		setState(3406)
		 		try match(Cobol85Parser.Tokens.INDEX.rawValue)

		 		break

		 	case .KANJI:
		 		setState(3407)
		 		try match(Cobol85Parser.Tokens.KANJI.rawValue)

		 		break

		 	case .LOCK:
		 		setState(3408)
		 		try match(Cobol85Parser.Tokens.LOCK.rawValue)

		 		break

		 	case .NATIONAL:
		 		setState(3409)
		 		try match(Cobol85Parser.Tokens.NATIONAL.rawValue)

		 		break

		 	case .PACKED_DECIMAL:
		 		setState(3410)
		 		try match(Cobol85Parser.Tokens.PACKED_DECIMAL.rawValue)

		 		break

		 	case .POINTER:
		 		setState(3411)
		 		try match(Cobol85Parser.Tokens.POINTER.rawValue)

		 		break

		 	case .PROCEDURE_POINTER:
		 		setState(3412)
		 		try match(Cobol85Parser.Tokens.PROCEDURE_POINTER.rawValue)

		 		break

		 	case .REAL:
		 		setState(3413)
		 		try match(Cobol85Parser.Tokens.REAL.rawValue)

		 		break

		 	case .TASK:
		 		setState(3414)
		 		try match(Cobol85Parser.Tokens.TASK.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataUsingClauseContext: ParserRuleContext {
			open
			func USING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USING.rawValue, 0)
			}
			open
			func LANGUAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LANGUAGE.rawValue, 0)
			}
			open
			func CONVENTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONVENTION.rawValue, 0)
			}
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataUsingClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataUsingClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataUsingClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataUsingClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataUsingClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataUsingClause() throws -> DataUsingClauseContext {
		var _localctx: DataUsingClauseContext = DataUsingClauseContext(_ctx, getState())
		try enterRule(_localctx, 492, Cobol85Parser.RULE_dataUsingClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3417)
		 	try match(Cobol85Parser.Tokens.USING.rawValue)
		 	setState(3418)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.CONVENTION.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.LANGUAGE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3420)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.OF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3419)
		 		try match(Cobol85Parser.Tokens.OF.rawValue)

		 	}

		 	setState(3424)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,433, _ctx)) {
		 	case 1:
		 		setState(3422)
		 		try cobolWord()

		 		break
		 	case 2:
		 		setState(3423)
		 		try dataName()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataValueClauseContext: ParserRuleContext {
			open
			func dataValueInterval() -> [DataValueIntervalContext] {
				return getRuleContexts(DataValueIntervalContext.self)
			}
			open
			func dataValueInterval(_ i: Int) -> DataValueIntervalContext? {
				return getRuleContext(DataValueIntervalContext.self, i)
			}
			open
			func VALUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VALUE.rawValue, 0)
			}
			open
			func VALUES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VALUES.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func ARE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ARE.rawValue, 0)
			}
			open
			func COMMACHAR() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.COMMACHAR.rawValue)
			}
			open
			func COMMACHAR(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMACHAR.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataValueClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataValueClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataValueClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataValueClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataValueClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataValueClause() throws -> DataValueClauseContext {
		var _localctx: DataValueClauseContext = DataValueClauseContext(_ctx, getState())
		try enterRule(_localctx, 494, Cobol85Parser.RULE_dataValueClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3434)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .VALUE:
		 	 	setState(3426)
		 	 	try match(Cobol85Parser.Tokens.VALUE.rawValue)
		 	 	setState(3428)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(3427)
		 	 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	 	}


		 		break

		 	case .VALUES:
		 	 	setState(3430)
		 	 	try match(Cobol85Parser.Tokens.VALUES.rawValue)
		 	 	setState(3432)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ARE.rawValue
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(3431)
		 	 		try match(Cobol85Parser.Tokens.ARE.rawValue)

		 	 	}


		 		break
		 	case .ABORT:fallthrough
		 	case .ALL:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FALSE:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .HIGH_VALUE:fallthrough
		 	case .HIGH_VALUES:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .LOW_VALUE:fallthrough
		 	case .LOW_VALUES:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .QUOTE:fallthrough
		 	case .QUOTES:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SPACE:fallthrough
		 	case .SPACES:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .ZEROS:fallthrough
		 	case .ZEROES:fallthrough
		 	case .NONNUMERICLITERAL:fallthrough
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:fallthrough
		 	case .NUMERICLITERAL:fallthrough
		 	case .IDENTIFIER:
		 		break
		 	default:
		 		break
		 	}
		 	setState(3436)
		 	try dataValueInterval()
		 	setState(3443)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,438,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3438)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMACHAR.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(3437)
		 				try match(Cobol85Parser.Tokens.COMMACHAR.rawValue)

		 			}

		 			setState(3440)
		 			try dataValueInterval()

		 	 
		 		}
		 		setState(3445)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,438,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataValueIntervalContext: ParserRuleContext {
			open
			func dataValueIntervalFrom() -> DataValueIntervalFromContext? {
				return getRuleContext(DataValueIntervalFromContext.self, 0)
			}
			open
			func dataValueIntervalTo() -> DataValueIntervalToContext? {
				return getRuleContext(DataValueIntervalToContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataValueInterval
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataValueInterval(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataValueInterval(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataValueInterval(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataValueInterval(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataValueInterval() throws -> DataValueIntervalContext {
		var _localctx: DataValueIntervalContext = DataValueIntervalContext(_ctx, getState())
		try enterRule(_localctx, 496, Cobol85Parser.RULE_dataValueInterval)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3446)
		 	try dataValueIntervalFrom()
		 	setState(3448)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3447)
		 		try dataValueIntervalTo()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataValueIntervalFromContext: ParserRuleContext {
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataValueIntervalFrom
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataValueIntervalFrom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataValueIntervalFrom(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataValueIntervalFrom(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataValueIntervalFrom(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataValueIntervalFrom() throws -> DataValueIntervalFromContext {
		var _localctx: DataValueIntervalFromContext = DataValueIntervalFromContext(_ctx, getState())
		try enterRule(_localctx, 498, Cobol85Parser.RULE_dataValueIntervalFrom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3452)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,440, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3450)
		 		try literal()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3451)
		 		try cobolWord()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataValueIntervalToContext: ParserRuleContext {
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func THROUGH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THROUGH.rawValue, 0)
			}
			open
			func THRU() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THRU.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataValueIntervalTo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataValueIntervalTo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataValueIntervalTo(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataValueIntervalTo(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataValueIntervalTo(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataValueIntervalTo() throws -> DataValueIntervalToContext {
		var _localctx: DataValueIntervalToContext = DataValueIntervalToContext(_ctx, getState())
		try enterRule(_localctx, 500, Cobol85Parser.RULE_dataValueIntervalTo)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3454)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3455)
		 	try literal()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataWithLowerBoundsClauseContext: ParserRuleContext {
			open
			func LOWER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOWER.rawValue, 0)
			}
			open
			func BOUNDS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BOUNDS.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataWithLowerBoundsClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataWithLowerBoundsClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataWithLowerBoundsClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataWithLowerBoundsClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataWithLowerBoundsClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataWithLowerBoundsClause() throws -> DataWithLowerBoundsClauseContext {
		var _localctx: DataWithLowerBoundsClauseContext = DataWithLowerBoundsClauseContext(_ctx, getState())
		try enterRule(_localctx, 502, Cobol85Parser.RULE_dataWithLowerBoundsClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3458)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3457)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(3460)
		 	try match(Cobol85Parser.Tokens.LOWER.rawValue)
		 	setState(3461)
		 	try match(Cobol85Parser.Tokens.BOUNDS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureDivisionContext: ParserRuleContext {
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROCEDURE.rawValue, 0)
			}
			open
			func DIVISION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DIVISION.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func procedureDivisionBody() -> ProcedureDivisionBodyContext? {
				return getRuleContext(ProcedureDivisionBodyContext.self, 0)
			}
			open
			func procedureDivisionUsingClause() -> ProcedureDivisionUsingClauseContext? {
				return getRuleContext(ProcedureDivisionUsingClauseContext.self, 0)
			}
			open
			func procedureDivisionGivingClause() -> ProcedureDivisionGivingClauseContext? {
				return getRuleContext(ProcedureDivisionGivingClauseContext.self, 0)
			}
			open
			func procedureDeclaratives() -> ProcedureDeclarativesContext? {
				return getRuleContext(ProcedureDeclarativesContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureDivision
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureDivision(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureDivision(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureDivision(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureDivision(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureDivision() throws -> ProcedureDivisionContext {
		var _localctx: ProcedureDivisionContext = ProcedureDivisionContext(_ctx, getState())
		try enterRule(_localctx, 504, Cobol85Parser.RULE_procedureDivision)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3463)
		 	try match(Cobol85Parser.Tokens.PROCEDURE.rawValue)
		 	setState(3464)
		 	try match(Cobol85Parser.Tokens.DIVISION.rawValue)
		 	setState(3466)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.CHAINING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.USING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3465)
		 		try procedureDivisionUsingClause()

		 	}

		 	setState(3469)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.GIVING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.RETURNING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3468)
		 		try procedureDivisionGivingClause()

		 	}

		 	setState(3471)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(3473)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DECLARATIVES.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3472)
		 		try procedureDeclaratives()

		 	}

		 	setState(3475)
		 	try procedureDivisionBody()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureDivisionUsingClauseContext: ParserRuleContext {
			open
			func USING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USING.rawValue, 0)
			}
			open
			func CHAINING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHAINING.rawValue, 0)
			}
			open
			func procedureDivisionUsingParameter() -> [ProcedureDivisionUsingParameterContext] {
				return getRuleContexts(ProcedureDivisionUsingParameterContext.self)
			}
			open
			func procedureDivisionUsingParameter(_ i: Int) -> ProcedureDivisionUsingParameterContext? {
				return getRuleContext(ProcedureDivisionUsingParameterContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureDivisionUsingClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureDivisionUsingClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureDivisionUsingClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureDivisionUsingClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureDivisionUsingClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureDivisionUsingClause() throws -> ProcedureDivisionUsingClauseContext {
		var _localctx: ProcedureDivisionUsingClauseContext = ProcedureDivisionUsingClauseContext(_ctx, getState())
		try enterRule(_localctx, 506, Cobol85Parser.RULE_procedureDivisionUsingClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3477)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.CHAINING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.USING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3479) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3478)
		 		try procedureDivisionUsingParameter()


		 		setState(3481); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ANY.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.BY.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.OPTIONAL.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REFERENCE.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VALUE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureDivisionGivingClauseContext: ParserRuleContext {
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func GIVING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GIVING.rawValue, 0)
			}
			open
			func RETURNING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RETURNING.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureDivisionGivingClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureDivisionGivingClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureDivisionGivingClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureDivisionGivingClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureDivisionGivingClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureDivisionGivingClause() throws -> ProcedureDivisionGivingClauseContext {
		var _localctx: ProcedureDivisionGivingClauseContext = ProcedureDivisionGivingClauseContext(_ctx, getState())
		try enterRule(_localctx, 508, Cobol85Parser.RULE_procedureDivisionGivingClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3483)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.GIVING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.RETURNING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3484)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureDivisionUsingParameterContext: ParserRuleContext {
			open
			func procedureDivisionByReferencePhrase() -> ProcedureDivisionByReferencePhraseContext? {
				return getRuleContext(ProcedureDivisionByReferencePhraseContext.self, 0)
			}
			open
			func procedureDivisionByValuePhrase() -> ProcedureDivisionByValuePhraseContext? {
				return getRuleContext(ProcedureDivisionByValuePhraseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureDivisionUsingParameter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureDivisionUsingParameter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureDivisionUsingParameter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureDivisionUsingParameter(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureDivisionUsingParameter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureDivisionUsingParameter() throws -> ProcedureDivisionUsingParameterContext {
		var _localctx: ProcedureDivisionUsingParameterContext = ProcedureDivisionUsingParameterContext(_ctx, getState())
		try enterRule(_localctx, 510, Cobol85Parser.RULE_procedureDivisionUsingParameter)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3488)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,446, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3486)
		 		try procedureDivisionByReferencePhrase()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3487)
		 		try procedureDivisionByValuePhrase()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureDivisionByReferencePhraseContext: ParserRuleContext {
			open
			func REFERENCE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REFERENCE.rawValue, 0)
			}
			open
			func procedureDivisionByReference() -> [ProcedureDivisionByReferenceContext] {
				return getRuleContexts(ProcedureDivisionByReferenceContext.self)
			}
			open
			func procedureDivisionByReference(_ i: Int) -> ProcedureDivisionByReferenceContext? {
				return getRuleContext(ProcedureDivisionByReferenceContext.self, i)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureDivisionByReferencePhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureDivisionByReferencePhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureDivisionByReferencePhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureDivisionByReferencePhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureDivisionByReferencePhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureDivisionByReferencePhrase() throws -> ProcedureDivisionByReferencePhraseContext {
		var _localctx: ProcedureDivisionByReferencePhraseContext = ProcedureDivisionByReferencePhraseContext(_ctx, getState())
		try enterRule(_localctx, 512, Cobol85Parser.RULE_procedureDivisionByReferencePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3494)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.BY.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.REFERENCE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3491)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.BY.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3490)
		 			try match(Cobol85Parser.Tokens.BY.rawValue)

		 		}

		 		setState(3493)
		 		try match(Cobol85Parser.Tokens.REFERENCE.rawValue)

		 	}

		 	setState(3497); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3496)
		 			try procedureDivisionByReference()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3499); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,449,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureDivisionByReferenceContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func OPTIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OPTIONAL.rawValue, 0)
			}
			open
			func ANY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ANY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureDivisionByReference
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureDivisionByReference(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureDivisionByReference(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureDivisionByReference(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureDivisionByReference(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureDivisionByReference() throws -> ProcedureDivisionByReferenceContext {
		var _localctx: ProcedureDivisionByReferenceContext = ProcedureDivisionByReferenceContext(_ctx, getState())
		try enterRule(_localctx, 514, Cobol85Parser.RULE_procedureDivisionByReference)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3509)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ABORT:fallthrough
		 	case .ADDRESS:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DAY_OF_WEEK:fallthrough
		 	case .DEBUG_CONTENTS:fallthrough
		 	case .DEBUG_ITEM:fallthrough
		 	case .DEBUG_LINE:fallthrough
		 	case .DEBUG_NAME:fallthrough
		 	case .DEBUG_SUB_1:fallthrough
		 	case .DEBUG_SUB_2:fallthrough
		 	case .DEBUG_SUB_3:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LINAGE_COUNTER:fallthrough
		 	case .LINE_COUNTER:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .OPTIONAL:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PAGE_COUNTER:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .RETURN_CODE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHIFT_IN:fallthrough
		 	case .SHIFT_OUT:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SORT_CONTROL:fallthrough
		 	case .SORT_CORE_SIZE:fallthrough
		 	case .SORT_FILE_SIZE:fallthrough
		 	case .SORT_MESSAGE:fallthrough
		 	case .SORT_MODE_SIZE:fallthrough
		 	case .SORT_RETURN:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TALLY:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .WHEN_COMPILED:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:fallthrough
		 	case .IDENTIFIER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3502)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.OPTIONAL.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3501)
		 			try match(Cobol85Parser.Tokens.OPTIONAL.rawValue)

		 		}

		 		setState(3506)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,451, _ctx)) {
		 		case 1:
		 			setState(3504)
		 			try identifier()

		 			break
		 		case 2:
		 			setState(3505)
		 			try fileName()

		 			break
		 		default: break
		 		}


		 		break

		 	case .ANY:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3508)
		 		try match(Cobol85Parser.Tokens.ANY.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureDivisionByValuePhraseContext: ParserRuleContext {
			open
			func VALUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VALUE.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func procedureDivisionByValue() -> [ProcedureDivisionByValueContext] {
				return getRuleContexts(ProcedureDivisionByValueContext.self)
			}
			open
			func procedureDivisionByValue(_ i: Int) -> ProcedureDivisionByValueContext? {
				return getRuleContext(ProcedureDivisionByValueContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureDivisionByValuePhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureDivisionByValuePhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureDivisionByValuePhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureDivisionByValuePhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureDivisionByValuePhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureDivisionByValuePhrase() throws -> ProcedureDivisionByValuePhraseContext {
		var _localctx: ProcedureDivisionByValuePhraseContext = ProcedureDivisionByValuePhraseContext(_ctx, getState())
		try enterRule(_localctx, 516, Cobol85Parser.RULE_procedureDivisionByValuePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3512)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.BY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3511)
		 		try match(Cobol85Parser.Tokens.BY.rawValue)

		 	}

		 	setState(3514)
		 	try match(Cobol85Parser.Tokens.VALUE.rawValue)
		 	setState(3516); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3515)
		 			try procedureDivisionByValue()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3518); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,454,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureDivisionByValueContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func ANY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ANY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureDivisionByValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureDivisionByValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureDivisionByValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureDivisionByValue(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureDivisionByValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureDivisionByValue() throws -> ProcedureDivisionByValueContext {
		var _localctx: ProcedureDivisionByValueContext = ProcedureDivisionByValueContext(_ctx, getState())
		try enterRule(_localctx, 518, Cobol85Parser.RULE_procedureDivisionByValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3523)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,455, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3520)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3521)
		 		try literal()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3522)
		 		try match(Cobol85Parser.Tokens.ANY.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureDeclarativesContext: ParserRuleContext {
			open
			func DECLARATIVES() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.DECLARATIVES.rawValue)
			}
			open
			func DECLARATIVES(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DECLARATIVES.rawValue, i)
			}
			open
			func DOT_FS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.DOT_FS.rawValue)
			}
			open
			func DOT_FS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, i)
			}
			open
			func END() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END.rawValue, 0)
			}
			open
			func procedureDeclarative() -> [ProcedureDeclarativeContext] {
				return getRuleContexts(ProcedureDeclarativeContext.self)
			}
			open
			func procedureDeclarative(_ i: Int) -> ProcedureDeclarativeContext? {
				return getRuleContext(ProcedureDeclarativeContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureDeclaratives
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureDeclaratives(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureDeclaratives(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureDeclaratives(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureDeclaratives(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureDeclaratives() throws -> ProcedureDeclarativesContext {
		var _localctx: ProcedureDeclarativesContext = ProcedureDeclarativesContext(_ctx, getState())
		try enterRule(_localctx, 520, Cobol85Parser.RULE_procedureDeclaratives)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3525)
		 	try match(Cobol85Parser.Tokens.DECLARATIVES.rawValue)
		 	setState(3526)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(3528) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3527)
		 		try procedureDeclarative()


		 		setState(3530); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(3532)
		 	try match(Cobol85Parser.Tokens.END.rawValue)
		 	setState(3533)
		 	try match(Cobol85Parser.Tokens.DECLARATIVES.rawValue)
		 	setState(3534)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureDeclarativeContext: ParserRuleContext {
			open
			func procedureSectionHeader() -> ProcedureSectionHeaderContext? {
				return getRuleContext(ProcedureSectionHeaderContext.self, 0)
			}
			open
			func DOT_FS() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.DOT_FS.rawValue)
			}
			open
			func DOT_FS(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, i)
			}
			open
			func useStatement() -> UseStatementContext? {
				return getRuleContext(UseStatementContext.self, 0)
			}
			open
			func paragraphs() -> ParagraphsContext? {
				return getRuleContext(ParagraphsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureDeclarative
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureDeclarative(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureDeclarative(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureDeclarative(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureDeclarative(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureDeclarative() throws -> ProcedureDeclarativeContext {
		var _localctx: ProcedureDeclarativeContext = ProcedureDeclarativeContext(_ctx, getState())
		try enterRule(_localctx, 522, Cobol85Parser.RULE_procedureDeclarative)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3536)
		 	try procedureSectionHeader()
		 	setState(3537)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(3538)
		 	try useStatement()
		 	setState(3539)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(3540)
		 	try paragraphs()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureSectionHeaderContext: ParserRuleContext {
			open
			func sectionName() -> SectionNameContext? {
				return getRuleContext(SectionNameContext.self, 0)
			}
			open
			func SECTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECTION.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureSectionHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureSectionHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureSectionHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureSectionHeader(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureSectionHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureSectionHeader() throws -> ProcedureSectionHeaderContext {
		var _localctx: ProcedureSectionHeaderContext = ProcedureSectionHeaderContext(_ctx, getState())
		try enterRule(_localctx, 524, Cobol85Parser.RULE_procedureSectionHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3542)
		 	try sectionName()
		 	setState(3543)
		 	try match(Cobol85Parser.Tokens.SECTION.rawValue)
		 	setState(3545)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 552)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(3544)
		 		try integerLiteral()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureDivisionBodyContext: ParserRuleContext {
			open
			func paragraphs() -> ParagraphsContext? {
				return getRuleContext(ParagraphsContext.self, 0)
			}
			open
			func procedureSection() -> [ProcedureSectionContext] {
				return getRuleContexts(ProcedureSectionContext.self)
			}
			open
			func procedureSection(_ i: Int) -> ProcedureSectionContext? {
				return getRuleContext(ProcedureSectionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureDivisionBody
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureDivisionBody(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureDivisionBody(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureDivisionBody(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureDivisionBody(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureDivisionBody() throws -> ProcedureDivisionBodyContext {
		var _localctx: ProcedureDivisionBodyContext = ProcedureDivisionBodyContext(_ctx, getState())
		try enterRule(_localctx, 526, Cobol85Parser.RULE_procedureDivisionBody)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3547)
		 	try paragraphs()
		 	setState(3551)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(3548)
		 		try procedureSection()


		 		setState(3553)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureSectionContext: ParserRuleContext {
			open
			func procedureSectionHeader() -> ProcedureSectionHeaderContext? {
				return getRuleContext(ProcedureSectionHeaderContext.self, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func paragraphs() -> ParagraphsContext? {
				return getRuleContext(ParagraphsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureSection() throws -> ProcedureSectionContext {
		var _localctx: ProcedureSectionContext = ProcedureSectionContext(_ctx, getState())
		try enterRule(_localctx, 528, Cobol85Parser.RULE_procedureSection)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3554)
		 	try procedureSectionHeader()
		 	setState(3555)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(3556)
		 	try paragraphs()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ParagraphsContext: ParserRuleContext {
			open
			func sentence() -> [SentenceContext] {
				return getRuleContexts(SentenceContext.self)
			}
			open
			func sentence(_ i: Int) -> SentenceContext? {
				return getRuleContext(SentenceContext.self, i)
			}
			open
			func paragraph() -> [ParagraphContext] {
				return getRuleContexts(ParagraphContext.self)
			}
			open
			func paragraph(_ i: Int) -> ParagraphContext? {
				return getRuleContext(ParagraphContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_paragraphs
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterParagraphs(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitParagraphs(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitParagraphs(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitParagraphs(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func paragraphs() throws -> ParagraphsContext {
		var _localctx: ParagraphsContext = ParagraphsContext(_ctx, getState())
		try enterRule(_localctx, 530, Cobol85Parser.RULE_paragraphs)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3561)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ACCEPT.rawValue,Cobol85Parser.Tokens.ADD.rawValue,Cobol85Parser.Tokens.ALTER.rawValue,Cobol85Parser.Tokens.CALL.rawValue,Cobol85Parser.Tokens.CANCEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE.rawValue,Cobol85Parser.Tokens.COMPUTE.rawValue,Cobol85Parser.Tokens.CONTINUE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 67)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DELETE.rawValue,Cobol85Parser.Tokens.DISABLE.rawValue,Cobol85Parser.Tokens.DISPLAY.rawValue,Cobol85Parser.Tokens.DIVIDE.rawValue,Cobol85Parser.Tokens.ENABLE.rawValue,Cobol85Parser.Tokens.ENTRY.rawValue,Cobol85Parser.Tokens.EVALUATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 131)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXHIBIT.rawValue,Cobol85Parser.Tokens.EXIT.rawValue,Cobol85Parser.Tokens.GENERATE.rawValue,Cobol85Parser.Tokens.GOBACK.rawValue,Cobol85Parser.Tokens.GO.rawValue,Cobol85Parser.Tokens.IF.rawValue,Cobol85Parser.Tokens.INITIALIZE.rawValue,Cobol85Parser.Tokens.INITIATE.rawValue,Cobol85Parser.Tokens.INSPECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 198)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.MERGE.rawValue,Cobol85Parser.Tokens.MOVE.rawValue,Cobol85Parser.Tokens.MULTIPLY.rawValue,Cobol85Parser.Tokens.OPEN.rawValue,Cobol85Parser.Tokens.PERFORM.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 294)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.PURGE.rawValue,Cobol85Parser.Tokens.READ.rawValue,Cobol85Parser.Tokens.RECEIVE.rawValue,Cobol85Parser.Tokens.RELEASE.rawValue,Cobol85Parser.Tokens.RETURN.rawValue,Cobol85Parser.Tokens.REWRITE.rawValue,Cobol85Parser.Tokens.SEARCH.rawValue,Cobol85Parser.Tokens.SEND.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 365)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SET.rawValue,Cobol85Parser.Tokens.SORT.rawValue,Cobol85Parser.Tokens.START.rawValue,Cobol85Parser.Tokens.STOP.rawValue,Cobol85Parser.Tokens.STRING.rawValue,Cobol85Parser.Tokens.SUBTRACT.rawValue,Cobol85Parser.Tokens.TERMINATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 430)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.UNSTRING.rawValue,Cobol85Parser.Tokens.WRITE.rawValue,Cobol85Parser.Tokens.DOT_FS.rawValue,Cobol85Parser.Tokens.EXECCICSLINE.rawValue,Cobol85Parser.Tokens.EXECSQLIMSLINE.rawValue,Cobol85Parser.Tokens.EXECSQLLINE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 500)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(3558)
		 		try sentence()


		 		setState(3563)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3567)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,460,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3564)
		 			try paragraph()

		 	 
		 		}
		 		setState(3569)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,460,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ParagraphContext: ParserRuleContext {
			open
			func paragraphName() -> ParagraphNameContext? {
				return getRuleContext(ParagraphNameContext.self, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func alteredGoTo() -> AlteredGoToContext? {
				return getRuleContext(AlteredGoToContext.self, 0)
			}
			open
			func sentence() -> [SentenceContext] {
				return getRuleContexts(SentenceContext.self)
			}
			open
			func sentence(_ i: Int) -> SentenceContext? {
				return getRuleContext(SentenceContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_paragraph
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterParagraph(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitParagraph(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitParagraph(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitParagraph(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func paragraph() throws -> ParagraphContext {
		var _localctx: ParagraphContext = ParagraphContext(_ctx, getState())
		try enterRule(_localctx, 532, Cobol85Parser.RULE_paragraph)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3570)
		 	try paragraphName()
		 	setState(3571)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)
		 	setState(3579)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,462, _ctx)) {
		 	case 1:
		 		setState(3572)
		 		try alteredGoTo()

		 		break
		 	case 2:
		 		setState(3576)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ACCEPT.rawValue,Cobol85Parser.Tokens.ADD.rawValue,Cobol85Parser.Tokens.ALTER.rawValue,Cobol85Parser.Tokens.CALL.rawValue,Cobol85Parser.Tokens.CANCEL.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE.rawValue,Cobol85Parser.Tokens.COMPUTE.rawValue,Cobol85Parser.Tokens.CONTINUE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 67)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DELETE.rawValue,Cobol85Parser.Tokens.DISABLE.rawValue,Cobol85Parser.Tokens.DISPLAY.rawValue,Cobol85Parser.Tokens.DIVIDE.rawValue,Cobol85Parser.Tokens.ENABLE.rawValue,Cobol85Parser.Tokens.ENTRY.rawValue,Cobol85Parser.Tokens.EVALUATE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 131)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXHIBIT.rawValue,Cobol85Parser.Tokens.EXIT.rawValue,Cobol85Parser.Tokens.GENERATE.rawValue,Cobol85Parser.Tokens.GOBACK.rawValue,Cobol85Parser.Tokens.GO.rawValue,Cobol85Parser.Tokens.IF.rawValue,Cobol85Parser.Tokens.INITIALIZE.rawValue,Cobol85Parser.Tokens.INITIATE.rawValue,Cobol85Parser.Tokens.INSPECT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 198)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.MERGE.rawValue,Cobol85Parser.Tokens.MOVE.rawValue,Cobol85Parser.Tokens.MULTIPLY.rawValue,Cobol85Parser.Tokens.OPEN.rawValue,Cobol85Parser.Tokens.PERFORM.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 294)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.PURGE.rawValue,Cobol85Parser.Tokens.READ.rawValue,Cobol85Parser.Tokens.RECEIVE.rawValue,Cobol85Parser.Tokens.RELEASE.rawValue,Cobol85Parser.Tokens.RETURN.rawValue,Cobol85Parser.Tokens.REWRITE.rawValue,Cobol85Parser.Tokens.SEARCH.rawValue,Cobol85Parser.Tokens.SEND.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 365)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SET.rawValue,Cobol85Parser.Tokens.SORT.rawValue,Cobol85Parser.Tokens.START.rawValue,Cobol85Parser.Tokens.STOP.rawValue,Cobol85Parser.Tokens.STRING.rawValue,Cobol85Parser.Tokens.SUBTRACT.rawValue,Cobol85Parser.Tokens.TERMINATE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 430)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.UNSTRING.rawValue,Cobol85Parser.Tokens.WRITE.rawValue,Cobol85Parser.Tokens.DOT_FS.rawValue,Cobol85Parser.Tokens.EXECCICSLINE.rawValue,Cobol85Parser.Tokens.EXECSQLIMSLINE.rawValue,Cobol85Parser.Tokens.EXECSQLLINE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 500)
		 		          }()
		 		      return testSet
		 		 }()) {
		 			setState(3573)
		 			try sentence()


		 			setState(3578)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SentenceContext: ParserRuleContext {
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sentence
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSentence(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSentence(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSentence(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSentence(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sentence() throws -> SentenceContext {
		var _localctx: SentenceContext = SentenceContext(_ctx, getState())
		try enterRule(_localctx, 534, Cobol85Parser.RULE_sentence)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3584)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ACCEPT.rawValue,Cobol85Parser.Tokens.ADD.rawValue,Cobol85Parser.Tokens.ALTER.rawValue,Cobol85Parser.Tokens.CALL.rawValue,Cobol85Parser.Tokens.CANCEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE.rawValue,Cobol85Parser.Tokens.COMPUTE.rawValue,Cobol85Parser.Tokens.CONTINUE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 67)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DELETE.rawValue,Cobol85Parser.Tokens.DISABLE.rawValue,Cobol85Parser.Tokens.DISPLAY.rawValue,Cobol85Parser.Tokens.DIVIDE.rawValue,Cobol85Parser.Tokens.ENABLE.rawValue,Cobol85Parser.Tokens.ENTRY.rawValue,Cobol85Parser.Tokens.EVALUATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 131)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXHIBIT.rawValue,Cobol85Parser.Tokens.EXIT.rawValue,Cobol85Parser.Tokens.GENERATE.rawValue,Cobol85Parser.Tokens.GOBACK.rawValue,Cobol85Parser.Tokens.GO.rawValue,Cobol85Parser.Tokens.IF.rawValue,Cobol85Parser.Tokens.INITIALIZE.rawValue,Cobol85Parser.Tokens.INITIATE.rawValue,Cobol85Parser.Tokens.INSPECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 198)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.MERGE.rawValue,Cobol85Parser.Tokens.MOVE.rawValue,Cobol85Parser.Tokens.MULTIPLY.rawValue,Cobol85Parser.Tokens.OPEN.rawValue,Cobol85Parser.Tokens.PERFORM.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 294)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.PURGE.rawValue,Cobol85Parser.Tokens.READ.rawValue,Cobol85Parser.Tokens.RECEIVE.rawValue,Cobol85Parser.Tokens.RELEASE.rawValue,Cobol85Parser.Tokens.RETURN.rawValue,Cobol85Parser.Tokens.REWRITE.rawValue,Cobol85Parser.Tokens.SEARCH.rawValue,Cobol85Parser.Tokens.SEND.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 365)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SET.rawValue,Cobol85Parser.Tokens.SORT.rawValue,Cobol85Parser.Tokens.START.rawValue,Cobol85Parser.Tokens.STOP.rawValue,Cobol85Parser.Tokens.STRING.rawValue,Cobol85Parser.Tokens.SUBTRACT.rawValue,Cobol85Parser.Tokens.TERMINATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 430)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.UNSTRING.rawValue,Cobol85Parser.Tokens.WRITE.rawValue,Cobol85Parser.Tokens.EXECCICSLINE.rawValue,Cobol85Parser.Tokens.EXECSQLIMSLINE.rawValue,Cobol85Parser.Tokens.EXECSQLLINE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 500)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(3581)
		 		try statement()


		 		setState(3586)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3587)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StatementContext: ParserRuleContext {
			open
			func acceptStatement() -> AcceptStatementContext? {
				return getRuleContext(AcceptStatementContext.self, 0)
			}
			open
			func addStatement() -> AddStatementContext? {
				return getRuleContext(AddStatementContext.self, 0)
			}
			open
			func alterStatement() -> AlterStatementContext? {
				return getRuleContext(AlterStatementContext.self, 0)
			}
			open
			func callStatement() -> CallStatementContext? {
				return getRuleContext(CallStatementContext.self, 0)
			}
			open
			func cancelStatement() -> CancelStatementContext? {
				return getRuleContext(CancelStatementContext.self, 0)
			}
			open
			func closeStatement() -> CloseStatementContext? {
				return getRuleContext(CloseStatementContext.self, 0)
			}
			open
			func computeStatement() -> ComputeStatementContext? {
				return getRuleContext(ComputeStatementContext.self, 0)
			}
			open
			func continueStatement() -> ContinueStatementContext? {
				return getRuleContext(ContinueStatementContext.self, 0)
			}
			open
			func deleteStatement() -> DeleteStatementContext? {
				return getRuleContext(DeleteStatementContext.self, 0)
			}
			open
			func disableStatement() -> DisableStatementContext? {
				return getRuleContext(DisableStatementContext.self, 0)
			}
			open
			func displayStatement() -> DisplayStatementContext? {
				return getRuleContext(DisplayStatementContext.self, 0)
			}
			open
			func divideStatement() -> DivideStatementContext? {
				return getRuleContext(DivideStatementContext.self, 0)
			}
			open
			func enableStatement() -> EnableStatementContext? {
				return getRuleContext(EnableStatementContext.self, 0)
			}
			open
			func entryStatement() -> EntryStatementContext? {
				return getRuleContext(EntryStatementContext.self, 0)
			}
			open
			func evaluateStatement() -> EvaluateStatementContext? {
				return getRuleContext(EvaluateStatementContext.self, 0)
			}
			open
			func exhibitStatement() -> ExhibitStatementContext? {
				return getRuleContext(ExhibitStatementContext.self, 0)
			}
			open
			func execCicsStatement() -> ExecCicsStatementContext? {
				return getRuleContext(ExecCicsStatementContext.self, 0)
			}
			open
			func execSqlStatement() -> ExecSqlStatementContext? {
				return getRuleContext(ExecSqlStatementContext.self, 0)
			}
			open
			func execSqlImsStatement() -> ExecSqlImsStatementContext? {
				return getRuleContext(ExecSqlImsStatementContext.self, 0)
			}
			open
			func exitStatement() -> ExitStatementContext? {
				return getRuleContext(ExitStatementContext.self, 0)
			}
			open
			func generateStatement() -> GenerateStatementContext? {
				return getRuleContext(GenerateStatementContext.self, 0)
			}
			open
			func gobackStatement() -> GobackStatementContext? {
				return getRuleContext(GobackStatementContext.self, 0)
			}
			open
			func goToStatement() -> GoToStatementContext? {
				return getRuleContext(GoToStatementContext.self, 0)
			}
			open
			func ifStatement() -> IfStatementContext? {
				return getRuleContext(IfStatementContext.self, 0)
			}
			open
			func initializeStatement() -> InitializeStatementContext? {
				return getRuleContext(InitializeStatementContext.self, 0)
			}
			open
			func initiateStatement() -> InitiateStatementContext? {
				return getRuleContext(InitiateStatementContext.self, 0)
			}
			open
			func inspectStatement() -> InspectStatementContext? {
				return getRuleContext(InspectStatementContext.self, 0)
			}
			open
			func mergeStatement() -> MergeStatementContext? {
				return getRuleContext(MergeStatementContext.self, 0)
			}
			open
			func moveStatement() -> MoveStatementContext? {
				return getRuleContext(MoveStatementContext.self, 0)
			}
			open
			func multiplyStatement() -> MultiplyStatementContext? {
				return getRuleContext(MultiplyStatementContext.self, 0)
			}
			open
			func openStatement() -> OpenStatementContext? {
				return getRuleContext(OpenStatementContext.self, 0)
			}
			open
			func performStatement() -> PerformStatementContext? {
				return getRuleContext(PerformStatementContext.self, 0)
			}
			open
			func purgeStatement() -> PurgeStatementContext? {
				return getRuleContext(PurgeStatementContext.self, 0)
			}
			open
			func readStatement() -> ReadStatementContext? {
				return getRuleContext(ReadStatementContext.self, 0)
			}
			open
			func receiveStatement() -> ReceiveStatementContext? {
				return getRuleContext(ReceiveStatementContext.self, 0)
			}
			open
			func releaseStatement() -> ReleaseStatementContext? {
				return getRuleContext(ReleaseStatementContext.self, 0)
			}
			open
			func returnStatement() -> ReturnStatementContext? {
				return getRuleContext(ReturnStatementContext.self, 0)
			}
			open
			func rewriteStatement() -> RewriteStatementContext? {
				return getRuleContext(RewriteStatementContext.self, 0)
			}
			open
			func searchStatement() -> SearchStatementContext? {
				return getRuleContext(SearchStatementContext.self, 0)
			}
			open
			func sendStatement() -> SendStatementContext? {
				return getRuleContext(SendStatementContext.self, 0)
			}
			open
			func setStatement() -> SetStatementContext? {
				return getRuleContext(SetStatementContext.self, 0)
			}
			open
			func sortStatement() -> SortStatementContext? {
				return getRuleContext(SortStatementContext.self, 0)
			}
			open
			func startStatement() -> StartStatementContext? {
				return getRuleContext(StartStatementContext.self, 0)
			}
			open
			func stopStatement() -> StopStatementContext? {
				return getRuleContext(StopStatementContext.self, 0)
			}
			open
			func stringStatement() -> StringStatementContext? {
				return getRuleContext(StringStatementContext.self, 0)
			}
			open
			func subtractStatement() -> SubtractStatementContext? {
				return getRuleContext(SubtractStatementContext.self, 0)
			}
			open
			func terminateStatement() -> TerminateStatementContext? {
				return getRuleContext(TerminateStatementContext.self, 0)
			}
			open
			func unstringStatement() -> UnstringStatementContext? {
				return getRuleContext(UnstringStatementContext.self, 0)
			}
			open
			func writeStatement() -> WriteStatementContext? {
				return getRuleContext(WriteStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_statement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func statement() throws -> StatementContext {
		var _localctx: StatementContext = StatementContext(_ctx, getState())
		try enterRule(_localctx, 536, Cobol85Parser.RULE_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3638)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ACCEPT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3589)
		 		try acceptStatement()

		 		break

		 	case .ADD:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3590)
		 		try addStatement()

		 		break

		 	case .ALTER:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3591)
		 		try alterStatement()

		 		break

		 	case .CALL:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3592)
		 		try callStatement()

		 		break

		 	case .CANCEL:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3593)
		 		try cancelStatement()

		 		break

		 	case .CLOSE:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3594)
		 		try closeStatement()

		 		break

		 	case .COMPUTE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(3595)
		 		try computeStatement()

		 		break

		 	case .CONTINUE:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(3596)
		 		try continueStatement()

		 		break

		 	case .DELETE:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(3597)
		 		try deleteStatement()

		 		break

		 	case .DISABLE:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(3598)
		 		try disableStatement()

		 		break

		 	case .DISPLAY:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(3599)
		 		try displayStatement()

		 		break

		 	case .DIVIDE:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(3600)
		 		try divideStatement()

		 		break

		 	case .ENABLE:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(3601)
		 		try enableStatement()

		 		break

		 	case .ENTRY:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(3602)
		 		try entryStatement()

		 		break

		 	case .EVALUATE:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(3603)
		 		try evaluateStatement()

		 		break

		 	case .EXHIBIT:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(3604)
		 		try exhibitStatement()

		 		break

		 	case .EXECCICSLINE:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(3605)
		 		try execCicsStatement()

		 		break

		 	case .EXECSQLLINE:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(3606)
		 		try execSqlStatement()

		 		break

		 	case .EXECSQLIMSLINE:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(3607)
		 		try execSqlImsStatement()

		 		break

		 	case .EXIT:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(3608)
		 		try exitStatement()

		 		break

		 	case .GENERATE:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(3609)
		 		try generateStatement()

		 		break

		 	case .GOBACK:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(3610)
		 		try gobackStatement()

		 		break

		 	case .GO:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(3611)
		 		try goToStatement()

		 		break

		 	case .IF:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(3612)
		 		try ifStatement()

		 		break

		 	case .INITIALIZE:
		 		try enterOuterAlt(_localctx, 25)
		 		setState(3613)
		 		try initializeStatement()

		 		break

		 	case .INITIATE:
		 		try enterOuterAlt(_localctx, 26)
		 		setState(3614)
		 		try initiateStatement()

		 		break

		 	case .INSPECT:
		 		try enterOuterAlt(_localctx, 27)
		 		setState(3615)
		 		try inspectStatement()

		 		break

		 	case .MERGE:
		 		try enterOuterAlt(_localctx, 28)
		 		setState(3616)
		 		try mergeStatement()

		 		break

		 	case .MOVE:
		 		try enterOuterAlt(_localctx, 29)
		 		setState(3617)
		 		try moveStatement()

		 		break

		 	case .MULTIPLY:
		 		try enterOuterAlt(_localctx, 30)
		 		setState(3618)
		 		try multiplyStatement()

		 		break

		 	case .OPEN:
		 		try enterOuterAlt(_localctx, 31)
		 		setState(3619)
		 		try openStatement()

		 		break

		 	case .PERFORM:
		 		try enterOuterAlt(_localctx, 32)
		 		setState(3620)
		 		try performStatement()

		 		break

		 	case .PURGE:
		 		try enterOuterAlt(_localctx, 33)
		 		setState(3621)
		 		try purgeStatement()

		 		break

		 	case .READ:
		 		try enterOuterAlt(_localctx, 34)
		 		setState(3622)
		 		try readStatement()

		 		break

		 	case .RECEIVE:
		 		try enterOuterAlt(_localctx, 35)
		 		setState(3623)
		 		try receiveStatement()

		 		break

		 	case .RELEASE:
		 		try enterOuterAlt(_localctx, 36)
		 		setState(3624)
		 		try releaseStatement()

		 		break

		 	case .RETURN:
		 		try enterOuterAlt(_localctx, 37)
		 		setState(3625)
		 		try returnStatement()

		 		break

		 	case .REWRITE:
		 		try enterOuterAlt(_localctx, 38)
		 		setState(3626)
		 		try rewriteStatement()

		 		break

		 	case .SEARCH:
		 		try enterOuterAlt(_localctx, 39)
		 		setState(3627)
		 		try searchStatement()

		 		break

		 	case .SEND:
		 		try enterOuterAlt(_localctx, 40)
		 		setState(3628)
		 		try sendStatement()

		 		break

		 	case .SET:
		 		try enterOuterAlt(_localctx, 41)
		 		setState(3629)
		 		try setStatement()

		 		break

		 	case .SORT:
		 		try enterOuterAlt(_localctx, 42)
		 		setState(3630)
		 		try sortStatement()

		 		break

		 	case .START:
		 		try enterOuterAlt(_localctx, 43)
		 		setState(3631)
		 		try startStatement()

		 		break

		 	case .STOP:
		 		try enterOuterAlt(_localctx, 44)
		 		setState(3632)
		 		try stopStatement()

		 		break

		 	case .STRING:
		 		try enterOuterAlt(_localctx, 45)
		 		setState(3633)
		 		try stringStatement()

		 		break

		 	case .SUBTRACT:
		 		try enterOuterAlt(_localctx, 46)
		 		setState(3634)
		 		try subtractStatement()

		 		break

		 	case .TERMINATE:
		 		try enterOuterAlt(_localctx, 47)
		 		setState(3635)
		 		try terminateStatement()

		 		break

		 	case .UNSTRING:
		 		try enterOuterAlt(_localctx, 48)
		 		setState(3636)
		 		try unstringStatement()

		 		break

		 	case .WRITE:
		 		try enterOuterAlt(_localctx, 49)
		 		setState(3637)
		 		try writeStatement()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AcceptStatementContext: ParserRuleContext {
			open
			func ACCEPT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ACCEPT.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func acceptFromDateStatement() -> AcceptFromDateStatementContext? {
				return getRuleContext(AcceptFromDateStatementContext.self, 0)
			}
			open
			func acceptFromEscapeKeyStatement() -> AcceptFromEscapeKeyStatementContext? {
				return getRuleContext(AcceptFromEscapeKeyStatementContext.self, 0)
			}
			open
			func acceptFromMnemonicStatement() -> AcceptFromMnemonicStatementContext? {
				return getRuleContext(AcceptFromMnemonicStatementContext.self, 0)
			}
			open
			func acceptMessageCountStatement() -> AcceptMessageCountStatementContext? {
				return getRuleContext(AcceptMessageCountStatementContext.self, 0)
			}
			open
			func onExceptionClause() -> OnExceptionClauseContext? {
				return getRuleContext(OnExceptionClauseContext.self, 0)
			}
			open
			func notOnExceptionClause() -> NotOnExceptionClauseContext? {
				return getRuleContext(NotOnExceptionClauseContext.self, 0)
			}
			open
			func END_ACCEPT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_ACCEPT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_acceptStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAcceptStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAcceptStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAcceptStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAcceptStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func acceptStatement() throws -> AcceptStatementContext {
		var _localctx: AcceptStatementContext = AcceptStatementContext(_ctx, getState())
		try enterRule(_localctx, 538, Cobol85Parser.RULE_acceptStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3640)
		 	try match(Cobol85Parser.Tokens.ACCEPT.rawValue)
		 	setState(3641)
		 	try identifier()
		 	setState(3646)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,465,_ctx)) {
		 	case 1:
		 		setState(3642)
		 		try acceptFromDateStatement()

		 		break
		 	case 2:
		 		setState(3643)
		 		try acceptFromEscapeKeyStatement()

		 		break
		 	case 3:
		 		setState(3644)
		 		try acceptFromMnemonicStatement()

		 		break
		 	case 4:
		 		setState(3645)
		 		try acceptMessageCountStatement()

		 		break
		 	default: break
		 	}
		 	setState(3649)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,466,_ctx)) {
		 	case 1:
		 		setState(3648)
		 		try onExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(3652)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,467,_ctx)) {
		 	case 1:
		 		setState(3651)
		 		try notOnExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(3655)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,468,_ctx)) {
		 	case 1:
		 		setState(3654)
		 		try match(Cobol85Parser.Tokens.END_ACCEPT.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AcceptFromDateStatementContext: ParserRuleContext {
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATE.rawValue, 0)
			}
			open
			func DAY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DAY.rawValue, 0)
			}
			open
			func DAY_OF_WEEK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue, 0)
			}
			open
			func TIME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TIME.rawValue, 0)
			}
			open
			func TIMER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TIMER.rawValue, 0)
			}
			open
			func TODAYS_DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TODAYS_DATE.rawValue, 0)
			}
			open
			func TODAYS_NAME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TODAYS_NAME.rawValue, 0)
			}
			open
			func YEAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.YEAR.rawValue, 0)
			}
			open
			func YYYYMMDD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.YYYYMMDD.rawValue, 0)
			}
			open
			func YYYYDDD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.YYYYDDD.rawValue, 0)
			}
			open
			func MMDDYYYY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MMDDYYYY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_acceptFromDateStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAcceptFromDateStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAcceptFromDateStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAcceptFromDateStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAcceptFromDateStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func acceptFromDateStatement() throws -> AcceptFromDateStatementContext {
		var _localctx: AcceptFromDateStatementContext = AcceptFromDateStatementContext(_ctx, getState())
		try enterRule(_localctx, 540, Cobol85Parser.RULE_acceptFromDateStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3657)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(3677)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DATE:
		 		setState(3658)
		 		try match(Cobol85Parser.Tokens.DATE.rawValue)
		 		setState(3660)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.YYYYMMDD.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3659)
		 			try match(Cobol85Parser.Tokens.YYYYMMDD.rawValue)

		 		}


		 		break

		 	case .DAY:
		 		setState(3662)
		 		try match(Cobol85Parser.Tokens.DAY.rawValue)
		 		setState(3664)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.YYYYDDD.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3663)
		 			try match(Cobol85Parser.Tokens.YYYYDDD.rawValue)

		 		}


		 		break

		 	case .DAY_OF_WEEK:
		 		setState(3666)
		 		try match(Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue)

		 		break

		 	case .TIME:
		 		setState(3667)
		 		try match(Cobol85Parser.Tokens.TIME.rawValue)

		 		break

		 	case .TIMER:
		 		setState(3668)
		 		try match(Cobol85Parser.Tokens.TIMER.rawValue)

		 		break

		 	case .TODAYS_DATE:
		 		setState(3669)
		 		try match(Cobol85Parser.Tokens.TODAYS_DATE.rawValue)
		 		setState(3671)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.MMDDYYYY.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3670)
		 			try match(Cobol85Parser.Tokens.MMDDYYYY.rawValue)

		 		}


		 		break

		 	case .TODAYS_NAME:
		 		setState(3673)
		 		try match(Cobol85Parser.Tokens.TODAYS_NAME.rawValue)

		 		break

		 	case .YEAR:
		 		setState(3674)
		 		try match(Cobol85Parser.Tokens.YEAR.rawValue)

		 		break

		 	case .YYYYMMDD:
		 		setState(3675)
		 		try match(Cobol85Parser.Tokens.YYYYMMDD.rawValue)

		 		break

		 	case .YYYYDDD:
		 		setState(3676)
		 		try match(Cobol85Parser.Tokens.YYYYDDD.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AcceptFromMnemonicStatementContext: ParserRuleContext {
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func mnemonicName() -> MnemonicNameContext? {
				return getRuleContext(MnemonicNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_acceptFromMnemonicStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAcceptFromMnemonicStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAcceptFromMnemonicStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAcceptFromMnemonicStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAcceptFromMnemonicStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func acceptFromMnemonicStatement() throws -> AcceptFromMnemonicStatementContext {
		var _localctx: AcceptFromMnemonicStatementContext = AcceptFromMnemonicStatementContext(_ctx, getState())
		try enterRule(_localctx, 542, Cobol85Parser.RULE_acceptFromMnemonicStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3679)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(3680)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AcceptFromEscapeKeyStatementContext: ParserRuleContext {
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func ESCAPE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ESCAPE.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_acceptFromEscapeKeyStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAcceptFromEscapeKeyStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAcceptFromEscapeKeyStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAcceptFromEscapeKeyStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAcceptFromEscapeKeyStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func acceptFromEscapeKeyStatement() throws -> AcceptFromEscapeKeyStatementContext {
		var _localctx: AcceptFromEscapeKeyStatementContext = AcceptFromEscapeKeyStatementContext(_ctx, getState())
		try enterRule(_localctx, 544, Cobol85Parser.RULE_acceptFromEscapeKeyStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3682)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(3683)
		 	try match(Cobol85Parser.Tokens.ESCAPE.rawValue)
		 	setState(3684)
		 	try match(Cobol85Parser.Tokens.KEY.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AcceptMessageCountStatementContext: ParserRuleContext {
			open
			func COUNT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COUNT.rawValue, 0)
			}
			open
			func MESSAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MESSAGE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_acceptMessageCountStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAcceptMessageCountStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAcceptMessageCountStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAcceptMessageCountStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAcceptMessageCountStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func acceptMessageCountStatement() throws -> AcceptMessageCountStatementContext {
		var _localctx: AcceptMessageCountStatementContext = AcceptMessageCountStatementContext(_ctx, getState())
		try enterRule(_localctx, 546, Cobol85Parser.RULE_acceptMessageCountStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3687)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.MESSAGE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3686)
		 		try match(Cobol85Parser.Tokens.MESSAGE.rawValue)

		 	}

		 	setState(3689)
		 	try match(Cobol85Parser.Tokens.COUNT.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AddStatementContext: ParserRuleContext {
			open
			func ADD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ADD.rawValue, 0)
			}
			open
			func addToStatement() -> AddToStatementContext? {
				return getRuleContext(AddToStatementContext.self, 0)
			}
			open
			func addToGivingStatement() -> AddToGivingStatementContext? {
				return getRuleContext(AddToGivingStatementContext.self, 0)
			}
			open
			func addCorrespondingStatement() -> AddCorrespondingStatementContext? {
				return getRuleContext(AddCorrespondingStatementContext.self, 0)
			}
			open
			func onSizeErrorPhrase() -> OnSizeErrorPhraseContext? {
				return getRuleContext(OnSizeErrorPhraseContext.self, 0)
			}
			open
			func notOnSizeErrorPhrase() -> NotOnSizeErrorPhraseContext? {
				return getRuleContext(NotOnSizeErrorPhraseContext.self, 0)
			}
			open
			func END_ADD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_ADD.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_addStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAddStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAddStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAddStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAddStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func addStatement() throws -> AddStatementContext {
		var _localctx: AddStatementContext = AddStatementContext(_ctx, getState())
		try enterRule(_localctx, 548, Cobol85Parser.RULE_addStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3691)
		 	try match(Cobol85Parser.Tokens.ADD.rawValue)
		 	setState(3695)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,474, _ctx)) {
		 	case 1:
		 		setState(3692)
		 		try addToStatement()

		 		break
		 	case 2:
		 		setState(3693)
		 		try addToGivingStatement()

		 		break
		 	case 3:
		 		setState(3694)
		 		try addCorrespondingStatement()

		 		break
		 	default: break
		 	}
		 	setState(3698)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,475,_ctx)) {
		 	case 1:
		 		setState(3697)
		 		try onSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3701)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,476,_ctx)) {
		 	case 1:
		 		setState(3700)
		 		try notOnSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3704)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,477,_ctx)) {
		 	case 1:
		 		setState(3703)
		 		try match(Cobol85Parser.Tokens.END_ADD.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AddToStatementContext: ParserRuleContext {
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func addFrom() -> [AddFromContext] {
				return getRuleContexts(AddFromContext.self)
			}
			open
			func addFrom(_ i: Int) -> AddFromContext? {
				return getRuleContext(AddFromContext.self, i)
			}
			open
			func addTo() -> [AddToContext] {
				return getRuleContexts(AddToContext.self)
			}
			open
			func addTo(_ i: Int) -> AddToContext? {
				return getRuleContext(AddToContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_addToStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAddToStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAddToStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAddToStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAddToStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func addToStatement() throws -> AddToStatementContext {
		var _localctx: AddToStatementContext = AddToStatementContext(_ctx, getState())
		try enterRule(_localctx, 550, Cobol85Parser.RULE_addToStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3707) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3706)
		 		try addFrom()


		 		setState(3709); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 551)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(3711)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(3713) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3712)
		 		try addTo()


		 		setState(3715); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AddToGivingStatementContext: ParserRuleContext {
			open
			func GIVING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GIVING.rawValue, 0)
			}
			open
			func addFrom() -> [AddFromContext] {
				return getRuleContexts(AddFromContext.self)
			}
			open
			func addFrom(_ i: Int) -> AddFromContext? {
				return getRuleContext(AddFromContext.self, i)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func addGiving() -> [AddGivingContext] {
				return getRuleContexts(AddGivingContext.self)
			}
			open
			func addGiving(_ i: Int) -> AddGivingContext? {
				return getRuleContext(AddGivingContext.self, i)
			}
			open
			func addToGiving() -> [AddToGivingContext] {
				return getRuleContexts(AddToGivingContext.self)
			}
			open
			func addToGiving(_ i: Int) -> AddToGivingContext? {
				return getRuleContext(AddToGivingContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_addToGivingStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAddToGivingStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAddToGivingStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAddToGivingStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAddToGivingStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func addToGivingStatement() throws -> AddToGivingStatementContext {
		var _localctx: AddToGivingStatementContext = AddToGivingStatementContext(_ctx, getState())
		try enterRule(_localctx, 552, Cobol85Parser.RULE_addToGivingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3718) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3717)
		 		try addFrom()


		 		setState(3720); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 551)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(3728)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3722)
		 		try match(Cobol85Parser.Tokens.TO.rawValue)
		 		setState(3724) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(3723)
		 			try addToGiving()


		 			setState(3726); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 68)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 138)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 202)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 268)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 401)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 466)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 551)
		 		          }()
		 		      return testSet
		 		 }())

		 	}

		 	setState(3730)
		 	try match(Cobol85Parser.Tokens.GIVING.rawValue)
		 	setState(3732) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3731)
		 		try addGiving()


		 		setState(3734); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AddCorrespondingStatementContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func addTo() -> AddToContext? {
				return getRuleContext(AddToContext.self, 0)
			}
			open
			func CORRESPONDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CORRESPONDING.rawValue, 0)
			}
			open
			func CORR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CORR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_addCorrespondingStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAddCorrespondingStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAddCorrespondingStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAddCorrespondingStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAddCorrespondingStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func addCorrespondingStatement() throws -> AddCorrespondingStatementContext {
		var _localctx: AddCorrespondingStatementContext = AddCorrespondingStatementContext(_ctx, getState())
		try enterRule(_localctx, 554, Cobol85Parser.RULE_addCorrespondingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3736)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CORR.rawValue || _la == Cobol85Parser.Tokens.CORRESPONDING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3737)
		 	try identifier()
		 	setState(3738)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(3739)
		 	try addTo()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AddFromContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_addFrom
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAddFrom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAddFrom(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAddFrom(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAddFrom(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func addFrom() throws -> AddFromContext {
		var _localctx: AddFromContext = AddFromContext(_ctx, getState())
		try enterRule(_localctx, 556, Cobol85Parser.RULE_addFrom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3743)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,484, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3741)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3742)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AddToContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func ROUNDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ROUNDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_addTo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAddTo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAddTo(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAddTo(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAddTo(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func addTo() throws -> AddToContext {
		var _localctx: AddToContext = AddToContext(_ctx, getState())
		try enterRule(_localctx, 558, Cobol85Parser.RULE_addTo)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3745)
		 	try identifier()
		 	setState(3747)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ROUNDED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3746)
		 		try match(Cobol85Parser.Tokens.ROUNDED.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AddToGivingContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_addToGiving
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAddToGiving(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAddToGiving(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAddToGiving(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAddToGiving(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func addToGiving() throws -> AddToGivingContext {
		var _localctx: AddToGivingContext = AddToGivingContext(_ctx, getState())
		try enterRule(_localctx, 560, Cobol85Parser.RULE_addToGiving)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3751)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,486, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3749)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3750)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AddGivingContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func ROUNDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ROUNDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_addGiving
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAddGiving(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAddGiving(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAddGiving(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAddGiving(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func addGiving() throws -> AddGivingContext {
		var _localctx: AddGivingContext = AddGivingContext(_ctx, getState())
		try enterRule(_localctx, 562, Cobol85Parser.RULE_addGiving)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3753)
		 	try identifier()
		 	setState(3755)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ROUNDED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3754)
		 		try match(Cobol85Parser.Tokens.ROUNDED.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlteredGoToContext: ParserRuleContext {
			open
			func GO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GO.rawValue, 0)
			}
			open
			func DOT_FS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOT_FS.rawValue, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_alteredGoTo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAlteredGoTo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAlteredGoTo(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAlteredGoTo(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAlteredGoTo(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func alteredGoTo() throws -> AlteredGoToContext {
		var _localctx: AlteredGoToContext = AlteredGoToContext(_ctx, getState())
		try enterRule(_localctx, 564, Cobol85Parser.RULE_alteredGoTo)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3757)
		 	try match(Cobol85Parser.Tokens.GO.rawValue)
		 	setState(3759)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3758)
		 		try match(Cobol85Parser.Tokens.TO.rawValue)

		 	}

		 	setState(3761)
		 	try match(Cobol85Parser.Tokens.DOT_FS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterStatementContext: ParserRuleContext {
			open
			func ALTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALTER.rawValue, 0)
			}
			open
			func alterProceedTo() -> [AlterProceedToContext] {
				return getRuleContexts(AlterProceedToContext.self)
			}
			open
			func alterProceedTo(_ i: Int) -> AlterProceedToContext? {
				return getRuleContext(AlterProceedToContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_alterStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAlterStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAlterStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAlterStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAlterStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func alterStatement() throws -> AlterStatementContext {
		var _localctx: AlterStatementContext = AlterStatementContext(_ctx, getState())
		try enterRule(_localctx, 566, Cobol85Parser.RULE_alterStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3763)
		 	try match(Cobol85Parser.Tokens.ALTER.rawValue)
		 	setState(3765) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3764)
		 		try alterProceedTo()


		 		setState(3767); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterProceedToContext: ParserRuleContext {
			open
			func procedureName() -> [ProcedureNameContext] {
				return getRuleContexts(ProcedureNameContext.self)
			}
			open
			func procedureName(_ i: Int) -> ProcedureNameContext? {
				return getRuleContext(ProcedureNameContext.self, i)
			}
			open
			func TO() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.TO.rawValue)
			}
			open
			func TO(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, i)
			}
			open
			func PROCEED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROCEED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_alterProceedTo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAlterProceedTo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAlterProceedTo(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAlterProceedTo(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAlterProceedTo(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func alterProceedTo() throws -> AlterProceedToContext {
		var _localctx: AlterProceedToContext = AlterProceedToContext(_ctx, getState())
		try enterRule(_localctx, 568, Cobol85Parser.RULE_alterProceedTo)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3769)
		 	try procedureName()
		 	setState(3770)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(3773)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.PROCEED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3771)
		 		try match(Cobol85Parser.Tokens.PROCEED.rawValue)
		 		setState(3772)
		 		try match(Cobol85Parser.Tokens.TO.rawValue)

		 	}

		 	setState(3775)
		 	try procedureName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CallStatementContext: ParserRuleContext {
			open
			func CALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CALL.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func callUsingPhrase() -> CallUsingPhraseContext? {
				return getRuleContext(CallUsingPhraseContext.self, 0)
			}
			open
			func callGivingPhrase() -> CallGivingPhraseContext? {
				return getRuleContext(CallGivingPhraseContext.self, 0)
			}
			open
			func onOverflowPhrase() -> OnOverflowPhraseContext? {
				return getRuleContext(OnOverflowPhraseContext.self, 0)
			}
			open
			func onExceptionClause() -> OnExceptionClauseContext? {
				return getRuleContext(OnExceptionClauseContext.self, 0)
			}
			open
			func notOnExceptionClause() -> NotOnExceptionClauseContext? {
				return getRuleContext(NotOnExceptionClauseContext.self, 0)
			}
			open
			func END_CALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_CALL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_callStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCallStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCallStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCallStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCallStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func callStatement() throws -> CallStatementContext {
		var _localctx: CallStatementContext = CallStatementContext(_ctx, getState())
		try enterRule(_localctx, 570, Cobol85Parser.RULE_callStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3777)
		 	try match(Cobol85Parser.Tokens.CALL.rawValue)
		 	setState(3780)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,491, _ctx)) {
		 	case 1:
		 		setState(3778)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(3779)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(3783)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.USING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3782)
		 		try callUsingPhrase()

		 	}

		 	setState(3786)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.GIVING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.RETURNING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3785)
		 		try callGivingPhrase()

		 	}

		 	setState(3789)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,494,_ctx)) {
		 	case 1:
		 		setState(3788)
		 		try onOverflowPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3792)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,495,_ctx)) {
		 	case 1:
		 		setState(3791)
		 		try onExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(3795)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,496,_ctx)) {
		 	case 1:
		 		setState(3794)
		 		try notOnExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(3798)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,497,_ctx)) {
		 	case 1:
		 		setState(3797)
		 		try match(Cobol85Parser.Tokens.END_CALL.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CallUsingPhraseContext: ParserRuleContext {
			open
			func USING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USING.rawValue, 0)
			}
			open
			func callUsingParameter() -> [CallUsingParameterContext] {
				return getRuleContexts(CallUsingParameterContext.self)
			}
			open
			func callUsingParameter(_ i: Int) -> CallUsingParameterContext? {
				return getRuleContext(CallUsingParameterContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_callUsingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCallUsingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCallUsingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCallUsingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCallUsingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func callUsingPhrase() throws -> CallUsingPhraseContext {
		var _localctx: CallUsingPhraseContext = CallUsingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 572, Cobol85Parser.RULE_callUsingPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3800)
		 	try match(Cobol85Parser.Tokens.USING.rawValue)
		 	setState(3802); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3801)
		 			try callUsingParameter()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3804); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,498,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CallUsingParameterContext: ParserRuleContext {
			open
			func callByReferencePhrase() -> CallByReferencePhraseContext? {
				return getRuleContext(CallByReferencePhraseContext.self, 0)
			}
			open
			func callByValuePhrase() -> CallByValuePhraseContext? {
				return getRuleContext(CallByValuePhraseContext.self, 0)
			}
			open
			func callByContentPhrase() -> CallByContentPhraseContext? {
				return getRuleContext(CallByContentPhraseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_callUsingParameter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCallUsingParameter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCallUsingParameter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCallUsingParameter(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCallUsingParameter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func callUsingParameter() throws -> CallUsingParameterContext {
		var _localctx: CallUsingParameterContext = CallUsingParameterContext(_ctx, getState())
		try enterRule(_localctx, 574, Cobol85Parser.RULE_callUsingParameter)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3809)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,499, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3806)
		 		try callByReferencePhrase()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3807)
		 		try callByValuePhrase()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3808)
		 		try callByContentPhrase()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CallByReferencePhraseContext: ParserRuleContext {
			open
			func REFERENCE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REFERENCE.rawValue, 0)
			}
			open
			func callByReference() -> [CallByReferenceContext] {
				return getRuleContexts(CallByReferenceContext.self)
			}
			open
			func callByReference(_ i: Int) -> CallByReferenceContext? {
				return getRuleContext(CallByReferenceContext.self, i)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_callByReferencePhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCallByReferencePhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCallByReferencePhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCallByReferencePhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCallByReferencePhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func callByReferencePhrase() throws -> CallByReferencePhraseContext {
		var _localctx: CallByReferencePhraseContext = CallByReferencePhraseContext(_ctx, getState())
		try enterRule(_localctx, 576, Cobol85Parser.RULE_callByReferencePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3815)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.BY.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.REFERENCE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3812)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.BY.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3811)
		 			try match(Cobol85Parser.Tokens.BY.rawValue)

		 		}

		 		setState(3814)
		 		try match(Cobol85Parser.Tokens.REFERENCE.rawValue)

		 	}

		 	setState(3818); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3817)
		 			try callByReference()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3820); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,502,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CallByReferenceContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func ADDRESS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ADDRESS.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
			open
			func INTEGER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTEGER.rawValue, 0)
			}
			open
			func STRING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STRING.rawValue, 0)
			}
			open
			func OMITTED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OMITTED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_callByReference
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCallByReference(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCallByReference(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCallByReference(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCallByReference(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func callByReference() throws -> CallByReferenceContext {
		var _localctx: CallByReferenceContext = CallByReferenceContext(_ctx, getState())
		try enterRule(_localctx, 578, Cobol85Parser.RULE_callByReference)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3834)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ABORT:fallthrough
		 	case .ADDRESS:fallthrough
		 	case .ALL:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DAY_OF_WEEK:fallthrough
		 	case .DEBUG_CONTENTS:fallthrough
		 	case .DEBUG_ITEM:fallthrough
		 	case .DEBUG_LINE:fallthrough
		 	case .DEBUG_NAME:fallthrough
		 	case .DEBUG_SUB_1:fallthrough
		 	case .DEBUG_SUB_2:fallthrough
		 	case .DEBUG_SUB_3:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FALSE:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .HIGH_VALUE:fallthrough
		 	case .HIGH_VALUES:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LINAGE_COUNTER:fallthrough
		 	case .LINE_COUNTER:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .LOW_VALUE:fallthrough
		 	case .LOW_VALUES:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PAGE_COUNTER:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .QUOTE:fallthrough
		 	case .QUOTES:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .RETURN_CODE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHIFT_IN:fallthrough
		 	case .SHIFT_OUT:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SORT_CONTROL:fallthrough
		 	case .SORT_CORE_SIZE:fallthrough
		 	case .SORT_FILE_SIZE:fallthrough
		 	case .SORT_MESSAGE:fallthrough
		 	case .SORT_MODE_SIZE:fallthrough
		 	case .SORT_RETURN:fallthrough
		 	case .SPACE:fallthrough
		 	case .SPACES:fallthrough
		 	case .STRING:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TALLY:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .WHEN_COMPILED:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .ZEROS:fallthrough
		 	case .ZEROES:fallthrough
		 	case .NONNUMERICLITERAL:fallthrough
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:fallthrough
		 	case .NUMERICLITERAL:fallthrough
		 	case .IDENTIFIER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3831)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,504, _ctx)) {
		 		case 1:
		 			setState(3826)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,503,_ctx)) {
		 			case 1:
		 				setState(3822)
		 				try match(Cobol85Parser.Tokens.ADDRESS.rawValue)
		 				setState(3823)
		 				try match(Cobol85Parser.Tokens.OF.rawValue)

		 				break
		 			case 2:
		 				setState(3824)
		 				try match(Cobol85Parser.Tokens.INTEGER.rawValue)

		 				break
		 			case 3:
		 				setState(3825)
		 				try match(Cobol85Parser.Tokens.STRING.rawValue)

		 				break
		 			default: break
		 			}
		 			setState(3828)
		 			try identifier()

		 			break
		 		case 2:
		 			setState(3829)
		 			try literal()

		 			break
		 		case 3:
		 			setState(3830)
		 			try fileName()

		 			break
		 		default: break
		 		}

		 		break

		 	case .OMITTED:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3833)
		 		try match(Cobol85Parser.Tokens.OMITTED.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CallByValuePhraseContext: ParserRuleContext {
			open
			func VALUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VALUE.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func callByValue() -> [CallByValueContext] {
				return getRuleContexts(CallByValueContext.self)
			}
			open
			func callByValue(_ i: Int) -> CallByValueContext? {
				return getRuleContext(CallByValueContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_callByValuePhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCallByValuePhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCallByValuePhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCallByValuePhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCallByValuePhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func callByValuePhrase() throws -> CallByValuePhraseContext {
		var _localctx: CallByValuePhraseContext = CallByValuePhraseContext(_ctx, getState())
		try enterRule(_localctx, 580, Cobol85Parser.RULE_callByValuePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3837)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.BY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3836)
		 		try match(Cobol85Parser.Tokens.BY.rawValue)

		 	}

		 	setState(3839)
		 	try match(Cobol85Parser.Tokens.VALUE.rawValue)
		 	setState(3841); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3840)
		 			try callByValue()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3843); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,507,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CallByValueContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func ADDRESS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ADDRESS.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
			open
			func LENGTH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LENGTH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_callByValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCallByValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCallByValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCallByValue(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCallByValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func callByValue() throws -> CallByValueContext {
		var _localctx: CallByValueContext = CallByValueContext(_ctx, getState())
		try enterRule(_localctx, 582, Cobol85Parser.RULE_callByValue)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3851)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,509,_ctx)) {
		 	case 1:
		 		setState(3845)
		 		try match(Cobol85Parser.Tokens.ADDRESS.rawValue)
		 		setState(3846)
		 		try match(Cobol85Parser.Tokens.OF.rawValue)

		 		break
		 	case 2:
		 		setState(3847)
		 		try match(Cobol85Parser.Tokens.LENGTH.rawValue)
		 		setState(3849)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.OF.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3848)
		 			try match(Cobol85Parser.Tokens.OF.rawValue)

		 		}


		 		break
		 	default: break
		 	}
		 	setState(3855)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,510, _ctx)) {
		 	case 1:
		 		setState(3853)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(3854)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CallByContentPhraseContext: ParserRuleContext {
			open
			func CONTENT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTENT.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func callByContent() -> [CallByContentContext] {
				return getRuleContexts(CallByContentContext.self)
			}
			open
			func callByContent(_ i: Int) -> CallByContentContext? {
				return getRuleContext(CallByContentContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_callByContentPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCallByContentPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCallByContentPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCallByContentPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCallByContentPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func callByContentPhrase() throws -> CallByContentPhraseContext {
		var _localctx: CallByContentPhraseContext = CallByContentPhraseContext(_ctx, getState())
		try enterRule(_localctx, 584, Cobol85Parser.RULE_callByContentPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3858)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.BY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3857)
		 		try match(Cobol85Parser.Tokens.BY.rawValue)

		 	}

		 	setState(3860)
		 	try match(Cobol85Parser.Tokens.CONTENT.rawValue)
		 	setState(3862); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(3861)
		 			try callByContent()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3864); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,512,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CallByContentContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func ADDRESS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ADDRESS.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
			open
			func LENGTH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LENGTH.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func OMITTED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OMITTED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_callByContent
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCallByContent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCallByContent(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCallByContent(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCallByContent(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func callByContent() throws -> CallByContentContext {
		var _localctx: CallByContentContext = CallByContentContext(_ctx, getState())
		try enterRule(_localctx, 586, Cobol85Parser.RULE_callByContent)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3877)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,515, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3872)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,514,_ctx)) {
		 		case 1:
		 			setState(3866)
		 			try match(Cobol85Parser.Tokens.ADDRESS.rawValue)
		 			setState(3867)
		 			try match(Cobol85Parser.Tokens.OF.rawValue)

		 			break
		 		case 2:
		 			setState(3868)
		 			try match(Cobol85Parser.Tokens.LENGTH.rawValue)
		 			setState(3870)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.OF.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(3869)
		 				try match(Cobol85Parser.Tokens.OF.rawValue)

		 			}


		 			break
		 		default: break
		 		}
		 		setState(3874)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3875)
		 		try literal()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3876)
		 		try match(Cobol85Parser.Tokens.OMITTED.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CallGivingPhraseContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func GIVING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GIVING.rawValue, 0)
			}
			open
			func RETURNING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RETURNING.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_callGivingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCallGivingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCallGivingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCallGivingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCallGivingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func callGivingPhrase() throws -> CallGivingPhraseContext {
		var _localctx: CallGivingPhraseContext = CallGivingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 588, Cobol85Parser.RULE_callGivingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3879)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.GIVING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.RETURNING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3880)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CancelStatementContext: ParserRuleContext {
			open
			func CANCEL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CANCEL.rawValue, 0)
			}
			open
			func cancelCall() -> [CancelCallContext] {
				return getRuleContexts(CancelCallContext.self)
			}
			open
			func cancelCall(_ i: Int) -> CancelCallContext? {
				return getRuleContext(CancelCallContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_cancelStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCancelStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCancelStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCancelStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCancelStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cancelStatement() throws -> CancelStatementContext {
		var _localctx: CancelStatementContext = CancelStatementContext(_ctx, getState())
		try enterRule(_localctx, 590, Cobol85Parser.RULE_cancelStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3882)
		 	try match(Cobol85Parser.Tokens.CANCEL.rawValue)
		 	setState(3884) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3883)
		 		try cancelCall()


		 		setState(3886); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 551)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CancelCallContext: ParserRuleContext {
			open
			func libraryName() -> LibraryNameContext? {
				return getRuleContext(LibraryNameContext.self, 0)
			}
			open
			func BYTITLE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BYTITLE.rawValue, 0)
			}
			open
			func BYFUNCTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BYFUNCTION.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_cancelCall
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCancelCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCancelCall(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCancelCall(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCancelCall(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cancelCall() throws -> CancelCallContext {
		var _localctx: CancelCallContext = CancelCallContext(_ctx, getState())
		try enterRule(_localctx, 592, Cobol85Parser.RULE_cancelCall)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3893)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,517, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3888)
		 		try libraryName()
		 		setState(3889)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.BYFUNCTION.rawValue || _la == Cobol85Parser.Tokens.BYTITLE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3891)
		 		try identifier()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3892)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CloseStatementContext: ParserRuleContext {
			open
			func CLOSE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CLOSE.rawValue, 0)
			}
			open
			func closeFile() -> [CloseFileContext] {
				return getRuleContexts(CloseFileContext.self)
			}
			open
			func closeFile(_ i: Int) -> CloseFileContext? {
				return getRuleContext(CloseFileContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_closeStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCloseStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCloseStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCloseStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCloseStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func closeStatement() throws -> CloseStatementContext {
		var _localctx: CloseStatementContext = CloseStatementContext(_ctx, getState())
		try enterRule(_localctx, 594, Cobol85Parser.RULE_closeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3895)
		 	try match(Cobol85Parser.Tokens.CLOSE.rawValue)
		 	setState(3897) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3896)
		 		try closeFile()


		 		setState(3899); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CloseFileContext: ParserRuleContext {
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func closeReelUnitStatement() -> CloseReelUnitStatementContext? {
				return getRuleContext(CloseReelUnitStatementContext.self, 0)
			}
			open
			func closeRelativeStatement() -> CloseRelativeStatementContext? {
				return getRuleContext(CloseRelativeStatementContext.self, 0)
			}
			open
			func closePortFileIOStatement() -> ClosePortFileIOStatementContext? {
				return getRuleContext(ClosePortFileIOStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_closeFile
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCloseFile(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCloseFile(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCloseFile(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCloseFile(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func closeFile() throws -> CloseFileContext {
		var _localctx: CloseFileContext = CloseFileContext(_ctx, getState())
		try enterRule(_localctx, 596, Cobol85Parser.RULE_closeFile)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3901)
		 	try fileName()
		 	setState(3905)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,519,_ctx)) {
		 	case 1:
		 		setState(3902)
		 		try closeReelUnitStatement()

		 		break
		 	case 2:
		 		setState(3903)
		 		try closeRelativeStatement()

		 		break
		 	case 3:
		 		setState(3904)
		 		try closePortFileIOStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CloseReelUnitStatementContext: ParserRuleContext {
			open
			func REEL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REEL.rawValue, 0)
			}
			open
			func UNIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.UNIT.rawValue, 0)
			}
			open
			func REMOVAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REMOVAL.rawValue, 0)
			}
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
			open
			func REWIND() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REWIND.rawValue, 0)
			}
			open
			func LOCK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOCK.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_closeReelUnitStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCloseReelUnitStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCloseReelUnitStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCloseReelUnitStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCloseReelUnitStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func closeReelUnitStatement() throws -> CloseReelUnitStatementContext {
		var _localctx: CloseReelUnitStatementContext = CloseReelUnitStatementContext(_ctx, getState())
		try enterRule(_localctx, 598, Cobol85Parser.RULE_closeReelUnitStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3907)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.REEL.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.UNIT.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3912)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.REMOVAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3909)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3908)
		 			try match(Cobol85Parser.Tokens.FOR.rawValue)

		 		}

		 		setState(3911)
		 		try match(Cobol85Parser.Tokens.REMOVAL.rawValue)

		 	}

		 	setState(3922)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,524,_ctx)) {
		 	case 1:
		 		setState(3915)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3914)
		 			try match(Cobol85Parser.Tokens.WITH.rawValue)

		 		}

		 		setState(3920)
		 		try _errHandler.sync(self)
		 		switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .NO:
		 			setState(3917)
		 			try match(Cobol85Parser.Tokens.NO.rawValue)
		 			setState(3918)
		 			try match(Cobol85Parser.Tokens.REWIND.rawValue)

		 			break

		 		case .LOCK:
		 			setState(3919)
		 			try match(Cobol85Parser.Tokens.LOCK.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CloseRelativeStatementContext: ParserRuleContext {
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
			open
			func REWIND() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REWIND.rawValue, 0)
			}
			open
			func LOCK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOCK.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_closeRelativeStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCloseRelativeStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCloseRelativeStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCloseRelativeStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCloseRelativeStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func closeRelativeStatement() throws -> CloseRelativeStatementContext {
		var _localctx: CloseRelativeStatementContext = CloseRelativeStatementContext(_ctx, getState())
		try enterRule(_localctx, 600, Cobol85Parser.RULE_closeRelativeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3925)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3924)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(3930)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NO:
		 		setState(3927)
		 		try match(Cobol85Parser.Tokens.NO.rawValue)
		 		setState(3928)
		 		try match(Cobol85Parser.Tokens.REWIND.rawValue)

		 		break

		 	case .LOCK:
		 		setState(3929)
		 		try match(Cobol85Parser.Tokens.LOCK.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClosePortFileIOStatementContext: ParserRuleContext {
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
			open
			func WAIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WAIT.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
			open
			func USING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USING.rawValue, 0)
			}
			open
			func closePortFileIOUsing() -> [ClosePortFileIOUsingContext] {
				return getRuleContexts(ClosePortFileIOUsingContext.self)
			}
			open
			func closePortFileIOUsing(_ i: Int) -> ClosePortFileIOUsingContext? {
				return getRuleContext(ClosePortFileIOUsingContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_closePortFileIOStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterClosePortFileIOStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitClosePortFileIOStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitClosePortFileIOStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitClosePortFileIOStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func closePortFileIOStatement() throws -> ClosePortFileIOStatementContext {
		var _localctx: ClosePortFileIOStatementContext = ClosePortFileIOStatementContext(_ctx, getState())
		try enterRule(_localctx, 602, Cobol85Parser.RULE_closePortFileIOStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3939)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,528, _ctx)) {
		 	case 1:
		 		setState(3933)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3932)
		 			try match(Cobol85Parser.Tokens.WITH.rawValue)

		 		}

		 		setState(3935)
		 		try match(Cobol85Parser.Tokens.NO.rawValue)
		 		setState(3936)
		 		try match(Cobol85Parser.Tokens.WAIT.rawValue)

		 		break
		 	case 2:
		 		setState(3937)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)
		 		setState(3938)
		 		try match(Cobol85Parser.Tokens.WAIT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(3947)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.USING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3941)
		 		try match(Cobol85Parser.Tokens.USING.rawValue)
		 		setState(3943); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(3942)
		 				try closePortFileIOUsing()


		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(3945); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,529,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClosePortFileIOUsingContext: ParserRuleContext {
			open
			func closePortFileIOUsingCloseDisposition() -> ClosePortFileIOUsingCloseDispositionContext? {
				return getRuleContext(ClosePortFileIOUsingCloseDispositionContext.self, 0)
			}
			open
			func closePortFileIOUsingAssociatedData() -> ClosePortFileIOUsingAssociatedDataContext? {
				return getRuleContext(ClosePortFileIOUsingAssociatedDataContext.self, 0)
			}
			open
			func closePortFileIOUsingAssociatedDataLength() -> ClosePortFileIOUsingAssociatedDataLengthContext? {
				return getRuleContext(ClosePortFileIOUsingAssociatedDataLengthContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_closePortFileIOUsing
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterClosePortFileIOUsing(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitClosePortFileIOUsing(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitClosePortFileIOUsing(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitClosePortFileIOUsing(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func closePortFileIOUsing() throws -> ClosePortFileIOUsingContext {
		var _localctx: ClosePortFileIOUsingContext = ClosePortFileIOUsingContext(_ctx, getState())
		try enterRule(_localctx, 604, Cobol85Parser.RULE_closePortFileIOUsing)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3952)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CLOSE_DISPOSITION:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3949)
		 		try closePortFileIOUsingCloseDisposition()

		 		break

		 	case .ASSOCIATED_DATA:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3950)
		 		try closePortFileIOUsingAssociatedData()

		 		break

		 	case .ASSOCIATED_DATA_LENGTH:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3951)
		 		try closePortFileIOUsingAssociatedDataLength()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClosePortFileIOUsingCloseDispositionContext: ParserRuleContext {
			open
			func CLOSE_DISPOSITION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue, 0)
			}
			open
			func ABORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ABORT.rawValue, 0)
			}
			open
			func ORDERLY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ORDERLY.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_closePortFileIOUsingCloseDisposition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterClosePortFileIOUsingCloseDisposition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitClosePortFileIOUsingCloseDisposition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitClosePortFileIOUsingCloseDisposition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitClosePortFileIOUsingCloseDisposition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func closePortFileIOUsingCloseDisposition() throws -> ClosePortFileIOUsingCloseDispositionContext {
		var _localctx: ClosePortFileIOUsingCloseDispositionContext = ClosePortFileIOUsingCloseDispositionContext(_ctx, getState())
		try enterRule(_localctx, 606, Cobol85Parser.RULE_closePortFileIOUsingCloseDisposition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3954)
		 	try match(Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue)
		 	setState(3956)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.OF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3955)
		 		try match(Cobol85Parser.Tokens.OF.rawValue)

		 	}

		 	setState(3958)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ABORT.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.ORDERLY.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClosePortFileIOUsingAssociatedDataContext: ParserRuleContext {
			open
			func ASSOCIATED_DATA() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_closePortFileIOUsingAssociatedData
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterClosePortFileIOUsingAssociatedData(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitClosePortFileIOUsingAssociatedData(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitClosePortFileIOUsingAssociatedData(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitClosePortFileIOUsingAssociatedData(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func closePortFileIOUsingAssociatedData() throws -> ClosePortFileIOUsingAssociatedDataContext {
		var _localctx: ClosePortFileIOUsingAssociatedDataContext = ClosePortFileIOUsingAssociatedDataContext(_ctx, getState())
		try enterRule(_localctx, 608, Cobol85Parser.RULE_closePortFileIOUsingAssociatedData)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3960)
		 	try match(Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue)
		 	setState(3963)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,533, _ctx)) {
		 	case 1:
		 		setState(3961)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(3962)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClosePortFileIOUsingAssociatedDataLengthContext: ParserRuleContext {
			open
			func ASSOCIATED_DATA_LENGTH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_closePortFileIOUsingAssociatedDataLength
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterClosePortFileIOUsingAssociatedDataLength(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitClosePortFileIOUsingAssociatedDataLength(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitClosePortFileIOUsingAssociatedDataLength(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitClosePortFileIOUsingAssociatedDataLength(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func closePortFileIOUsingAssociatedDataLength() throws -> ClosePortFileIOUsingAssociatedDataLengthContext {
		var _localctx: ClosePortFileIOUsingAssociatedDataLengthContext = ClosePortFileIOUsingAssociatedDataLengthContext(_ctx, getState())
		try enterRule(_localctx, 610, Cobol85Parser.RULE_closePortFileIOUsingAssociatedDataLength)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3965)
		 	try match(Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue)
		 	setState(3967)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.OF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3966)
		 		try match(Cobol85Parser.Tokens.OF.rawValue)

		 	}

		 	setState(3971)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,535, _ctx)) {
		 	case 1:
		 		setState(3969)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(3970)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ComputeStatementContext: ParserRuleContext {
			open
			func COMPUTE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMPUTE.rawValue, 0)
			}
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
			open
			func EQUALCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EQUALCHAR.rawValue, 0)
			}
			open
			func EQUAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EQUAL.rawValue, 0)
			}
			open
			func computeStore() -> [ComputeStoreContext] {
				return getRuleContexts(ComputeStoreContext.self)
			}
			open
			func computeStore(_ i: Int) -> ComputeStoreContext? {
				return getRuleContext(ComputeStoreContext.self, i)
			}
			open
			func onSizeErrorPhrase() -> OnSizeErrorPhraseContext? {
				return getRuleContext(OnSizeErrorPhraseContext.self, 0)
			}
			open
			func notOnSizeErrorPhrase() -> NotOnSizeErrorPhraseContext? {
				return getRuleContext(NotOnSizeErrorPhraseContext.self, 0)
			}
			open
			func END_COMPUTE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_COMPUTE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_computeStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterComputeStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitComputeStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitComputeStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitComputeStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func computeStatement() throws -> ComputeStatementContext {
		var _localctx: ComputeStatementContext = ComputeStatementContext(_ctx, getState())
		try enterRule(_localctx, 612, Cobol85Parser.RULE_computeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3973)
		 	try match(Cobol85Parser.Tokens.COMPUTE.rawValue)
		 	setState(3975) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3974)
		 		try computeStore()


		 		setState(3977); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(3979)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.EQUAL.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.EQUALCHAR.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3980)
		 	try arithmeticExpression()
		 	setState(3982)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,537,_ctx)) {
		 	case 1:
		 		setState(3981)
		 		try onSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3985)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,538,_ctx)) {
		 	case 1:
		 		setState(3984)
		 		try notOnSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(3988)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,539,_ctx)) {
		 	case 1:
		 		setState(3987)
		 		try match(Cobol85Parser.Tokens.END_COMPUTE.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ComputeStoreContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func ROUNDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ROUNDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_computeStore
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterComputeStore(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitComputeStore(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitComputeStore(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitComputeStore(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func computeStore() throws -> ComputeStoreContext {
		var _localctx: ComputeStoreContext = ComputeStoreContext(_ctx, getState())
		try enterRule(_localctx, 614, Cobol85Parser.RULE_computeStore)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3990)
		 	try identifier()
		 	setState(3992)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ROUNDED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3991)
		 		try match(Cobol85Parser.Tokens.ROUNDED.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ContinueStatementContext: ParserRuleContext {
			open
			func CONTINUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTINUE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_continueStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterContinueStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitContinueStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitContinueStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitContinueStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func continueStatement() throws -> ContinueStatementContext {
		var _localctx: ContinueStatementContext = ContinueStatementContext(_ctx, getState())
		try enterRule(_localctx, 616, Cobol85Parser.RULE_continueStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3994)
		 	try match(Cobol85Parser.Tokens.CONTINUE.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DeleteStatementContext: ParserRuleContext {
			open
			func DELETE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DELETE.rawValue, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func invalidKeyPhrase() -> InvalidKeyPhraseContext? {
				return getRuleContext(InvalidKeyPhraseContext.self, 0)
			}
			open
			func notInvalidKeyPhrase() -> NotInvalidKeyPhraseContext? {
				return getRuleContext(NotInvalidKeyPhraseContext.self, 0)
			}
			open
			func END_DELETE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_DELETE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_deleteStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDeleteStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDeleteStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDeleteStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDeleteStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func deleteStatement() throws -> DeleteStatementContext {
		var _localctx: DeleteStatementContext = DeleteStatementContext(_ctx, getState())
		try enterRule(_localctx, 618, Cobol85Parser.RULE_deleteStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3996)
		 	try match(Cobol85Parser.Tokens.DELETE.rawValue)
		 	setState(3997)
		 	try fileName()
		 	setState(3999)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.RECORD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3998)
		 		try match(Cobol85Parser.Tokens.RECORD.rawValue)

		 	}

		 	setState(4002)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,542,_ctx)) {
		 	case 1:
		 		setState(4001)
		 		try invalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4005)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,543,_ctx)) {
		 	case 1:
		 		setState(4004)
		 		try notInvalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4008)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,544,_ctx)) {
		 	case 1:
		 		setState(4007)
		 		try match(Cobol85Parser.Tokens.END_DELETE.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DisableStatementContext: ParserRuleContext {
			open
			func DISABLE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISABLE.rawValue, 0)
			}
			open
			func cdName() -> CdNameContext? {
				return getRuleContext(CdNameContext.self, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func INPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INPUT.rawValue, 0)
			}
			open
			func I_O() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.I_O.rawValue, 0)
			}
			open
			func TERMINAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TERMINAL.rawValue, 0)
			}
			open
			func OUTPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OUTPUT.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_disableStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDisableStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDisableStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDisableStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDisableStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func disableStatement() throws -> DisableStatementContext {
		var _localctx: DisableStatementContext = DisableStatementContext(_ctx, getState())
		try enterRule(_localctx, 620, Cobol85Parser.RULE_disableStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4010)
		 	try match(Cobol85Parser.Tokens.DISABLE.rawValue)
		 	setState(4018)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .INPUT:
		 		setState(4011)
		 		try match(Cobol85Parser.Tokens.INPUT.rawValue)
		 		setState(4013)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.TERMINAL.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4012)
		 			try match(Cobol85Parser.Tokens.TERMINAL.rawValue)

		 		}


		 		break

		 	case .I_O:
		 		setState(4015)
		 		try match(Cobol85Parser.Tokens.I_O.rawValue)
		 		setState(4016)
		 		try match(Cobol85Parser.Tokens.TERMINAL.rawValue)

		 		break

		 	case .OUTPUT:
		 		setState(4017)
		 		try match(Cobol85Parser.Tokens.OUTPUT.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4020)
		 	try cdName()
		 	setState(4022)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4021)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(4024)
		 	try match(Cobol85Parser.Tokens.KEY.rawValue)
		 	setState(4027)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,548, _ctx)) {
		 	case 1:
		 		setState(4025)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4026)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DisplayStatementContext: ParserRuleContext {
			open
			func DISPLAY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISPLAY.rawValue, 0)
			}
			open
			func displayOperand() -> [DisplayOperandContext] {
				return getRuleContexts(DisplayOperandContext.self)
			}
			open
			func displayOperand(_ i: Int) -> DisplayOperandContext? {
				return getRuleContext(DisplayOperandContext.self, i)
			}
			open
			func displayAt() -> DisplayAtContext? {
				return getRuleContext(DisplayAtContext.self, 0)
			}
			open
			func displayUpon() -> DisplayUponContext? {
				return getRuleContext(DisplayUponContext.self, 0)
			}
			open
			func displayWith() -> DisplayWithContext? {
				return getRuleContext(DisplayWithContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_displayStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDisplayStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDisplayStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDisplayStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDisplayStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func displayStatement() throws -> DisplayStatementContext {
		var _localctx: DisplayStatementContext = DisplayStatementContext(_ctx, getState())
		try enterRule(_localctx, 622, Cobol85Parser.RULE_displayStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4029)
		 	try match(Cobol85Parser.Tokens.DISPLAY.rawValue)
		 	setState(4031) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4030)
		 		try displayOperand()


		 		setState(4033); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 551)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(4036)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,550,_ctx)) {
		 	case 1:
		 		setState(4035)
		 		try displayAt()

		 		break
		 	default: break
		 	}
		 	setState(4039)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.UPON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4038)
		 		try displayUpon()

		 	}

		 	setState(4042)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,552,_ctx)) {
		 	case 1:
		 		setState(4041)
		 		try displayWith()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DisplayOperandContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_displayOperand
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDisplayOperand(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDisplayOperand(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDisplayOperand(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDisplayOperand(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func displayOperand() throws -> DisplayOperandContext {
		var _localctx: DisplayOperandContext = DisplayOperandContext(_ctx, getState())
		try enterRule(_localctx, 624, Cobol85Parser.RULE_displayOperand)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4046)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,553, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4044)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4045)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DisplayAtContext: ParserRuleContext {
			open
			func AT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AT.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_displayAt
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDisplayAt(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDisplayAt(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDisplayAt(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDisplayAt(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func displayAt() throws -> DisplayAtContext {
		var _localctx: DisplayAtContext = DisplayAtContext(_ctx, getState())
		try enterRule(_localctx, 626, Cobol85Parser.RULE_displayAt)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4048)
		 	try match(Cobol85Parser.Tokens.AT.rawValue)
		 	setState(4051)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,554, _ctx)) {
		 	case 1:
		 		setState(4049)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4050)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DisplayUponContext: ParserRuleContext {
			open
			func UPON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.UPON.rawValue, 0)
			}
			open
			func mnemonicName() -> MnemonicNameContext? {
				return getRuleContext(MnemonicNameContext.self, 0)
			}
			open
			func environmentName() -> EnvironmentNameContext? {
				return getRuleContext(EnvironmentNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_displayUpon
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDisplayUpon(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDisplayUpon(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDisplayUpon(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDisplayUpon(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func displayUpon() throws -> DisplayUponContext {
		var _localctx: DisplayUponContext = DisplayUponContext(_ctx, getState())
		try enterRule(_localctx, 628, Cobol85Parser.RULE_displayUpon)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4053)
		 	try match(Cobol85Parser.Tokens.UPON.rawValue)
		 	setState(4056)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,555, _ctx)) {
		 	case 1:
		 		setState(4054)
		 		try mnemonicName()

		 		break
		 	case 2:
		 		setState(4055)
		 		try environmentName()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DisplayWithContext: ParserRuleContext {
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
			open
			func ADVANCING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ADVANCING.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_displayWith
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDisplayWith(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDisplayWith(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDisplayWith(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDisplayWith(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func displayWith() throws -> DisplayWithContext {
		var _localctx: DisplayWithContext = DisplayWithContext(_ctx, getState())
		try enterRule(_localctx, 630, Cobol85Parser.RULE_displayWith)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4059)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4058)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(4061)
		 	try match(Cobol85Parser.Tokens.NO.rawValue)
		 	setState(4062)
		 	try match(Cobol85Parser.Tokens.ADVANCING.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DivideStatementContext: ParserRuleContext {
			open
			func DIVIDE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DIVIDE.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func divideIntoStatement() -> DivideIntoStatementContext? {
				return getRuleContext(DivideIntoStatementContext.self, 0)
			}
			open
			func divideIntoGivingStatement() -> DivideIntoGivingStatementContext? {
				return getRuleContext(DivideIntoGivingStatementContext.self, 0)
			}
			open
			func divideByGivingStatement() -> DivideByGivingStatementContext? {
				return getRuleContext(DivideByGivingStatementContext.self, 0)
			}
			open
			func divideRemainder() -> DivideRemainderContext? {
				return getRuleContext(DivideRemainderContext.self, 0)
			}
			open
			func onSizeErrorPhrase() -> OnSizeErrorPhraseContext? {
				return getRuleContext(OnSizeErrorPhraseContext.self, 0)
			}
			open
			func notOnSizeErrorPhrase() -> NotOnSizeErrorPhraseContext? {
				return getRuleContext(NotOnSizeErrorPhraseContext.self, 0)
			}
			open
			func END_DIVIDE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_DIVIDE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_divideStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDivideStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDivideStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDivideStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDivideStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func divideStatement() throws -> DivideStatementContext {
		var _localctx: DivideStatementContext = DivideStatementContext(_ctx, getState())
		try enterRule(_localctx, 632, Cobol85Parser.RULE_divideStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4064)
		 	try match(Cobol85Parser.Tokens.DIVIDE.rawValue)
		 	setState(4067)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,557, _ctx)) {
		 	case 1:
		 		setState(4065)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4066)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4072)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,558, _ctx)) {
		 	case 1:
		 		setState(4069)
		 		try divideIntoStatement()

		 		break
		 	case 2:
		 		setState(4070)
		 		try divideIntoGivingStatement()

		 		break
		 	case 3:
		 		setState(4071)
		 		try divideByGivingStatement()

		 		break
		 	default: break
		 	}
		 	setState(4075)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.REMAINDER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4074)
		 		try divideRemainder()

		 	}

		 	setState(4078)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,560,_ctx)) {
		 	case 1:
		 		setState(4077)
		 		try onSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4081)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,561,_ctx)) {
		 	case 1:
		 		setState(4080)
		 		try notOnSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4084)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,562,_ctx)) {
		 	case 1:
		 		setState(4083)
		 		try match(Cobol85Parser.Tokens.END_DIVIDE.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DivideIntoStatementContext: ParserRuleContext {
			open
			func INTO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTO.rawValue, 0)
			}
			open
			func divideInto() -> [DivideIntoContext] {
				return getRuleContexts(DivideIntoContext.self)
			}
			open
			func divideInto(_ i: Int) -> DivideIntoContext? {
				return getRuleContext(DivideIntoContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_divideIntoStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDivideIntoStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDivideIntoStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDivideIntoStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDivideIntoStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func divideIntoStatement() throws -> DivideIntoStatementContext {
		var _localctx: DivideIntoStatementContext = DivideIntoStatementContext(_ctx, getState())
		try enterRule(_localctx, 634, Cobol85Parser.RULE_divideIntoStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4086)
		 	try match(Cobol85Parser.Tokens.INTO.rawValue)
		 	setState(4088) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4087)
		 		try divideInto()


		 		setState(4090); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DivideIntoGivingStatementContext: ParserRuleContext {
			open
			func INTO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTO.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func divideGivingPhrase() -> DivideGivingPhraseContext? {
				return getRuleContext(DivideGivingPhraseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_divideIntoGivingStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDivideIntoGivingStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDivideIntoGivingStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDivideIntoGivingStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDivideIntoGivingStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func divideIntoGivingStatement() throws -> DivideIntoGivingStatementContext {
		var _localctx: DivideIntoGivingStatementContext = DivideIntoGivingStatementContext(_ctx, getState())
		try enterRule(_localctx, 636, Cobol85Parser.RULE_divideIntoGivingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4092)
		 	try match(Cobol85Parser.Tokens.INTO.rawValue)
		 	setState(4095)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,564, _ctx)) {
		 	case 1:
		 		setState(4093)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4094)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4098)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.GIVING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4097)
		 		try divideGivingPhrase()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DivideByGivingStatementContext: ParserRuleContext {
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func divideGivingPhrase() -> DivideGivingPhraseContext? {
				return getRuleContext(DivideGivingPhraseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_divideByGivingStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDivideByGivingStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDivideByGivingStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDivideByGivingStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDivideByGivingStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func divideByGivingStatement() throws -> DivideByGivingStatementContext {
		var _localctx: DivideByGivingStatementContext = DivideByGivingStatementContext(_ctx, getState())
		try enterRule(_localctx, 638, Cobol85Parser.RULE_divideByGivingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4100)
		 	try match(Cobol85Parser.Tokens.BY.rawValue)
		 	setState(4103)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,566, _ctx)) {
		 	case 1:
		 		setState(4101)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4102)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4106)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.GIVING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4105)
		 		try divideGivingPhrase()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DivideGivingPhraseContext: ParserRuleContext {
			open
			func GIVING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GIVING.rawValue, 0)
			}
			open
			func divideGiving() -> [DivideGivingContext] {
				return getRuleContexts(DivideGivingContext.self)
			}
			open
			func divideGiving(_ i: Int) -> DivideGivingContext? {
				return getRuleContext(DivideGivingContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_divideGivingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDivideGivingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDivideGivingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDivideGivingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDivideGivingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func divideGivingPhrase() throws -> DivideGivingPhraseContext {
		var _localctx: DivideGivingPhraseContext = DivideGivingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 640, Cobol85Parser.RULE_divideGivingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4108)
		 	try match(Cobol85Parser.Tokens.GIVING.rawValue)
		 	setState(4110) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4109)
		 		try divideGiving()


		 		setState(4112); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DivideIntoContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func ROUNDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ROUNDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_divideInto
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDivideInto(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDivideInto(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDivideInto(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDivideInto(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func divideInto() throws -> DivideIntoContext {
		var _localctx: DivideIntoContext = DivideIntoContext(_ctx, getState())
		try enterRule(_localctx, 642, Cobol85Parser.RULE_divideInto)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4114)
		 	try identifier()
		 	setState(4116)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ROUNDED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4115)
		 		try match(Cobol85Parser.Tokens.ROUNDED.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DivideGivingContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func ROUNDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ROUNDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_divideGiving
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDivideGiving(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDivideGiving(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDivideGiving(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDivideGiving(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func divideGiving() throws -> DivideGivingContext {
		var _localctx: DivideGivingContext = DivideGivingContext(_ctx, getState())
		try enterRule(_localctx, 644, Cobol85Parser.RULE_divideGiving)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4118)
		 	try identifier()
		 	setState(4120)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ROUNDED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4119)
		 		try match(Cobol85Parser.Tokens.ROUNDED.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DivideRemainderContext: ParserRuleContext {
			open
			func REMAINDER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REMAINDER.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_divideRemainder
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDivideRemainder(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDivideRemainder(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDivideRemainder(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDivideRemainder(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func divideRemainder() throws -> DivideRemainderContext {
		var _localctx: DivideRemainderContext = DivideRemainderContext(_ctx, getState())
		try enterRule(_localctx, 646, Cobol85Parser.RULE_divideRemainder)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4122)
		 	try match(Cobol85Parser.Tokens.REMAINDER.rawValue)
		 	setState(4123)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EnableStatementContext: ParserRuleContext {
			open
			func ENABLE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ENABLE.rawValue, 0)
			}
			open
			func cdName() -> CdNameContext? {
				return getRuleContext(CdNameContext.self, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func INPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INPUT.rawValue, 0)
			}
			open
			func I_O() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.I_O.rawValue, 0)
			}
			open
			func TERMINAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TERMINAL.rawValue, 0)
			}
			open
			func OUTPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OUTPUT.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_enableStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEnableStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEnableStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEnableStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEnableStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func enableStatement() throws -> EnableStatementContext {
		var _localctx: EnableStatementContext = EnableStatementContext(_ctx, getState())
		try enterRule(_localctx, 648, Cobol85Parser.RULE_enableStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4125)
		 	try match(Cobol85Parser.Tokens.ENABLE.rawValue)
		 	setState(4133)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .INPUT:
		 		setState(4126)
		 		try match(Cobol85Parser.Tokens.INPUT.rawValue)
		 		setState(4128)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.TERMINAL.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4127)
		 			try match(Cobol85Parser.Tokens.TERMINAL.rawValue)

		 		}


		 		break

		 	case .I_O:
		 		setState(4130)
		 		try match(Cobol85Parser.Tokens.I_O.rawValue)
		 		setState(4131)
		 		try match(Cobol85Parser.Tokens.TERMINAL.rawValue)

		 		break

		 	case .OUTPUT:
		 		setState(4132)
		 		try match(Cobol85Parser.Tokens.OUTPUT.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4135)
		 	try cdName()
		 	setState(4137)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4136)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(4139)
		 	try match(Cobol85Parser.Tokens.KEY.rawValue)
		 	setState(4142)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,574, _ctx)) {
		 	case 1:
		 		setState(4140)
		 		try literal()

		 		break
		 	case 2:
		 		setState(4141)
		 		try identifier()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EntryStatementContext: ParserRuleContext {
			open
			func ENTRY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ENTRY.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func USING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USING.rawValue, 0)
			}
			open
			func identifier() -> [IdentifierContext] {
				return getRuleContexts(IdentifierContext.self)
			}
			open
			func identifier(_ i: Int) -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_entryStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEntryStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEntryStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEntryStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEntryStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func entryStatement() throws -> EntryStatementContext {
		var _localctx: EntryStatementContext = EntryStatementContext(_ctx, getState())
		try enterRule(_localctx, 650, Cobol85Parser.RULE_entryStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4144)
		 	try match(Cobol85Parser.Tokens.ENTRY.rawValue)
		 	setState(4145)
		 	try literal()
		 	setState(4152)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.USING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4146)
		 		try match(Cobol85Parser.Tokens.USING.rawValue)
		 		setState(4148) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(4147)
		 			try identifier()


		 			setState(4150); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 68)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 138)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 202)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 268)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 401)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 466)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 552)
		 		          }()
		 		      return testSet
		 		 }())

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EvaluateStatementContext: ParserRuleContext {
			open
			func EVALUATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EVALUATE.rawValue, 0)
			}
			open
			func evaluateSelect() -> EvaluateSelectContext? {
				return getRuleContext(EvaluateSelectContext.self, 0)
			}
			open
			func evaluateAlsoSelect() -> [EvaluateAlsoSelectContext] {
				return getRuleContexts(EvaluateAlsoSelectContext.self)
			}
			open
			func evaluateAlsoSelect(_ i: Int) -> EvaluateAlsoSelectContext? {
				return getRuleContext(EvaluateAlsoSelectContext.self, i)
			}
			open
			func evaluateWhenPhrase() -> [EvaluateWhenPhraseContext] {
				return getRuleContexts(EvaluateWhenPhraseContext.self)
			}
			open
			func evaluateWhenPhrase(_ i: Int) -> EvaluateWhenPhraseContext? {
				return getRuleContext(EvaluateWhenPhraseContext.self, i)
			}
			open
			func evaluateWhenOther() -> EvaluateWhenOtherContext? {
				return getRuleContext(EvaluateWhenOtherContext.self, 0)
			}
			open
			func END_EVALUATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_EVALUATE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_evaluateStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEvaluateStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEvaluateStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEvaluateStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEvaluateStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func evaluateStatement() throws -> EvaluateStatementContext {
		var _localctx: EvaluateStatementContext = EvaluateStatementContext(_ctx, getState())
		try enterRule(_localctx, 652, Cobol85Parser.RULE_evaluateStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4154)
		 	try match(Cobol85Parser.Tokens.EVALUATE.rawValue)
		 	setState(4155)
		 	try evaluateSelect()
		 	setState(4159)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ALSO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4156)
		 		try evaluateAlsoSelect()


		 		setState(4161)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4163); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4162)
		 			try evaluateWhenPhrase()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4165); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,578,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4168)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,579,_ctx)) {
		 	case 1:
		 		setState(4167)
		 		try evaluateWhenOther()

		 		break
		 	default: break
		 	}
		 	setState(4171)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,580,_ctx)) {
		 	case 1:
		 		setState(4170)
		 		try match(Cobol85Parser.Tokens.END_EVALUATE.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EvaluateSelectContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
			open
			func condition() -> ConditionContext? {
				return getRuleContext(ConditionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_evaluateSelect
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEvaluateSelect(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEvaluateSelect(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEvaluateSelect(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEvaluateSelect(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func evaluateSelect() throws -> EvaluateSelectContext {
		var _localctx: EvaluateSelectContext = EvaluateSelectContext(_ctx, getState())
		try enterRule(_localctx, 654, Cobol85Parser.RULE_evaluateSelect)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4177)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,581, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4173)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4174)
		 		try literal()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4175)
		 		try arithmeticExpression()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4176)
		 		try condition()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EvaluateAlsoSelectContext: ParserRuleContext {
			open
			func ALSO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALSO.rawValue, 0)
			}
			open
			func evaluateSelect() -> EvaluateSelectContext? {
				return getRuleContext(EvaluateSelectContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_evaluateAlsoSelect
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEvaluateAlsoSelect(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEvaluateAlsoSelect(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEvaluateAlsoSelect(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEvaluateAlsoSelect(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func evaluateAlsoSelect() throws -> EvaluateAlsoSelectContext {
		var _localctx: EvaluateAlsoSelectContext = EvaluateAlsoSelectContext(_ctx, getState())
		try enterRule(_localctx, 656, Cobol85Parser.RULE_evaluateAlsoSelect)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4179)
		 	try match(Cobol85Parser.Tokens.ALSO.rawValue)
		 	setState(4180)
		 	try evaluateSelect()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EvaluateWhenPhraseContext: ParserRuleContext {
			open
			func evaluateWhen() -> [EvaluateWhenContext] {
				return getRuleContexts(EvaluateWhenContext.self)
			}
			open
			func evaluateWhen(_ i: Int) -> EvaluateWhenContext? {
				return getRuleContext(EvaluateWhenContext.self, i)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_evaluateWhenPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEvaluateWhenPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEvaluateWhenPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEvaluateWhenPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEvaluateWhenPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func evaluateWhenPhrase() throws -> EvaluateWhenPhraseContext {
		var _localctx: EvaluateWhenPhraseContext = EvaluateWhenPhraseContext(_ctx, getState())
		try enterRule(_localctx, 658, Cobol85Parser.RULE_evaluateWhenPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4183); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4182)
		 			try evaluateWhen()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4185); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,582,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4190)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,583,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4187)
		 			try statement()

		 	 
		 		}
		 		setState(4192)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,583,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EvaluateWhenContext: ParserRuleContext {
			open
			func WHEN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WHEN.rawValue, 0)
			}
			open
			func evaluateCondition() -> EvaluateConditionContext? {
				return getRuleContext(EvaluateConditionContext.self, 0)
			}
			open
			func evaluateAlsoCondition() -> [EvaluateAlsoConditionContext] {
				return getRuleContexts(EvaluateAlsoConditionContext.self)
			}
			open
			func evaluateAlsoCondition(_ i: Int) -> EvaluateAlsoConditionContext? {
				return getRuleContext(EvaluateAlsoConditionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_evaluateWhen
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEvaluateWhen(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEvaluateWhen(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEvaluateWhen(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEvaluateWhen(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func evaluateWhen() throws -> EvaluateWhenContext {
		var _localctx: EvaluateWhenContext = EvaluateWhenContext(_ctx, getState())
		try enterRule(_localctx, 660, Cobol85Parser.RULE_evaluateWhen)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4193)
		 	try match(Cobol85Parser.Tokens.WHEN.rawValue)
		 	setState(4194)
		 	try evaluateCondition()
		 	setState(4198)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ALSO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4195)
		 		try evaluateAlsoCondition()


		 		setState(4200)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EvaluateConditionContext: ParserRuleContext {
			open
			func ANY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ANY.rawValue, 0)
			}
			open
			func evaluateValue() -> EvaluateValueContext? {
				return getRuleContext(EvaluateValueContext.self, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
			open
			func evaluateThrough() -> EvaluateThroughContext? {
				return getRuleContext(EvaluateThroughContext.self, 0)
			}
			open
			func condition() -> ConditionContext? {
				return getRuleContext(ConditionContext.self, 0)
			}
			open
			func booleanLiteral() -> BooleanLiteralContext? {
				return getRuleContext(BooleanLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_evaluateCondition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEvaluateCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEvaluateCondition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEvaluateCondition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEvaluateCondition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func evaluateCondition() throws -> EvaluateConditionContext {
		var _localctx: EvaluateConditionContext = EvaluateConditionContext(_ctx, getState())
		try enterRule(_localctx, 662, Cobol85Parser.RULE_evaluateCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4211)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,587, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4201)
		 		try match(Cobol85Parser.Tokens.ANY.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4203)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.NOT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4202)
		 			try match(Cobol85Parser.Tokens.NOT.rawValue)

		 		}

		 		setState(4205)
		 		try evaluateValue()
		 		setState(4207)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4206)
		 			try evaluateThrough()

		 		}


		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4209)
		 		try condition()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4210)
		 		try booleanLiteral()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EvaluateThroughContext: ParserRuleContext {
			open
			func evaluateValue() -> EvaluateValueContext? {
				return getRuleContext(EvaluateValueContext.self, 0)
			}
			open
			func THROUGH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THROUGH.rawValue, 0)
			}
			open
			func THRU() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THRU.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_evaluateThrough
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEvaluateThrough(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEvaluateThrough(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEvaluateThrough(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEvaluateThrough(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func evaluateThrough() throws -> EvaluateThroughContext {
		var _localctx: EvaluateThroughContext = EvaluateThroughContext(_ctx, getState())
		try enterRule(_localctx, 664, Cobol85Parser.RULE_evaluateThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4213)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4214)
		 	try evaluateValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EvaluateAlsoConditionContext: ParserRuleContext {
			open
			func ALSO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALSO.rawValue, 0)
			}
			open
			func evaluateCondition() -> EvaluateConditionContext? {
				return getRuleContext(EvaluateConditionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_evaluateAlsoCondition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEvaluateAlsoCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEvaluateAlsoCondition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEvaluateAlsoCondition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEvaluateAlsoCondition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func evaluateAlsoCondition() throws -> EvaluateAlsoConditionContext {
		var _localctx: EvaluateAlsoConditionContext = EvaluateAlsoConditionContext(_ctx, getState())
		try enterRule(_localctx, 666, Cobol85Parser.RULE_evaluateAlsoCondition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4216)
		 	try match(Cobol85Parser.Tokens.ALSO.rawValue)
		 	setState(4217)
		 	try evaluateCondition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EvaluateWhenOtherContext: ParserRuleContext {
			open
			func WHEN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WHEN.rawValue, 0)
			}
			open
			func OTHER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OTHER.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_evaluateWhenOther
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEvaluateWhenOther(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEvaluateWhenOther(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEvaluateWhenOther(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEvaluateWhenOther(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func evaluateWhenOther() throws -> EvaluateWhenOtherContext {
		var _localctx: EvaluateWhenOtherContext = EvaluateWhenOtherContext(_ctx, getState())
		try enterRule(_localctx, 668, Cobol85Parser.RULE_evaluateWhenOther)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4219)
		 	try match(Cobol85Parser.Tokens.WHEN.rawValue)
		 	setState(4220)
		 	try match(Cobol85Parser.Tokens.OTHER.rawValue)
		 	setState(4224)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,588,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4221)
		 			try statement()

		 	 
		 		}
		 		setState(4226)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,588,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EvaluateValueContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_evaluateValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEvaluateValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEvaluateValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEvaluateValue(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEvaluateValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func evaluateValue() throws -> EvaluateValueContext {
		var _localctx: EvaluateValueContext = EvaluateValueContext(_ctx, getState())
		try enterRule(_localctx, 670, Cobol85Parser.RULE_evaluateValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4230)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,589, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4227)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4228)
		 		try literal()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4229)
		 		try arithmeticExpression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExecCicsStatementContext: ParserRuleContext {
			open
			func EXECCICSLINE() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.EXECCICSLINE.rawValue)
			}
			open
			func EXECCICSLINE(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXECCICSLINE.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_execCicsStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterExecCicsStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitExecCicsStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitExecCicsStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitExecCicsStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func execCicsStatement() throws -> ExecCicsStatementContext {
		var _localctx: ExecCicsStatementContext = ExecCicsStatementContext(_ctx, getState())
		try enterRule(_localctx, 672, Cobol85Parser.RULE_execCicsStatement)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4233); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4232)
		 			try match(Cobol85Parser.Tokens.EXECCICSLINE.rawValue)


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4235); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,590,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExecSqlStatementContext: ParserRuleContext {
			open
			func EXECSQLLINE() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.EXECSQLLINE.rawValue)
			}
			open
			func EXECSQLLINE(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXECSQLLINE.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_execSqlStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterExecSqlStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitExecSqlStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitExecSqlStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitExecSqlStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func execSqlStatement() throws -> ExecSqlStatementContext {
		var _localctx: ExecSqlStatementContext = ExecSqlStatementContext(_ctx, getState())
		try enterRule(_localctx, 674, Cobol85Parser.RULE_execSqlStatement)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4238); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4237)
		 			try match(Cobol85Parser.Tokens.EXECSQLLINE.rawValue)


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4240); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,591,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExecSqlImsStatementContext: ParserRuleContext {
			open
			func EXECSQLIMSLINE() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.EXECSQLIMSLINE.rawValue)
			}
			open
			func EXECSQLIMSLINE(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXECSQLIMSLINE.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_execSqlImsStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterExecSqlImsStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitExecSqlImsStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitExecSqlImsStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitExecSqlImsStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func execSqlImsStatement() throws -> ExecSqlImsStatementContext {
		var _localctx: ExecSqlImsStatementContext = ExecSqlImsStatementContext(_ctx, getState())
		try enterRule(_localctx, 676, Cobol85Parser.RULE_execSqlImsStatement)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4243); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4242)
		 			try match(Cobol85Parser.Tokens.EXECSQLIMSLINE.rawValue)


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4245); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,592,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExhibitStatementContext: ParserRuleContext {
			open
			func EXHIBIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXHIBIT.rawValue, 0)
			}
			open
			func NAMED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NAMED.rawValue, 0)
			}
			open
			func CHANGED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHANGED.rawValue, 0)
			}
			open
			func exhibitOperand() -> [ExhibitOperandContext] {
				return getRuleContexts(ExhibitOperandContext.self)
			}
			open
			func exhibitOperand(_ i: Int) -> ExhibitOperandContext? {
				return getRuleContext(ExhibitOperandContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_exhibitStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterExhibitStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitExhibitStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitExhibitStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitExhibitStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func exhibitStatement() throws -> ExhibitStatementContext {
		var _localctx: ExhibitStatementContext = ExhibitStatementContext(_ctx, getState())
		try enterRule(_localctx, 678, Cobol85Parser.RULE_exhibitStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4247)
		 	try match(Cobol85Parser.Tokens.EXHIBIT.rawValue)
		 	setState(4249)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,593,_ctx)) {
		 	case 1:
		 		setState(4248)
		 		try match(Cobol85Parser.Tokens.NAMED.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4252)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,594,_ctx)) {
		 	case 1:
		 		setState(4251)
		 		try match(Cobol85Parser.Tokens.CHANGED.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4255) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4254)
		 		try exhibitOperand()


		 		setState(4257); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 551)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExhibitOperandContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_exhibitOperand
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterExhibitOperand(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitExhibitOperand(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitExhibitOperand(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitExhibitOperand(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func exhibitOperand() throws -> ExhibitOperandContext {
		var _localctx: ExhibitOperandContext = ExhibitOperandContext(_ctx, getState())
		try enterRule(_localctx, 680, Cobol85Parser.RULE_exhibitOperand)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4261)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,596, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4259)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4260)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExitStatementContext: ParserRuleContext {
			open
			func EXIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXIT.rawValue, 0)
			}
			open
			func PROGRAM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROGRAM.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_exitStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterExitStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitExitStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitExitStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitExitStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func exitStatement() throws -> ExitStatementContext {
		var _localctx: ExitStatementContext = ExitStatementContext(_ctx, getState())
		try enterRule(_localctx, 682, Cobol85Parser.RULE_exitStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4263)
		 	try match(Cobol85Parser.Tokens.EXIT.rawValue)
		 	setState(4265)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.PROGRAM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4264)
		 		try match(Cobol85Parser.Tokens.PROGRAM.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GenerateStatementContext: ParserRuleContext {
			open
			func GENERATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GENERATE.rawValue, 0)
			}
			open
			func reportName() -> ReportNameContext? {
				return getRuleContext(ReportNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_generateStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterGenerateStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitGenerateStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitGenerateStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitGenerateStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func generateStatement() throws -> GenerateStatementContext {
		var _localctx: GenerateStatementContext = GenerateStatementContext(_ctx, getState())
		try enterRule(_localctx, 684, Cobol85Parser.RULE_generateStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4267)
		 	try match(Cobol85Parser.Tokens.GENERATE.rawValue)
		 	setState(4268)
		 	try reportName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GobackStatementContext: ParserRuleContext {
			open
			func GOBACK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GOBACK.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_gobackStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterGobackStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitGobackStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitGobackStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitGobackStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func gobackStatement() throws -> GobackStatementContext {
		var _localctx: GobackStatementContext = GobackStatementContext(_ctx, getState())
		try enterRule(_localctx, 686, Cobol85Parser.RULE_gobackStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4270)
		 	try match(Cobol85Parser.Tokens.GOBACK.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GoToStatementContext: ParserRuleContext {
			open
			func GO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GO.rawValue, 0)
			}
			open
			func goToStatementSimple() -> GoToStatementSimpleContext? {
				return getRuleContext(GoToStatementSimpleContext.self, 0)
			}
			open
			func goToDependingOnStatement() -> GoToDependingOnStatementContext? {
				return getRuleContext(GoToDependingOnStatementContext.self, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_goToStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterGoToStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitGoToStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitGoToStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitGoToStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func goToStatement() throws -> GoToStatementContext {
		var _localctx: GoToStatementContext = GoToStatementContext(_ctx, getState())
		try enterRule(_localctx, 688, Cobol85Parser.RULE_goToStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4272)
		 	try match(Cobol85Parser.Tokens.GO.rawValue)
		 	setState(4274)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4273)
		 		try match(Cobol85Parser.Tokens.TO.rawValue)

		 	}

		 	setState(4278)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,599, _ctx)) {
		 	case 1:
		 		setState(4276)
		 		try goToStatementSimple()

		 		break
		 	case 2:
		 		setState(4277)
		 		try goToDependingOnStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GoToStatementSimpleContext: ParserRuleContext {
			open
			func procedureName() -> ProcedureNameContext? {
				return getRuleContext(ProcedureNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_goToStatementSimple
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterGoToStatementSimple(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitGoToStatementSimple(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitGoToStatementSimple(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitGoToStatementSimple(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func goToStatementSimple() throws -> GoToStatementSimpleContext {
		var _localctx: GoToStatementSimpleContext = GoToStatementSimpleContext(_ctx, getState())
		try enterRule(_localctx, 690, Cobol85Parser.RULE_goToStatementSimple)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4280)
		 	try procedureName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GoToDependingOnStatementContext: ParserRuleContext {
			open
			func MORE_LABELS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MORE_LABELS.rawValue, 0)
			}
			open
			func procedureName() -> [ProcedureNameContext] {
				return getRuleContexts(ProcedureNameContext.self)
			}
			open
			func procedureName(_ i: Int) -> ProcedureNameContext? {
				return getRuleContext(ProcedureNameContext.self, i)
			}
			open
			func DEPENDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEPENDING.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_goToDependingOnStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterGoToDependingOnStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitGoToDependingOnStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitGoToDependingOnStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitGoToDependingOnStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func goToDependingOnStatement() throws -> GoToDependingOnStatementContext {
		var _localctx: GoToDependingOnStatementContext = GoToDependingOnStatementContext(_ctx, getState())
		try enterRule(_localctx, 692, Cobol85Parser.RULE_goToDependingOnStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4295)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .MORE_LABELS:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4282)
		 		try match(Cobol85Parser.Tokens.MORE_LABELS.rawValue)

		 		break
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:fallthrough
		 	case .IDENTIFIER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4284) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(4283)
		 			try procedureName()


		 			setState(4286); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 68)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 138)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 202)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 268)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 401)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 466)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 552)
		 		          }()
		 		      return testSet
		 		 }())
		 		setState(4293)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.DEPENDING.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4288)
		 			try match(Cobol85Parser.Tokens.DEPENDING.rawValue)
		 			setState(4290)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(4289)
		 				try match(Cobol85Parser.Tokens.ON.rawValue)

		 			}

		 			setState(4292)
		 			try identifier()

		 		}


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IfStatementContext: ParserRuleContext {
			open
			func IF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IF.rawValue, 0)
			}
			open
			func condition() -> ConditionContext? {
				return getRuleContext(ConditionContext.self, 0)
			}
			open
			func ifThen() -> IfThenContext? {
				return getRuleContext(IfThenContext.self, 0)
			}
			open
			func ifElse() -> IfElseContext? {
				return getRuleContext(IfElseContext.self, 0)
			}
			open
			func END_IF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_IF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_ifStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterIfStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitIfStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitIfStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitIfStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ifStatement() throws -> IfStatementContext {
		var _localctx: IfStatementContext = IfStatementContext(_ctx, getState())
		try enterRule(_localctx, 694, Cobol85Parser.RULE_ifStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4297)
		 	try match(Cobol85Parser.Tokens.IF.rawValue)
		 	setState(4298)
		 	try condition()
		 	setState(4299)
		 	try ifThen()
		 	setState(4301)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,604,_ctx)) {
		 	case 1:
		 		setState(4300)
		 		try ifElse()

		 		break
		 	default: break
		 	}
		 	setState(4304)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,605,_ctx)) {
		 	case 1:
		 		setState(4303)
		 		try match(Cobol85Parser.Tokens.END_IF.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IfThenContext: ParserRuleContext {
			open
			func NEXT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NEXT.rawValue, 0)
			}
			open
			func SENTENCE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SENTENCE.rawValue, 0)
			}
			open
			func THEN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THEN.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_ifThen
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterIfThen(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitIfThen(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitIfThen(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitIfThen(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ifThen() throws -> IfThenContext {
		var _localctx: IfThenContext = IfThenContext(_ctx, getState())
		try enterRule(_localctx, 696, Cobol85Parser.RULE_ifThen)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4307)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THEN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4306)
		 		try match(Cobol85Parser.Tokens.THEN.rawValue)

		 	}

		 	setState(4317)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NEXT:
		 		setState(4309)
		 		try match(Cobol85Parser.Tokens.NEXT.rawValue)
		 		setState(4310)
		 		try match(Cobol85Parser.Tokens.SENTENCE.rawValue)

		 		break
		 	case .ACCEPT:fallthrough
		 	case .ADD:fallthrough
		 	case .ALTER:fallthrough
		 	case .AT:fallthrough
		 	case .CALL:fallthrough
		 	case .CANCEL:fallthrough
		 	case .CLOSE:fallthrough
		 	case .COMPUTE:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .DELETE:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISPLAY:fallthrough
		 	case .DIVIDE:fallthrough
		 	case .ELSE:fallthrough
		 	case .ENABLE:fallthrough
		 	case .END:fallthrough
		 	case .END_ACCEPT:fallthrough
		 	case .END_ADD:fallthrough
		 	case .END_CALL:fallthrough
		 	case .END_COMPUTE:fallthrough
		 	case .END_DELETE:fallthrough
		 	case .END_DIVIDE:fallthrough
		 	case .END_EVALUATE:fallthrough
		 	case .END_IF:fallthrough
		 	case .END_MULTIPLY:fallthrough
		 	case .END_PERFORM:fallthrough
		 	case .END_READ:fallthrough
		 	case .END_RECEIVE:fallthrough
		 	case .END_RETURN:fallthrough
		 	case .END_REWRITE:fallthrough
		 	case .END_SEARCH:fallthrough
		 	case .END_START:fallthrough
		 	case .END_STRING:fallthrough
		 	case .END_SUBTRACT:fallthrough
		 	case .END_UNSTRING:fallthrough
		 	case .END_WRITE:fallthrough
		 	case .ENTRY:fallthrough
		 	case .EVALUATE:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXHIBIT:fallthrough
		 	case .EXIT:fallthrough
		 	case .GENERATE:fallthrough
		 	case .GOBACK:fallthrough
		 	case .GO:fallthrough
		 	case .IF:fallthrough
		 	case .INITIALIZE:fallthrough
		 	case .INITIATE:fallthrough
		 	case .INSPECT:fallthrough
		 	case .INVALID:fallthrough
		 	case .MERGE:fallthrough
		 	case .MOVE:fallthrough
		 	case .MULTIPLY:fallthrough
		 	case .NOT:fallthrough
		 	case .ON:fallthrough
		 	case .OPEN:fallthrough
		 	case .PERFORM:fallthrough
		 	case .PURGE:fallthrough
		 	case .READ:fallthrough
		 	case .RECEIVE:fallthrough
		 	case .RELEASE:fallthrough
		 	case .RETURN:fallthrough
		 	case .REWRITE:fallthrough
		 	case .SEARCH:fallthrough
		 	case .SEND:fallthrough
		 	case .SET:fallthrough
		 	case .SORT:fallthrough
		 	case .START:fallthrough
		 	case .STOP:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBTRACT:fallthrough
		 	case .TERMINATE:fallthrough
		 	case .UNSTRING:fallthrough
		 	case .WHEN:fallthrough
		 	case .WITH:fallthrough
		 	case .WRITE:fallthrough
		 	case .DOT_FS:fallthrough
		 	case .EXECCICSLINE:fallthrough
		 	case .EXECSQLIMSLINE:fallthrough
		 	case .EXECSQLLINE:
		 		setState(4314)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,607,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(4311)
		 				try statement()

		 		 
		 			}
		 			setState(4316)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,607,_ctx)
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IfElseContext: ParserRuleContext {
			open
			func ELSE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ELSE.rawValue, 0)
			}
			open
			func NEXT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NEXT.rawValue, 0)
			}
			open
			func SENTENCE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SENTENCE.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_ifElse
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterIfElse(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitIfElse(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitIfElse(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitIfElse(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ifElse() throws -> IfElseContext {
		var _localctx: IfElseContext = IfElseContext(_ctx, getState())
		try enterRule(_localctx, 698, Cobol85Parser.RULE_ifElse)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4319)
		 	try match(Cobol85Parser.Tokens.ELSE.rawValue)
		 	setState(4328)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NEXT:
		 		setState(4320)
		 		try match(Cobol85Parser.Tokens.NEXT.rawValue)
		 		setState(4321)
		 		try match(Cobol85Parser.Tokens.SENTENCE.rawValue)

		 		break
		 	case .ACCEPT:fallthrough
		 	case .ADD:fallthrough
		 	case .ALTER:fallthrough
		 	case .AT:fallthrough
		 	case .CALL:fallthrough
		 	case .CANCEL:fallthrough
		 	case .CLOSE:fallthrough
		 	case .COMPUTE:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .DELETE:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISPLAY:fallthrough
		 	case .DIVIDE:fallthrough
		 	case .ELSE:fallthrough
		 	case .ENABLE:fallthrough
		 	case .END:fallthrough
		 	case .END_ACCEPT:fallthrough
		 	case .END_ADD:fallthrough
		 	case .END_CALL:fallthrough
		 	case .END_COMPUTE:fallthrough
		 	case .END_DELETE:fallthrough
		 	case .END_DIVIDE:fallthrough
		 	case .END_EVALUATE:fallthrough
		 	case .END_IF:fallthrough
		 	case .END_MULTIPLY:fallthrough
		 	case .END_PERFORM:fallthrough
		 	case .END_READ:fallthrough
		 	case .END_RECEIVE:fallthrough
		 	case .END_RETURN:fallthrough
		 	case .END_REWRITE:fallthrough
		 	case .END_SEARCH:fallthrough
		 	case .END_START:fallthrough
		 	case .END_STRING:fallthrough
		 	case .END_SUBTRACT:fallthrough
		 	case .END_UNSTRING:fallthrough
		 	case .END_WRITE:fallthrough
		 	case .ENTRY:fallthrough
		 	case .EVALUATE:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXHIBIT:fallthrough
		 	case .EXIT:fallthrough
		 	case .GENERATE:fallthrough
		 	case .GOBACK:fallthrough
		 	case .GO:fallthrough
		 	case .IF:fallthrough
		 	case .INITIALIZE:fallthrough
		 	case .INITIATE:fallthrough
		 	case .INSPECT:fallthrough
		 	case .INVALID:fallthrough
		 	case .MERGE:fallthrough
		 	case .MOVE:fallthrough
		 	case .MULTIPLY:fallthrough
		 	case .NOT:fallthrough
		 	case .ON:fallthrough
		 	case .OPEN:fallthrough
		 	case .PERFORM:fallthrough
		 	case .PURGE:fallthrough
		 	case .READ:fallthrough
		 	case .RECEIVE:fallthrough
		 	case .RELEASE:fallthrough
		 	case .RETURN:fallthrough
		 	case .REWRITE:fallthrough
		 	case .SEARCH:fallthrough
		 	case .SEND:fallthrough
		 	case .SET:fallthrough
		 	case .SORT:fallthrough
		 	case .START:fallthrough
		 	case .STOP:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBTRACT:fallthrough
		 	case .TERMINATE:fallthrough
		 	case .UNSTRING:fallthrough
		 	case .WHEN:fallthrough
		 	case .WITH:fallthrough
		 	case .WRITE:fallthrough
		 	case .DOT_FS:fallthrough
		 	case .EXECCICSLINE:fallthrough
		 	case .EXECSQLIMSLINE:fallthrough
		 	case .EXECSQLLINE:
		 		setState(4325)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,609,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(4322)
		 				try statement()

		 		 
		 			}
		 			setState(4327)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,609,_ctx)
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InitializeStatementContext: ParserRuleContext {
			open
			func INITIALIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INITIALIZE.rawValue, 0)
			}
			open
			func identifier() -> [IdentifierContext] {
				return getRuleContexts(IdentifierContext.self)
			}
			open
			func identifier(_ i: Int) -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, i)
			}
			open
			func initializeReplacingPhrase() -> InitializeReplacingPhraseContext? {
				return getRuleContext(InitializeReplacingPhraseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_initializeStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInitializeStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInitializeStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInitializeStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInitializeStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func initializeStatement() throws -> InitializeStatementContext {
		var _localctx: InitializeStatementContext = InitializeStatementContext(_ctx, getState())
		try enterRule(_localctx, 700, Cobol85Parser.RULE_initializeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4330)
		 	try match(Cobol85Parser.Tokens.INITIALIZE.rawValue)
		 	setState(4332) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4331)
		 		try identifier()


		 		setState(4334); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(4337)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.REPLACING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4336)
		 		try initializeReplacingPhrase()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InitializeReplacingPhraseContext: ParserRuleContext {
			open
			func REPLACING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REPLACING.rawValue, 0)
			}
			open
			func initializeReplacingBy() -> [InitializeReplacingByContext] {
				return getRuleContexts(InitializeReplacingByContext.self)
			}
			open
			func initializeReplacingBy(_ i: Int) -> InitializeReplacingByContext? {
				return getRuleContext(InitializeReplacingByContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_initializeReplacingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInitializeReplacingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInitializeReplacingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInitializeReplacingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInitializeReplacingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func initializeReplacingPhrase() throws -> InitializeReplacingPhraseContext {
		var _localctx: InitializeReplacingPhraseContext = InitializeReplacingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 702, Cobol85Parser.RULE_initializeReplacingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4339)
		 	try match(Cobol85Parser.Tokens.REPLACING.rawValue)
		 	setState(4341) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4340)
		 		try initializeReplacingBy()


		 		setState(4343); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ALPHABETIC.rawValue,Cobol85Parser.Tokens.ALPHANUMERIC.rawValue,Cobol85Parser.Tokens.ALPHANUMERIC_EDITED.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.DBCS.rawValue || _la == Cobol85Parser.Tokens.EGCS.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NUMERIC.rawValue,Cobol85Parser.Tokens.NUMERIC_EDITED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 304)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InitializeReplacingByContext: ParserRuleContext {
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func ALPHABETIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHABETIC.rawValue, 0)
			}
			open
			func ALPHANUMERIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHANUMERIC.rawValue, 0)
			}
			open
			func ALPHANUMERIC_EDITED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHANUMERIC_EDITED.rawValue, 0)
			}
			open
			func NATIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIONAL.rawValue, 0)
			}
			open
			func NATIONAL_EDITED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue, 0)
			}
			open
			func NUMERIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMERIC.rawValue, 0)
			}
			open
			func NUMERIC_EDITED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMERIC_EDITED.rawValue, 0)
			}
			open
			func DBCS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DBCS.rawValue, 0)
			}
			open
			func EGCS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EGCS.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func DATA() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATA.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_initializeReplacingBy
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInitializeReplacingBy(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInitializeReplacingBy(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInitializeReplacingBy(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInitializeReplacingBy(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func initializeReplacingBy() throws -> InitializeReplacingByContext {
		var _localctx: InitializeReplacingByContext = InitializeReplacingByContext(_ctx, getState())
		try enterRule(_localctx, 704, Cobol85Parser.RULE_initializeReplacingBy)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4345)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ALPHABETIC.rawValue,Cobol85Parser.Tokens.ALPHANUMERIC.rawValue,Cobol85Parser.Tokens.ALPHANUMERIC_EDITED.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.DBCS.rawValue || _la == Cobol85Parser.Tokens.EGCS.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NUMERIC.rawValue,Cobol85Parser.Tokens.NUMERIC_EDITED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 304)
		 	          }()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4347)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DATA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4346)
		 		try match(Cobol85Parser.Tokens.DATA.rawValue)

		 	}

		 	setState(4349)
		 	try match(Cobol85Parser.Tokens.BY.rawValue)
		 	setState(4352)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,615, _ctx)) {
		 	case 1:
		 		setState(4350)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4351)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InitiateStatementContext: ParserRuleContext {
			open
			func INITIATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INITIATE.rawValue, 0)
			}
			open
			func reportName() -> [ReportNameContext] {
				return getRuleContexts(ReportNameContext.self)
			}
			open
			func reportName(_ i: Int) -> ReportNameContext? {
				return getRuleContext(ReportNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_initiateStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInitiateStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInitiateStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInitiateStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInitiateStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func initiateStatement() throws -> InitiateStatementContext {
		var _localctx: InitiateStatementContext = InitiateStatementContext(_ctx, getState())
		try enterRule(_localctx, 706, Cobol85Parser.RULE_initiateStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4354)
		 	try match(Cobol85Parser.Tokens.INITIATE.rawValue)
		 	setState(4356) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4355)
		 		try reportName()


		 		setState(4358); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectStatementContext: ParserRuleContext {
			open
			func INSPECT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INSPECT.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func inspectTallyingPhrase() -> InspectTallyingPhraseContext? {
				return getRuleContext(InspectTallyingPhraseContext.self, 0)
			}
			open
			func inspectReplacingPhrase() -> InspectReplacingPhraseContext? {
				return getRuleContext(InspectReplacingPhraseContext.self, 0)
			}
			open
			func inspectTallyingReplacingPhrase() -> InspectTallyingReplacingPhraseContext? {
				return getRuleContext(InspectTallyingReplacingPhraseContext.self, 0)
			}
			open
			func inspectConvertingPhrase() -> InspectConvertingPhraseContext? {
				return getRuleContext(InspectConvertingPhraseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectStatement() throws -> InspectStatementContext {
		var _localctx: InspectStatementContext = InspectStatementContext(_ctx, getState())
		try enterRule(_localctx, 708, Cobol85Parser.RULE_inspectStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4360)
		 	try match(Cobol85Parser.Tokens.INSPECT.rawValue)
		 	setState(4361)
		 	try identifier()
		 	setState(4366)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,617, _ctx)) {
		 	case 1:
		 		setState(4362)
		 		try inspectTallyingPhrase()

		 		break
		 	case 2:
		 		setState(4363)
		 		try inspectReplacingPhrase()

		 		break
		 	case 3:
		 		setState(4364)
		 		try inspectTallyingReplacingPhrase()

		 		break
		 	case 4:
		 		setState(4365)
		 		try inspectConvertingPhrase()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectTallyingPhraseContext: ParserRuleContext {
			open
			func TALLYING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TALLYING.rawValue, 0)
			}
			open
			func inspectFor() -> [InspectForContext] {
				return getRuleContexts(InspectForContext.self)
			}
			open
			func inspectFor(_ i: Int) -> InspectForContext? {
				return getRuleContext(InspectForContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectTallyingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectTallyingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectTallyingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectTallyingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectTallyingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectTallyingPhrase() throws -> InspectTallyingPhraseContext {
		var _localctx: InspectTallyingPhraseContext = InspectTallyingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 710, Cobol85Parser.RULE_inspectTallyingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4368)
		 	try match(Cobol85Parser.Tokens.TALLYING.rawValue)
		 	setState(4370) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4369)
		 		try inspectFor()


		 		setState(4372); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectReplacingPhraseContext: ParserRuleContext {
			open
			func REPLACING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REPLACING.rawValue, 0)
			}
			open
			func inspectReplacingCharacters() -> [InspectReplacingCharactersContext] {
				return getRuleContexts(InspectReplacingCharactersContext.self)
			}
			open
			func inspectReplacingCharacters(_ i: Int) -> InspectReplacingCharactersContext? {
				return getRuleContext(InspectReplacingCharactersContext.self, i)
			}
			open
			func inspectReplacingAllLeadings() -> [InspectReplacingAllLeadingsContext] {
				return getRuleContexts(InspectReplacingAllLeadingsContext.self)
			}
			open
			func inspectReplacingAllLeadings(_ i: Int) -> InspectReplacingAllLeadingsContext? {
				return getRuleContext(InspectReplacingAllLeadingsContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectReplacingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectReplacingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectReplacingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectReplacingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectReplacingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectReplacingPhrase() throws -> InspectReplacingPhraseContext {
		var _localctx: InspectReplacingPhraseContext = InspectReplacingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 712, Cobol85Parser.RULE_inspectReplacingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4374)
		 	try match(Cobol85Parser.Tokens.REPLACING.rawValue)
		 	setState(4377) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4377)
		 		try _errHandler.sync(self)
		 		switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CHARACTERS:
		 			setState(4375)
		 			try inspectReplacingCharacters()

		 			break
		 		case .ALL:fallthrough
		 		case .FIRST:fallthrough
		 		case .LEADING:
		 			setState(4376)
		 			try inspectReplacingAllLeadings()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4379); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ALL.rawValue || _la == Cobol85Parser.Tokens.CHARACTERS.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.FIRST.rawValue || _la == Cobol85Parser.Tokens.LEADING.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectTallyingReplacingPhraseContext: ParserRuleContext {
			open
			func TALLYING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TALLYING.rawValue, 0)
			}
			open
			func inspectFor() -> [InspectForContext] {
				return getRuleContexts(InspectForContext.self)
			}
			open
			func inspectFor(_ i: Int) -> InspectForContext? {
				return getRuleContext(InspectForContext.self, i)
			}
			open
			func inspectReplacingPhrase() -> [InspectReplacingPhraseContext] {
				return getRuleContexts(InspectReplacingPhraseContext.self)
			}
			open
			func inspectReplacingPhrase(_ i: Int) -> InspectReplacingPhraseContext? {
				return getRuleContext(InspectReplacingPhraseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectTallyingReplacingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectTallyingReplacingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectTallyingReplacingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectTallyingReplacingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectTallyingReplacingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectTallyingReplacingPhrase() throws -> InspectTallyingReplacingPhraseContext {
		var _localctx: InspectTallyingReplacingPhraseContext = InspectTallyingReplacingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 714, Cobol85Parser.RULE_inspectTallyingReplacingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4381)
		 	try match(Cobol85Parser.Tokens.TALLYING.rawValue)
		 	setState(4383) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4382)
		 		try inspectFor()


		 		setState(4385); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(4388) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4387)
		 		try inspectReplacingPhrase()


		 		setState(4390); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.REPLACING.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectConvertingPhraseContext: ParserRuleContext {
			open
			func CONVERTING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONVERTING.rawValue, 0)
			}
			open
			func inspectTo() -> InspectToContext? {
				return getRuleContext(InspectToContext.self, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func inspectBeforeAfter() -> [InspectBeforeAfterContext] {
				return getRuleContexts(InspectBeforeAfterContext.self)
			}
			open
			func inspectBeforeAfter(_ i: Int) -> InspectBeforeAfterContext? {
				return getRuleContext(InspectBeforeAfterContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectConvertingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectConvertingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectConvertingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectConvertingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectConvertingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectConvertingPhrase() throws -> InspectConvertingPhraseContext {
		var _localctx: InspectConvertingPhraseContext = InspectConvertingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 716, Cobol85Parser.RULE_inspectConvertingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4392)
		 	try match(Cobol85Parser.Tokens.CONVERTING.rawValue)
		 	setState(4395)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,623, _ctx)) {
		 	case 1:
		 		setState(4393)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4394)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4397)
		 	try inspectTo()
		 	setState(4401)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue || _la == Cobol85Parser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4398)
		 		try inspectBeforeAfter()


		 		setState(4403)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectForContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func inspectCharacters() -> [InspectCharactersContext] {
				return getRuleContexts(InspectCharactersContext.self)
			}
			open
			func inspectCharacters(_ i: Int) -> InspectCharactersContext? {
				return getRuleContext(InspectCharactersContext.self, i)
			}
			open
			func inspectAllLeadings() -> [InspectAllLeadingsContext] {
				return getRuleContexts(InspectAllLeadingsContext.self)
			}
			open
			func inspectAllLeadings(_ i: Int) -> InspectAllLeadingsContext? {
				return getRuleContext(InspectAllLeadingsContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectFor
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectFor(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectFor(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectFor(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectFor(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectFor() throws -> InspectForContext {
		var _localctx: InspectForContext = InspectForContext(_ctx, getState())
		try enterRule(_localctx, 718, Cobol85Parser.RULE_inspectFor)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4404)
		 	try identifier()
		 	setState(4405)
		 	try match(Cobol85Parser.Tokens.FOR.rawValue)
		 	setState(4408) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4408)
		 		try _errHandler.sync(self)
		 		switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CHARACTERS:
		 			setState(4406)
		 			try inspectCharacters()

		 			break
		 		case .ALL:fallthrough
		 		case .LEADING:
		 			setState(4407)
		 			try inspectAllLeadings()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4410); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ALL.rawValue || _la == Cobol85Parser.Tokens.CHARACTERS.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.LEADING.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectCharactersContext: ParserRuleContext {
			open
			func CHARACTERS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTERS.rawValue, 0)
			}
			open
			func inspectBeforeAfter() -> [InspectBeforeAfterContext] {
				return getRuleContexts(InspectBeforeAfterContext.self)
			}
			open
			func inspectBeforeAfter(_ i: Int) -> InspectBeforeAfterContext? {
				return getRuleContext(InspectBeforeAfterContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectCharacters
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectCharacters(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectCharacters(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectCharacters(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectCharacters(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectCharacters() throws -> InspectCharactersContext {
		var _localctx: InspectCharactersContext = InspectCharactersContext(_ctx, getState())
		try enterRule(_localctx, 720, Cobol85Parser.RULE_inspectCharacters)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4412)
		 	try match(Cobol85Parser.Tokens.CHARACTERS.rawValue)
		 	setState(4416)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue || _la == Cobol85Parser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4413)
		 		try inspectBeforeAfter()


		 		setState(4418)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectReplacingCharactersContext: ParserRuleContext {
			open
			func CHARACTERS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHARACTERS.rawValue, 0)
			}
			open
			func inspectBy() -> InspectByContext? {
				return getRuleContext(InspectByContext.self, 0)
			}
			open
			func inspectBeforeAfter() -> [InspectBeforeAfterContext] {
				return getRuleContexts(InspectBeforeAfterContext.self)
			}
			open
			func inspectBeforeAfter(_ i: Int) -> InspectBeforeAfterContext? {
				return getRuleContext(InspectBeforeAfterContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectReplacingCharacters
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectReplacingCharacters(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectReplacingCharacters(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectReplacingCharacters(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectReplacingCharacters(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectReplacingCharacters() throws -> InspectReplacingCharactersContext {
		var _localctx: InspectReplacingCharactersContext = InspectReplacingCharactersContext(_ctx, getState())
		try enterRule(_localctx, 722, Cobol85Parser.RULE_inspectReplacingCharacters)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4419)
		 	try match(Cobol85Parser.Tokens.CHARACTERS.rawValue)
		 	setState(4420)
		 	try inspectBy()
		 	setState(4424)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue || _la == Cobol85Parser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4421)
		 		try inspectBeforeAfter()


		 		setState(4426)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectAllLeadingsContext: ParserRuleContext {
			open
			func ALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALL.rawValue, 0)
			}
			open
			func LEADING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEADING.rawValue, 0)
			}
			open
			func inspectAllLeading() -> [InspectAllLeadingContext] {
				return getRuleContexts(InspectAllLeadingContext.self)
			}
			open
			func inspectAllLeading(_ i: Int) -> InspectAllLeadingContext? {
				return getRuleContext(InspectAllLeadingContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectAllLeadings
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectAllLeadings(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectAllLeadings(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectAllLeadings(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectAllLeadings(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectAllLeadings() throws -> InspectAllLeadingsContext {
		var _localctx: InspectAllLeadingsContext = InspectAllLeadingsContext(_ctx, getState())
		try enterRule(_localctx, 724, Cobol85Parser.RULE_inspectAllLeadings)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4427)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ALL.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.LEADING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4429); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4428)
		 			try inspectAllLeading()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4431); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,629,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectReplacingAllLeadingsContext: ParserRuleContext {
			open
			func ALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALL.rawValue, 0)
			}
			open
			func LEADING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEADING.rawValue, 0)
			}
			open
			func FIRST() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FIRST.rawValue, 0)
			}
			open
			func inspectReplacingAllLeading() -> [InspectReplacingAllLeadingContext] {
				return getRuleContexts(InspectReplacingAllLeadingContext.self)
			}
			open
			func inspectReplacingAllLeading(_ i: Int) -> InspectReplacingAllLeadingContext? {
				return getRuleContext(InspectReplacingAllLeadingContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectReplacingAllLeadings
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectReplacingAllLeadings(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectReplacingAllLeadings(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectReplacingAllLeadings(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectReplacingAllLeadings(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectReplacingAllLeadings() throws -> InspectReplacingAllLeadingsContext {
		var _localctx: InspectReplacingAllLeadingsContext = InspectReplacingAllLeadingsContext(_ctx, getState())
		try enterRule(_localctx, 726, Cobol85Parser.RULE_inspectReplacingAllLeadings)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4433)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ALL.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.FIRST.rawValue || _la == Cobol85Parser.Tokens.LEADING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4435); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4434)
		 			try inspectReplacingAllLeading()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4437); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,630,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectAllLeadingContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func inspectBeforeAfter() -> [InspectBeforeAfterContext] {
				return getRuleContexts(InspectBeforeAfterContext.self)
			}
			open
			func inspectBeforeAfter(_ i: Int) -> InspectBeforeAfterContext? {
				return getRuleContext(InspectBeforeAfterContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectAllLeading
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectAllLeading(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectAllLeading(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectAllLeading(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectAllLeading(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectAllLeading() throws -> InspectAllLeadingContext {
		var _localctx: InspectAllLeadingContext = InspectAllLeadingContext(_ctx, getState())
		try enterRule(_localctx, 728, Cobol85Parser.RULE_inspectAllLeading)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4441)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,631, _ctx)) {
		 	case 1:
		 		setState(4439)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4440)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4446)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue || _la == Cobol85Parser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4443)
		 		try inspectBeforeAfter()


		 		setState(4448)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectReplacingAllLeadingContext: ParserRuleContext {
			open
			func inspectBy() -> InspectByContext? {
				return getRuleContext(InspectByContext.self, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func inspectBeforeAfter() -> [InspectBeforeAfterContext] {
				return getRuleContexts(InspectBeforeAfterContext.self)
			}
			open
			func inspectBeforeAfter(_ i: Int) -> InspectBeforeAfterContext? {
				return getRuleContext(InspectBeforeAfterContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectReplacingAllLeading
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectReplacingAllLeading(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectReplacingAllLeading(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectReplacingAllLeading(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectReplacingAllLeading(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectReplacingAllLeading() throws -> InspectReplacingAllLeadingContext {
		var _localctx: InspectReplacingAllLeadingContext = InspectReplacingAllLeadingContext(_ctx, getState())
		try enterRule(_localctx, 730, Cobol85Parser.RULE_inspectReplacingAllLeading)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4451)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,633, _ctx)) {
		 	case 1:
		 		setState(4449)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4450)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4453)
		 	try inspectBy()
		 	setState(4457)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue || _la == Cobol85Parser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4454)
		 		try inspectBeforeAfter()


		 		setState(4459)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectByContext: ParserRuleContext {
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectBy
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectBy(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectBy(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectBy(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectBy(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectBy() throws -> InspectByContext {
		var _localctx: InspectByContext = InspectByContext(_ctx, getState())
		try enterRule(_localctx, 732, Cobol85Parser.RULE_inspectBy)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4460)
		 	try match(Cobol85Parser.Tokens.BY.rawValue)
		 	setState(4463)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,635, _ctx)) {
		 	case 1:
		 		setState(4461)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4462)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectToContext: ParserRuleContext {
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectTo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectTo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectTo(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectTo(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectTo(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectTo() throws -> InspectToContext {
		var _localctx: InspectToContext = InspectToContext(_ctx, getState())
		try enterRule(_localctx, 734, Cobol85Parser.RULE_inspectTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4465)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(4468)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,636, _ctx)) {
		 	case 1:
		 		setState(4466)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4467)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InspectBeforeAfterContext: ParserRuleContext {
			open
			func BEFORE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BEFORE.rawValue, 0)
			}
			open
			func AFTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AFTER.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func INITIAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INITIAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inspectBeforeAfter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInspectBeforeAfter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInspectBeforeAfter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInspectBeforeAfter(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInspectBeforeAfter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inspectBeforeAfter() throws -> InspectBeforeAfterContext {
		var _localctx: InspectBeforeAfterContext = InspectBeforeAfterContext(_ctx, getState())
		try enterRule(_localctx, 736, Cobol85Parser.RULE_inspectBeforeAfter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4470)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue || _la == Cobol85Parser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4472)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.INITIAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4471)
		 		try match(Cobol85Parser.Tokens.INITIAL.rawValue)

		 	}

		 	setState(4476)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,638, _ctx)) {
		 	case 1:
		 		setState(4474)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4475)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MergeStatementContext: ParserRuleContext {
			open
			func MERGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MERGE.rawValue, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func mergeOnKeyClause() -> [MergeOnKeyClauseContext] {
				return getRuleContexts(MergeOnKeyClauseContext.self)
			}
			open
			func mergeOnKeyClause(_ i: Int) -> MergeOnKeyClauseContext? {
				return getRuleContext(MergeOnKeyClauseContext.self, i)
			}
			open
			func mergeCollatingSequencePhrase() -> MergeCollatingSequencePhraseContext? {
				return getRuleContext(MergeCollatingSequencePhraseContext.self, 0)
			}
			open
			func mergeUsing() -> [MergeUsingContext] {
				return getRuleContexts(MergeUsingContext.self)
			}
			open
			func mergeUsing(_ i: Int) -> MergeUsingContext? {
				return getRuleContext(MergeUsingContext.self, i)
			}
			open
			func mergeOutputProcedurePhrase() -> MergeOutputProcedurePhraseContext? {
				return getRuleContext(MergeOutputProcedurePhraseContext.self, 0)
			}
			open
			func mergeGivingPhrase() -> [MergeGivingPhraseContext] {
				return getRuleContexts(MergeGivingPhraseContext.self)
			}
			open
			func mergeGivingPhrase(_ i: Int) -> MergeGivingPhraseContext? {
				return getRuleContext(MergeGivingPhraseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_mergeStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMergeStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMergeStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMergeStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMergeStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mergeStatement() throws -> MergeStatementContext {
		var _localctx: MergeStatementContext = MergeStatementContext(_ctx, getState())
		try enterRule(_localctx, 738, Cobol85Parser.RULE_mergeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4478)
		 	try match(Cobol85Parser.Tokens.MERGE.rawValue)
		 	setState(4479)
		 	try fileName()
		 	setState(4481); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4480)
		 			try mergeOnKeyClause()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4483); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,639,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4486)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.COLLATING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.SEQUENCE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4485)
		 		try mergeCollatingSequencePhrase()

		 	}

		 	setState(4491)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.USING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4488)
		 		try mergeUsing()


		 		setState(4493)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4495)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.OUTPUT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4494)
		 		try mergeOutputProcedurePhrase()

		 	}

		 	setState(4500)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.GIVING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4497)
		 		try mergeGivingPhrase()


		 		setState(4502)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MergeOnKeyClauseContext: ParserRuleContext {
			open
			func ASCENDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASCENDING.rawValue, 0)
			}
			open
			func DESCENDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DESCENDING.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func qualifiedDataName() -> [QualifiedDataNameContext] {
				return getRuleContexts(QualifiedDataNameContext.self)
			}
			open
			func qualifiedDataName(_ i: Int) -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_mergeOnKeyClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMergeOnKeyClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMergeOnKeyClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMergeOnKeyClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMergeOnKeyClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mergeOnKeyClause() throws -> MergeOnKeyClauseContext {
		var _localctx: MergeOnKeyClauseContext = MergeOnKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 740, Cobol85Parser.RULE_mergeOnKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4504)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4503)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 	}

		 	setState(4506)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ASCENDING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.DESCENDING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4508)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.KEY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4507)
		 		try match(Cobol85Parser.Tokens.KEY.rawValue)

		 	}

		 	setState(4511) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4510)
		 		try qualifiedDataName()


		 		setState(4513); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MergeCollatingSequencePhraseContext: ParserRuleContext {
			open
			func SEQUENCE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEQUENCE.rawValue, 0)
			}
			open
			func COLLATING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COLLATING.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func alphabetName() -> [AlphabetNameContext] {
				return getRuleContexts(AlphabetNameContext.self)
			}
			open
			func alphabetName(_ i: Int) -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, i)
			}
			open
			func mergeCollatingAlphanumeric() -> MergeCollatingAlphanumericContext? {
				return getRuleContext(MergeCollatingAlphanumericContext.self, 0)
			}
			open
			func mergeCollatingNational() -> MergeCollatingNationalContext? {
				return getRuleContext(MergeCollatingNationalContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_mergeCollatingSequencePhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMergeCollatingSequencePhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMergeCollatingSequencePhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMergeCollatingSequencePhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMergeCollatingSequencePhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mergeCollatingSequencePhrase() throws -> MergeCollatingSequencePhraseContext {
		var _localctx: MergeCollatingSequencePhraseContext = MergeCollatingSequencePhraseContext(_ctx, getState())
		try enterRule(_localctx, 742, Cobol85Parser.RULE_mergeCollatingSequencePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4516)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COLLATING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4515)
		 		try match(Cobol85Parser.Tokens.COLLATING.rawValue)

		 	}

		 	setState(4518)
		 	try match(Cobol85Parser.Tokens.SEQUENCE.rawValue)
		 	setState(4520)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4519)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(4523); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4522)
		 			try alphabetName()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4525); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,649,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4528)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,650,_ctx)) {
		 	case 1:
		 		setState(4527)
		 		try mergeCollatingAlphanumeric()

		 		break
		 	default: break
		 	}
		 	setState(4531)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.NATIONAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4530)
		 		try mergeCollatingNational()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MergeCollatingAlphanumericContext: ParserRuleContext {
			open
			func ALPHANUMERIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHANUMERIC.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func alphabetName() -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_mergeCollatingAlphanumeric
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMergeCollatingAlphanumeric(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMergeCollatingAlphanumeric(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMergeCollatingAlphanumeric(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMergeCollatingAlphanumeric(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mergeCollatingAlphanumeric() throws -> MergeCollatingAlphanumericContext {
		var _localctx: MergeCollatingAlphanumericContext = MergeCollatingAlphanumericContext(_ctx, getState())
		try enterRule(_localctx, 744, Cobol85Parser.RULE_mergeCollatingAlphanumeric)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4534)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4533)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(4536)
		 	try match(Cobol85Parser.Tokens.ALPHANUMERIC.rawValue)
		 	setState(4537)
		 	try match(Cobol85Parser.Tokens.IS.rawValue)
		 	setState(4538)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MergeCollatingNationalContext: ParserRuleContext {
			open
			func NATIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIONAL.rawValue, 0)
			}
			open
			func alphabetName() -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_mergeCollatingNational
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMergeCollatingNational(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMergeCollatingNational(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMergeCollatingNational(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMergeCollatingNational(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mergeCollatingNational() throws -> MergeCollatingNationalContext {
		var _localctx: MergeCollatingNationalContext = MergeCollatingNationalContext(_ctx, getState())
		try enterRule(_localctx, 746, Cobol85Parser.RULE_mergeCollatingNational)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4541)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4540)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(4543)
		 	try match(Cobol85Parser.Tokens.NATIONAL.rawValue)
		 	setState(4545)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4544)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(4547)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MergeUsingContext: ParserRuleContext {
			open
			func USING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USING.rawValue, 0)
			}
			open
			func fileName() -> [FileNameContext] {
				return getRuleContexts(FileNameContext.self)
			}
			open
			func fileName(_ i: Int) -> FileNameContext? {
				return getRuleContext(FileNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_mergeUsing
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMergeUsing(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMergeUsing(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMergeUsing(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMergeUsing(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mergeUsing() throws -> MergeUsingContext {
		var _localctx: MergeUsingContext = MergeUsingContext(_ctx, getState())
		try enterRule(_localctx, 748, Cobol85Parser.RULE_mergeUsing)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4549)
		 	try match(Cobol85Parser.Tokens.USING.rawValue)
		 	setState(4551) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4550)
		 		try fileName()


		 		setState(4553); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MergeOutputProcedurePhraseContext: ParserRuleContext {
			open
			func OUTPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OUTPUT.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROCEDURE.rawValue, 0)
			}
			open
			func procedureName() -> ProcedureNameContext? {
				return getRuleContext(ProcedureNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func mergeOutputThrough() -> MergeOutputThroughContext? {
				return getRuleContext(MergeOutputThroughContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_mergeOutputProcedurePhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMergeOutputProcedurePhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMergeOutputProcedurePhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMergeOutputProcedurePhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMergeOutputProcedurePhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mergeOutputProcedurePhrase() throws -> MergeOutputProcedurePhraseContext {
		var _localctx: MergeOutputProcedurePhraseContext = MergeOutputProcedurePhraseContext(_ctx, getState())
		try enterRule(_localctx, 750, Cobol85Parser.RULE_mergeOutputProcedurePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4555)
		 	try match(Cobol85Parser.Tokens.OUTPUT.rawValue)
		 	setState(4556)
		 	try match(Cobol85Parser.Tokens.PROCEDURE.rawValue)
		 	setState(4558)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4557)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(4560)
		 	try procedureName()
		 	setState(4562)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4561)
		 		try mergeOutputThrough()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MergeOutputThroughContext: ParserRuleContext {
			open
			func procedureName() -> ProcedureNameContext? {
				return getRuleContext(ProcedureNameContext.self, 0)
			}
			open
			func THROUGH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THROUGH.rawValue, 0)
			}
			open
			func THRU() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THRU.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_mergeOutputThrough
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMergeOutputThrough(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMergeOutputThrough(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMergeOutputThrough(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMergeOutputThrough(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mergeOutputThrough() throws -> MergeOutputThroughContext {
		var _localctx: MergeOutputThroughContext = MergeOutputThroughContext(_ctx, getState())
		try enterRule(_localctx, 752, Cobol85Parser.RULE_mergeOutputThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4564)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4565)
		 	try procedureName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MergeGivingPhraseContext: ParserRuleContext {
			open
			func GIVING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GIVING.rawValue, 0)
			}
			open
			func mergeGiving() -> [MergeGivingContext] {
				return getRuleContexts(MergeGivingContext.self)
			}
			open
			func mergeGiving(_ i: Int) -> MergeGivingContext? {
				return getRuleContext(MergeGivingContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_mergeGivingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMergeGivingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMergeGivingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMergeGivingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMergeGivingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mergeGivingPhrase() throws -> MergeGivingPhraseContext {
		var _localctx: MergeGivingPhraseContext = MergeGivingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 754, Cobol85Parser.RULE_mergeGivingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4567)
		 	try match(Cobol85Parser.Tokens.GIVING.rawValue)
		 	setState(4569) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4568)
		 		try mergeGiving()


		 		setState(4571); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MergeGivingContext: ParserRuleContext {
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func LOCK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOCK.rawValue, 0)
			}
			open
			func SAVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SAVE.rawValue, 0)
			}
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
			open
			func REWIND() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REWIND.rawValue, 0)
			}
			open
			func CRUNCH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CRUNCH.rawValue, 0)
			}
			open
			func RELEASE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RELEASE.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
			open
			func REMOVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REMOVE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_mergeGiving
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMergeGiving(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMergeGiving(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMergeGiving(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMergeGiving(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mergeGiving() throws -> MergeGivingContext {
		var _localctx: MergeGivingContext = MergeGivingContext(_ctx, getState())
		try enterRule(_localctx, 756, Cobol85Parser.RULE_mergeGiving)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4573)
		 	try fileName()
		 	setState(4583)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,659,_ctx)) {
		 	case 1:
		 		setState(4574)
		 		try match(Cobol85Parser.Tokens.LOCK.rawValue)

		 		break
		 	case 2:
		 		setState(4575)
		 		try match(Cobol85Parser.Tokens.SAVE.rawValue)

		 		break
		 	case 3:
		 		setState(4576)
		 		try match(Cobol85Parser.Tokens.NO.rawValue)
		 		setState(4577)
		 		try match(Cobol85Parser.Tokens.REWIND.rawValue)

		 		break
		 	case 4:
		 		setState(4578)
		 		try match(Cobol85Parser.Tokens.CRUNCH.rawValue)

		 		break
		 	case 5:
		 		setState(4579)
		 		try match(Cobol85Parser.Tokens.RELEASE.rawValue)

		 		break
		 	case 6:
		 		setState(4580)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)
		 		setState(4581)
		 		try match(Cobol85Parser.Tokens.REMOVE.rawValue)
		 		setState(4582)
		 		try match(Cobol85Parser.Tokens.CRUNCH.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MoveStatementContext: ParserRuleContext {
			open
			func MOVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MOVE.rawValue, 0)
			}
			open
			func moveToStatement() -> MoveToStatementContext? {
				return getRuleContext(MoveToStatementContext.self, 0)
			}
			open
			func moveCorrespondingToStatement() -> MoveCorrespondingToStatementContext? {
				return getRuleContext(MoveCorrespondingToStatementContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_moveStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMoveStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMoveStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMoveStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMoveStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func moveStatement() throws -> MoveStatementContext {
		var _localctx: MoveStatementContext = MoveStatementContext(_ctx, getState())
		try enterRule(_localctx, 758, Cobol85Parser.RULE_moveStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4585)
		 	try match(Cobol85Parser.Tokens.MOVE.rawValue)
		 	setState(4587)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,660,_ctx)) {
		 	case 1:
		 		setState(4586)
		 		try match(Cobol85Parser.Tokens.ALL.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4591)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ABORT:fallthrough
		 	case .ADDRESS:fallthrough
		 	case .ALL:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DAY_OF_WEEK:fallthrough
		 	case .DEBUG_CONTENTS:fallthrough
		 	case .DEBUG_ITEM:fallthrough
		 	case .DEBUG_LINE:fallthrough
		 	case .DEBUG_NAME:fallthrough
		 	case .DEBUG_SUB_1:fallthrough
		 	case .DEBUG_SUB_2:fallthrough
		 	case .DEBUG_SUB_3:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FALSE:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .HIGH_VALUE:fallthrough
		 	case .HIGH_VALUES:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LINAGE_COUNTER:fallthrough
		 	case .LINE_COUNTER:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .LOW_VALUE:fallthrough
		 	case .LOW_VALUES:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PAGE_COUNTER:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .QUOTE:fallthrough
		 	case .QUOTES:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .RETURN_CODE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHIFT_IN:fallthrough
		 	case .SHIFT_OUT:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SORT_CONTROL:fallthrough
		 	case .SORT_CORE_SIZE:fallthrough
		 	case .SORT_FILE_SIZE:fallthrough
		 	case .SORT_MESSAGE:fallthrough
		 	case .SORT_MODE_SIZE:fallthrough
		 	case .SORT_RETURN:fallthrough
		 	case .SPACE:fallthrough
		 	case .SPACES:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TALLY:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .WHEN_COMPILED:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .ZEROS:fallthrough
		 	case .ZEROES:fallthrough
		 	case .NONNUMERICLITERAL:fallthrough
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:fallthrough
		 	case .NUMERICLITERAL:fallthrough
		 	case .IDENTIFIER:
		 		setState(4589)
		 		try moveToStatement()

		 		break
		 	case .CORR:fallthrough
		 	case .CORRESPONDING:
		 		setState(4590)
		 		try moveCorrespondingToStatement()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MoveToStatementContext: ParserRuleContext {
			open
			func moveToSendingArea() -> MoveToSendingAreaContext? {
				return getRuleContext(MoveToSendingAreaContext.self, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func identifier() -> [IdentifierContext] {
				return getRuleContexts(IdentifierContext.self)
			}
			open
			func identifier(_ i: Int) -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_moveToStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMoveToStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMoveToStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMoveToStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMoveToStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func moveToStatement() throws -> MoveToStatementContext {
		var _localctx: MoveToStatementContext = MoveToStatementContext(_ctx, getState())
		try enterRule(_localctx, 760, Cobol85Parser.RULE_moveToStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4593)
		 	try moveToSendingArea()
		 	setState(4594)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(4596) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4595)
		 		try identifier()


		 		setState(4598); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MoveToSendingAreaContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_moveToSendingArea
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMoveToSendingArea(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMoveToSendingArea(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMoveToSendingArea(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMoveToSendingArea(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func moveToSendingArea() throws -> MoveToSendingAreaContext {
		var _localctx: MoveToSendingAreaContext = MoveToSendingAreaContext(_ctx, getState())
		try enterRule(_localctx, 762, Cobol85Parser.RULE_moveToSendingArea)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4602)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,663, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4600)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4601)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MoveCorrespondingToStatementContext: ParserRuleContext {
			open
			func moveCorrespondingToSendingArea() -> MoveCorrespondingToSendingAreaContext? {
				return getRuleContext(MoveCorrespondingToSendingAreaContext.self, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func CORRESPONDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CORRESPONDING.rawValue, 0)
			}
			open
			func CORR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CORR.rawValue, 0)
			}
			open
			func identifier() -> [IdentifierContext] {
				return getRuleContexts(IdentifierContext.self)
			}
			open
			func identifier(_ i: Int) -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_moveCorrespondingToStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMoveCorrespondingToStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMoveCorrespondingToStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMoveCorrespondingToStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMoveCorrespondingToStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func moveCorrespondingToStatement() throws -> MoveCorrespondingToStatementContext {
		var _localctx: MoveCorrespondingToStatementContext = MoveCorrespondingToStatementContext(_ctx, getState())
		try enterRule(_localctx, 764, Cobol85Parser.RULE_moveCorrespondingToStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4604)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CORR.rawValue || _la == Cobol85Parser.Tokens.CORRESPONDING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4605)
		 	try moveCorrespondingToSendingArea()
		 	setState(4606)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(4608) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4607)
		 		try identifier()


		 		setState(4610); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MoveCorrespondingToSendingAreaContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_moveCorrespondingToSendingArea
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMoveCorrespondingToSendingArea(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMoveCorrespondingToSendingArea(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMoveCorrespondingToSendingArea(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMoveCorrespondingToSendingArea(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func moveCorrespondingToSendingArea() throws -> MoveCorrespondingToSendingAreaContext {
		var _localctx: MoveCorrespondingToSendingAreaContext = MoveCorrespondingToSendingAreaContext(_ctx, getState())
		try enterRule(_localctx, 766, Cobol85Parser.RULE_moveCorrespondingToSendingArea)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4612)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultiplyStatementContext: ParserRuleContext {
			open
			func MULTIPLY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MULTIPLY.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func multiplyRegular() -> MultiplyRegularContext? {
				return getRuleContext(MultiplyRegularContext.self, 0)
			}
			open
			func multiplyGiving() -> MultiplyGivingContext? {
				return getRuleContext(MultiplyGivingContext.self, 0)
			}
			open
			func onSizeErrorPhrase() -> OnSizeErrorPhraseContext? {
				return getRuleContext(OnSizeErrorPhraseContext.self, 0)
			}
			open
			func notOnSizeErrorPhrase() -> NotOnSizeErrorPhraseContext? {
				return getRuleContext(NotOnSizeErrorPhraseContext.self, 0)
			}
			open
			func END_MULTIPLY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_MULTIPLY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_multiplyStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMultiplyStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMultiplyStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMultiplyStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMultiplyStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func multiplyStatement() throws -> MultiplyStatementContext {
		var _localctx: MultiplyStatementContext = MultiplyStatementContext(_ctx, getState())
		try enterRule(_localctx, 768, Cobol85Parser.RULE_multiplyStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4614)
		 	try match(Cobol85Parser.Tokens.MULTIPLY.rawValue)
		 	setState(4617)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,665, _ctx)) {
		 	case 1:
		 		setState(4615)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4616)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4619)
		 	try match(Cobol85Parser.Tokens.BY.rawValue)
		 	setState(4622)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,666, _ctx)) {
		 	case 1:
		 		setState(4620)
		 		try multiplyRegular()

		 		break
		 	case 2:
		 		setState(4621)
		 		try multiplyGiving()

		 		break
		 	default: break
		 	}
		 	setState(4625)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,667,_ctx)) {
		 	case 1:
		 		setState(4624)
		 		try onSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4628)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,668,_ctx)) {
		 	case 1:
		 		setState(4627)
		 		try notOnSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4631)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,669,_ctx)) {
		 	case 1:
		 		setState(4630)
		 		try match(Cobol85Parser.Tokens.END_MULTIPLY.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultiplyRegularContext: ParserRuleContext {
			open
			func multiplyRegularOperand() -> [MultiplyRegularOperandContext] {
				return getRuleContexts(MultiplyRegularOperandContext.self)
			}
			open
			func multiplyRegularOperand(_ i: Int) -> MultiplyRegularOperandContext? {
				return getRuleContext(MultiplyRegularOperandContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_multiplyRegular
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMultiplyRegular(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMultiplyRegular(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMultiplyRegular(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMultiplyRegular(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func multiplyRegular() throws -> MultiplyRegularContext {
		var _localctx: MultiplyRegularContext = MultiplyRegularContext(_ctx, getState())
		try enterRule(_localctx, 770, Cobol85Parser.RULE_multiplyRegular)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4634) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4633)
		 		try multiplyRegularOperand()


		 		setState(4636); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultiplyRegularOperandContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func ROUNDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ROUNDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_multiplyRegularOperand
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMultiplyRegularOperand(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMultiplyRegularOperand(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMultiplyRegularOperand(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMultiplyRegularOperand(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func multiplyRegularOperand() throws -> MultiplyRegularOperandContext {
		var _localctx: MultiplyRegularOperandContext = MultiplyRegularOperandContext(_ctx, getState())
		try enterRule(_localctx, 772, Cobol85Parser.RULE_multiplyRegularOperand)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4638)
		 	try identifier()
		 	setState(4640)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ROUNDED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4639)
		 		try match(Cobol85Parser.Tokens.ROUNDED.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultiplyGivingContext: ParserRuleContext {
			open
			func multiplyGivingOperand() -> MultiplyGivingOperandContext? {
				return getRuleContext(MultiplyGivingOperandContext.self, 0)
			}
			open
			func GIVING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GIVING.rawValue, 0)
			}
			open
			func multiplyGivingResult() -> [MultiplyGivingResultContext] {
				return getRuleContexts(MultiplyGivingResultContext.self)
			}
			open
			func multiplyGivingResult(_ i: Int) -> MultiplyGivingResultContext? {
				return getRuleContext(MultiplyGivingResultContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_multiplyGiving
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMultiplyGiving(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMultiplyGiving(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMultiplyGiving(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMultiplyGiving(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func multiplyGiving() throws -> MultiplyGivingContext {
		var _localctx: MultiplyGivingContext = MultiplyGivingContext(_ctx, getState())
		try enterRule(_localctx, 774, Cobol85Parser.RULE_multiplyGiving)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4642)
		 	try multiplyGivingOperand()
		 	setState(4643)
		 	try match(Cobol85Parser.Tokens.GIVING.rawValue)
		 	setState(4645) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4644)
		 		try multiplyGivingResult()


		 		setState(4647); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultiplyGivingOperandContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_multiplyGivingOperand
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMultiplyGivingOperand(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMultiplyGivingOperand(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMultiplyGivingOperand(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMultiplyGivingOperand(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func multiplyGivingOperand() throws -> MultiplyGivingOperandContext {
		var _localctx: MultiplyGivingOperandContext = MultiplyGivingOperandContext(_ctx, getState())
		try enterRule(_localctx, 776, Cobol85Parser.RULE_multiplyGivingOperand)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4651)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,673, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4649)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4650)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultiplyGivingResultContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func ROUNDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ROUNDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_multiplyGivingResult
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMultiplyGivingResult(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMultiplyGivingResult(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMultiplyGivingResult(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMultiplyGivingResult(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func multiplyGivingResult() throws -> MultiplyGivingResultContext {
		var _localctx: MultiplyGivingResultContext = MultiplyGivingResultContext(_ctx, getState())
		try enterRule(_localctx, 778, Cobol85Parser.RULE_multiplyGivingResult)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4653)
		 	try identifier()
		 	setState(4655)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ROUNDED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4654)
		 		try match(Cobol85Parser.Tokens.ROUNDED.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OpenStatementContext: ParserRuleContext {
			open
			func OPEN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OPEN.rawValue, 0)
			}
			open
			func openInputStatement() -> [OpenInputStatementContext] {
				return getRuleContexts(OpenInputStatementContext.self)
			}
			open
			func openInputStatement(_ i: Int) -> OpenInputStatementContext? {
				return getRuleContext(OpenInputStatementContext.self, i)
			}
			open
			func openOutputStatement() -> [OpenOutputStatementContext] {
				return getRuleContexts(OpenOutputStatementContext.self)
			}
			open
			func openOutputStatement(_ i: Int) -> OpenOutputStatementContext? {
				return getRuleContext(OpenOutputStatementContext.self, i)
			}
			open
			func openIOStatement() -> [OpenIOStatementContext] {
				return getRuleContexts(OpenIOStatementContext.self)
			}
			open
			func openIOStatement(_ i: Int) -> OpenIOStatementContext? {
				return getRuleContext(OpenIOStatementContext.self, i)
			}
			open
			func openExtendStatement() -> [OpenExtendStatementContext] {
				return getRuleContexts(OpenExtendStatementContext.self)
			}
			open
			func openExtendStatement(_ i: Int) -> OpenExtendStatementContext? {
				return getRuleContext(OpenExtendStatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_openStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOpenStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOpenStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOpenStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOpenStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func openStatement() throws -> OpenStatementContext {
		var _localctx: OpenStatementContext = OpenStatementContext(_ctx, getState())
		try enterRule(_localctx, 780, Cobol85Parser.RULE_openStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4657)
		 	try match(Cobol85Parser.Tokens.OPEN.rawValue)
		 	setState(4662) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4662)
		 		try _errHandler.sync(self)
		 		switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .INPUT:
		 			setState(4658)
		 			try openInputStatement()

		 			break

		 		case .OUTPUT:
		 			setState(4659)
		 			try openOutputStatement()

		 			break

		 		case .I_O:
		 			setState(4660)
		 			try openIOStatement()

		 			break

		 		case .EXTEND:
		 			setState(4661)
		 			try openExtendStatement()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4664); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTEND.rawValue,Cobol85Parser.Tokens.I_O.rawValue,Cobol85Parser.Tokens.INPUT.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 201)
		 	}()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.OUTPUT.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OpenInputStatementContext: ParserRuleContext {
			open
			func INPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INPUT.rawValue, 0)
			}
			open
			func openInput() -> [OpenInputContext] {
				return getRuleContexts(OpenInputContext.self)
			}
			open
			func openInput(_ i: Int) -> OpenInputContext? {
				return getRuleContext(OpenInputContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_openInputStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOpenInputStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOpenInputStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOpenInputStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOpenInputStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func openInputStatement() throws -> OpenInputStatementContext {
		var _localctx: OpenInputStatementContext = OpenInputStatementContext(_ctx, getState())
		try enterRule(_localctx, 782, Cobol85Parser.RULE_openInputStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4666)
		 	try match(Cobol85Parser.Tokens.INPUT.rawValue)
		 	setState(4668) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4667)
		 		try openInput()


		 		setState(4670); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OpenInputContext: ParserRuleContext {
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func REVERSED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REVERSED.rawValue, 0)
			}
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
			open
			func REWIND() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REWIND.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_openInput
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOpenInput(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOpenInput(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOpenInput(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOpenInput(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func openInput() throws -> OpenInputContext {
		var _localctx: OpenInputContext = OpenInputContext(_ctx, getState())
		try enterRule(_localctx, 784, Cobol85Parser.RULE_openInput)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4672)
		 	try fileName()
		 	setState(4679)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,679,_ctx)) {
		 	case 1:
		 		setState(4673)
		 		try match(Cobol85Parser.Tokens.REVERSED.rawValue)

		 		break
		 	case 2:
		 		setState(4675)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4674)
		 			try match(Cobol85Parser.Tokens.WITH.rawValue)

		 		}

		 		setState(4677)
		 		try match(Cobol85Parser.Tokens.NO.rawValue)
		 		setState(4678)
		 		try match(Cobol85Parser.Tokens.REWIND.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OpenOutputStatementContext: ParserRuleContext {
			open
			func OUTPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OUTPUT.rawValue, 0)
			}
			open
			func openOutput() -> [OpenOutputContext] {
				return getRuleContexts(OpenOutputContext.self)
			}
			open
			func openOutput(_ i: Int) -> OpenOutputContext? {
				return getRuleContext(OpenOutputContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_openOutputStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOpenOutputStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOpenOutputStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOpenOutputStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOpenOutputStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func openOutputStatement() throws -> OpenOutputStatementContext {
		var _localctx: OpenOutputStatementContext = OpenOutputStatementContext(_ctx, getState())
		try enterRule(_localctx, 786, Cobol85Parser.RULE_openOutputStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4681)
		 	try match(Cobol85Parser.Tokens.OUTPUT.rawValue)
		 	setState(4683) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4682)
		 		try openOutput()


		 		setState(4685); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OpenOutputContext: ParserRuleContext {
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
			open
			func REWIND() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REWIND.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_openOutput
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOpenOutput(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOpenOutput(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOpenOutput(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOpenOutput(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func openOutput() throws -> OpenOutputContext {
		var _localctx: OpenOutputContext = OpenOutputContext(_ctx, getState())
		try enterRule(_localctx, 788, Cobol85Parser.RULE_openOutput)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4687)
		 	try fileName()
		 	setState(4693)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,682,_ctx)) {
		 	case 1:
		 		setState(4689)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4688)
		 			try match(Cobol85Parser.Tokens.WITH.rawValue)

		 		}

		 		setState(4691)
		 		try match(Cobol85Parser.Tokens.NO.rawValue)
		 		setState(4692)
		 		try match(Cobol85Parser.Tokens.REWIND.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OpenIOStatementContext: ParserRuleContext {
			open
			func I_O() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.I_O.rawValue, 0)
			}
			open
			func fileName() -> [FileNameContext] {
				return getRuleContexts(FileNameContext.self)
			}
			open
			func fileName(_ i: Int) -> FileNameContext? {
				return getRuleContext(FileNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_openIOStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOpenIOStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOpenIOStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOpenIOStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOpenIOStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func openIOStatement() throws -> OpenIOStatementContext {
		var _localctx: OpenIOStatementContext = OpenIOStatementContext(_ctx, getState())
		try enterRule(_localctx, 790, Cobol85Parser.RULE_openIOStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4695)
		 	try match(Cobol85Parser.Tokens.I_O.rawValue)
		 	setState(4697) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4696)
		 		try fileName()


		 		setState(4699); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OpenExtendStatementContext: ParserRuleContext {
			open
			func EXTEND() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXTEND.rawValue, 0)
			}
			open
			func fileName() -> [FileNameContext] {
				return getRuleContexts(FileNameContext.self)
			}
			open
			func fileName(_ i: Int) -> FileNameContext? {
				return getRuleContext(FileNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_openExtendStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOpenExtendStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOpenExtendStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOpenExtendStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOpenExtendStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func openExtendStatement() throws -> OpenExtendStatementContext {
		var _localctx: OpenExtendStatementContext = OpenExtendStatementContext(_ctx, getState())
		try enterRule(_localctx, 792, Cobol85Parser.RULE_openExtendStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4701)
		 	try match(Cobol85Parser.Tokens.EXTEND.rawValue)
		 	setState(4703) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4702)
		 		try fileName()


		 		setState(4705); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformStatementContext: ParserRuleContext {
			open
			func PERFORM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PERFORM.rawValue, 0)
			}
			open
			func performInlineStatement() -> PerformInlineStatementContext? {
				return getRuleContext(PerformInlineStatementContext.self, 0)
			}
			open
			func performProcedureStatement() -> PerformProcedureStatementContext? {
				return getRuleContext(PerformProcedureStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performStatement() throws -> PerformStatementContext {
		var _localctx: PerformStatementContext = PerformStatementContext(_ctx, getState())
		try enterRule(_localctx, 794, Cobol85Parser.RULE_performStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4707)
		 	try match(Cobol85Parser.Tokens.PERFORM.rawValue)
		 	setState(4710)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,685, _ctx)) {
		 	case 1:
		 		setState(4708)
		 		try performInlineStatement()

		 		break
		 	case 2:
		 		setState(4709)
		 		try performProcedureStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformInlineStatementContext: ParserRuleContext {
			open
			func END_PERFORM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_PERFORM.rawValue, 0)
			}
			open
			func performType() -> PerformTypeContext? {
				return getRuleContext(PerformTypeContext.self, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performInlineStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformInlineStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformInlineStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformInlineStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformInlineStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performInlineStatement() throws -> PerformInlineStatementContext {
		var _localctx: PerformInlineStatementContext = PerformInlineStatementContext(_ctx, getState())
		try enterRule(_localctx, 796, Cobol85Parser.RULE_performInlineStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4713)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.TEST.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.UNTIL.rawValue,Cobol85Parser.Tokens.VARYING.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.WITH.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4712)
		 		try performType()

		 	}

		 	setState(4718)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ACCEPT.rawValue,Cobol85Parser.Tokens.ADD.rawValue,Cobol85Parser.Tokens.ALTER.rawValue,Cobol85Parser.Tokens.CALL.rawValue,Cobol85Parser.Tokens.CANCEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE.rawValue,Cobol85Parser.Tokens.COMPUTE.rawValue,Cobol85Parser.Tokens.CONTINUE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 67)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DELETE.rawValue,Cobol85Parser.Tokens.DISABLE.rawValue,Cobol85Parser.Tokens.DISPLAY.rawValue,Cobol85Parser.Tokens.DIVIDE.rawValue,Cobol85Parser.Tokens.ENABLE.rawValue,Cobol85Parser.Tokens.ENTRY.rawValue,Cobol85Parser.Tokens.EVALUATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 131)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXHIBIT.rawValue,Cobol85Parser.Tokens.EXIT.rawValue,Cobol85Parser.Tokens.GENERATE.rawValue,Cobol85Parser.Tokens.GOBACK.rawValue,Cobol85Parser.Tokens.GO.rawValue,Cobol85Parser.Tokens.IF.rawValue,Cobol85Parser.Tokens.INITIALIZE.rawValue,Cobol85Parser.Tokens.INITIATE.rawValue,Cobol85Parser.Tokens.INSPECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 198)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.MERGE.rawValue,Cobol85Parser.Tokens.MOVE.rawValue,Cobol85Parser.Tokens.MULTIPLY.rawValue,Cobol85Parser.Tokens.OPEN.rawValue,Cobol85Parser.Tokens.PERFORM.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 294)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.PURGE.rawValue,Cobol85Parser.Tokens.READ.rawValue,Cobol85Parser.Tokens.RECEIVE.rawValue,Cobol85Parser.Tokens.RELEASE.rawValue,Cobol85Parser.Tokens.RETURN.rawValue,Cobol85Parser.Tokens.REWRITE.rawValue,Cobol85Parser.Tokens.SEARCH.rawValue,Cobol85Parser.Tokens.SEND.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 365)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SET.rawValue,Cobol85Parser.Tokens.SORT.rawValue,Cobol85Parser.Tokens.START.rawValue,Cobol85Parser.Tokens.STOP.rawValue,Cobol85Parser.Tokens.STRING.rawValue,Cobol85Parser.Tokens.SUBTRACT.rawValue,Cobol85Parser.Tokens.TERMINATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 430)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.UNSTRING.rawValue,Cobol85Parser.Tokens.WRITE.rawValue,Cobol85Parser.Tokens.EXECCICSLINE.rawValue,Cobol85Parser.Tokens.EXECSQLIMSLINE.rawValue,Cobol85Parser.Tokens.EXECSQLLINE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 500)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4715)
		 		try statement()


		 		setState(4720)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4721)
		 	try match(Cobol85Parser.Tokens.END_PERFORM.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformProcedureStatementContext: ParserRuleContext {
			open
			func procedureName() -> [ProcedureNameContext] {
				return getRuleContexts(ProcedureNameContext.self)
			}
			open
			func procedureName(_ i: Int) -> ProcedureNameContext? {
				return getRuleContext(ProcedureNameContext.self, i)
			}
			open
			func performType() -> PerformTypeContext? {
				return getRuleContext(PerformTypeContext.self, 0)
			}
			open
			func THROUGH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THROUGH.rawValue, 0)
			}
			open
			func THRU() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THRU.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performProcedureStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformProcedureStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformProcedureStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformProcedureStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformProcedureStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performProcedureStatement() throws -> PerformProcedureStatementContext {
		var _localctx: PerformProcedureStatementContext = PerformProcedureStatementContext(_ctx, getState())
		try enterRule(_localctx, 798, Cobol85Parser.RULE_performProcedureStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4723)
		 	try procedureName()
		 	setState(4726)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4724)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4725)
		 		try procedureName()

		 	}

		 	setState(4729)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,689,_ctx)) {
		 	case 1:
		 		setState(4728)
		 		try performType()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformTypeContext: ParserRuleContext {
			open
			func performTimes() -> PerformTimesContext? {
				return getRuleContext(PerformTimesContext.self, 0)
			}
			open
			func performUntil() -> PerformUntilContext? {
				return getRuleContext(PerformUntilContext.self, 0)
			}
			open
			func performVarying() -> PerformVaryingContext? {
				return getRuleContext(PerformVaryingContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformType(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformType(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformType(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performType() throws -> PerformTypeContext {
		var _localctx: PerformTypeContext = PerformTypeContext(_ctx, getState())
		try enterRule(_localctx, 800, Cobol85Parser.RULE_performType)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4734)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,690, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4731)
		 		try performTimes()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4732)
		 		try performUntil()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4733)
		 		try performVarying()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformTimesContext: ParserRuleContext {
			open
			func TIMES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TIMES.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performTimes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformTimes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformTimes(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformTimes(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformTimes(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performTimes() throws -> PerformTimesContext {
		var _localctx: PerformTimesContext = PerformTimesContext(_ctx, getState())
		try enterRule(_localctx, 802, Cobol85Parser.RULE_performTimes)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4738)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,691, _ctx)) {
		 	case 1:
		 		setState(4736)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4737)
		 		try integerLiteral()

		 		break
		 	default: break
		 	}
		 	setState(4740)
		 	try match(Cobol85Parser.Tokens.TIMES.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformUntilContext: ParserRuleContext {
			open
			func UNTIL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.UNTIL.rawValue, 0)
			}
			open
			func condition() -> ConditionContext? {
				return getRuleContext(ConditionContext.self, 0)
			}
			open
			func performTestClause() -> PerformTestClauseContext? {
				return getRuleContext(PerformTestClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performUntil
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformUntil(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformUntil(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformUntil(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformUntil(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performUntil() throws -> PerformUntilContext {
		var _localctx: PerformUntilContext = PerformUntilContext(_ctx, getState())
		try enterRule(_localctx, 804, Cobol85Parser.RULE_performUntil)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4743)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TEST.rawValue || _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4742)
		 		try performTestClause()

		 	}

		 	setState(4745)
		 	try match(Cobol85Parser.Tokens.UNTIL.rawValue)
		 	setState(4746)
		 	try condition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformVaryingContext: ParserRuleContext {
			open
			func performTestClause() -> PerformTestClauseContext? {
				return getRuleContext(PerformTestClauseContext.self, 0)
			}
			open
			func performVaryingClause() -> PerformVaryingClauseContext? {
				return getRuleContext(PerformVaryingClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performVarying
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformVarying(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformVarying(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformVarying(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformVarying(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performVarying() throws -> PerformVaryingContext {
		var _localctx: PerformVaryingContext = PerformVaryingContext(_ctx, getState())
		try enterRule(_localctx, 806, Cobol85Parser.RULE_performVarying)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4755)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .TEST:fallthrough
		 	case .WITH:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4748)
		 		try performTestClause()
		 		setState(4749)
		 		try performVaryingClause()

		 		break

		 	case .VARYING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4751)
		 		try performVaryingClause()
		 		setState(4753)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,693,_ctx)) {
		 		case 1:
		 			setState(4752)
		 			try performTestClause()

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformVaryingClauseContext: ParserRuleContext {
			open
			func VARYING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VARYING.rawValue, 0)
			}
			open
			func performVaryingPhrase() -> PerformVaryingPhraseContext? {
				return getRuleContext(PerformVaryingPhraseContext.self, 0)
			}
			open
			func performAfter() -> [PerformAfterContext] {
				return getRuleContexts(PerformAfterContext.self)
			}
			open
			func performAfter(_ i: Int) -> PerformAfterContext? {
				return getRuleContext(PerformAfterContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performVaryingClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformVaryingClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformVaryingClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformVaryingClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformVaryingClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performVaryingClause() throws -> PerformVaryingClauseContext {
		var _localctx: PerformVaryingClauseContext = PerformVaryingClauseContext(_ctx, getState())
		try enterRule(_localctx, 808, Cobol85Parser.RULE_performVaryingClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4757)
		 	try match(Cobol85Parser.Tokens.VARYING.rawValue)
		 	setState(4758)
		 	try performVaryingPhrase()
		 	setState(4762)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4759)
		 		try performAfter()


		 		setState(4764)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformVaryingPhraseContext: ParserRuleContext {
			open
			func performFrom() -> PerformFromContext? {
				return getRuleContext(PerformFromContext.self, 0)
			}
			open
			func performBy() -> PerformByContext? {
				return getRuleContext(PerformByContext.self, 0)
			}
			open
			func performUntil() -> PerformUntilContext? {
				return getRuleContext(PerformUntilContext.self, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performVaryingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformVaryingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformVaryingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformVaryingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformVaryingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performVaryingPhrase() throws -> PerformVaryingPhraseContext {
		var _localctx: PerformVaryingPhraseContext = PerformVaryingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 810, Cobol85Parser.RULE_performVaryingPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4767)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,696, _ctx)) {
		 	case 1:
		 		setState(4765)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4766)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(4769)
		 	try performFrom()
		 	setState(4770)
		 	try performBy()
		 	setState(4771)
		 	try performUntil()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformAfterContext: ParserRuleContext {
			open
			func AFTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AFTER.rawValue, 0)
			}
			open
			func performVaryingPhrase() -> PerformVaryingPhraseContext? {
				return getRuleContext(PerformVaryingPhraseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performAfter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformAfter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformAfter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformAfter(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformAfter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performAfter() throws -> PerformAfterContext {
		var _localctx: PerformAfterContext = PerformAfterContext(_ctx, getState())
		try enterRule(_localctx, 812, Cobol85Parser.RULE_performAfter)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4773)
		 	try match(Cobol85Parser.Tokens.AFTER.rawValue)
		 	setState(4774)
		 	try performVaryingPhrase()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformFromContext: ParserRuleContext {
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performFrom
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformFrom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformFrom(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformFrom(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformFrom(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performFrom() throws -> PerformFromContext {
		var _localctx: PerformFromContext = PerformFromContext(_ctx, getState())
		try enterRule(_localctx, 814, Cobol85Parser.RULE_performFrom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4776)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(4780)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,697, _ctx)) {
		 	case 1:
		 		setState(4777)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4778)
		 		try literal()

		 		break
		 	case 3:
		 		setState(4779)
		 		try arithmeticExpression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformByContext: ParserRuleContext {
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performBy
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformBy(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformBy(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformBy(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformBy(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performBy() throws -> PerformByContext {
		var _localctx: PerformByContext = PerformByContext(_ctx, getState())
		try enterRule(_localctx, 816, Cobol85Parser.RULE_performBy)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4782)
		 	try match(Cobol85Parser.Tokens.BY.rawValue)
		 	setState(4786)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,698, _ctx)) {
		 	case 1:
		 		setState(4783)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(4784)
		 		try literal()

		 		break
		 	case 3:
		 		setState(4785)
		 		try arithmeticExpression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PerformTestClauseContext: ParserRuleContext {
			open
			func TEST() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TEST.rawValue, 0)
			}
			open
			func BEFORE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BEFORE.rawValue, 0)
			}
			open
			func AFTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AFTER.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_performTestClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPerformTestClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPerformTestClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPerformTestClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPerformTestClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func performTestClause() throws -> PerformTestClauseContext {
		var _localctx: PerformTestClauseContext = PerformTestClauseContext(_ctx, getState())
		try enterRule(_localctx, 818, Cobol85Parser.RULE_performTestClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4789)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4788)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(4791)
		 	try match(Cobol85Parser.Tokens.TEST.rawValue)
		 	setState(4792)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue || _la == Cobol85Parser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PurgeStatementContext: ParserRuleContext {
			open
			func PURGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PURGE.rawValue, 0)
			}
			open
			func cdName() -> [CdNameContext] {
				return getRuleContexts(CdNameContext.self)
			}
			open
			func cdName(_ i: Int) -> CdNameContext? {
				return getRuleContext(CdNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_purgeStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPurgeStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPurgeStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPurgeStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPurgeStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func purgeStatement() throws -> PurgeStatementContext {
		var _localctx: PurgeStatementContext = PurgeStatementContext(_ctx, getState())
		try enterRule(_localctx, 820, Cobol85Parser.RULE_purgeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4794)
		 	try match(Cobol85Parser.Tokens.PURGE.rawValue)
		 	setState(4796) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4795)
		 		try cdName()


		 		setState(4798); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReadStatementContext: ParserRuleContext {
			open
			func READ() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.READ.rawValue, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func NEXT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NEXT.rawValue, 0)
			}
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func readInto() -> ReadIntoContext? {
				return getRuleContext(ReadIntoContext.self, 0)
			}
			open
			func readWith() -> ReadWithContext? {
				return getRuleContext(ReadWithContext.self, 0)
			}
			open
			func readKey() -> ReadKeyContext? {
				return getRuleContext(ReadKeyContext.self, 0)
			}
			open
			func invalidKeyPhrase() -> InvalidKeyPhraseContext? {
				return getRuleContext(InvalidKeyPhraseContext.self, 0)
			}
			open
			func notInvalidKeyPhrase() -> NotInvalidKeyPhraseContext? {
				return getRuleContext(NotInvalidKeyPhraseContext.self, 0)
			}
			open
			func atEndPhrase() -> AtEndPhraseContext? {
				return getRuleContext(AtEndPhraseContext.self, 0)
			}
			open
			func notAtEndPhrase() -> NotAtEndPhraseContext? {
				return getRuleContext(NotAtEndPhraseContext.self, 0)
			}
			open
			func END_READ() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_READ.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_readStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReadStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReadStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReadStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReadStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func readStatement() throws -> ReadStatementContext {
		var _localctx: ReadStatementContext = ReadStatementContext(_ctx, getState())
		try enterRule(_localctx, 822, Cobol85Parser.RULE_readStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4800)
		 	try match(Cobol85Parser.Tokens.READ.rawValue)
		 	setState(4801)
		 	try fileName()
		 	setState(4803)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.NEXT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4802)
		 		try match(Cobol85Parser.Tokens.NEXT.rawValue)

		 	}

		 	setState(4806)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.RECORD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4805)
		 		try match(Cobol85Parser.Tokens.RECORD.rawValue)

		 	}

		 	setState(4809)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4808)
		 		try readInto()

		 	}

		 	setState(4812)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,704,_ctx)) {
		 	case 1:
		 		setState(4811)
		 		try readWith()

		 		break
		 	default: break
		 	}
		 	setState(4815)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.KEY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4814)
		 		try readKey()

		 	}

		 	setState(4818)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,706,_ctx)) {
		 	case 1:
		 		setState(4817)
		 		try invalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4821)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,707,_ctx)) {
		 	case 1:
		 		setState(4820)
		 		try notInvalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4824)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,708,_ctx)) {
		 	case 1:
		 		setState(4823)
		 		try atEndPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4827)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,709,_ctx)) {
		 	case 1:
		 		setState(4826)
		 		try notAtEndPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4830)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,710,_ctx)) {
		 	case 1:
		 		setState(4829)
		 		try match(Cobol85Parser.Tokens.END_READ.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReadIntoContext: ParserRuleContext {
			open
			func INTO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTO.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_readInto
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReadInto(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReadInto(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReadInto(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReadInto(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func readInto() throws -> ReadIntoContext {
		var _localctx: ReadIntoContext = ReadIntoContext(_ctx, getState())
		try enterRule(_localctx, 824, Cobol85Parser.RULE_readInto)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4832)
		 	try match(Cobol85Parser.Tokens.INTO.rawValue)
		 	setState(4833)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReadWithContext: ParserRuleContext {
			open
			func LOCK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOCK.rawValue, 0)
			}
			open
			func WAIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WAIT.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
			open
			func KEPT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEPT.rawValue, 0)
			}
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_readWith
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReadWith(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReadWith(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReadWith(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReadWith(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func readWith() throws -> ReadWithContext {
		var _localctx: ReadWithContext = ReadWithContext(_ctx, getState())
		try enterRule(_localctx, 826, Cobol85Parser.RULE_readWith)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4836)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4835)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(4841)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .KEPT:fallthrough
		 	case .NO:
		 		setState(4838)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.KEPT.rawValue || _la == Cobol85Parser.Tokens.NO.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4839)
		 		try match(Cobol85Parser.Tokens.LOCK.rawValue)

		 		break

		 	case .WAIT:
		 		setState(4840)
		 		try match(Cobol85Parser.Tokens.WAIT.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReadKeyContext: ParserRuleContext {
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_readKey
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReadKey(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReadKey(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReadKey(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReadKey(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func readKey() throws -> ReadKeyContext {
		var _localctx: ReadKeyContext = ReadKeyContext(_ctx, getState())
		try enterRule(_localctx, 828, Cobol85Parser.RULE_readKey)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4843)
		 	try match(Cobol85Parser.Tokens.KEY.rawValue)
		 	setState(4845)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4844)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(4847)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReceiveStatementContext: ParserRuleContext {
			open
			func RECEIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECEIVE.rawValue, 0)
			}
			open
			func receiveFromStatement() -> ReceiveFromStatementContext? {
				return getRuleContext(ReceiveFromStatementContext.self, 0)
			}
			open
			func receiveIntoStatement() -> ReceiveIntoStatementContext? {
				return getRuleContext(ReceiveIntoStatementContext.self, 0)
			}
			open
			func onExceptionClause() -> OnExceptionClauseContext? {
				return getRuleContext(OnExceptionClauseContext.self, 0)
			}
			open
			func notOnExceptionClause() -> NotOnExceptionClauseContext? {
				return getRuleContext(NotOnExceptionClauseContext.self, 0)
			}
			open
			func END_RECEIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_RECEIVE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_receiveStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReceiveStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReceiveStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReceiveStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReceiveStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func receiveStatement() throws -> ReceiveStatementContext {
		var _localctx: ReceiveStatementContext = ReceiveStatementContext(_ctx, getState())
		try enterRule(_localctx, 830, Cobol85Parser.RULE_receiveStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4849)
		 	try match(Cobol85Parser.Tokens.RECEIVE.rawValue)
		 	setState(4852)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,714, _ctx)) {
		 	case 1:
		 		setState(4850)
		 		try receiveFromStatement()

		 		break
		 	case 2:
		 		setState(4851)
		 		try receiveIntoStatement()

		 		break
		 	default: break
		 	}
		 	setState(4855)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,715,_ctx)) {
		 	case 1:
		 		setState(4854)
		 		try onExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(4858)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,716,_ctx)) {
		 	case 1:
		 		setState(4857)
		 		try notOnExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(4861)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,717,_ctx)) {
		 	case 1:
		 		setState(4860)
		 		try match(Cobol85Parser.Tokens.END_RECEIVE.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReceiveFromStatementContext: ParserRuleContext {
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func receiveFrom() -> ReceiveFromContext? {
				return getRuleContext(ReceiveFromContext.self, 0)
			}
			open
			func receiveBefore() -> [ReceiveBeforeContext] {
				return getRuleContexts(ReceiveBeforeContext.self)
			}
			open
			func receiveBefore(_ i: Int) -> ReceiveBeforeContext? {
				return getRuleContext(ReceiveBeforeContext.self, i)
			}
			open
			func receiveWith() -> [ReceiveWithContext] {
				return getRuleContexts(ReceiveWithContext.self)
			}
			open
			func receiveWith(_ i: Int) -> ReceiveWithContext? {
				return getRuleContext(ReceiveWithContext.self, i)
			}
			open
			func receiveThread() -> [ReceiveThreadContext] {
				return getRuleContexts(ReceiveThreadContext.self)
			}
			open
			func receiveThread(_ i: Int) -> ReceiveThreadContext? {
				return getRuleContext(ReceiveThreadContext.self, i)
			}
			open
			func receiveSize() -> [ReceiveSizeContext] {
				return getRuleContexts(ReceiveSizeContext.self)
			}
			open
			func receiveSize(_ i: Int) -> ReceiveSizeContext? {
				return getRuleContext(ReceiveSizeContext.self, i)
			}
			open
			func receiveStatus() -> [ReceiveStatusContext] {
				return getRuleContexts(ReceiveStatusContext.self)
			}
			open
			func receiveStatus(_ i: Int) -> ReceiveStatusContext? {
				return getRuleContext(ReceiveStatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_receiveFromStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReceiveFromStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReceiveFromStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReceiveFromStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReceiveFromStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func receiveFromStatement() throws -> ReceiveFromStatementContext {
		var _localctx: ReceiveFromStatementContext = ReceiveFromStatementContext(_ctx, getState())
		try enterRule(_localctx, 832, Cobol85Parser.RULE_receiveFromStatement)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4863)
		 	try dataName()
		 	setState(4864)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(4865)
		 	try receiveFrom()
		 	setState(4873)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,719,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4871)
		 			try _errHandler.sync(self)
		 			switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .BEFORE:
		 				setState(4866)
		 				try receiveBefore()

		 				break
		 			case .NO:fallthrough
		 			case .WITH:
		 				setState(4867)
		 				try receiveWith()

		 				break

		 			case .THREAD:
		 				setState(4868)
		 				try receiveThread()

		 				break

		 			case .SIZE:
		 				setState(4869)
		 				try receiveSize()

		 				break

		 			case .STATUS:
		 				setState(4870)
		 				try receiveStatus()

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 	 
		 		}
		 		setState(4875)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,719,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReceiveFromContext: ParserRuleContext {
			open
			func THREAD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THREAD.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func LAST() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LAST.rawValue, 0)
			}
			open
			func ANY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ANY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_receiveFrom
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReceiveFrom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReceiveFrom(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReceiveFrom(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReceiveFrom(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func receiveFrom() throws -> ReceiveFromContext {
		var _localctx: ReceiveFromContext = ReceiveFromContext(_ctx, getState())
		try enterRule(_localctx, 834, Cobol85Parser.RULE_receiveFrom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4882)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .THREAD:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4876)
		 		try match(Cobol85Parser.Tokens.THREAD.rawValue)
		 		setState(4877)
		 		try dataName()

		 		break

		 	case .LAST:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4878)
		 		try match(Cobol85Parser.Tokens.LAST.rawValue)
		 		setState(4879)
		 		try match(Cobol85Parser.Tokens.THREAD.rawValue)

		 		break

		 	case .ANY:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4880)
		 		try match(Cobol85Parser.Tokens.ANY.rawValue)
		 		setState(4881)
		 		try match(Cobol85Parser.Tokens.THREAD.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReceiveIntoStatementContext: ParserRuleContext {
			open
			func cdName() -> CdNameContext? {
				return getRuleContext(CdNameContext.self, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func MESSAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MESSAGE.rawValue, 0)
			}
			open
			func SEGMENT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEGMENT.rawValue, 0)
			}
			open
			func INTO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTO.rawValue, 0)
			}
			open
			func receiveNoData() -> ReceiveNoDataContext? {
				return getRuleContext(ReceiveNoDataContext.self, 0)
			}
			open
			func receiveWithData() -> ReceiveWithDataContext? {
				return getRuleContext(ReceiveWithDataContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_receiveIntoStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReceiveIntoStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReceiveIntoStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReceiveIntoStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReceiveIntoStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func receiveIntoStatement() throws -> ReceiveIntoStatementContext {
		var _localctx: ReceiveIntoStatementContext = ReceiveIntoStatementContext(_ctx, getState())
		try enterRule(_localctx, 836, Cobol85Parser.RULE_receiveIntoStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4884)
		 	try cdName()
		 	setState(4885)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.MESSAGE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.SEGMENT.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4887)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4886)
		 		try match(Cobol85Parser.Tokens.INTO.rawValue)

		 	}

		 	setState(4889)
		 	try identifier()
		 	setState(4891)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.NO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4890)
		 		try receiveNoData()

		 	}

		 	setState(4894)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,723,_ctx)) {
		 	case 1:
		 		setState(4893)
		 		try receiveWithData()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReceiveNoDataContext: ParserRuleContext {
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
			open
			func DATA() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATA.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_receiveNoData
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReceiveNoData(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReceiveNoData(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReceiveNoData(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReceiveNoData(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func receiveNoData() throws -> ReceiveNoDataContext {
		var _localctx: ReceiveNoDataContext = ReceiveNoDataContext(_ctx, getState())
		try enterRule(_localctx, 838, Cobol85Parser.RULE_receiveNoData)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4896)
		 	try match(Cobol85Parser.Tokens.NO.rawValue)
		 	setState(4897)
		 	try match(Cobol85Parser.Tokens.DATA.rawValue)
		 	setState(4901)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,724,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4898)
		 			try statement()

		 	 
		 		}
		 		setState(4903)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,724,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReceiveWithDataContext: ParserRuleContext {
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
			open
			func DATA() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATA.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_receiveWithData
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReceiveWithData(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReceiveWithData(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReceiveWithData(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReceiveWithData(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func receiveWithData() throws -> ReceiveWithDataContext {
		var _localctx: ReceiveWithDataContext = ReceiveWithDataContext(_ctx, getState())
		try enterRule(_localctx, 840, Cobol85Parser.RULE_receiveWithData)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4904)
		 	try match(Cobol85Parser.Tokens.WITH.rawValue)
		 	setState(4905)
		 	try match(Cobol85Parser.Tokens.DATA.rawValue)
		 	setState(4909)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,725,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4906)
		 			try statement()

		 	 
		 		}
		 		setState(4911)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,725,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReceiveBeforeContext: ParserRuleContext {
			open
			func BEFORE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BEFORE.rawValue, 0)
			}
			open
			func numericLiteral() -> NumericLiteralContext? {
				return getRuleContext(NumericLiteralContext.self, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func TIME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TIME.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_receiveBefore
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReceiveBefore(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReceiveBefore(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReceiveBefore(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReceiveBefore(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func receiveBefore() throws -> ReceiveBeforeContext {
		var _localctx: ReceiveBeforeContext = ReceiveBeforeContext(_ctx, getState())
		try enterRule(_localctx, 842, Cobol85Parser.RULE_receiveBefore)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4912)
		 	try match(Cobol85Parser.Tokens.BEFORE.rawValue)
		 	setState(4914)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,726,_ctx)) {
		 	case 1:
		 		setState(4913)
		 		try match(Cobol85Parser.Tokens.TIME.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4918)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,727, _ctx)) {
		 	case 1:
		 		setState(4916)
		 		try numericLiteral()

		 		break
		 	case 2:
		 		setState(4917)
		 		try identifier()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReceiveWithContext: ParserRuleContext {
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
			open
			func WAIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WAIT.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_receiveWith
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReceiveWith(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReceiveWith(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReceiveWith(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReceiveWith(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func receiveWith() throws -> ReceiveWithContext {
		var _localctx: ReceiveWithContext = ReceiveWithContext(_ctx, getState())
		try enterRule(_localctx, 844, Cobol85Parser.RULE_receiveWith)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4921)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4920)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(4923)
		 	try match(Cobol85Parser.Tokens.NO.rawValue)
		 	setState(4924)
		 	try match(Cobol85Parser.Tokens.WAIT.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReceiveThreadContext: ParserRuleContext {
			open
			func THREAD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THREAD.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_receiveThread
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReceiveThread(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReceiveThread(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReceiveThread(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReceiveThread(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func receiveThread() throws -> ReceiveThreadContext {
		var _localctx: ReceiveThreadContext = ReceiveThreadContext(_ctx, getState())
		try enterRule(_localctx, 846, Cobol85Parser.RULE_receiveThread)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4926)
		 	try match(Cobol85Parser.Tokens.THREAD.rawValue)
		 	setState(4928)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4927)
		 		try match(Cobol85Parser.Tokens.IN.rawValue)

		 	}

		 	setState(4930)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReceiveSizeContext: ParserRuleContext {
			open
			func SIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIZE.rawValue, 0)
			}
			open
			func numericLiteral() -> NumericLiteralContext? {
				return getRuleContext(NumericLiteralContext.self, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_receiveSize
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReceiveSize(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReceiveSize(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReceiveSize(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReceiveSize(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func receiveSize() throws -> ReceiveSizeContext {
		var _localctx: ReceiveSizeContext = ReceiveSizeContext(_ctx, getState())
		try enterRule(_localctx, 848, Cobol85Parser.RULE_receiveSize)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4932)
		 	try match(Cobol85Parser.Tokens.SIZE.rawValue)
		 	setState(4934)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4933)
		 		try match(Cobol85Parser.Tokens.IN.rawValue)

		 	}

		 	setState(4938)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,731, _ctx)) {
		 	case 1:
		 		setState(4936)
		 		try numericLiteral()

		 		break
		 	case 2:
		 		setState(4937)
		 		try identifier()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReceiveStatusContext: ParserRuleContext {
			open
			func STATUS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STATUS.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_receiveStatus
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReceiveStatus(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReceiveStatus(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReceiveStatus(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReceiveStatus(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func receiveStatus() throws -> ReceiveStatusContext {
		var _localctx: ReceiveStatusContext = ReceiveStatusContext(_ctx, getState())
		try enterRule(_localctx, 850, Cobol85Parser.RULE_receiveStatus)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4940)
		 	try match(Cobol85Parser.Tokens.STATUS.rawValue)
		 	setState(4942)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4941)
		 		try match(Cobol85Parser.Tokens.IN.rawValue)

		 	}

		 	setState(4944)
		 	try identifier()


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReleaseStatementContext: ParserRuleContext {
			open
			func RELEASE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RELEASE.rawValue, 0)
			}
			open
			func recordName() -> RecordNameContext? {
				return getRuleContext(RecordNameContext.self, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_releaseStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReleaseStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReleaseStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReleaseStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReleaseStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func releaseStatement() throws -> ReleaseStatementContext {
		var _localctx: ReleaseStatementContext = ReleaseStatementContext(_ctx, getState())
		try enterRule(_localctx, 852, Cobol85Parser.RULE_releaseStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4946)
		 	try match(Cobol85Parser.Tokens.RELEASE.rawValue)
		 	setState(4947)
		 	try recordName()
		 	setState(4950)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FROM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4948)
		 		try match(Cobol85Parser.Tokens.FROM.rawValue)
		 		setState(4949)
		 		try qualifiedDataName()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReturnStatementContext: ParserRuleContext {
			open
			func RETURN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RETURN.rawValue, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func atEndPhrase() -> AtEndPhraseContext? {
				return getRuleContext(AtEndPhraseContext.self, 0)
			}
			open
			func RECORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECORD.rawValue, 0)
			}
			open
			func returnInto() -> ReturnIntoContext? {
				return getRuleContext(ReturnIntoContext.self, 0)
			}
			open
			func notAtEndPhrase() -> NotAtEndPhraseContext? {
				return getRuleContext(NotAtEndPhraseContext.self, 0)
			}
			open
			func END_RETURN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_RETURN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_returnStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReturnStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReturnStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReturnStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReturnStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func returnStatement() throws -> ReturnStatementContext {
		var _localctx: ReturnStatementContext = ReturnStatementContext(_ctx, getState())
		try enterRule(_localctx, 854, Cobol85Parser.RULE_returnStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4952)
		 	try match(Cobol85Parser.Tokens.RETURN.rawValue)
		 	setState(4953)
		 	try fileName()
		 	setState(4955)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.RECORD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4954)
		 		try match(Cobol85Parser.Tokens.RECORD.rawValue)

		 	}

		 	setState(4958)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4957)
		 		try returnInto()

		 	}

		 	setState(4960)
		 	try atEndPhrase()
		 	setState(4962)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,736,_ctx)) {
		 	case 1:
		 		setState(4961)
		 		try notAtEndPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4965)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,737,_ctx)) {
		 	case 1:
		 		setState(4964)
		 		try match(Cobol85Parser.Tokens.END_RETURN.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReturnIntoContext: ParserRuleContext {
			open
			func INTO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTO.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_returnInto
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReturnInto(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReturnInto(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReturnInto(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReturnInto(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func returnInto() throws -> ReturnIntoContext {
		var _localctx: ReturnIntoContext = ReturnIntoContext(_ctx, getState())
		try enterRule(_localctx, 856, Cobol85Parser.RULE_returnInto)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4967)
		 	try match(Cobol85Parser.Tokens.INTO.rawValue)
		 	setState(4968)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RewriteStatementContext: ParserRuleContext {
			open
			func REWRITE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REWRITE.rawValue, 0)
			}
			open
			func recordName() -> RecordNameContext? {
				return getRuleContext(RecordNameContext.self, 0)
			}
			open
			func rewriteFrom() -> RewriteFromContext? {
				return getRuleContext(RewriteFromContext.self, 0)
			}
			open
			func invalidKeyPhrase() -> InvalidKeyPhraseContext? {
				return getRuleContext(InvalidKeyPhraseContext.self, 0)
			}
			open
			func notInvalidKeyPhrase() -> NotInvalidKeyPhraseContext? {
				return getRuleContext(NotInvalidKeyPhraseContext.self, 0)
			}
			open
			func END_REWRITE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_REWRITE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_rewriteStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRewriteStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRewriteStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRewriteStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRewriteStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func rewriteStatement() throws -> RewriteStatementContext {
		var _localctx: RewriteStatementContext = RewriteStatementContext(_ctx, getState())
		try enterRule(_localctx, 858, Cobol85Parser.RULE_rewriteStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4970)
		 	try match(Cobol85Parser.Tokens.REWRITE.rawValue)
		 	setState(4971)
		 	try recordName()
		 	setState(4973)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FROM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4972)
		 		try rewriteFrom()

		 	}

		 	setState(4976)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,739,_ctx)) {
		 	case 1:
		 		setState(4975)
		 		try invalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4979)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,740,_ctx)) {
		 	case 1:
		 		setState(4978)
		 		try notInvalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(4982)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,741,_ctx)) {
		 	case 1:
		 		setState(4981)
		 		try match(Cobol85Parser.Tokens.END_REWRITE.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RewriteFromContext: ParserRuleContext {
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_rewriteFrom
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRewriteFrom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRewriteFrom(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRewriteFrom(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRewriteFrom(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func rewriteFrom() throws -> RewriteFromContext {
		var _localctx: RewriteFromContext = RewriteFromContext(_ctx, getState())
		try enterRule(_localctx, 860, Cobol85Parser.RULE_rewriteFrom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4984)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(4985)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SearchStatementContext: ParserRuleContext {
			open
			func SEARCH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEARCH.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALL.rawValue, 0)
			}
			open
			func searchVarying() -> SearchVaryingContext? {
				return getRuleContext(SearchVaryingContext.self, 0)
			}
			open
			func atEndPhrase() -> AtEndPhraseContext? {
				return getRuleContext(AtEndPhraseContext.self, 0)
			}
			open
			func searchWhen() -> [SearchWhenContext] {
				return getRuleContexts(SearchWhenContext.self)
			}
			open
			func searchWhen(_ i: Int) -> SearchWhenContext? {
				return getRuleContext(SearchWhenContext.self, i)
			}
			open
			func END_SEARCH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_SEARCH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_searchStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSearchStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSearchStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSearchStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSearchStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func searchStatement() throws -> SearchStatementContext {
		var _localctx: SearchStatementContext = SearchStatementContext(_ctx, getState())
		try enterRule(_localctx, 862, Cobol85Parser.RULE_searchStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4987)
		 	try match(Cobol85Parser.Tokens.SEARCH.rawValue)
		 	setState(4989)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ALL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4988)
		 		try match(Cobol85Parser.Tokens.ALL.rawValue)

		 	}

		 	setState(4991)
		 	try qualifiedDataName()
		 	setState(4993)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.VARYING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4992)
		 		try searchVarying()

		 	}

		 	setState(4996)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.AT.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.END.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4995)
		 		try atEndPhrase()

		 	}

		 	setState(4999); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4998)
		 			try searchWhen()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5001); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,745,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(5004)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,746,_ctx)) {
		 	case 1:
		 		setState(5003)
		 		try match(Cobol85Parser.Tokens.END_SEARCH.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SearchVaryingContext: ParserRuleContext {
			open
			func VARYING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VARYING.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_searchVarying
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSearchVarying(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSearchVarying(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSearchVarying(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSearchVarying(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func searchVarying() throws -> SearchVaryingContext {
		var _localctx: SearchVaryingContext = SearchVaryingContext(_ctx, getState())
		try enterRule(_localctx, 864, Cobol85Parser.RULE_searchVarying)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5006)
		 	try match(Cobol85Parser.Tokens.VARYING.rawValue)
		 	setState(5007)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SearchWhenContext: ParserRuleContext {
			open
			func WHEN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WHEN.rawValue, 0)
			}
			open
			func condition() -> ConditionContext? {
				return getRuleContext(ConditionContext.self, 0)
			}
			open
			func NEXT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NEXT.rawValue, 0)
			}
			open
			func SENTENCE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SENTENCE.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_searchWhen
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSearchWhen(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSearchWhen(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSearchWhen(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSearchWhen(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func searchWhen() throws -> SearchWhenContext {
		var _localctx: SearchWhenContext = SearchWhenContext(_ctx, getState())
		try enterRule(_localctx, 866, Cobol85Parser.RULE_searchWhen)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5009)
		 	try match(Cobol85Parser.Tokens.WHEN.rawValue)
		 	setState(5010)
		 	try condition()
		 	setState(5019)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NEXT:
		 		setState(5011)
		 		try match(Cobol85Parser.Tokens.NEXT.rawValue)
		 		setState(5012)
		 		try match(Cobol85Parser.Tokens.SENTENCE.rawValue)

		 		break
		 	case .ACCEPT:fallthrough
		 	case .ADD:fallthrough
		 	case .ALTER:fallthrough
		 	case .AT:fallthrough
		 	case .CALL:fallthrough
		 	case .CANCEL:fallthrough
		 	case .CLOSE:fallthrough
		 	case .COMPUTE:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .DELETE:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISPLAY:fallthrough
		 	case .DIVIDE:fallthrough
		 	case .ELSE:fallthrough
		 	case .ENABLE:fallthrough
		 	case .END:fallthrough
		 	case .END_ACCEPT:fallthrough
		 	case .END_ADD:fallthrough
		 	case .END_CALL:fallthrough
		 	case .END_COMPUTE:fallthrough
		 	case .END_DELETE:fallthrough
		 	case .END_DIVIDE:fallthrough
		 	case .END_EVALUATE:fallthrough
		 	case .END_IF:fallthrough
		 	case .END_MULTIPLY:fallthrough
		 	case .END_PERFORM:fallthrough
		 	case .END_READ:fallthrough
		 	case .END_RECEIVE:fallthrough
		 	case .END_RETURN:fallthrough
		 	case .END_REWRITE:fallthrough
		 	case .END_SEARCH:fallthrough
		 	case .END_START:fallthrough
		 	case .END_STRING:fallthrough
		 	case .END_SUBTRACT:fallthrough
		 	case .END_UNSTRING:fallthrough
		 	case .END_WRITE:fallthrough
		 	case .ENTRY:fallthrough
		 	case .EVALUATE:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXHIBIT:fallthrough
		 	case .EXIT:fallthrough
		 	case .GENERATE:fallthrough
		 	case .GOBACK:fallthrough
		 	case .GO:fallthrough
		 	case .IF:fallthrough
		 	case .INITIALIZE:fallthrough
		 	case .INITIATE:fallthrough
		 	case .INSPECT:fallthrough
		 	case .INVALID:fallthrough
		 	case .MERGE:fallthrough
		 	case .MOVE:fallthrough
		 	case .MULTIPLY:fallthrough
		 	case .NOT:fallthrough
		 	case .ON:fallthrough
		 	case .OPEN:fallthrough
		 	case .PERFORM:fallthrough
		 	case .PURGE:fallthrough
		 	case .READ:fallthrough
		 	case .RECEIVE:fallthrough
		 	case .RELEASE:fallthrough
		 	case .RETURN:fallthrough
		 	case .REWRITE:fallthrough
		 	case .SEARCH:fallthrough
		 	case .SEND:fallthrough
		 	case .SET:fallthrough
		 	case .SORT:fallthrough
		 	case .START:fallthrough
		 	case .STOP:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBTRACT:fallthrough
		 	case .TERMINATE:fallthrough
		 	case .UNSTRING:fallthrough
		 	case .WHEN:fallthrough
		 	case .WITH:fallthrough
		 	case .WRITE:fallthrough
		 	case .DOT_FS:fallthrough
		 	case .EXECCICSLINE:fallthrough
		 	case .EXECSQLIMSLINE:fallthrough
		 	case .EXECSQLLINE:
		 		setState(5016)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,747,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(5013)
		 				try statement()

		 		 
		 			}
		 			setState(5018)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,747,_ctx)
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SendStatementContext: ParserRuleContext {
			open
			func SEND() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEND.rawValue, 0)
			}
			open
			func sendStatementSync() -> SendStatementSyncContext? {
				return getRuleContext(SendStatementSyncContext.self, 0)
			}
			open
			func sendStatementAsync() -> SendStatementAsyncContext? {
				return getRuleContext(SendStatementAsyncContext.self, 0)
			}
			open
			func onExceptionClause() -> OnExceptionClauseContext? {
				return getRuleContext(OnExceptionClauseContext.self, 0)
			}
			open
			func notOnExceptionClause() -> NotOnExceptionClauseContext? {
				return getRuleContext(NotOnExceptionClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sendStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSendStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSendStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSendStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSendStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sendStatement() throws -> SendStatementContext {
		var _localctx: SendStatementContext = SendStatementContext(_ctx, getState())
		try enterRule(_localctx, 868, Cobol85Parser.RULE_sendStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5021)
		 	try match(Cobol85Parser.Tokens.SEND.rawValue)
		 	setState(5024)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ABORT:fallthrough
		 	case .ADDRESS:fallthrough
		 	case .ALL:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DAY_OF_WEEK:fallthrough
		 	case .DEBUG_CONTENTS:fallthrough
		 	case .DEBUG_ITEM:fallthrough
		 	case .DEBUG_LINE:fallthrough
		 	case .DEBUG_NAME:fallthrough
		 	case .DEBUG_SUB_1:fallthrough
		 	case .DEBUG_SUB_2:fallthrough
		 	case .DEBUG_SUB_3:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FALSE:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .HIGH_VALUE:fallthrough
		 	case .HIGH_VALUES:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LINAGE_COUNTER:fallthrough
		 	case .LINE_COUNTER:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .LOW_VALUE:fallthrough
		 	case .LOW_VALUES:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PAGE_COUNTER:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .QUOTE:fallthrough
		 	case .QUOTES:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .RETURN_CODE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHIFT_IN:fallthrough
		 	case .SHIFT_OUT:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SORT_CONTROL:fallthrough
		 	case .SORT_CORE_SIZE:fallthrough
		 	case .SORT_FILE_SIZE:fallthrough
		 	case .SORT_MESSAGE:fallthrough
		 	case .SORT_MODE_SIZE:fallthrough
		 	case .SORT_RETURN:fallthrough
		 	case .SPACE:fallthrough
		 	case .SPACES:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TALLY:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .WHEN_COMPILED:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .ZEROS:fallthrough
		 	case .ZEROES:fallthrough
		 	case .NONNUMERICLITERAL:fallthrough
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:fallthrough
		 	case .NUMERICLITERAL:fallthrough
		 	case .IDENTIFIER:
		 		setState(5022)
		 		try sendStatementSync()

		 		break

		 	case .TO:
		 		setState(5023)
		 		try sendStatementAsync()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5027)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,750,_ctx)) {
		 	case 1:
		 		setState(5026)
		 		try onExceptionClause()

		 		break
		 	default: break
		 	}
		 	setState(5030)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,751,_ctx)) {
		 	case 1:
		 		setState(5029)
		 		try notOnExceptionClause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SendStatementSyncContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func sendFromPhrase() -> SendFromPhraseContext? {
				return getRuleContext(SendFromPhraseContext.self, 0)
			}
			open
			func sendWithPhrase() -> SendWithPhraseContext? {
				return getRuleContext(SendWithPhraseContext.self, 0)
			}
			open
			func sendReplacingPhrase() -> SendReplacingPhraseContext? {
				return getRuleContext(SendReplacingPhraseContext.self, 0)
			}
			open
			func sendAdvancingPhrase() -> SendAdvancingPhraseContext? {
				return getRuleContext(SendAdvancingPhraseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sendStatementSync
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSendStatementSync(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSendStatementSync(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSendStatementSync(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSendStatementSync(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sendStatementSync() throws -> SendStatementSyncContext {
		var _localctx: SendStatementSyncContext = SendStatementSyncContext(_ctx, getState())
		try enterRule(_localctx, 870, Cobol85Parser.RULE_sendStatementSync)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5034)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,752, _ctx)) {
		 	case 1:
		 		setState(5032)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5033)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(5037)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FROM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5036)
		 		try sendFromPhrase()

		 	}

		 	setState(5040)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,754,_ctx)) {
		 	case 1:
		 		setState(5039)
		 		try sendWithPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5043)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.REPLACING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5042)
		 		try sendReplacingPhrase()

		 	}

		 	setState(5046)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue || _la == Cobol85Parser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5045)
		 		try sendAdvancingPhrase()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SendStatementAsyncContext: ParserRuleContext {
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func TOP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TOP.rawValue, 0)
			}
			open
			func BOTTOM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BOTTOM.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sendStatementAsync
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSendStatementAsync(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSendStatementAsync(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSendStatementAsync(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSendStatementAsync(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sendStatementAsync() throws -> SendStatementAsyncContext {
		var _localctx: SendStatementAsyncContext = SendStatementAsyncContext(_ctx, getState())
		try enterRule(_localctx, 872, Cobol85Parser.RULE_sendStatementAsync)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5048)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(5049)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.BOTTOM.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.TOP.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5050)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SendFromPhraseContext: ParserRuleContext {
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sendFromPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSendFromPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSendFromPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSendFromPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSendFromPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sendFromPhrase() throws -> SendFromPhraseContext {
		var _localctx: SendFromPhraseContext = SendFromPhraseContext(_ctx, getState())
		try enterRule(_localctx, 874, Cobol85Parser.RULE_sendFromPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5052)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(5053)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SendWithPhraseContext: ParserRuleContext {
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
			open
			func EGI() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EGI.rawValue, 0)
			}
			open
			func EMI() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EMI.rawValue, 0)
			}
			open
			func ESI() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ESI.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sendWithPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSendWithPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSendWithPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSendWithPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSendWithPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sendWithPhrase() throws -> SendWithPhraseContext {
		var _localctx: SendWithPhraseContext = SendWithPhraseContext(_ctx, getState())
		try enterRule(_localctx, 876, Cobol85Parser.RULE_sendWithPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5055)
		 	try match(Cobol85Parser.Tokens.WITH.rawValue)
		 	setState(5060)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .EGI:
		 		setState(5056)
		 		try match(Cobol85Parser.Tokens.EGI.rawValue)

		 		break

		 	case .EMI:
		 		setState(5057)
		 		try match(Cobol85Parser.Tokens.EMI.rawValue)

		 		break

		 	case .ESI:
		 		setState(5058)
		 		try match(Cobol85Parser.Tokens.ESI.rawValue)

		 		break
		 	case .ABORT:fallthrough
		 	case .ADDRESS:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DAY_OF_WEEK:fallthrough
		 	case .DEBUG_CONTENTS:fallthrough
		 	case .DEBUG_ITEM:fallthrough
		 	case .DEBUG_LINE:fallthrough
		 	case .DEBUG_NAME:fallthrough
		 	case .DEBUG_SUB_1:fallthrough
		 	case .DEBUG_SUB_2:fallthrough
		 	case .DEBUG_SUB_3:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LINAGE_COUNTER:fallthrough
		 	case .LINE_COUNTER:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PAGE_COUNTER:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .RETURN_CODE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHIFT_IN:fallthrough
		 	case .SHIFT_OUT:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SORT_CONTROL:fallthrough
		 	case .SORT_CORE_SIZE:fallthrough
		 	case .SORT_FILE_SIZE:fallthrough
		 	case .SORT_MESSAGE:fallthrough
		 	case .SORT_MODE_SIZE:fallthrough
		 	case .SORT_RETURN:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TALLY:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .WHEN_COMPILED:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:fallthrough
		 	case .IDENTIFIER:
		 		setState(5059)
		 		try identifier()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SendReplacingPhraseContext: ParserRuleContext {
			open
			func REPLACING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REPLACING.rawValue, 0)
			}
			open
			func LINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sendReplacingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSendReplacingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSendReplacingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSendReplacingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSendReplacingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sendReplacingPhrase() throws -> SendReplacingPhraseContext {
		var _localctx: SendReplacingPhraseContext = SendReplacingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 878, Cobol85Parser.RULE_sendReplacingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5062)
		 	try match(Cobol85Parser.Tokens.REPLACING.rawValue)
		 	setState(5064)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LINE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5063)
		 		try match(Cobol85Parser.Tokens.LINE.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SendAdvancingPhraseContext: ParserRuleContext {
			open
			func BEFORE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BEFORE.rawValue, 0)
			}
			open
			func AFTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AFTER.rawValue, 0)
			}
			open
			func sendAdvancingPage() -> SendAdvancingPageContext? {
				return getRuleContext(SendAdvancingPageContext.self, 0)
			}
			open
			func sendAdvancingLines() -> SendAdvancingLinesContext? {
				return getRuleContext(SendAdvancingLinesContext.self, 0)
			}
			open
			func sendAdvancingMnemonic() -> SendAdvancingMnemonicContext? {
				return getRuleContext(SendAdvancingMnemonicContext.self, 0)
			}
			open
			func ADVANCING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ADVANCING.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sendAdvancingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSendAdvancingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSendAdvancingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSendAdvancingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSendAdvancingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sendAdvancingPhrase() throws -> SendAdvancingPhraseContext {
		var _localctx: SendAdvancingPhraseContext = SendAdvancingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 880, Cobol85Parser.RULE_sendAdvancingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5066)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue || _la == Cobol85Parser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5068)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ADVANCING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5067)
		 		try match(Cobol85Parser.Tokens.ADVANCING.rawValue)

		 	}

		 	setState(5073)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,760, _ctx)) {
		 	case 1:
		 		setState(5070)
		 		try sendAdvancingPage()

		 		break
		 	case 2:
		 		setState(5071)
		 		try sendAdvancingLines()

		 		break
		 	case 3:
		 		setState(5072)
		 		try sendAdvancingMnemonic()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SendAdvancingPageContext: ParserRuleContext {
			open
			func PAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PAGE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sendAdvancingPage
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSendAdvancingPage(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSendAdvancingPage(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSendAdvancingPage(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSendAdvancingPage(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sendAdvancingPage() throws -> SendAdvancingPageContext {
		var _localctx: SendAdvancingPageContext = SendAdvancingPageContext(_ctx, getState())
		try enterRule(_localctx, 882, Cobol85Parser.RULE_sendAdvancingPage)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5075)
		 	try match(Cobol85Parser.Tokens.PAGE.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SendAdvancingLinesContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func LINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINE.rawValue, 0)
			}
			open
			func LINES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINES.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sendAdvancingLines
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSendAdvancingLines(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSendAdvancingLines(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSendAdvancingLines(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSendAdvancingLines(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sendAdvancingLines() throws -> SendAdvancingLinesContext {
		var _localctx: SendAdvancingLinesContext = SendAdvancingLinesContext(_ctx, getState())
		try enterRule(_localctx, 884, Cobol85Parser.RULE_sendAdvancingLines)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5079)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,761, _ctx)) {
		 	case 1:
		 		setState(5077)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5078)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(5082)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LINE.rawValue || _la == Cobol85Parser.Tokens.LINES.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5081)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.LINE.rawValue || _la == Cobol85Parser.Tokens.LINES.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SendAdvancingMnemonicContext: ParserRuleContext {
			open
			func mnemonicName() -> MnemonicNameContext? {
				return getRuleContext(MnemonicNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sendAdvancingMnemonic
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSendAdvancingMnemonic(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSendAdvancingMnemonic(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSendAdvancingMnemonic(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSendAdvancingMnemonic(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sendAdvancingMnemonic() throws -> SendAdvancingMnemonicContext {
		var _localctx: SendAdvancingMnemonicContext = SendAdvancingMnemonicContext(_ctx, getState())
		try enterRule(_localctx, 886, Cobol85Parser.RULE_sendAdvancingMnemonic)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5084)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetStatementContext: ParserRuleContext {
			open
			func SET() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SET.rawValue, 0)
			}
			open
			func setUpDownByStatement() -> SetUpDownByStatementContext? {
				return getRuleContext(SetUpDownByStatementContext.self, 0)
			}
			open
			func setToStatement() -> [SetToStatementContext] {
				return getRuleContexts(SetToStatementContext.self)
			}
			open
			func setToStatement(_ i: Int) -> SetToStatementContext? {
				return getRuleContext(SetToStatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_setStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSetStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSetStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSetStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSetStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setStatement() throws -> SetStatementContext {
		var _localctx: SetStatementContext = SetStatementContext(_ctx, getState())
		try enterRule(_localctx, 888, Cobol85Parser.RULE_setStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5086)
		 	try match(Cobol85Parser.Tokens.SET.rawValue)
		 	setState(5093)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,764, _ctx)) {
		 	case 1:
		 		setState(5088) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(5087)
		 			try setToStatement()


		 			setState(5090); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 68)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 138)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 202)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 268)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 401)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 466)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 552)
		 		          }()
		 		      return testSet
		 		 }())

		 		break
		 	case 2:
		 		setState(5092)
		 		try setUpDownByStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetToStatementContext: ParserRuleContext {
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func setTo() -> [SetToContext] {
				return getRuleContexts(SetToContext.self)
			}
			open
			func setTo(_ i: Int) -> SetToContext? {
				return getRuleContext(SetToContext.self, i)
			}
			open
			func setToValue() -> [SetToValueContext] {
				return getRuleContexts(SetToValueContext.self)
			}
			open
			func setToValue(_ i: Int) -> SetToValueContext? {
				return getRuleContext(SetToValueContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_setToStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSetToStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSetToStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSetToStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSetToStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setToStatement() throws -> SetToStatementContext {
		var _localctx: SetToStatementContext = SetToStatementContext(_ctx, getState())
		try enterRule(_localctx, 890, Cobol85Parser.RULE_setToStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5096) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5095)
		 		try setTo()


		 		setState(5098); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5100)
		 	try match(Cobol85Parser.Tokens.TO.rawValue)
		 	setState(5102); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(5101)
		 			try setToValue()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5104); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,766,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetUpDownByStatementContext: ParserRuleContext {
			open
			func setByValue() -> SetByValueContext? {
				return getRuleContext(SetByValueContext.self, 0)
			}
			open
			func UP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.UP.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func DOWN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOWN.rawValue, 0)
			}
			open
			func setTo() -> [SetToContext] {
				return getRuleContexts(SetToContext.self)
			}
			open
			func setTo(_ i: Int) -> SetToContext? {
				return getRuleContext(SetToContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_setUpDownByStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSetUpDownByStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSetUpDownByStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSetUpDownByStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSetUpDownByStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setUpDownByStatement() throws -> SetUpDownByStatementContext {
		var _localctx: SetUpDownByStatementContext = SetUpDownByStatementContext(_ctx, getState())
		try enterRule(_localctx, 892, Cobol85Parser.RULE_setUpDownByStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5107) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5106)
		 		try setTo()


		 		setState(5109); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5115)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .UP:
		 		setState(5111)
		 		try match(Cobol85Parser.Tokens.UP.rawValue)
		 		setState(5112)
		 		try match(Cobol85Parser.Tokens.BY.rawValue)

		 		break

		 	case .DOWN:
		 		setState(5113)
		 		try match(Cobol85Parser.Tokens.DOWN.rawValue)
		 		setState(5114)
		 		try match(Cobol85Parser.Tokens.BY.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5117)
		 	try setByValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetToContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_setTo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSetTo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSetTo(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSetTo(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSetTo(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setTo() throws -> SetToContext {
		var _localctx: SetToContext = SetToContext(_ctx, getState())
		try enterRule(_localctx, 894, Cobol85Parser.RULE_setTo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5119)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetToValueContext: ParserRuleContext {
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func OFF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OFF.rawValue, 0)
			}
			open
			func ENTRY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ENTRY.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_setToValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSetToValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSetToValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSetToValue(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSetToValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setToValue() throws -> SetToValueContext {
		var _localctx: SetToValueContext = SetToValueContext(_ctx, getState())
		try enterRule(_localctx, 896, Cobol85Parser.RULE_setToValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5130)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,770, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5121)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5122)
		 		try match(Cobol85Parser.Tokens.OFF.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5123)
		 		try match(Cobol85Parser.Tokens.ENTRY.rawValue)
		 		setState(5126)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,769, _ctx)) {
		 		case 1:
		 			setState(5124)
		 			try identifier()

		 			break
		 		case 2:
		 			setState(5125)
		 			try literal()

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5128)
		 		try identifier()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5129)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetByValueContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_setByValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSetByValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSetByValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSetByValue(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSetByValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setByValue() throws -> SetByValueContext {
		var _localctx: SetByValueContext = SetByValueContext(_ctx, getState())
		try enterRule(_localctx, 898, Cobol85Parser.RULE_setByValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5134)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,771, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5132)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5133)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortStatementContext: ParserRuleContext {
			open
			func SORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SORT.rawValue, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func sortOnKeyClause() -> [SortOnKeyClauseContext] {
				return getRuleContexts(SortOnKeyClauseContext.self)
			}
			open
			func sortOnKeyClause(_ i: Int) -> SortOnKeyClauseContext? {
				return getRuleContext(SortOnKeyClauseContext.self, i)
			}
			open
			func sortDuplicatesPhrase() -> SortDuplicatesPhraseContext? {
				return getRuleContext(SortDuplicatesPhraseContext.self, 0)
			}
			open
			func sortCollatingSequencePhrase() -> SortCollatingSequencePhraseContext? {
				return getRuleContext(SortCollatingSequencePhraseContext.self, 0)
			}
			open
			func sortInputProcedurePhrase() -> SortInputProcedurePhraseContext? {
				return getRuleContext(SortInputProcedurePhraseContext.self, 0)
			}
			open
			func sortUsing() -> [SortUsingContext] {
				return getRuleContexts(SortUsingContext.self)
			}
			open
			func sortUsing(_ i: Int) -> SortUsingContext? {
				return getRuleContext(SortUsingContext.self, i)
			}
			open
			func sortOutputProcedurePhrase() -> SortOutputProcedurePhraseContext? {
				return getRuleContext(SortOutputProcedurePhraseContext.self, 0)
			}
			open
			func sortGivingPhrase() -> [SortGivingPhraseContext] {
				return getRuleContexts(SortGivingPhraseContext.self)
			}
			open
			func sortGivingPhrase(_ i: Int) -> SortGivingPhraseContext? {
				return getRuleContext(SortGivingPhraseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortStatement() throws -> SortStatementContext {
		var _localctx: SortStatementContext = SortStatementContext(_ctx, getState())
		try enterRule(_localctx, 900, Cobol85Parser.RULE_sortStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5136)
		 	try match(Cobol85Parser.Tokens.SORT.rawValue)
		 	setState(5137)
		 	try fileName()
		 	setState(5139); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(5138)
		 			try sortOnKeyClause()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5141); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,772,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(5144)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,773,_ctx)) {
		 	case 1:
		 		setState(5143)
		 		try sortDuplicatesPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5147)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.COLLATING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.SEQUENCE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5146)
		 		try sortCollatingSequencePhrase()

		 	}

		 	setState(5150)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.INPUT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5149)
		 		try sortInputProcedurePhrase()

		 	}

		 	setState(5155)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.USING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5152)
		 		try sortUsing()


		 		setState(5157)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5159)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.OUTPUT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5158)
		 		try sortOutputProcedurePhrase()

		 	}

		 	setState(5164)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.GIVING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5161)
		 		try sortGivingPhrase()


		 		setState(5166)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortOnKeyClauseContext: ParserRuleContext {
			open
			func ASCENDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASCENDING.rawValue, 0)
			}
			open
			func DESCENDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DESCENDING.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func qualifiedDataName() -> [QualifiedDataNameContext] {
				return getRuleContexts(QualifiedDataNameContext.self)
			}
			open
			func qualifiedDataName(_ i: Int) -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortOnKeyClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortOnKeyClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortOnKeyClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortOnKeyClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortOnKeyClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortOnKeyClause() throws -> SortOnKeyClauseContext {
		var _localctx: SortOnKeyClauseContext = SortOnKeyClauseContext(_ctx, getState())
		try enterRule(_localctx, 902, Cobol85Parser.RULE_sortOnKeyClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5168)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5167)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 	}

		 	setState(5170)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ASCENDING.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.DESCENDING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5172)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.KEY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5171)
		 		try match(Cobol85Parser.Tokens.KEY.rawValue)

		 	}

		 	setState(5175) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5174)
		 		try qualifiedDataName()


		 		setState(5177); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortDuplicatesPhraseContext: ParserRuleContext {
			open
			func DUPLICATES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DUPLICATES.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
			open
			func ORDER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ORDER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortDuplicatesPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortDuplicatesPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortDuplicatesPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortDuplicatesPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortDuplicatesPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortDuplicatesPhrase() throws -> SortDuplicatesPhraseContext {
		var _localctx: SortDuplicatesPhraseContext = SortDuplicatesPhraseContext(_ctx, getState())
		try enterRule(_localctx, 904, Cobol85Parser.RULE_sortDuplicatesPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5180)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5179)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(5182)
		 	try match(Cobol85Parser.Tokens.DUPLICATES.rawValue)
		 	setState(5184)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5183)
		 		try match(Cobol85Parser.Tokens.IN.rawValue)

		 	}

		 	setState(5187)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ORDER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5186)
		 		try match(Cobol85Parser.Tokens.ORDER.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortCollatingSequencePhraseContext: ParserRuleContext {
			open
			func SEQUENCE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SEQUENCE.rawValue, 0)
			}
			open
			func COLLATING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COLLATING.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func alphabetName() -> [AlphabetNameContext] {
				return getRuleContexts(AlphabetNameContext.self)
			}
			open
			func alphabetName(_ i: Int) -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, i)
			}
			open
			func sortCollatingAlphanumeric() -> SortCollatingAlphanumericContext? {
				return getRuleContext(SortCollatingAlphanumericContext.self, 0)
			}
			open
			func sortCollatingNational() -> SortCollatingNationalContext? {
				return getRuleContext(SortCollatingNationalContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortCollatingSequencePhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortCollatingSequencePhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortCollatingSequencePhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortCollatingSequencePhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortCollatingSequencePhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortCollatingSequencePhrase() throws -> SortCollatingSequencePhraseContext {
		var _localctx: SortCollatingSequencePhraseContext = SortCollatingSequencePhraseContext(_ctx, getState())
		try enterRule(_localctx, 906, Cobol85Parser.RULE_sortCollatingSequencePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5190)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COLLATING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5189)
		 		try match(Cobol85Parser.Tokens.COLLATING.rawValue)

		 	}

		 	setState(5192)
		 	try match(Cobol85Parser.Tokens.SEQUENCE.rawValue)
		 	setState(5194)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5193)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(5197); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(5196)
		 			try alphabetName()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5199); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,787,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(5202)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,788,_ctx)) {
		 	case 1:
		 		setState(5201)
		 		try sortCollatingAlphanumeric()

		 		break
		 	default: break
		 	}
		 	setState(5205)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.NATIONAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5204)
		 		try sortCollatingNational()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortCollatingAlphanumericContext: ParserRuleContext {
			open
			func ALPHANUMERIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHANUMERIC.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func alphabetName() -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortCollatingAlphanumeric
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortCollatingAlphanumeric(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortCollatingAlphanumeric(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortCollatingAlphanumeric(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortCollatingAlphanumeric(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortCollatingAlphanumeric() throws -> SortCollatingAlphanumericContext {
		var _localctx: SortCollatingAlphanumericContext = SortCollatingAlphanumericContext(_ctx, getState())
		try enterRule(_localctx, 908, Cobol85Parser.RULE_sortCollatingAlphanumeric)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5208)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5207)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(5210)
		 	try match(Cobol85Parser.Tokens.ALPHANUMERIC.rawValue)
		 	setState(5211)
		 	try match(Cobol85Parser.Tokens.IS.rawValue)
		 	setState(5212)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortCollatingNationalContext: ParserRuleContext {
			open
			func NATIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIONAL.rawValue, 0)
			}
			open
			func alphabetName() -> AlphabetNameContext? {
				return getRuleContext(AlphabetNameContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortCollatingNational
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortCollatingNational(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortCollatingNational(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortCollatingNational(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortCollatingNational(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortCollatingNational() throws -> SortCollatingNationalContext {
		var _localctx: SortCollatingNationalContext = SortCollatingNationalContext(_ctx, getState())
		try enterRule(_localctx, 910, Cobol85Parser.RULE_sortCollatingNational)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5215)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5214)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(5217)
		 	try match(Cobol85Parser.Tokens.NATIONAL.rawValue)
		 	setState(5219)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5218)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(5221)
		 	try alphabetName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortInputProcedurePhraseContext: ParserRuleContext {
			open
			func INPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INPUT.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROCEDURE.rawValue, 0)
			}
			open
			func procedureName() -> ProcedureNameContext? {
				return getRuleContext(ProcedureNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func sortInputThrough() -> SortInputThroughContext? {
				return getRuleContext(SortInputThroughContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortInputProcedurePhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortInputProcedurePhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortInputProcedurePhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortInputProcedurePhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortInputProcedurePhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortInputProcedurePhrase() throws -> SortInputProcedurePhraseContext {
		var _localctx: SortInputProcedurePhraseContext = SortInputProcedurePhraseContext(_ctx, getState())
		try enterRule(_localctx, 912, Cobol85Parser.RULE_sortInputProcedurePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5223)
		 	try match(Cobol85Parser.Tokens.INPUT.rawValue)
		 	setState(5224)
		 	try match(Cobol85Parser.Tokens.PROCEDURE.rawValue)
		 	setState(5226)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5225)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(5228)
		 	try procedureName()
		 	setState(5230)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5229)
		 		try sortInputThrough()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortInputThroughContext: ParserRuleContext {
			open
			func procedureName() -> ProcedureNameContext? {
				return getRuleContext(ProcedureNameContext.self, 0)
			}
			open
			func THROUGH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THROUGH.rawValue, 0)
			}
			open
			func THRU() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THRU.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortInputThrough
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortInputThrough(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortInputThrough(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortInputThrough(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortInputThrough(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortInputThrough() throws -> SortInputThroughContext {
		var _localctx: SortInputThroughContext = SortInputThroughContext(_ctx, getState())
		try enterRule(_localctx, 914, Cobol85Parser.RULE_sortInputThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5232)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5233)
		 	try procedureName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortUsingContext: ParserRuleContext {
			open
			func USING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USING.rawValue, 0)
			}
			open
			func fileName() -> [FileNameContext] {
				return getRuleContexts(FileNameContext.self)
			}
			open
			func fileName(_ i: Int) -> FileNameContext? {
				return getRuleContext(FileNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortUsing
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortUsing(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortUsing(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortUsing(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortUsing(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortUsing() throws -> SortUsingContext {
		var _localctx: SortUsingContext = SortUsingContext(_ctx, getState())
		try enterRule(_localctx, 916, Cobol85Parser.RULE_sortUsing)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5235)
		 	try match(Cobol85Parser.Tokens.USING.rawValue)
		 	setState(5237) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5236)
		 		try fileName()


		 		setState(5239); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortOutputProcedurePhraseContext: ParserRuleContext {
			open
			func OUTPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OUTPUT.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROCEDURE.rawValue, 0)
			}
			open
			func procedureName() -> ProcedureNameContext? {
				return getRuleContext(ProcedureNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func sortOutputThrough() -> SortOutputThroughContext? {
				return getRuleContext(SortOutputThroughContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortOutputProcedurePhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortOutputProcedurePhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortOutputProcedurePhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortOutputProcedurePhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortOutputProcedurePhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortOutputProcedurePhrase() throws -> SortOutputProcedurePhraseContext {
		var _localctx: SortOutputProcedurePhraseContext = SortOutputProcedurePhraseContext(_ctx, getState())
		try enterRule(_localctx, 918, Cobol85Parser.RULE_sortOutputProcedurePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5241)
		 	try match(Cobol85Parser.Tokens.OUTPUT.rawValue)
		 	setState(5242)
		 	try match(Cobol85Parser.Tokens.PROCEDURE.rawValue)
		 	setState(5244)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5243)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(5246)
		 	try procedureName()
		 	setState(5248)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5247)
		 		try sortOutputThrough()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortOutputThroughContext: ParserRuleContext {
			open
			func procedureName() -> ProcedureNameContext? {
				return getRuleContext(ProcedureNameContext.self, 0)
			}
			open
			func THROUGH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THROUGH.rawValue, 0)
			}
			open
			func THRU() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THRU.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortOutputThrough
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortOutputThrough(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortOutputThrough(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortOutputThrough(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortOutputThrough(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortOutputThrough() throws -> SortOutputThroughContext {
		var _localctx: SortOutputThroughContext = SortOutputThroughContext(_ctx, getState())
		try enterRule(_localctx, 920, Cobol85Parser.RULE_sortOutputThrough)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5250)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.THROUGH.rawValue || _la == Cobol85Parser.Tokens.THRU.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5251)
		 	try procedureName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortGivingPhraseContext: ParserRuleContext {
			open
			func GIVING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GIVING.rawValue, 0)
			}
			open
			func sortGiving() -> [SortGivingContext] {
				return getRuleContexts(SortGivingContext.self)
			}
			open
			func sortGiving(_ i: Int) -> SortGivingContext? {
				return getRuleContext(SortGivingContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortGivingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortGivingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortGivingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortGivingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortGivingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortGivingPhrase() throws -> SortGivingPhraseContext {
		var _localctx: SortGivingPhraseContext = SortGivingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 922, Cobol85Parser.RULE_sortGivingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5253)
		 	try match(Cobol85Parser.Tokens.GIVING.rawValue)
		 	setState(5255) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5254)
		 		try sortGiving()


		 		setState(5257); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SortGivingContext: ParserRuleContext {
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func LOCK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOCK.rawValue, 0)
			}
			open
			func SAVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SAVE.rawValue, 0)
			}
			open
			func NO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO.rawValue, 0)
			}
			open
			func REWIND() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REWIND.rawValue, 0)
			}
			open
			func CRUNCH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CRUNCH.rawValue, 0)
			}
			open
			func RELEASE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RELEASE.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
			open
			func REMOVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REMOVE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sortGiving
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSortGiving(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSortGiving(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSortGiving(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSortGiving(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sortGiving() throws -> SortGivingContext {
		var _localctx: SortGivingContext = SortGivingContext(_ctx, getState())
		try enterRule(_localctx, 924, Cobol85Parser.RULE_sortGiving)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5259)
		 	try fileName()
		 	setState(5269)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,799,_ctx)) {
		 	case 1:
		 		setState(5260)
		 		try match(Cobol85Parser.Tokens.LOCK.rawValue)

		 		break
		 	case 2:
		 		setState(5261)
		 		try match(Cobol85Parser.Tokens.SAVE.rawValue)

		 		break
		 	case 3:
		 		setState(5262)
		 		try match(Cobol85Parser.Tokens.NO.rawValue)
		 		setState(5263)
		 		try match(Cobol85Parser.Tokens.REWIND.rawValue)

		 		break
		 	case 4:
		 		setState(5264)
		 		try match(Cobol85Parser.Tokens.CRUNCH.rawValue)

		 		break
		 	case 5:
		 		setState(5265)
		 		try match(Cobol85Parser.Tokens.RELEASE.rawValue)

		 		break
		 	case 6:
		 		setState(5266)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)
		 		setState(5267)
		 		try match(Cobol85Parser.Tokens.REMOVE.rawValue)
		 		setState(5268)
		 		try match(Cobol85Parser.Tokens.CRUNCH.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StartStatementContext: ParserRuleContext {
			open
			func START() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.START.rawValue, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func startKey() -> StartKeyContext? {
				return getRuleContext(StartKeyContext.self, 0)
			}
			open
			func invalidKeyPhrase() -> InvalidKeyPhraseContext? {
				return getRuleContext(InvalidKeyPhraseContext.self, 0)
			}
			open
			func notInvalidKeyPhrase() -> NotInvalidKeyPhraseContext? {
				return getRuleContext(NotInvalidKeyPhraseContext.self, 0)
			}
			open
			func END_START() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_START.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_startStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStartStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStartStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStartStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStartStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func startStatement() throws -> StartStatementContext {
		var _localctx: StartStatementContext = StartStatementContext(_ctx, getState())
		try enterRule(_localctx, 926, Cobol85Parser.RULE_startStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5271)
		 	try match(Cobol85Parser.Tokens.START.rawValue)
		 	setState(5272)
		 	try fileName()
		 	setState(5274)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.KEY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5273)
		 		try startKey()

		 	}

		 	setState(5277)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,801,_ctx)) {
		 	case 1:
		 		setState(5276)
		 		try invalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5280)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,802,_ctx)) {
		 	case 1:
		 		setState(5279)
		 		try notInvalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5283)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,803,_ctx)) {
		 	case 1:
		 		setState(5282)
		 		try match(Cobol85Parser.Tokens.END_START.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StartKeyContext: ParserRuleContext {
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func EQUAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EQUAL.rawValue, 0)
			}
			open
			func EQUALCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EQUALCHAR.rawValue, 0)
			}
			open
			func GREATER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GREATER.rawValue, 0)
			}
			open
			func MORETHANCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MORETHANCHAR.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
			open
			func LESS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LESS.rawValue, 0)
			}
			open
			func LESSTHANCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LESSTHANCHAR.rawValue, 0)
			}
			open
			func OR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OR.rawValue, 0)
			}
			open
			func MORETHANOREQUAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MORETHANOREQUAL.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
			open
			func THAN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THAN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_startKey
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStartKey(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStartKey(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStartKey(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStartKey(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func startKey() throws -> StartKeyContext {
		var _localctx: StartKeyContext = StartKeyContext(_ctx, getState())
		try enterRule(_localctx, 928, Cobol85Parser.RULE_startKey)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5285)
		 	try match(Cobol85Parser.Tokens.KEY.rawValue)
		 	setState(5287)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5286)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(5316)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,810, _ctx)) {
		 	case 1:
		 		setState(5289)
		 		try match(Cobol85Parser.Tokens.EQUAL.rawValue)
		 		setState(5291)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5290)
		 			try match(Cobol85Parser.Tokens.TO.rawValue)

		 		}


		 		break
		 	case 2:
		 		setState(5293)
		 		try match(Cobol85Parser.Tokens.EQUALCHAR.rawValue)

		 		break
		 	case 3:
		 		setState(5294)
		 		try match(Cobol85Parser.Tokens.GREATER.rawValue)
		 		setState(5296)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.THAN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5295)
		 			try match(Cobol85Parser.Tokens.THAN.rawValue)

		 		}


		 		break
		 	case 4:
		 		setState(5298)
		 		try match(Cobol85Parser.Tokens.MORETHANCHAR.rawValue)

		 		break
		 	case 5:
		 		setState(5299)
		 		try match(Cobol85Parser.Tokens.NOT.rawValue)
		 		setState(5300)
		 		try match(Cobol85Parser.Tokens.LESS.rawValue)
		 		setState(5302)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.THAN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5301)
		 			try match(Cobol85Parser.Tokens.THAN.rawValue)

		 		}


		 		break
		 	case 6:
		 		setState(5304)
		 		try match(Cobol85Parser.Tokens.NOT.rawValue)
		 		setState(5305)
		 		try match(Cobol85Parser.Tokens.LESSTHANCHAR.rawValue)

		 		break
		 	case 7:
		 		setState(5306)
		 		try match(Cobol85Parser.Tokens.GREATER.rawValue)
		 		setState(5308)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.THAN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5307)
		 			try match(Cobol85Parser.Tokens.THAN.rawValue)

		 		}

		 		setState(5310)
		 		try match(Cobol85Parser.Tokens.OR.rawValue)
		 		setState(5311)
		 		try match(Cobol85Parser.Tokens.EQUAL.rawValue)
		 		setState(5313)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5312)
		 			try match(Cobol85Parser.Tokens.TO.rawValue)

		 		}


		 		break
		 	case 8:
		 		setState(5315)
		 		try match(Cobol85Parser.Tokens.MORETHANOREQUAL.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(5318)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StopStatementContext: ParserRuleContext {
			open
			func STOP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STOP.rawValue, 0)
			}
			open
			func RUN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RUN.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_stopStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStopStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStopStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStopStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStopStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stopStatement() throws -> StopStatementContext {
		var _localctx: StopStatementContext = StopStatementContext(_ctx, getState())
		try enterRule(_localctx, 930, Cobol85Parser.RULE_stopStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5320)
		 	try match(Cobol85Parser.Tokens.STOP.rawValue)
		 	setState(5323)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .RUN:
		 		setState(5321)
		 		try match(Cobol85Parser.Tokens.RUN.rawValue)

		 		break
		 	case .ALL:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .FALSE:fallthrough
		 	case .HIGH_VALUE:fallthrough
		 	case .HIGH_VALUES:fallthrough
		 	case .LOW_VALUE:fallthrough
		 	case .LOW_VALUES:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .QUOTE:fallthrough
		 	case .QUOTES:fallthrough
		 	case .SPACE:fallthrough
		 	case .SPACES:fallthrough
		 	case .TRUE:fallthrough
		 	case .ZERO:fallthrough
		 	case .ZEROS:fallthrough
		 	case .ZEROES:fallthrough
		 	case .NONNUMERICLITERAL:fallthrough
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:fallthrough
		 	case .NUMERICLITERAL:
		 		setState(5322)
		 		try literal()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringStatementContext: ParserRuleContext {
			open
			func STRING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STRING.rawValue, 0)
			}
			open
			func stringIntoPhrase() -> StringIntoPhraseContext? {
				return getRuleContext(StringIntoPhraseContext.self, 0)
			}
			open
			func stringSendingPhrase() -> [StringSendingPhraseContext] {
				return getRuleContexts(StringSendingPhraseContext.self)
			}
			open
			func stringSendingPhrase(_ i: Int) -> StringSendingPhraseContext? {
				return getRuleContext(StringSendingPhraseContext.self, i)
			}
			open
			func stringWithPointerPhrase() -> StringWithPointerPhraseContext? {
				return getRuleContext(StringWithPointerPhraseContext.self, 0)
			}
			open
			func onOverflowPhrase() -> OnOverflowPhraseContext? {
				return getRuleContext(OnOverflowPhraseContext.self, 0)
			}
			open
			func notOnOverflowPhrase() -> NotOnOverflowPhraseContext? {
				return getRuleContext(NotOnOverflowPhraseContext.self, 0)
			}
			open
			func END_STRING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_STRING.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_stringStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStringStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStringStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStringStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStringStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringStatement() throws -> StringStatementContext {
		var _localctx: StringStatementContext = StringStatementContext(_ctx, getState())
		try enterRule(_localctx, 932, Cobol85Parser.RULE_stringStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5325)
		 	try match(Cobol85Parser.Tokens.STRING.rawValue)
		 	setState(5327) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5326)
		 		try stringSendingPhrase()


		 		setState(5329); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 551)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5331)
		 	try stringIntoPhrase()
		 	setState(5333)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,813,_ctx)) {
		 	case 1:
		 		setState(5332)
		 		try stringWithPointerPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5336)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,814,_ctx)) {
		 	case 1:
		 		setState(5335)
		 		try onOverflowPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5339)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,815,_ctx)) {
		 	case 1:
		 		setState(5338)
		 		try notOnOverflowPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5342)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,816,_ctx)) {
		 	case 1:
		 		setState(5341)
		 		try match(Cobol85Parser.Tokens.END_STRING.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringSendingPhraseContext: ParserRuleContext {
			open
			func stringDelimitedByPhrase() -> StringDelimitedByPhraseContext? {
				return getRuleContext(StringDelimitedByPhraseContext.self, 0)
			}
			open
			func stringForPhrase() -> StringForPhraseContext? {
				return getRuleContext(StringForPhraseContext.self, 0)
			}
			open
			func stringSending() -> [StringSendingContext] {
				return getRuleContexts(StringSendingContext.self)
			}
			open
			func stringSending(_ i: Int) -> StringSendingContext? {
				return getRuleContext(StringSendingContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_stringSendingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStringSendingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStringSendingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStringSendingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStringSendingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringSendingPhrase() throws -> StringSendingPhraseContext {
		var _localctx: StringSendingPhraseContext = StringSendingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 934, Cobol85Parser.RULE_stringSendingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5345) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5344)
		 		try stringSending()


		 		setState(5347); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 551)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5351)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DELIMITED:
		 		setState(5349)
		 		try stringDelimitedByPhrase()

		 		break

		 	case .FOR:
		 		setState(5350)
		 		try stringForPhrase()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringSendingContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_stringSending
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStringSending(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStringSending(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStringSending(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStringSending(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringSending() throws -> StringSendingContext {
		var _localctx: StringSendingContext = StringSendingContext(_ctx, getState())
		try enterRule(_localctx, 936, Cobol85Parser.RULE_stringSending)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5355)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,819, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5353)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5354)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringDelimitedByPhraseContext: ParserRuleContext {
			open
			func DELIMITED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DELIMITED.rawValue, 0)
			}
			open
			func SIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIZE.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_stringDelimitedByPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStringDelimitedByPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStringDelimitedByPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStringDelimitedByPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStringDelimitedByPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringDelimitedByPhrase() throws -> StringDelimitedByPhraseContext {
		var _localctx: StringDelimitedByPhraseContext = StringDelimitedByPhraseContext(_ctx, getState())
		try enterRule(_localctx, 938, Cobol85Parser.RULE_stringDelimitedByPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5357)
		 	try match(Cobol85Parser.Tokens.DELIMITED.rawValue)
		 	setState(5359)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.BY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5358)
		 		try match(Cobol85Parser.Tokens.BY.rawValue)

		 	}

		 	setState(5364)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,821, _ctx)) {
		 	case 1:
		 		setState(5361)
		 		try match(Cobol85Parser.Tokens.SIZE.rawValue)

		 		break
		 	case 2:
		 		setState(5362)
		 		try identifier()

		 		break
		 	case 3:
		 		setState(5363)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringForPhraseContext: ParserRuleContext {
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_stringForPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStringForPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStringForPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStringForPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStringForPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringForPhrase() throws -> StringForPhraseContext {
		var _localctx: StringForPhraseContext = StringForPhraseContext(_ctx, getState())
		try enterRule(_localctx, 940, Cobol85Parser.RULE_stringForPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5366)
		 	try match(Cobol85Parser.Tokens.FOR.rawValue)
		 	setState(5369)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,822, _ctx)) {
		 	case 1:
		 		setState(5367)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5368)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringIntoPhraseContext: ParserRuleContext {
			open
			func INTO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTO.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_stringIntoPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStringIntoPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStringIntoPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStringIntoPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStringIntoPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringIntoPhrase() throws -> StringIntoPhraseContext {
		var _localctx: StringIntoPhraseContext = StringIntoPhraseContext(_ctx, getState())
		try enterRule(_localctx, 942, Cobol85Parser.RULE_stringIntoPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5371)
		 	try match(Cobol85Parser.Tokens.INTO.rawValue)
		 	setState(5372)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringWithPointerPhraseContext: ParserRuleContext {
			open
			func POINTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.POINTER.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_stringWithPointerPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterStringWithPointerPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitStringWithPointerPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitStringWithPointerPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitStringWithPointerPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringWithPointerPhrase() throws -> StringWithPointerPhraseContext {
		var _localctx: StringWithPointerPhraseContext = StringWithPointerPhraseContext(_ctx, getState())
		try enterRule(_localctx, 944, Cobol85Parser.RULE_stringWithPointerPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5375)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5374)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(5377)
		 	try match(Cobol85Parser.Tokens.POINTER.rawValue)
		 	setState(5378)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubtractStatementContext: ParserRuleContext {
			open
			func SUBTRACT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SUBTRACT.rawValue, 0)
			}
			open
			func subtractFromStatement() -> SubtractFromStatementContext? {
				return getRuleContext(SubtractFromStatementContext.self, 0)
			}
			open
			func subtractFromGivingStatement() -> SubtractFromGivingStatementContext? {
				return getRuleContext(SubtractFromGivingStatementContext.self, 0)
			}
			open
			func subtractCorrespondingStatement() -> SubtractCorrespondingStatementContext? {
				return getRuleContext(SubtractCorrespondingStatementContext.self, 0)
			}
			open
			func onSizeErrorPhrase() -> OnSizeErrorPhraseContext? {
				return getRuleContext(OnSizeErrorPhraseContext.self, 0)
			}
			open
			func notOnSizeErrorPhrase() -> NotOnSizeErrorPhraseContext? {
				return getRuleContext(NotOnSizeErrorPhraseContext.self, 0)
			}
			open
			func END_SUBTRACT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_SUBTRACT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_subtractStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSubtractStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSubtractStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSubtractStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSubtractStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subtractStatement() throws -> SubtractStatementContext {
		var _localctx: SubtractStatementContext = SubtractStatementContext(_ctx, getState())
		try enterRule(_localctx, 946, Cobol85Parser.RULE_subtractStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5380)
		 	try match(Cobol85Parser.Tokens.SUBTRACT.rawValue)
		 	setState(5384)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,824, _ctx)) {
		 	case 1:
		 		setState(5381)
		 		try subtractFromStatement()

		 		break
		 	case 2:
		 		setState(5382)
		 		try subtractFromGivingStatement()

		 		break
		 	case 3:
		 		setState(5383)
		 		try subtractCorrespondingStatement()

		 		break
		 	default: break
		 	}
		 	setState(5387)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,825,_ctx)) {
		 	case 1:
		 		setState(5386)
		 		try onSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5390)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,826,_ctx)) {
		 	case 1:
		 		setState(5389)
		 		try notOnSizeErrorPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5393)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,827,_ctx)) {
		 	case 1:
		 		setState(5392)
		 		try match(Cobol85Parser.Tokens.END_SUBTRACT.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubtractFromStatementContext: ParserRuleContext {
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func subtractSubtrahend() -> [SubtractSubtrahendContext] {
				return getRuleContexts(SubtractSubtrahendContext.self)
			}
			open
			func subtractSubtrahend(_ i: Int) -> SubtractSubtrahendContext? {
				return getRuleContext(SubtractSubtrahendContext.self, i)
			}
			open
			func subtractMinuend() -> [SubtractMinuendContext] {
				return getRuleContexts(SubtractMinuendContext.self)
			}
			open
			func subtractMinuend(_ i: Int) -> SubtractMinuendContext? {
				return getRuleContext(SubtractMinuendContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_subtractFromStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSubtractFromStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSubtractFromStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSubtractFromStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSubtractFromStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subtractFromStatement() throws -> SubtractFromStatementContext {
		var _localctx: SubtractFromStatementContext = SubtractFromStatementContext(_ctx, getState())
		try enterRule(_localctx, 948, Cobol85Parser.RULE_subtractFromStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5396) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5395)
		 		try subtractSubtrahend()


		 		setState(5398); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 551)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5400)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(5402) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5401)
		 		try subtractMinuend()


		 		setState(5404); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubtractFromGivingStatementContext: ParserRuleContext {
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func subtractMinuendGiving() -> SubtractMinuendGivingContext? {
				return getRuleContext(SubtractMinuendGivingContext.self, 0)
			}
			open
			func GIVING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GIVING.rawValue, 0)
			}
			open
			func subtractSubtrahend() -> [SubtractSubtrahendContext] {
				return getRuleContexts(SubtractSubtrahendContext.self)
			}
			open
			func subtractSubtrahend(_ i: Int) -> SubtractSubtrahendContext? {
				return getRuleContext(SubtractSubtrahendContext.self, i)
			}
			open
			func subtractGiving() -> [SubtractGivingContext] {
				return getRuleContexts(SubtractGivingContext.self)
			}
			open
			func subtractGiving(_ i: Int) -> SubtractGivingContext? {
				return getRuleContext(SubtractGivingContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_subtractFromGivingStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSubtractFromGivingStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSubtractFromGivingStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSubtractFromGivingStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSubtractFromGivingStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subtractFromGivingStatement() throws -> SubtractFromGivingStatementContext {
		var _localctx: SubtractFromGivingStatementContext = SubtractFromGivingStatementContext(_ctx, getState())
		try enterRule(_localctx, 950, Cobol85Parser.RULE_subtractFromGivingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5407) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5406)
		 		try subtractSubtrahend()


		 		setState(5409); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 551)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(5411)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(5412)
		 	try subtractMinuendGiving()
		 	setState(5413)
		 	try match(Cobol85Parser.Tokens.GIVING.rawValue)
		 	setState(5415) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5414)
		 		try subtractGiving()


		 		setState(5417); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubtractCorrespondingStatementContext: ParserRuleContext {
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func subtractMinuendCorresponding() -> SubtractMinuendCorrespondingContext? {
				return getRuleContext(SubtractMinuendCorrespondingContext.self, 0)
			}
			open
			func CORRESPONDING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CORRESPONDING.rawValue, 0)
			}
			open
			func CORR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CORR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_subtractCorrespondingStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSubtractCorrespondingStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSubtractCorrespondingStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSubtractCorrespondingStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSubtractCorrespondingStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subtractCorrespondingStatement() throws -> SubtractCorrespondingStatementContext {
		var _localctx: SubtractCorrespondingStatementContext = SubtractCorrespondingStatementContext(_ctx, getState())
		try enterRule(_localctx, 952, Cobol85Parser.RULE_subtractCorrespondingStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5419)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.CORR.rawValue || _la == Cobol85Parser.Tokens.CORRESPONDING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5420)
		 	try qualifiedDataName()
		 	setState(5421)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(5422)
		 	try subtractMinuendCorresponding()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubtractSubtrahendContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_subtractSubtrahend
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSubtractSubtrahend(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSubtractSubtrahend(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSubtractSubtrahend(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSubtractSubtrahend(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subtractSubtrahend() throws -> SubtractSubtrahendContext {
		var _localctx: SubtractSubtrahendContext = SubtractSubtrahendContext(_ctx, getState())
		try enterRule(_localctx, 954, Cobol85Parser.RULE_subtractSubtrahend)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5426)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,832, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5424)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5425)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubtractMinuendContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func ROUNDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ROUNDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_subtractMinuend
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSubtractMinuend(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSubtractMinuend(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSubtractMinuend(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSubtractMinuend(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subtractMinuend() throws -> SubtractMinuendContext {
		var _localctx: SubtractMinuendContext = SubtractMinuendContext(_ctx, getState())
		try enterRule(_localctx, 956, Cobol85Parser.RULE_subtractMinuend)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5428)
		 	try identifier()
		 	setState(5430)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ROUNDED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5429)
		 		try match(Cobol85Parser.Tokens.ROUNDED.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubtractMinuendGivingContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_subtractMinuendGiving
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSubtractMinuendGiving(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSubtractMinuendGiving(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSubtractMinuendGiving(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSubtractMinuendGiving(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subtractMinuendGiving() throws -> SubtractMinuendGivingContext {
		var _localctx: SubtractMinuendGivingContext = SubtractMinuendGivingContext(_ctx, getState())
		try enterRule(_localctx, 958, Cobol85Parser.RULE_subtractMinuendGiving)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5434)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,834, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5432)
		 		try identifier()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5433)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubtractGivingContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func ROUNDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ROUNDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_subtractGiving
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSubtractGiving(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSubtractGiving(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSubtractGiving(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSubtractGiving(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subtractGiving() throws -> SubtractGivingContext {
		var _localctx: SubtractGivingContext = SubtractGivingContext(_ctx, getState())
		try enterRule(_localctx, 960, Cobol85Parser.RULE_subtractGiving)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5436)
		 	try identifier()
		 	setState(5438)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ROUNDED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5437)
		 		try match(Cobol85Parser.Tokens.ROUNDED.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubtractMinuendCorrespondingContext: ParserRuleContext {
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func ROUNDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ROUNDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_subtractMinuendCorresponding
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSubtractMinuendCorresponding(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSubtractMinuendCorresponding(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSubtractMinuendCorresponding(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSubtractMinuendCorresponding(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subtractMinuendCorresponding() throws -> SubtractMinuendCorrespondingContext {
		var _localctx: SubtractMinuendCorrespondingContext = SubtractMinuendCorrespondingContext(_ctx, getState())
		try enterRule(_localctx, 962, Cobol85Parser.RULE_subtractMinuendCorresponding)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5440)
		 	try qualifiedDataName()
		 	setState(5442)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ROUNDED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5441)
		 		try match(Cobol85Parser.Tokens.ROUNDED.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TerminateStatementContext: ParserRuleContext {
			open
			func TERMINATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TERMINATE.rawValue, 0)
			}
			open
			func reportName() -> ReportNameContext? {
				return getRuleContext(ReportNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_terminateStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterTerminateStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitTerminateStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitTerminateStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitTerminateStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func terminateStatement() throws -> TerminateStatementContext {
		var _localctx: TerminateStatementContext = TerminateStatementContext(_ctx, getState())
		try enterRule(_localctx, 964, Cobol85Parser.RULE_terminateStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5444)
		 	try match(Cobol85Parser.Tokens.TERMINATE.rawValue)
		 	setState(5445)
		 	try reportName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnstringStatementContext: ParserRuleContext {
			open
			func UNSTRING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.UNSTRING.rawValue, 0)
			}
			open
			func unstringSendingPhrase() -> UnstringSendingPhraseContext? {
				return getRuleContext(UnstringSendingPhraseContext.self, 0)
			}
			open
			func unstringIntoPhrase() -> UnstringIntoPhraseContext? {
				return getRuleContext(UnstringIntoPhraseContext.self, 0)
			}
			open
			func unstringWithPointerPhrase() -> UnstringWithPointerPhraseContext? {
				return getRuleContext(UnstringWithPointerPhraseContext.self, 0)
			}
			open
			func unstringTallyingPhrase() -> UnstringTallyingPhraseContext? {
				return getRuleContext(UnstringTallyingPhraseContext.self, 0)
			}
			open
			func onOverflowPhrase() -> OnOverflowPhraseContext? {
				return getRuleContext(OnOverflowPhraseContext.self, 0)
			}
			open
			func notOnOverflowPhrase() -> NotOnOverflowPhraseContext? {
				return getRuleContext(NotOnOverflowPhraseContext.self, 0)
			}
			open
			func END_UNSTRING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_UNSTRING.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_unstringStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUnstringStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUnstringStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUnstringStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUnstringStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unstringStatement() throws -> UnstringStatementContext {
		var _localctx: UnstringStatementContext = UnstringStatementContext(_ctx, getState())
		try enterRule(_localctx, 966, Cobol85Parser.RULE_unstringStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5447)
		 	try match(Cobol85Parser.Tokens.UNSTRING.rawValue)
		 	setState(5448)
		 	try unstringSendingPhrase()
		 	setState(5449)
		 	try unstringIntoPhrase()
		 	setState(5451)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,837,_ctx)) {
		 	case 1:
		 		setState(5450)
		 		try unstringWithPointerPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5454)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.TALLYING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5453)
		 		try unstringTallyingPhrase()

		 	}

		 	setState(5457)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,839,_ctx)) {
		 	case 1:
		 		setState(5456)
		 		try onOverflowPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5460)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,840,_ctx)) {
		 	case 1:
		 		setState(5459)
		 		try notOnOverflowPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5463)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,841,_ctx)) {
		 	case 1:
		 		setState(5462)
		 		try match(Cobol85Parser.Tokens.END_UNSTRING.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnstringSendingPhraseContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func unstringDelimitedByPhrase() -> UnstringDelimitedByPhraseContext? {
				return getRuleContext(UnstringDelimitedByPhraseContext.self, 0)
			}
			open
			func unstringOrAllPhrase() -> [UnstringOrAllPhraseContext] {
				return getRuleContexts(UnstringOrAllPhraseContext.self)
			}
			open
			func unstringOrAllPhrase(_ i: Int) -> UnstringOrAllPhraseContext? {
				return getRuleContext(UnstringOrAllPhraseContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_unstringSendingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUnstringSendingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUnstringSendingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUnstringSendingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUnstringSendingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unstringSendingPhrase() throws -> UnstringSendingPhraseContext {
		var _localctx: UnstringSendingPhraseContext = UnstringSendingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 968, Cobol85Parser.RULE_unstringSendingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5465)
		 	try identifier()
		 	setState(5473)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DELIMITED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5466)
		 		try unstringDelimitedByPhrase()
		 		setState(5470)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.OR.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5467)
		 			try unstringOrAllPhrase()


		 			setState(5472)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnstringDelimitedByPhraseContext: ParserRuleContext {
			open
			func DELIMITED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DELIMITED.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BY.rawValue, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_unstringDelimitedByPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUnstringDelimitedByPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUnstringDelimitedByPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUnstringDelimitedByPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUnstringDelimitedByPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unstringDelimitedByPhrase() throws -> UnstringDelimitedByPhraseContext {
		var _localctx: UnstringDelimitedByPhraseContext = UnstringDelimitedByPhraseContext(_ctx, getState())
		try enterRule(_localctx, 970, Cobol85Parser.RULE_unstringDelimitedByPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5475)
		 	try match(Cobol85Parser.Tokens.DELIMITED.rawValue)
		 	setState(5477)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.BY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5476)
		 		try match(Cobol85Parser.Tokens.BY.rawValue)

		 	}

		 	setState(5480)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,845,_ctx)) {
		 	case 1:
		 		setState(5479)
		 		try match(Cobol85Parser.Tokens.ALL.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(5484)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,846, _ctx)) {
		 	case 1:
		 		setState(5482)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5483)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnstringOrAllPhraseContext: ParserRuleContext {
			open
			func OR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OR.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_unstringOrAllPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUnstringOrAllPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUnstringOrAllPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUnstringOrAllPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUnstringOrAllPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unstringOrAllPhrase() throws -> UnstringOrAllPhraseContext {
		var _localctx: UnstringOrAllPhraseContext = UnstringOrAllPhraseContext(_ctx, getState())
		try enterRule(_localctx, 972, Cobol85Parser.RULE_unstringOrAllPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5486)
		 	try match(Cobol85Parser.Tokens.OR.rawValue)
		 	setState(5488)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,847,_ctx)) {
		 	case 1:
		 		setState(5487)
		 		try match(Cobol85Parser.Tokens.ALL.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(5492)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,848, _ctx)) {
		 	case 1:
		 		setState(5490)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5491)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnstringIntoPhraseContext: ParserRuleContext {
			open
			func INTO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTO.rawValue, 0)
			}
			open
			func unstringInto() -> [UnstringIntoContext] {
				return getRuleContexts(UnstringIntoContext.self)
			}
			open
			func unstringInto(_ i: Int) -> UnstringIntoContext? {
				return getRuleContext(UnstringIntoContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_unstringIntoPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUnstringIntoPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUnstringIntoPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUnstringIntoPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUnstringIntoPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unstringIntoPhrase() throws -> UnstringIntoPhraseContext {
		var _localctx: UnstringIntoPhraseContext = UnstringIntoPhraseContext(_ctx, getState())
		try enterRule(_localctx, 974, Cobol85Parser.RULE_unstringIntoPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5494)
		 	try match(Cobol85Parser.Tokens.INTO.rawValue)
		 	setState(5496) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5495)
		 		try unstringInto()


		 		setState(5498); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnstringIntoContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func unstringDelimiterIn() -> UnstringDelimiterInContext? {
				return getRuleContext(UnstringDelimiterInContext.self, 0)
			}
			open
			func unstringCountIn() -> UnstringCountInContext? {
				return getRuleContext(UnstringCountInContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_unstringInto
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUnstringInto(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUnstringInto(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUnstringInto(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUnstringInto(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unstringInto() throws -> UnstringIntoContext {
		var _localctx: UnstringIntoContext = UnstringIntoContext(_ctx, getState())
		try enterRule(_localctx, 976, Cobol85Parser.RULE_unstringInto)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5500)
		 	try identifier()
		 	setState(5502)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DELIMITER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5501)
		 		try unstringDelimiterIn()

		 	}

		 	setState(5505)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COUNT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5504)
		 		try unstringCountIn()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnstringDelimiterInContext: ParserRuleContext {
			open
			func DELIMITER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DELIMITER.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_unstringDelimiterIn
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUnstringDelimiterIn(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUnstringDelimiterIn(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUnstringDelimiterIn(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUnstringDelimiterIn(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unstringDelimiterIn() throws -> UnstringDelimiterInContext {
		var _localctx: UnstringDelimiterInContext = UnstringDelimiterInContext(_ctx, getState())
		try enterRule(_localctx, 978, Cobol85Parser.RULE_unstringDelimiterIn)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5507)
		 	try match(Cobol85Parser.Tokens.DELIMITER.rawValue)
		 	setState(5509)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5508)
		 		try match(Cobol85Parser.Tokens.IN.rawValue)

		 	}

		 	setState(5511)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnstringCountInContext: ParserRuleContext {
			open
			func COUNT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COUNT.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_unstringCountIn
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUnstringCountIn(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUnstringCountIn(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUnstringCountIn(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUnstringCountIn(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unstringCountIn() throws -> UnstringCountInContext {
		var _localctx: UnstringCountInContext = UnstringCountInContext(_ctx, getState())
		try enterRule(_localctx, 980, Cobol85Parser.RULE_unstringCountIn)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5513)
		 	try match(Cobol85Parser.Tokens.COUNT.rawValue)
		 	setState(5515)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5514)
		 		try match(Cobol85Parser.Tokens.IN.rawValue)

		 	}

		 	setState(5517)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnstringWithPointerPhraseContext: ParserRuleContext {
			open
			func POINTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.POINTER.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WITH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_unstringWithPointerPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUnstringWithPointerPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUnstringWithPointerPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUnstringWithPointerPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUnstringWithPointerPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unstringWithPointerPhrase() throws -> UnstringWithPointerPhraseContext {
		var _localctx: UnstringWithPointerPhraseContext = UnstringWithPointerPhraseContext(_ctx, getState())
		try enterRule(_localctx, 982, Cobol85Parser.RULE_unstringWithPointerPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5520)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5519)
		 		try match(Cobol85Parser.Tokens.WITH.rawValue)

		 	}

		 	setState(5522)
		 	try match(Cobol85Parser.Tokens.POINTER.rawValue)
		 	setState(5523)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnstringTallyingPhraseContext: ParserRuleContext {
			open
			func TALLYING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TALLYING.rawValue, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_unstringTallyingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUnstringTallyingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUnstringTallyingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUnstringTallyingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUnstringTallyingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unstringTallyingPhrase() throws -> UnstringTallyingPhraseContext {
		var _localctx: UnstringTallyingPhraseContext = UnstringTallyingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 984, Cobol85Parser.RULE_unstringTallyingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5525)
		 	try match(Cobol85Parser.Tokens.TALLYING.rawValue)
		 	setState(5527)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5526)
		 		try match(Cobol85Parser.Tokens.IN.rawValue)

		 	}

		 	setState(5529)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UseStatementContext: ParserRuleContext {
			open
			func USE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.USE.rawValue, 0)
			}
			open
			func useAfterClause() -> UseAfterClauseContext? {
				return getRuleContext(UseAfterClauseContext.self, 0)
			}
			open
			func useDebugClause() -> UseDebugClauseContext? {
				return getRuleContext(UseDebugClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_useStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUseStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUseStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUseStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUseStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func useStatement() throws -> UseStatementContext {
		var _localctx: UseStatementContext = UseStatementContext(_ctx, getState())
		try enterRule(_localctx, 986, Cobol85Parser.RULE_useStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5531)
		 	try match(Cobol85Parser.Tokens.USE.rawValue)
		 	setState(5534)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .AFTER:fallthrough
		 	case .GLOBAL:
		 		setState(5532)
		 		try useAfterClause()

		 		break
		 	case .DEBUGGING:fallthrough
		 	case .FOR:
		 		setState(5533)
		 		try useDebugClause()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UseAfterClauseContext: ParserRuleContext {
			open
			func AFTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AFTER.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROCEDURE.rawValue, 0)
			}
			open
			func useAfterOn() -> UseAfterOnContext? {
				return getRuleContext(UseAfterOnContext.self, 0)
			}
			open
			func EXCEPTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXCEPTION.rawValue, 0)
			}
			open
			func ERROR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ERROR.rawValue, 0)
			}
			open
			func GLOBAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GLOBAL.rawValue, 0)
			}
			open
			func STANDARD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.STANDARD.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_useAfterClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUseAfterClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUseAfterClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUseAfterClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUseAfterClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func useAfterClause() throws -> UseAfterClauseContext {
		var _localctx: UseAfterClauseContext = UseAfterClauseContext(_ctx, getState())
		try enterRule(_localctx, 988, Cobol85Parser.RULE_useAfterClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5537)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.GLOBAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5536)
		 		try match(Cobol85Parser.Tokens.GLOBAL.rawValue)

		 	}

		 	setState(5539)
		 	try match(Cobol85Parser.Tokens.AFTER.rawValue)
		 	setState(5541)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.STANDARD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5540)
		 		try match(Cobol85Parser.Tokens.STANDARD.rawValue)

		 	}

		 	setState(5543)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ERROR.rawValue || _la == Cobol85Parser.Tokens.EXCEPTION.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5544)
		 	try match(Cobol85Parser.Tokens.PROCEDURE.rawValue)
		 	setState(5546)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5545)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 	}

		 	setState(5548)
		 	try useAfterOn()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UseAfterOnContext: ParserRuleContext {
			open
			func INPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INPUT.rawValue, 0)
			}
			open
			func OUTPUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OUTPUT.rawValue, 0)
			}
			open
			func I_O() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.I_O.rawValue, 0)
			}
			open
			func EXTEND() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXTEND.rawValue, 0)
			}
			open
			func fileName() -> [FileNameContext] {
				return getRuleContexts(FileNameContext.self)
			}
			open
			func fileName(_ i: Int) -> FileNameContext? {
				return getRuleContext(FileNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_useAfterOn
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUseAfterOn(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUseAfterOn(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUseAfterOn(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUseAfterOn(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func useAfterOn() throws -> UseAfterOnContext {
		var _localctx: UseAfterOnContext = UseAfterOnContext(_ctx, getState())
		try enterRule(_localctx, 990, Cobol85Parser.RULE_useAfterOn)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5559)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .INPUT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5550)
		 		try match(Cobol85Parser.Tokens.INPUT.rawValue)

		 		break

		 	case .OUTPUT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5551)
		 		try match(Cobol85Parser.Tokens.OUTPUT.rawValue)

		 		break

		 	case .I_O:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5552)
		 		try match(Cobol85Parser.Tokens.I_O.rawValue)

		 		break

		 	case .EXTEND:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5553)
		 		try match(Cobol85Parser.Tokens.EXTEND.rawValue)

		 		break
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5555) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(5554)
		 			try fileName()


		 			setState(5557); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 68)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 138)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 202)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 268)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 336)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 401)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 466)
		 		          }()
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 		      return testSet
		 		 }())

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UseDebugClauseContext: ParserRuleContext {
			open
			func DEBUGGING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEBUGGING.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOR.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func useDebugOn() -> [UseDebugOnContext] {
				return getRuleContexts(UseDebugOnContext.self)
			}
			open
			func useDebugOn(_ i: Int) -> UseDebugOnContext? {
				return getRuleContext(UseDebugOnContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_useDebugClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUseDebugClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUseDebugClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUseDebugClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUseDebugClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func useDebugClause() throws -> UseDebugClauseContext {
		var _localctx: UseDebugClauseContext = UseDebugClauseContext(_ctx, getState())
		try enterRule(_localctx, 992, Cobol85Parser.RULE_useDebugClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5562)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5561)
		 		try match(Cobol85Parser.Tokens.FOR.rawValue)

		 	}

		 	setState(5564)
		 	try match(Cobol85Parser.Tokens.DEBUGGING.rawValue)
		 	setState(5566)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5565)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 	}

		 	setState(5569) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5568)
		 		try useDebugOn()


		 		setState(5571); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 552)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UseDebugOnContext: ParserRuleContext {
			open
			func ALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALL.rawValue, 0)
			}
			open
			func PROCEDURES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROCEDURES.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func REFERENCES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REFERENCES.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
			open
			func procedureName() -> ProcedureNameContext? {
				return getRuleContext(ProcedureNameContext.self, 0)
			}
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_useDebugOn
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterUseDebugOn(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitUseDebugOn(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitUseDebugOn(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitUseDebugOn(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func useDebugOn() throws -> UseDebugOnContext {
		var _localctx: UseDebugOnContext = UseDebugOnContext(_ctx, getState())
		try enterRule(_localctx, 994, Cobol85Parser.RULE_useDebugOn)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5585)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,867, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5573)
		 		try match(Cobol85Parser.Tokens.ALL.rawValue)
		 		setState(5574)
		 		try match(Cobol85Parser.Tokens.PROCEDURES.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5575)
		 		try match(Cobol85Parser.Tokens.ALL.rawValue)
		 		setState(5577)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.REFERENCES.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5576)
		 			try match(Cobol85Parser.Tokens.REFERENCES.rawValue)

		 		}

		 		setState(5580)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.OF.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5579)
		 			try match(Cobol85Parser.Tokens.OF.rawValue)

		 		}

		 		setState(5582)
		 		try identifier()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5583)
		 		try procedureName()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5584)
		 		try fileName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WriteStatementContext: ParserRuleContext {
			open
			func WRITE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WRITE.rawValue, 0)
			}
			open
			func recordName() -> RecordNameContext? {
				return getRuleContext(RecordNameContext.self, 0)
			}
			open
			func writeFromPhrase() -> WriteFromPhraseContext? {
				return getRuleContext(WriteFromPhraseContext.self, 0)
			}
			open
			func writeAdvancingPhrase() -> WriteAdvancingPhraseContext? {
				return getRuleContext(WriteAdvancingPhraseContext.self, 0)
			}
			open
			func writeAtEndOfPagePhrase() -> WriteAtEndOfPagePhraseContext? {
				return getRuleContext(WriteAtEndOfPagePhraseContext.self, 0)
			}
			open
			func writeNotAtEndOfPagePhrase() -> WriteNotAtEndOfPagePhraseContext? {
				return getRuleContext(WriteNotAtEndOfPagePhraseContext.self, 0)
			}
			open
			func invalidKeyPhrase() -> InvalidKeyPhraseContext? {
				return getRuleContext(InvalidKeyPhraseContext.self, 0)
			}
			open
			func notInvalidKeyPhrase() -> NotInvalidKeyPhraseContext? {
				return getRuleContext(NotInvalidKeyPhraseContext.self, 0)
			}
			open
			func END_WRITE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_WRITE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_writeStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterWriteStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitWriteStatement(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitWriteStatement(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitWriteStatement(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func writeStatement() throws -> WriteStatementContext {
		var _localctx: WriteStatementContext = WriteStatementContext(_ctx, getState())
		try enterRule(_localctx, 996, Cobol85Parser.RULE_writeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5587)
		 	try match(Cobol85Parser.Tokens.WRITE.rawValue)
		 	setState(5588)
		 	try recordName()
		 	setState(5590)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.FROM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5589)
		 		try writeFromPhrase()

		 	}

		 	setState(5593)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue || _la == Cobol85Parser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5592)
		 		try writeAdvancingPhrase()

		 	}

		 	setState(5596)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,870,_ctx)) {
		 	case 1:
		 		setState(5595)
		 		try writeAtEndOfPagePhrase()

		 		break
		 	default: break
		 	}
		 	setState(5599)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,871,_ctx)) {
		 	case 1:
		 		setState(5598)
		 		try writeNotAtEndOfPagePhrase()

		 		break
		 	default: break
		 	}
		 	setState(5602)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,872,_ctx)) {
		 	case 1:
		 		setState(5601)
		 		try invalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5605)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,873,_ctx)) {
		 	case 1:
		 		setState(5604)
		 		try notInvalidKeyPhrase()

		 		break
		 	default: break
		 	}
		 	setState(5608)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,874,_ctx)) {
		 	case 1:
		 		setState(5607)
		 		try match(Cobol85Parser.Tokens.END_WRITE.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WriteFromPhraseContext: ParserRuleContext {
			open
			func FROM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FROM.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_writeFromPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterWriteFromPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitWriteFromPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitWriteFromPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitWriteFromPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func writeFromPhrase() throws -> WriteFromPhraseContext {
		var _localctx: WriteFromPhraseContext = WriteFromPhraseContext(_ctx, getState())
		try enterRule(_localctx, 998, Cobol85Parser.RULE_writeFromPhrase)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5610)
		 	try match(Cobol85Parser.Tokens.FROM.rawValue)
		 	setState(5613)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,875, _ctx)) {
		 	case 1:
		 		setState(5611)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5612)
		 		try literal()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WriteAdvancingPhraseContext: ParserRuleContext {
			open
			func BEFORE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BEFORE.rawValue, 0)
			}
			open
			func AFTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AFTER.rawValue, 0)
			}
			open
			func writeAdvancingPage() -> WriteAdvancingPageContext? {
				return getRuleContext(WriteAdvancingPageContext.self, 0)
			}
			open
			func writeAdvancingLines() -> WriteAdvancingLinesContext? {
				return getRuleContext(WriteAdvancingLinesContext.self, 0)
			}
			open
			func writeAdvancingMnemonic() -> WriteAdvancingMnemonicContext? {
				return getRuleContext(WriteAdvancingMnemonicContext.self, 0)
			}
			open
			func ADVANCING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ADVANCING.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_writeAdvancingPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterWriteAdvancingPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitWriteAdvancingPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitWriteAdvancingPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitWriteAdvancingPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func writeAdvancingPhrase() throws -> WriteAdvancingPhraseContext {
		var _localctx: WriteAdvancingPhraseContext = WriteAdvancingPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1000, Cobol85Parser.RULE_writeAdvancingPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5615)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AFTER.rawValue || _la == Cobol85Parser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5617)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ADVANCING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5616)
		 		try match(Cobol85Parser.Tokens.ADVANCING.rawValue)

		 	}

		 	setState(5622)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,877, _ctx)) {
		 	case 1:
		 		setState(5619)
		 		try writeAdvancingPage()

		 		break
		 	case 2:
		 		setState(5620)
		 		try writeAdvancingLines()

		 		break
		 	case 3:
		 		setState(5621)
		 		try writeAdvancingMnemonic()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WriteAdvancingPageContext: ParserRuleContext {
			open
			func PAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PAGE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_writeAdvancingPage
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterWriteAdvancingPage(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitWriteAdvancingPage(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitWriteAdvancingPage(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitWriteAdvancingPage(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func writeAdvancingPage() throws -> WriteAdvancingPageContext {
		var _localctx: WriteAdvancingPageContext = WriteAdvancingPageContext(_ctx, getState())
		try enterRule(_localctx, 1002, Cobol85Parser.RULE_writeAdvancingPage)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5624)
		 	try match(Cobol85Parser.Tokens.PAGE.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WriteAdvancingLinesContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func LINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINE.rawValue, 0)
			}
			open
			func LINES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINES.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_writeAdvancingLines
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterWriteAdvancingLines(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitWriteAdvancingLines(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitWriteAdvancingLines(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitWriteAdvancingLines(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func writeAdvancingLines() throws -> WriteAdvancingLinesContext {
		var _localctx: WriteAdvancingLinesContext = WriteAdvancingLinesContext(_ctx, getState())
		try enterRule(_localctx, 1004, Cobol85Parser.RULE_writeAdvancingLines)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5628)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,878, _ctx)) {
		 	case 1:
		 		setState(5626)
		 		try identifier()

		 		break
		 	case 2:
		 		setState(5627)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(5631)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.LINE.rawValue || _la == Cobol85Parser.Tokens.LINES.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5630)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.LINE.rawValue || _la == Cobol85Parser.Tokens.LINES.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WriteAdvancingMnemonicContext: ParserRuleContext {
			open
			func mnemonicName() -> MnemonicNameContext? {
				return getRuleContext(MnemonicNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_writeAdvancingMnemonic
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterWriteAdvancingMnemonic(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitWriteAdvancingMnemonic(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitWriteAdvancingMnemonic(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitWriteAdvancingMnemonic(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func writeAdvancingMnemonic() throws -> WriteAdvancingMnemonicContext {
		var _localctx: WriteAdvancingMnemonicContext = WriteAdvancingMnemonicContext(_ctx, getState())
		try enterRule(_localctx, 1006, Cobol85Parser.RULE_writeAdvancingMnemonic)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5633)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WriteAtEndOfPagePhraseContext: ParserRuleContext {
			open
			func END_OF_PAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_OF_PAGE.rawValue, 0)
			}
			open
			func EOP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EOP.rawValue, 0)
			}
			open
			func AT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AT.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_writeAtEndOfPagePhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterWriteAtEndOfPagePhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitWriteAtEndOfPagePhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitWriteAtEndOfPagePhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitWriteAtEndOfPagePhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func writeAtEndOfPagePhrase() throws -> WriteAtEndOfPagePhraseContext {
		var _localctx: WriteAtEndOfPagePhraseContext = WriteAtEndOfPagePhraseContext(_ctx, getState())
		try enterRule(_localctx, 1008, Cobol85Parser.RULE_writeAtEndOfPagePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5636)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5635)
		 		try match(Cobol85Parser.Tokens.AT.rawValue)

		 	}

		 	setState(5638)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.END_OF_PAGE.rawValue || _la == Cobol85Parser.Tokens.EOP.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5642)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,881,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5639)
		 			try statement()

		 	 
		 		}
		 		setState(5644)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,881,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WriteNotAtEndOfPagePhraseContext: ParserRuleContext {
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
			open
			func END_OF_PAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END_OF_PAGE.rawValue, 0)
			}
			open
			func EOP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EOP.rawValue, 0)
			}
			open
			func AT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AT.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_writeNotAtEndOfPagePhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterWriteNotAtEndOfPagePhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitWriteNotAtEndOfPagePhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitWriteNotAtEndOfPagePhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitWriteNotAtEndOfPagePhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func writeNotAtEndOfPagePhrase() throws -> WriteNotAtEndOfPagePhraseContext {
		var _localctx: WriteNotAtEndOfPagePhraseContext = WriteNotAtEndOfPagePhraseContext(_ctx, getState())
		try enterRule(_localctx, 1010, Cobol85Parser.RULE_writeNotAtEndOfPagePhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5645)
		 	try match(Cobol85Parser.Tokens.NOT.rawValue)
		 	setState(5647)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5646)
		 		try match(Cobol85Parser.Tokens.AT.rawValue)

		 	}

		 	setState(5649)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.END_OF_PAGE.rawValue || _la == Cobol85Parser.Tokens.EOP.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5653)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,883,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5650)
		 			try statement()

		 	 
		 		}
		 		setState(5655)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,883,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AtEndPhraseContext: ParserRuleContext {
			open
			func END() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END.rawValue, 0)
			}
			open
			func AT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AT.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_atEndPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAtEndPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAtEndPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAtEndPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAtEndPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func atEndPhrase() throws -> AtEndPhraseContext {
		var _localctx: AtEndPhraseContext = AtEndPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1012, Cobol85Parser.RULE_atEndPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5657)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5656)
		 		try match(Cobol85Parser.Tokens.AT.rawValue)

		 	}

		 	setState(5659)
		 	try match(Cobol85Parser.Tokens.END.rawValue)
		 	setState(5663)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,885,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5660)
		 			try statement()

		 	 
		 		}
		 		setState(5665)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,885,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NotAtEndPhraseContext: ParserRuleContext {
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
			open
			func END() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.END.rawValue, 0)
			}
			open
			func AT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AT.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_notAtEndPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterNotAtEndPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitNotAtEndPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitNotAtEndPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitNotAtEndPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func notAtEndPhrase() throws -> NotAtEndPhraseContext {
		var _localctx: NotAtEndPhraseContext = NotAtEndPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1014, Cobol85Parser.RULE_notAtEndPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5666)
		 	try match(Cobol85Parser.Tokens.NOT.rawValue)
		 	setState(5668)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.AT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5667)
		 		try match(Cobol85Parser.Tokens.AT.rawValue)

		 	}

		 	setState(5670)
		 	try match(Cobol85Parser.Tokens.END.rawValue)
		 	setState(5674)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,887,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5671)
		 			try statement()

		 	 
		 		}
		 		setState(5676)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,887,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InvalidKeyPhraseContext: ParserRuleContext {
			open
			func INVALID() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INVALID.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_invalidKeyPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInvalidKeyPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInvalidKeyPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInvalidKeyPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInvalidKeyPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func invalidKeyPhrase() throws -> InvalidKeyPhraseContext {
		var _localctx: InvalidKeyPhraseContext = InvalidKeyPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1016, Cobol85Parser.RULE_invalidKeyPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5677)
		 	try match(Cobol85Parser.Tokens.INVALID.rawValue)
		 	setState(5679)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.KEY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5678)
		 		try match(Cobol85Parser.Tokens.KEY.rawValue)

		 	}

		 	setState(5684)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,889,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5681)
		 			try statement()

		 	 
		 		}
		 		setState(5686)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,889,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NotInvalidKeyPhraseContext: ParserRuleContext {
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
			open
			func INVALID() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INVALID.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEY.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_notInvalidKeyPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterNotInvalidKeyPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitNotInvalidKeyPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitNotInvalidKeyPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitNotInvalidKeyPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func notInvalidKeyPhrase() throws -> NotInvalidKeyPhraseContext {
		var _localctx: NotInvalidKeyPhraseContext = NotInvalidKeyPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1018, Cobol85Parser.RULE_notInvalidKeyPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5687)
		 	try match(Cobol85Parser.Tokens.NOT.rawValue)
		 	setState(5688)
		 	try match(Cobol85Parser.Tokens.INVALID.rawValue)
		 	setState(5690)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.KEY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5689)
		 		try match(Cobol85Parser.Tokens.KEY.rawValue)

		 	}

		 	setState(5695)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,891,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5692)
		 			try statement()

		 	 
		 		}
		 		setState(5697)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,891,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OnOverflowPhraseContext: ParserRuleContext {
			open
			func OVERFLOW() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OVERFLOW.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_onOverflowPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOnOverflowPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOnOverflowPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOnOverflowPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOnOverflowPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func onOverflowPhrase() throws -> OnOverflowPhraseContext {
		var _localctx: OnOverflowPhraseContext = OnOverflowPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1020, Cobol85Parser.RULE_onOverflowPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5699)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5698)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 	}

		 	setState(5701)
		 	try match(Cobol85Parser.Tokens.OVERFLOW.rawValue)
		 	setState(5705)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,893,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5702)
		 			try statement()

		 	 
		 		}
		 		setState(5707)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,893,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NotOnOverflowPhraseContext: ParserRuleContext {
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
			open
			func OVERFLOW() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OVERFLOW.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_notOnOverflowPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterNotOnOverflowPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitNotOnOverflowPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitNotOnOverflowPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitNotOnOverflowPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func notOnOverflowPhrase() throws -> NotOnOverflowPhraseContext {
		var _localctx: NotOnOverflowPhraseContext = NotOnOverflowPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1022, Cobol85Parser.RULE_notOnOverflowPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5708)
		 	try match(Cobol85Parser.Tokens.NOT.rawValue)
		 	setState(5710)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5709)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 	}

		 	setState(5712)
		 	try match(Cobol85Parser.Tokens.OVERFLOW.rawValue)
		 	setState(5716)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,895,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5713)
		 			try statement()

		 	 
		 		}
		 		setState(5718)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,895,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OnSizeErrorPhraseContext: ParserRuleContext {
			open
			func SIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIZE.rawValue, 0)
			}
			open
			func ERROR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ERROR.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_onSizeErrorPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOnSizeErrorPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOnSizeErrorPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOnSizeErrorPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOnSizeErrorPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func onSizeErrorPhrase() throws -> OnSizeErrorPhraseContext {
		var _localctx: OnSizeErrorPhraseContext = OnSizeErrorPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1024, Cobol85Parser.RULE_onSizeErrorPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5720)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5719)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 	}

		 	setState(5722)
		 	try match(Cobol85Parser.Tokens.SIZE.rawValue)
		 	setState(5723)
		 	try match(Cobol85Parser.Tokens.ERROR.rawValue)
		 	setState(5727)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,897,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5724)
		 			try statement()

		 	 
		 		}
		 		setState(5729)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,897,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NotOnSizeErrorPhraseContext: ParserRuleContext {
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
			open
			func SIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SIZE.rawValue, 0)
			}
			open
			func ERROR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ERROR.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_notOnSizeErrorPhrase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterNotOnSizeErrorPhrase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitNotOnSizeErrorPhrase(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitNotOnSizeErrorPhrase(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitNotOnSizeErrorPhrase(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func notOnSizeErrorPhrase() throws -> NotOnSizeErrorPhraseContext {
		var _localctx: NotOnSizeErrorPhraseContext = NotOnSizeErrorPhraseContext(_ctx, getState())
		try enterRule(_localctx, 1026, Cobol85Parser.RULE_notOnSizeErrorPhrase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5730)
		 	try match(Cobol85Parser.Tokens.NOT.rawValue)
		 	setState(5732)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5731)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 	}

		 	setState(5734)
		 	try match(Cobol85Parser.Tokens.SIZE.rawValue)
		 	setState(5735)
		 	try match(Cobol85Parser.Tokens.ERROR.rawValue)
		 	setState(5739)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,899,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5736)
		 			try statement()

		 	 
		 		}
		 		setState(5741)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,899,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OnExceptionClauseContext: ParserRuleContext {
			open
			func EXCEPTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXCEPTION.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_onExceptionClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterOnExceptionClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitOnExceptionClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitOnExceptionClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitOnExceptionClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func onExceptionClause() throws -> OnExceptionClauseContext {
		var _localctx: OnExceptionClauseContext = OnExceptionClauseContext(_ctx, getState())
		try enterRule(_localctx, 1028, Cobol85Parser.RULE_onExceptionClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5743)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5742)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 	}

		 	setState(5745)
		 	try match(Cobol85Parser.Tokens.EXCEPTION.rawValue)
		 	setState(5749)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,901,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5746)
		 			try statement()

		 	 
		 		}
		 		setState(5751)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,901,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NotOnExceptionClauseContext: ParserRuleContext {
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
			open
			func EXCEPTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXCEPTION.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ON.rawValue, 0)
			}
			open
			func statement() -> [StatementContext] {
				return getRuleContexts(StatementContext.self)
			}
			open
			func statement(_ i: Int) -> StatementContext? {
				return getRuleContext(StatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_notOnExceptionClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterNotOnExceptionClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitNotOnExceptionClause(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitNotOnExceptionClause(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitNotOnExceptionClause(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func notOnExceptionClause() throws -> NotOnExceptionClauseContext {
		var _localctx: NotOnExceptionClauseContext = NotOnExceptionClauseContext(_ctx, getState())
		try enterRule(_localctx, 1030, Cobol85Parser.RULE_notOnExceptionClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5752)
		 	try match(Cobol85Parser.Tokens.NOT.rawValue)
		 	setState(5754)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5753)
		 		try match(Cobol85Parser.Tokens.ON.rawValue)

		 	}

		 	setState(5756)
		 	try match(Cobol85Parser.Tokens.EXCEPTION.rawValue)
		 	setState(5760)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,903,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5757)
		 			try statement()

		 	 
		 		}
		 		setState(5762)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,903,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ArithmeticExpressionContext: ParserRuleContext {
			open
			func multDivs() -> MultDivsContext? {
				return getRuleContext(MultDivsContext.self, 0)
			}
			open
			func plusMinus() -> [PlusMinusContext] {
				return getRuleContexts(PlusMinusContext.self)
			}
			open
			func plusMinus(_ i: Int) -> PlusMinusContext? {
				return getRuleContext(PlusMinusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_arithmeticExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterArithmeticExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitArithmeticExpression(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitArithmeticExpression(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitArithmeticExpression(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func arithmeticExpression() throws -> ArithmeticExpressionContext {
		var _localctx: ArithmeticExpressionContext = ArithmeticExpressionContext(_ctx, getState())
		try enterRule(_localctx, 1032, Cobol85Parser.RULE_arithmeticExpression)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5763)
		 	try multDivs()
		 	setState(5767)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,904,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5764)
		 			try plusMinus()

		 	 
		 		}
		 		setState(5769)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,904,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PlusMinusContext: ParserRuleContext {
			open
			func multDivs() -> MultDivsContext? {
				return getRuleContext(MultDivsContext.self, 0)
			}
			open
			func PLUSCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PLUSCHAR.rawValue, 0)
			}
			open
			func MINUSCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MINUSCHAR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_plusMinus
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPlusMinus(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPlusMinus(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPlusMinus(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPlusMinus(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func plusMinus() throws -> PlusMinusContext {
		var _localctx: PlusMinusContext = PlusMinusContext(_ctx, getState())
		try enterRule(_localctx, 1034, Cobol85Parser.RULE_plusMinus)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5770)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.MINUSCHAR.rawValue || _la == Cobol85Parser.Tokens.PLUSCHAR.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5771)
		 	try multDivs()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultDivsContext: ParserRuleContext {
			open
			func powers() -> PowersContext? {
				return getRuleContext(PowersContext.self, 0)
			}
			open
			func multDiv() -> [MultDivContext] {
				return getRuleContexts(MultDivContext.self)
			}
			open
			func multDiv(_ i: Int) -> MultDivContext? {
				return getRuleContext(MultDivContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_multDivs
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMultDivs(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMultDivs(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMultDivs(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMultDivs(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func multDivs() throws -> MultDivsContext {
		var _localctx: MultDivsContext = MultDivsContext(_ctx, getState())
		try enterRule(_localctx, 1036, Cobol85Parser.RULE_multDivs)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5773)
		 	try powers()
		 	setState(5777)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ASTERISKCHAR.rawValue || _la == Cobol85Parser.Tokens.SLASHCHAR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5774)
		 		try multDiv()


		 		setState(5779)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultDivContext: ParserRuleContext {
			open
			func powers() -> PowersContext? {
				return getRuleContext(PowersContext.self, 0)
			}
			open
			func ASTERISKCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASTERISKCHAR.rawValue, 0)
			}
			open
			func SLASHCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SLASHCHAR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_multDiv
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMultDiv(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMultDiv(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMultDiv(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMultDiv(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func multDiv() throws -> MultDivContext {
		var _localctx: MultDivContext = MultDivContext(_ctx, getState())
		try enterRule(_localctx, 1038, Cobol85Parser.RULE_multDiv)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5780)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.ASTERISKCHAR.rawValue || _la == Cobol85Parser.Tokens.SLASHCHAR.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5781)
		 	try powers()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PowersContext: ParserRuleContext {
			open
			func basis() -> BasisContext? {
				return getRuleContext(BasisContext.self, 0)
			}
			open
			func power() -> [PowerContext] {
				return getRuleContexts(PowerContext.self)
			}
			open
			func power(_ i: Int) -> PowerContext? {
				return getRuleContext(PowerContext.self, i)
			}
			open
			func PLUSCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PLUSCHAR.rawValue, 0)
			}
			open
			func MINUSCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MINUSCHAR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_powers
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPowers(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPowers(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPowers(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPowers(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func powers() throws -> PowersContext {
		var _localctx: PowersContext = PowersContext(_ctx, getState())
		try enterRule(_localctx, 1040, Cobol85Parser.RULE_powers)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5784)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.MINUSCHAR.rawValue || _la == Cobol85Parser.Tokens.PLUSCHAR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5783)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.MINUSCHAR.rawValue || _la == Cobol85Parser.Tokens.PLUSCHAR.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(5786)
		 	try basis()
		 	setState(5790)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.DOUBLEASTERISKCHAR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5787)
		 		try power()


		 		setState(5792)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PowerContext: ParserRuleContext {
			open
			func DOUBLEASTERISKCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOUBLEASTERISKCHAR.rawValue, 0)
			}
			open
			func basis() -> BasisContext? {
				return getRuleContext(BasisContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_power
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterPower(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitPower(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitPower(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitPower(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func power() throws -> PowerContext {
		var _localctx: PowerContext = PowerContext(_ctx, getState())
		try enterRule(_localctx, 1042, Cobol85Parser.RULE_power)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5793)
		 	try match(Cobol85Parser.Tokens.DOUBLEASTERISKCHAR.rawValue)
		 	setState(5794)
		 	try basis()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BasisContext: ParserRuleContext {
			open
			func LPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, 0)
			}
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
			open
			func RPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_basis
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterBasis(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitBasis(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitBasis(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitBasis(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func basis() throws -> BasisContext {
		var _localctx: BasisContext = BasisContext(_ctx, getState())
		try enterRule(_localctx, 1044, Cobol85Parser.RULE_basis)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5802)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,908, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5796)
		 		try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
		 		setState(5797)
		 		try arithmeticExpression()
		 		setState(5798)
		 		try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5800)
		 		try identifier()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5801)
		 		try literal()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConditionContext: ParserRuleContext {
			open
			func combinableCondition() -> CombinableConditionContext? {
				return getRuleContext(CombinableConditionContext.self, 0)
			}
			open
			func andOrCondition() -> [AndOrConditionContext] {
				return getRuleContexts(AndOrConditionContext.self)
			}
			open
			func andOrCondition(_ i: Int) -> AndOrConditionContext? {
				return getRuleContext(AndOrConditionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_condition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCondition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCondition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCondition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func condition() throws -> ConditionContext {
		var _localctx: ConditionContext = ConditionContext(_ctx, getState())
		try enterRule(_localctx, 1046, Cobol85Parser.RULE_condition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5804)
		 	try combinableCondition()
		 	setState(5808)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.AND.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.OR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5805)
		 		try andOrCondition()


		 		setState(5810)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AndOrConditionContext: ParserRuleContext {
			open
			func AND() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AND.rawValue, 0)
			}
			open
			func OR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OR.rawValue, 0)
			}
			open
			func combinableCondition() -> CombinableConditionContext? {
				return getRuleContext(CombinableConditionContext.self, 0)
			}
			open
			func abbreviation() -> [AbbreviationContext] {
				return getRuleContexts(AbbreviationContext.self)
			}
			open
			func abbreviation(_ i: Int) -> AbbreviationContext? {
				return getRuleContext(AbbreviationContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_andOrCondition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAndOrCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAndOrCondition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAndOrCondition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAndOrCondition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func andOrCondition() throws -> AndOrConditionContext {
		var _localctx: AndOrConditionContext = AndOrConditionContext(_ctx, getState())
		try enterRule(_localctx, 1048, Cobol85Parser.RULE_andOrCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5811)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.AND.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.OR.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5818)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,911, _ctx)) {
		 	case 1:
		 		setState(5812)
		 		try combinableCondition()

		 		break
		 	case 2:
		 		setState(5814); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(5813)
		 				try abbreviation()


		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(5816); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,910,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CombinableConditionContext: ParserRuleContext {
			open
			func simpleCondition() -> SimpleConditionContext? {
				return getRuleContext(SimpleConditionContext.self, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_combinableCondition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCombinableCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCombinableCondition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCombinableCondition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCombinableCondition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func combinableCondition() throws -> CombinableConditionContext {
		var _localctx: CombinableConditionContext = CombinableConditionContext(_ctx, getState())
		try enterRule(_localctx, 1050, Cobol85Parser.RULE_combinableCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5821)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.NOT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5820)
		 		try match(Cobol85Parser.Tokens.NOT.rawValue)

		 	}

		 	setState(5823)
		 	try simpleCondition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SimpleConditionContext: ParserRuleContext {
			open
			func LPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, 0)
			}
			open
			func condition() -> ConditionContext? {
				return getRuleContext(ConditionContext.self, 0)
			}
			open
			func RPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, 0)
			}
			open
			func relationCondition() -> RelationConditionContext? {
				return getRuleContext(RelationConditionContext.self, 0)
			}
			open
			func classCondition() -> ClassConditionContext? {
				return getRuleContext(ClassConditionContext.self, 0)
			}
			open
			func conditionNameReference() -> ConditionNameReferenceContext? {
				return getRuleContext(ConditionNameReferenceContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_simpleCondition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSimpleCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSimpleCondition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSimpleCondition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSimpleCondition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func simpleCondition() throws -> SimpleConditionContext {
		var _localctx: SimpleConditionContext = SimpleConditionContext(_ctx, getState())
		try enterRule(_localctx, 1052, Cobol85Parser.RULE_simpleCondition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5832)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,913, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5825)
		 		try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
		 		setState(5826)
		 		try condition()
		 		setState(5827)
		 		try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5829)
		 		try relationCondition()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5830)
		 		try classCondition()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5831)
		 		try conditionNameReference()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClassConditionContext: ParserRuleContext {
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func NUMERIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMERIC.rawValue, 0)
			}
			open
			func ALPHABETIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHABETIC.rawValue, 0)
			}
			open
			func ALPHABETIC_LOWER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHABETIC_LOWER.rawValue, 0)
			}
			open
			func ALPHABETIC_UPPER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALPHABETIC_UPPER.rawValue, 0)
			}
			open
			func DBCS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DBCS.rawValue, 0)
			}
			open
			func KANJI() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KANJI.rawValue, 0)
			}
			open
			func className() -> ClassNameContext? {
				return getRuleContext(ClassNameContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_classCondition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterClassCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitClassCondition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitClassCondition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitClassCondition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func classCondition() throws -> ClassConditionContext {
		var _localctx: ClassConditionContext = ClassConditionContext(_ctx, getState())
		try enterRule(_localctx, 1054, Cobol85Parser.RULE_classCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5834)
		 	try identifier()
		 	setState(5836)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5835)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(5839)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.NOT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5838)
		 		try match(Cobol85Parser.Tokens.NOT.rawValue)

		 	}

		 	setState(5848)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NUMERIC:
		 		setState(5841)
		 		try match(Cobol85Parser.Tokens.NUMERIC.rawValue)

		 		break

		 	case .ALPHABETIC:
		 		setState(5842)
		 		try match(Cobol85Parser.Tokens.ALPHABETIC.rawValue)

		 		break

		 	case .ALPHABETIC_LOWER:
		 		setState(5843)
		 		try match(Cobol85Parser.Tokens.ALPHABETIC_LOWER.rawValue)

		 		break

		 	case .ALPHABETIC_UPPER:
		 		setState(5844)
		 		try match(Cobol85Parser.Tokens.ALPHABETIC_UPPER.rawValue)

		 		break

		 	case .DBCS:
		 		setState(5845)
		 		try match(Cobol85Parser.Tokens.DBCS.rawValue)

		 		break

		 	case .KANJI:
		 		setState(5846)
		 		try match(Cobol85Parser.Tokens.KANJI.rawValue)

		 		break
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		setState(5847)
		 		try className()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConditionNameReferenceContext: ParserRuleContext {
			open
			func conditionName() -> ConditionNameContext? {
				return getRuleContext(ConditionNameContext.self, 0)
			}
			open
			func inData() -> [InDataContext] {
				return getRuleContexts(InDataContext.self)
			}
			open
			func inData(_ i: Int) -> InDataContext? {
				return getRuleContext(InDataContext.self, i)
			}
			open
			func inFile() -> InFileContext? {
				return getRuleContext(InFileContext.self, 0)
			}
			open
			func conditionNameSubscriptReference() -> [ConditionNameSubscriptReferenceContext] {
				return getRuleContexts(ConditionNameSubscriptReferenceContext.self)
			}
			open
			func conditionNameSubscriptReference(_ i: Int) -> ConditionNameSubscriptReferenceContext? {
				return getRuleContext(ConditionNameSubscriptReferenceContext.self, i)
			}
			open
			func inMnemonic() -> [InMnemonicContext] {
				return getRuleContexts(InMnemonicContext.self)
			}
			open
			func inMnemonic(_ i: Int) -> InMnemonicContext? {
				return getRuleContext(InMnemonicContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_conditionNameReference
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterConditionNameReference(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitConditionNameReference(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitConditionNameReference(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitConditionNameReference(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func conditionNameReference() throws -> ConditionNameReferenceContext {
		var _localctx: ConditionNameReferenceContext = ConditionNameReferenceContext(_ctx, getState())
		try enterRule(_localctx, 1056, Cobol85Parser.RULE_conditionNameReference)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5850)
		 	try conditionName()
		 	setState(5872)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,921, _ctx)) {
		 	case 1:
		 		setState(5854)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,917,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(5851)
		 				try inData()

		 		 
		 			}
		 			setState(5856)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,917,_ctx)
		 		}
		 		setState(5858)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.OF.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5857)
		 			try inFile()

		 		}

		 		setState(5863)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.LPARENCHAR.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5860)
		 			try conditionNameSubscriptReference()


		 			setState(5865)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		setState(5869)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.OF.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5866)
		 			try inMnemonic()


		 			setState(5871)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConditionNameSubscriptReferenceContext: ParserRuleContext {
			open
			func LPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, 0)
			}
			open
			func subscript() -> [SubscriptContext] {
				return getRuleContexts(SubscriptContext.self)
			}
			open
			func subscript(_ i: Int) -> SubscriptContext? {
				return getRuleContext(SubscriptContext.self, i)
			}
			open
			func RPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, 0)
			}
			open
			func COMMACHAR() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.COMMACHAR.rawValue)
			}
			open
			func COMMACHAR(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMACHAR.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_conditionNameSubscriptReference
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterConditionNameSubscriptReference(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitConditionNameSubscriptReference(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitConditionNameSubscriptReference(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitConditionNameSubscriptReference(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func conditionNameSubscriptReference() throws -> ConditionNameSubscriptReferenceContext {
		var _localctx: ConditionNameSubscriptReferenceContext = ConditionNameSubscriptReferenceContext(_ctx, getState())
		try enterRule(_localctx, 1058, Cobol85Parser.RULE_conditionNameSubscriptReference)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5874)
		 	try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
		 	setState(5875)
		 	try subscript()
		 	setState(5882)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue,Cobol85Parser.Tokens.COMMACHAR.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LPARENCHAR.rawValue,Cobol85Parser.Tokens.MINUSCHAR.rawValue,Cobol85Parser.Tokens.PLUSCHAR.rawValue,Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 542)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(5877)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMACHAR.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5876)
		 			try match(Cobol85Parser.Tokens.COMMACHAR.rawValue)

		 		}

		 		setState(5879)
		 		try subscript()


		 		setState(5884)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5885)
		 	try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RelationConditionContext: ParserRuleContext {
			open
			func relationSignCondition() -> RelationSignConditionContext? {
				return getRuleContext(RelationSignConditionContext.self, 0)
			}
			open
			func relationArithmeticComparison() -> RelationArithmeticComparisonContext? {
				return getRuleContext(RelationArithmeticComparisonContext.self, 0)
			}
			open
			func relationCombinedComparison() -> RelationCombinedComparisonContext? {
				return getRuleContext(RelationCombinedComparisonContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_relationCondition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRelationCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRelationCondition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRelationCondition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRelationCondition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func relationCondition() throws -> RelationConditionContext {
		var _localctx: RelationConditionContext = RelationConditionContext(_ctx, getState())
		try enterRule(_localctx, 1060, Cobol85Parser.RULE_relationCondition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5890)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,924, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5887)
		 		try relationSignCondition()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5888)
		 		try relationArithmeticComparison()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5889)
		 		try relationCombinedComparison()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RelationSignConditionContext: ParserRuleContext {
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
			open
			func POSITIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.POSITIVE.rawValue, 0)
			}
			open
			func NEGATIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NEGATIVE.rawValue, 0)
			}
			open
			func ZERO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZERO.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_relationSignCondition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRelationSignCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRelationSignCondition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRelationSignCondition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRelationSignCondition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func relationSignCondition() throws -> RelationSignConditionContext {
		var _localctx: RelationSignConditionContext = RelationSignConditionContext(_ctx, getState())
		try enterRule(_localctx, 1062, Cobol85Parser.RULE_relationSignCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5892)
		 	try arithmeticExpression()
		 	setState(5894)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5893)
		 		try match(Cobol85Parser.Tokens.IS.rawValue)

		 	}

		 	setState(5897)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.NOT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5896)
		 		try match(Cobol85Parser.Tokens.NOT.rawValue)

		 	}

		 	setState(5899)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.NEGATIVE.rawValue || _la == Cobol85Parser.Tokens.POSITIVE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.ZERO.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RelationArithmeticComparisonContext: ParserRuleContext {
			open
			func arithmeticExpression() -> [ArithmeticExpressionContext] {
				return getRuleContexts(ArithmeticExpressionContext.self)
			}
			open
			func arithmeticExpression(_ i: Int) -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, i)
			}
			open
			func relationalOperator() -> RelationalOperatorContext? {
				return getRuleContext(RelationalOperatorContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_relationArithmeticComparison
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRelationArithmeticComparison(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRelationArithmeticComparison(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRelationArithmeticComparison(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRelationArithmeticComparison(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func relationArithmeticComparison() throws -> RelationArithmeticComparisonContext {
		var _localctx: RelationArithmeticComparisonContext = RelationArithmeticComparisonContext(_ctx, getState())
		try enterRule(_localctx, 1064, Cobol85Parser.RULE_relationArithmeticComparison)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5901)
		 	try arithmeticExpression()
		 	setState(5902)
		 	try relationalOperator()
		 	setState(5903)
		 	try arithmeticExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RelationCombinedComparisonContext: ParserRuleContext {
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
			open
			func relationalOperator() -> RelationalOperatorContext? {
				return getRuleContext(RelationalOperatorContext.self, 0)
			}
			open
			func LPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, 0)
			}
			open
			func relationCombinedCondition() -> RelationCombinedConditionContext? {
				return getRuleContext(RelationCombinedConditionContext.self, 0)
			}
			open
			func RPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_relationCombinedComparison
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRelationCombinedComparison(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRelationCombinedComparison(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRelationCombinedComparison(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRelationCombinedComparison(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func relationCombinedComparison() throws -> RelationCombinedComparisonContext {
		var _localctx: RelationCombinedComparisonContext = RelationCombinedComparisonContext(_ctx, getState())
		try enterRule(_localctx, 1066, Cobol85Parser.RULE_relationCombinedComparison)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5905)
		 	try arithmeticExpression()
		 	setState(5906)
		 	try relationalOperator()
		 	setState(5907)
		 	try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
		 	setState(5908)
		 	try relationCombinedCondition()
		 	setState(5909)
		 	try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RelationCombinedConditionContext: ParserRuleContext {
			open
			func arithmeticExpression() -> [ArithmeticExpressionContext] {
				return getRuleContexts(ArithmeticExpressionContext.self)
			}
			open
			func arithmeticExpression(_ i: Int) -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, i)
			}
			open
			func AND() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.AND.rawValue)
			}
			open
			func AND(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AND.rawValue, i)
			}
			open
			func OR() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.OR.rawValue)
			}
			open
			func OR(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OR.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_relationCombinedCondition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRelationCombinedCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRelationCombinedCondition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRelationCombinedCondition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRelationCombinedCondition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func relationCombinedCondition() throws -> RelationCombinedConditionContext {
		var _localctx: RelationCombinedConditionContext = RelationCombinedConditionContext(_ctx, getState())
		try enterRule(_localctx, 1068, Cobol85Parser.RULE_relationCombinedCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5911)
		 	try arithmeticExpression()
		 	setState(5914) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(5912)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.AND.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.OR.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5913)
		 		try arithmeticExpression()


		 		setState(5916); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.AND.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.OR.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RelationalOperatorContext: ParserRuleContext {
			open
			func NOTEQUALCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOTEQUALCHAR.rawValue, 0)
			}
			open
			func GREATER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GREATER.rawValue, 0)
			}
			open
			func OR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OR.rawValue, 0)
			}
			open
			func EQUAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EQUAL.rawValue, 0)
			}
			open
			func MORETHANOREQUAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MORETHANOREQUAL.rawValue, 0)
			}
			open
			func LESS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LESS.rawValue, 0)
			}
			open
			func LESSTHANOREQUAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LESSTHANOREQUAL.rawValue, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IS.rawValue, 0)
			}
			open
			func ARE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ARE.rawValue, 0)
			}
			open
			func MORETHANCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MORETHANCHAR.rawValue, 0)
			}
			open
			func LESSTHANCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LESSTHANCHAR.rawValue, 0)
			}
			open
			func EQUALCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EQUALCHAR.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
			open
			func THAN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THAN.rawValue, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TO.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_relationalOperator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRelationalOperator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRelationalOperator(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRelationalOperator(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRelationalOperator(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func relationalOperator() throws -> RelationalOperatorContext {
		var _localctx: RelationalOperatorContext = RelationalOperatorContext(_ctx, getState())
		try enterRule(_localctx, 1070, Cobol85Parser.RULE_relationalOperator)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5919)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ARE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5918)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.ARE.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.IS.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(5962)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,938, _ctx)) {
		 	case 1:
		 		setState(5922)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.NOT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5921)
		 			try match(Cobol85Parser.Tokens.NOT.rawValue)

		 		}

		 		setState(5939)
		 		try _errHandler.sync(self)
		 		switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .GREATER:
		 			setState(5924)
		 			try match(Cobol85Parser.Tokens.GREATER.rawValue)
		 			setState(5926)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.THAN.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(5925)
		 				try match(Cobol85Parser.Tokens.THAN.rawValue)

		 			}


		 			break

		 		case .MORETHANCHAR:
		 			setState(5928)
		 			try match(Cobol85Parser.Tokens.MORETHANCHAR.rawValue)

		 			break

		 		case .LESS:
		 			setState(5929)
		 			try match(Cobol85Parser.Tokens.LESS.rawValue)
		 			setState(5931)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.THAN.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(5930)
		 				try match(Cobol85Parser.Tokens.THAN.rawValue)

		 			}


		 			break

		 		case .LESSTHANCHAR:
		 			setState(5933)
		 			try match(Cobol85Parser.Tokens.LESSTHANCHAR.rawValue)

		 			break

		 		case .EQUAL:
		 			setState(5934)
		 			try match(Cobol85Parser.Tokens.EQUAL.rawValue)
		 			setState(5936)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(5935)
		 				try match(Cobol85Parser.Tokens.TO.rawValue)

		 			}


		 			break

		 		case .EQUALCHAR:
		 			setState(5938)
		 			try match(Cobol85Parser.Tokens.EQUALCHAR.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 2:
		 		setState(5941)
		 		try match(Cobol85Parser.Tokens.NOTEQUALCHAR.rawValue)

		 		break
		 	case 3:
		 		setState(5942)
		 		try match(Cobol85Parser.Tokens.GREATER.rawValue)
		 		setState(5944)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.THAN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5943)
		 			try match(Cobol85Parser.Tokens.THAN.rawValue)

		 		}

		 		setState(5946)
		 		try match(Cobol85Parser.Tokens.OR.rawValue)
		 		setState(5947)
		 		try match(Cobol85Parser.Tokens.EQUAL.rawValue)
		 		setState(5949)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5948)
		 			try match(Cobol85Parser.Tokens.TO.rawValue)

		 		}


		 		break
		 	case 4:
		 		setState(5951)
		 		try match(Cobol85Parser.Tokens.MORETHANOREQUAL.rawValue)

		 		break
		 	case 5:
		 		setState(5952)
		 		try match(Cobol85Parser.Tokens.LESS.rawValue)
		 		setState(5954)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.THAN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5953)
		 			try match(Cobol85Parser.Tokens.THAN.rawValue)

		 		}

		 		setState(5956)
		 		try match(Cobol85Parser.Tokens.OR.rawValue)
		 		setState(5957)
		 		try match(Cobol85Parser.Tokens.EQUAL.rawValue)
		 		setState(5959)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.TO.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5958)
		 			try match(Cobol85Parser.Tokens.TO.rawValue)

		 		}


		 		break
		 	case 6:
		 		setState(5961)
		 		try match(Cobol85Parser.Tokens.LESSTHANOREQUAL.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AbbreviationContext: ParserRuleContext {
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
			open
			func LPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, 0)
			}
			open
			func abbreviation() -> AbbreviationContext? {
				return getRuleContext(AbbreviationContext.self, 0)
			}
			open
			func RPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NOT.rawValue, 0)
			}
			open
			func relationalOperator() -> RelationalOperatorContext? {
				return getRuleContext(RelationalOperatorContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_abbreviation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAbbreviation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAbbreviation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAbbreviation(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAbbreviation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func abbreviation() throws -> AbbreviationContext {
		var _localctx: AbbreviationContext = AbbreviationContext(_ctx, getState())
		try enterRule(_localctx, 1072, Cobol85Parser.RULE_abbreviation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5965)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,939,_ctx)) {
		 	case 1:
		 		setState(5964)
		 		try match(Cobol85Parser.Tokens.NOT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(5968)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.ARE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.EQUAL.rawValue || _la == Cobol85Parser.Tokens.GREATER.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.IS.rawValue,Cobol85Parser.Tokens.LESS.rawValue,Cobol85Parser.Tokens.NOT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 254)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EQUALCHAR.rawValue,Cobol85Parser.Tokens.LESSTHANCHAR.rawValue,Cobol85Parser.Tokens.LESSTHANOREQUAL.rawValue,Cobol85Parser.Tokens.MORETHANCHAR.rawValue,Cobol85Parser.Tokens.MORETHANOREQUAL.rawValue,Cobol85Parser.Tokens.NOTEQUALCHAR.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 536)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(5967)
		 		try relationalOperator()

		 	}

		 	setState(5976)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,941, _ctx)) {
		 	case 1:
		 		setState(5970)
		 		try arithmeticExpression()

		 		break
		 	case 2:
		 		setState(5971)
		 		try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
		 		setState(5972)
		 		try arithmeticExpression()
		 		setState(5973)
		 		try abbreviation()
		 		setState(5974)
		 		try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IdentifierContext: ParserRuleContext {
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func tableCall() -> TableCallContext? {
				return getRuleContext(TableCallContext.self, 0)
			}
			open
			func functionCall() -> FunctionCallContext? {
				return getRuleContext(FunctionCallContext.self, 0)
			}
			open
			func specialRegister() -> SpecialRegisterContext? {
				return getRuleContext(SpecialRegisterContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_identifier
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterIdentifier(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitIdentifier(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitIdentifier(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitIdentifier(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func identifier() throws -> IdentifierContext {
		var _localctx: IdentifierContext = IdentifierContext(_ctx, getState())
		try enterRule(_localctx, 1074, Cobol85Parser.RULE_identifier)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5982)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,942, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5978)
		 		try qualifiedDataName()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5979)
		 		try tableCall()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5980)
		 		try functionCall()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5981)
		 		try specialRegister()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TableCallContext: ParserRuleContext {
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func LPARENCHAR() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
			}
			open
			func LPARENCHAR(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, i)
			}
			open
			func subscript() -> [SubscriptContext] {
				return getRuleContexts(SubscriptContext.self)
			}
			open
			func subscript(_ i: Int) -> SubscriptContext? {
				return getRuleContext(SubscriptContext.self, i)
			}
			open
			func RPARENCHAR() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.RPARENCHAR.rawValue)
			}
			open
			func RPARENCHAR(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, i)
			}
			open
			func referenceModifier() -> ReferenceModifierContext? {
				return getRuleContext(ReferenceModifierContext.self, 0)
			}
			open
			func COMMACHAR() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.COMMACHAR.rawValue)
			}
			open
			func COMMACHAR(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMACHAR.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_tableCall
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterTableCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitTableCall(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitTableCall(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitTableCall(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func tableCall() throws -> TableCallContext {
		var _localctx: TableCallContext = TableCallContext(_ctx, getState())
		try enterRule(_localctx, 1076, Cobol85Parser.RULE_tableCall)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5984)
		 	try qualifiedDataName()
		 	setState(6000)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,945,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5985)
		 			try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
		 			setState(5986)
		 			try subscript()
		 			setState(5993)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 68)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 138)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 202)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 268)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 336)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 401)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue,Cobol85Parser.Tokens.COMMACHAR.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 466)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LPARENCHAR.rawValue,Cobol85Parser.Tokens.MINUSCHAR.rawValue,Cobol85Parser.Tokens.PLUSCHAR.rawValue,Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 542)
		 			          }()
		 			      return testSet
		 			 }()) {
		 				setState(5988)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (//closure
		 				 { () -> Bool in
		 				      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMACHAR.rawValue
		 				      return testSet
		 				 }()) {
		 					setState(5987)
		 					try match(Cobol85Parser.Tokens.COMMACHAR.rawValue)

		 				}

		 				setState(5990)
		 				try subscript()


		 				setState(5995)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(5996)
		 			try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		 	 
		 		}
		 		setState(6002)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,945,_ctx)
		 	}
		 	setState(6004)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,946,_ctx)) {
		 	case 1:
		 		setState(6003)
		 		try referenceModifier()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FunctionCallContext: ParserRuleContext {
			open
			func FUNCTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FUNCTION.rawValue, 0)
			}
			open
			func functionName() -> FunctionNameContext? {
				return getRuleContext(FunctionNameContext.self, 0)
			}
			open
			func LPARENCHAR() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
			}
			open
			func LPARENCHAR(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, i)
			}
			open
			func argument() -> [ArgumentContext] {
				return getRuleContexts(ArgumentContext.self)
			}
			open
			func argument(_ i: Int) -> ArgumentContext? {
				return getRuleContext(ArgumentContext.self, i)
			}
			open
			func RPARENCHAR() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.RPARENCHAR.rawValue)
			}
			open
			func RPARENCHAR(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, i)
			}
			open
			func referenceModifier() -> ReferenceModifierContext? {
				return getRuleContext(ReferenceModifierContext.self, 0)
			}
			open
			func COMMACHAR() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.COMMACHAR.rawValue)
			}
			open
			func COMMACHAR(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMACHAR.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_functionCall
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitFunctionCall(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitFunctionCall(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitFunctionCall(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func functionCall() throws -> FunctionCallContext {
		var _localctx: FunctionCallContext = FunctionCallContext(_ctx, getState())
		try enterRule(_localctx, 1078, Cobol85Parser.RULE_functionCall)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6006)
		 	try match(Cobol85Parser.Tokens.FUNCTION.rawValue)
		 	setState(6007)
		 	try functionName()
		 	setState(6023)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,949,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(6008)
		 			try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
		 			setState(6009)
		 			try argument()
		 			setState(6016)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 68)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 138)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 202)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 268)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 336)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 401)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue,Cobol85Parser.Tokens.COMMACHAR.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 466)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LPARENCHAR.rawValue,Cobol85Parser.Tokens.MINUSCHAR.rawValue,Cobol85Parser.Tokens.PLUSCHAR.rawValue,Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 542)
		 			          }()
		 			      return testSet
		 			 }()) {
		 				setState(6011)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (//closure
		 				 { () -> Bool in
		 				      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMACHAR.rawValue
		 				      return testSet
		 				 }()) {
		 					setState(6010)
		 					try match(Cobol85Parser.Tokens.COMMACHAR.rawValue)

		 				}

		 				setState(6013)
		 				try argument()


		 				setState(6018)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(6019)
		 			try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		 	 
		 		}
		 		setState(6025)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,949,_ctx)
		 	}
		 	setState(6027)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,950,_ctx)) {
		 	case 1:
		 		setState(6026)
		 		try referenceModifier()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReferenceModifierContext: ParserRuleContext {
			open
			func LPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, 0)
			}
			open
			func characterPosition() -> CharacterPositionContext? {
				return getRuleContext(CharacterPositionContext.self, 0)
			}
			open
			func COLONCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COLONCHAR.rawValue, 0)
			}
			open
			func RPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, 0)
			}
			open
			func length() -> LengthContext? {
				return getRuleContext(LengthContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_referenceModifier
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReferenceModifier(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReferenceModifier(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReferenceModifier(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReferenceModifier(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func referenceModifier() throws -> ReferenceModifierContext {
		var _localctx: ReferenceModifierContext = ReferenceModifierContext(_ctx, getState())
		try enterRule(_localctx, 1080, Cobol85Parser.RULE_referenceModifier)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6029)
		 	try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
		 	setState(6030)
		 	try characterPosition()
		 	setState(6031)
		 	try match(Cobol85Parser.Tokens.COLONCHAR.rawValue)
		 	setState(6033)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.ADDRESS.rawValue,Cobol85Parser.Tokens.ALL.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DATE.rawValue,Cobol85Parser.Tokens.DAY.rawValue,Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue,Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue,Cobol85Parser.Tokens.DEBUG_ITEM.rawValue,Cobol85Parser.Tokens.DEBUG_LINE.rawValue,Cobol85Parser.Tokens.DEBUG_NAME.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue,Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FALSE.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTION.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.HIGH_VALUE.rawValue,Cobol85Parser.Tokens.HIGH_VALUES.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue,Cobol85Parser.Tokens.LINE_COUNTER.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.LOW_VALUE.rawValue,Cobol85Parser.Tokens.LOW_VALUES.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NULL.rawValue,Cobol85Parser.Tokens.NULLS.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PAGE_COUNTER.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.QUOTE.rawValue,Cobol85Parser.Tokens.QUOTES.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.RETURN_CODE.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHIFT_IN.rawValue,Cobol85Parser.Tokens.SHIFT_OUT.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue,Cobol85Parser.Tokens.SORT_CONTROL.rawValue,Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_MESSAGE.rawValue,Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue,Cobol85Parser.Tokens.SORT_RETURN.rawValue,Cobol85Parser.Tokens.SPACE.rawValue,Cobol85Parser.Tokens.SPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TALLY.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIME.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUE.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.WHEN_COMPILED.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue,Cobol85Parser.Tokens.ZEROS.rawValue,Cobol85Parser.Tokens.ZEROES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LPARENCHAR.rawValue,Cobol85Parser.Tokens.MINUSCHAR.rawValue,Cobol85Parser.Tokens.PLUSCHAR.rawValue,Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue,Cobol85Parser.Tokens.NUMERICLITERAL.rawValue,Cobol85Parser.Tokens.IDENTIFIER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 542)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6032)
		 		try length()

		 	}

		 	setState(6035)
		 	try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CharacterPositionContext: ParserRuleContext {
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_characterPosition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCharacterPosition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCharacterPosition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCharacterPosition(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCharacterPosition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func characterPosition() throws -> CharacterPositionContext {
		var _localctx: CharacterPositionContext = CharacterPositionContext(_ctx, getState())
		try enterRule(_localctx, 1082, Cobol85Parser.RULE_characterPosition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6037)
		 	try arithmeticExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LengthContext: ParserRuleContext {
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_length
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLength(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLength(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLength(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLength(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func length() throws -> LengthContext {
		var _localctx: LengthContext = LengthContext(_ctx, getState())
		try enterRule(_localctx, 1084, Cobol85Parser.RULE_length)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6039)
		 	try arithmeticExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubscriptContext: ParserRuleContext {
			open
			func ALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALL.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func indexName() -> IndexNameContext? {
				return getRuleContext(IndexNameContext.self, 0)
			}
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_subscript
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSubscript(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSubscript(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSubscript(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSubscript(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subscript() throws -> SubscriptContext {
		var _localctx: SubscriptContext = SubscriptContext(_ctx, getState())
		try enterRule(_localctx, 1086, Cobol85Parser.RULE_subscript)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6052)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,954, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6041)
		 		try match(Cobol85Parser.Tokens.ALL.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6042)
		 		try integerLiteral()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6043)
		 		try qualifiedDataName()
		 		setState(6045)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,952,_ctx)) {
		 		case 1:
		 			setState(6044)
		 			try integerLiteral()

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6047)
		 		try indexName()
		 		setState(6049)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,953,_ctx)) {
		 		case 1:
		 			setState(6048)
		 			try integerLiteral()

		 			break
		 		default: break
		 		}

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6051)
		 		try arithmeticExpression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ArgumentContext: ParserRuleContext {
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
			open
			func indexName() -> IndexNameContext? {
				return getRuleContext(IndexNameContext.self, 0)
			}
			open
			func arithmeticExpression() -> ArithmeticExpressionContext? {
				return getRuleContext(ArithmeticExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_argument
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterArgument(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitArgument(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitArgument(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitArgument(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func argument() throws -> ArgumentContext {
		var _localctx: ArgumentContext = ArgumentContext(_ctx, getState())
		try enterRule(_localctx, 1088, Cobol85Parser.RULE_argument)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6065)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,957, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6054)
		 		try literal()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6055)
		 		try identifier()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6056)
		 		try qualifiedDataName()
		 		setState(6058)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,955,_ctx)) {
		 		case 1:
		 			setState(6057)
		 			try integerLiteral()

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6060)
		 		try indexName()
		 		setState(6062)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,956,_ctx)) {
		 		case 1:
		 			setState(6061)
		 			try integerLiteral()

		 			break
		 		default: break
		 		}

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6064)
		 		try arithmeticExpression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class QualifiedDataNameContext: ParserRuleContext {
			open
			func qualifiedDataNameFormat1() -> QualifiedDataNameFormat1Context? {
				return getRuleContext(QualifiedDataNameFormat1Context.self, 0)
			}
			open
			func qualifiedDataNameFormat2() -> QualifiedDataNameFormat2Context? {
				return getRuleContext(QualifiedDataNameFormat2Context.self, 0)
			}
			open
			func qualifiedDataNameFormat3() -> QualifiedDataNameFormat3Context? {
				return getRuleContext(QualifiedDataNameFormat3Context.self, 0)
			}
			open
			func qualifiedDataNameFormat4() -> QualifiedDataNameFormat4Context? {
				return getRuleContext(QualifiedDataNameFormat4Context.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_qualifiedDataName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterQualifiedDataName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitQualifiedDataName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitQualifiedDataName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitQualifiedDataName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func qualifiedDataName() throws -> QualifiedDataNameContext {
		var _localctx: QualifiedDataNameContext = QualifiedDataNameContext(_ctx, getState())
		try enterRule(_localctx, 1090, Cobol85Parser.RULE_qualifiedDataName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6071)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,958, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6067)
		 		try qualifiedDataNameFormat1()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6068)
		 		try qualifiedDataNameFormat2()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6069)
		 		try qualifiedDataNameFormat3()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6070)
		 		try qualifiedDataNameFormat4()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class QualifiedDataNameFormat1Context: ParserRuleContext {
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func conditionName() -> ConditionNameContext? {
				return getRuleContext(ConditionNameContext.self, 0)
			}
			open
			func inFile() -> InFileContext? {
				return getRuleContext(InFileContext.self, 0)
			}
			open
			func qualifiedInData() -> [QualifiedInDataContext] {
				return getRuleContexts(QualifiedInDataContext.self)
			}
			open
			func qualifiedInData(_ i: Int) -> QualifiedInDataContext? {
				return getRuleContext(QualifiedInDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_qualifiedDataNameFormat1
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterQualifiedDataNameFormat1(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitQualifiedDataNameFormat1(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitQualifiedDataNameFormat1(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitQualifiedDataNameFormat1(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func qualifiedDataNameFormat1() throws -> QualifiedDataNameFormat1Context {
		var _localctx: QualifiedDataNameFormat1Context = QualifiedDataNameFormat1Context(_ctx, getState())
		try enterRule(_localctx, 1092, Cobol85Parser.RULE_qualifiedDataNameFormat1)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6075)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,959, _ctx)) {
		 	case 1:
		 		setState(6073)
		 		try dataName()

		 		break
		 	case 2:
		 		setState(6074)
		 		try conditionName()

		 		break
		 	default: break
		 	}
		 	setState(6086)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,962,_ctx)) {
		 	case 1:
		 		setState(6078); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(6077)
		 				try qualifiedInData()


		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(6080); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,960,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 		setState(6083)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,961,_ctx)) {
		 		case 1:
		 			setState(6082)
		 			try inFile()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		setState(6085)
		 		try inFile()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class QualifiedDataNameFormat2Context: ParserRuleContext {
			open
			func paragraphName() -> ParagraphNameContext? {
				return getRuleContext(ParagraphNameContext.self, 0)
			}
			open
			func inSection() -> InSectionContext? {
				return getRuleContext(InSectionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_qualifiedDataNameFormat2
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterQualifiedDataNameFormat2(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitQualifiedDataNameFormat2(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitQualifiedDataNameFormat2(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitQualifiedDataNameFormat2(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func qualifiedDataNameFormat2() throws -> QualifiedDataNameFormat2Context {
		var _localctx: QualifiedDataNameFormat2Context = QualifiedDataNameFormat2Context(_ctx, getState())
		try enterRule(_localctx, 1094, Cobol85Parser.RULE_qualifiedDataNameFormat2)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6088)
		 	try paragraphName()
		 	setState(6089)
		 	try inSection()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class QualifiedDataNameFormat3Context: ParserRuleContext {
			open
			func textName() -> TextNameContext? {
				return getRuleContext(TextNameContext.self, 0)
			}
			open
			func inLibrary() -> InLibraryContext? {
				return getRuleContext(InLibraryContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_qualifiedDataNameFormat3
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterQualifiedDataNameFormat3(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitQualifiedDataNameFormat3(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitQualifiedDataNameFormat3(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitQualifiedDataNameFormat3(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func qualifiedDataNameFormat3() throws -> QualifiedDataNameFormat3Context {
		var _localctx: QualifiedDataNameFormat3Context = QualifiedDataNameFormat3Context(_ctx, getState())
		try enterRule(_localctx, 1096, Cobol85Parser.RULE_qualifiedDataNameFormat3)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6091)
		 	try textName()
		 	setState(6092)
		 	try inLibrary()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class QualifiedDataNameFormat4Context: ParserRuleContext {
			open
			func LINAGE_COUNTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue, 0)
			}
			open
			func inFile() -> InFileContext? {
				return getRuleContext(InFileContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_qualifiedDataNameFormat4
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterQualifiedDataNameFormat4(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitQualifiedDataNameFormat4(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitQualifiedDataNameFormat4(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitQualifiedDataNameFormat4(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func qualifiedDataNameFormat4() throws -> QualifiedDataNameFormat4Context {
		var _localctx: QualifiedDataNameFormat4Context = QualifiedDataNameFormat4Context(_ctx, getState())
		try enterRule(_localctx, 1098, Cobol85Parser.RULE_qualifiedDataNameFormat4)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6094)
		 	try match(Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue)
		 	setState(6095)
		 	try inFile()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class QualifiedInDataContext: ParserRuleContext {
			open
			func inData() -> InDataContext? {
				return getRuleContext(InDataContext.self, 0)
			}
			open
			func inTable() -> InTableContext? {
				return getRuleContext(InTableContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_qualifiedInData
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterQualifiedInData(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitQualifiedInData(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitQualifiedInData(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitQualifiedInData(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func qualifiedInData() throws -> QualifiedInDataContext {
		var _localctx: QualifiedInDataContext = QualifiedInDataContext(_ctx, getState())
		try enterRule(_localctx, 1100, Cobol85Parser.RULE_qualifiedInData)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6099)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,963, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6097)
		 		try inData()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6098)
		 		try inTable()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InDataContext: ParserRuleContext {
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inData
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInData(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInData(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInData(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInData(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inData() throws -> InDataContext {
		var _localctx: InDataContext = InDataContext(_ctx, getState())
		try enterRule(_localctx, 1102, Cobol85Parser.RULE_inData)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6101)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.OF.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(6102)
		 	try dataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InFileContext: ParserRuleContext {
			open
			func fileName() -> FileNameContext? {
				return getRuleContext(FileNameContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inFile
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInFile(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInFile(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInFile(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInFile(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inFile() throws -> InFileContext {
		var _localctx: InFileContext = InFileContext(_ctx, getState())
		try enterRule(_localctx, 1104, Cobol85Parser.RULE_inFile)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6104)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.OF.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(6105)
		 	try fileName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InMnemonicContext: ParserRuleContext {
			open
			func mnemonicName() -> MnemonicNameContext? {
				return getRuleContext(MnemonicNameContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inMnemonic
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInMnemonic(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInMnemonic(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInMnemonic(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInMnemonic(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inMnemonic() throws -> InMnemonicContext {
		var _localctx: InMnemonicContext = InMnemonicContext(_ctx, getState())
		try enterRule(_localctx, 1106, Cobol85Parser.RULE_inMnemonic)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6107)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.OF.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(6108)
		 	try mnemonicName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InSectionContext: ParserRuleContext {
			open
			func sectionName() -> SectionNameContext? {
				return getRuleContext(SectionNameContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInSection(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inSection() throws -> InSectionContext {
		var _localctx: InSectionContext = InSectionContext(_ctx, getState())
		try enterRule(_localctx, 1108, Cobol85Parser.RULE_inSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6110)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.OF.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(6111)
		 	try sectionName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InLibraryContext: ParserRuleContext {
			open
			func libraryName() -> LibraryNameContext? {
				return getRuleContext(LibraryNameContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inLibrary
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInLibrary(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInLibrary(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInLibrary(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInLibrary(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inLibrary() throws -> InLibraryContext {
		var _localctx: InLibraryContext = InLibraryContext(_ctx, getState())
		try enterRule(_localctx, 1110, Cobol85Parser.RULE_inLibrary)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6113)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.OF.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(6114)
		 	try libraryName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InTableContext: ParserRuleContext {
			open
			func tableCall() -> TableCallContext? {
				return getRuleContext(TableCallContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IN.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_inTable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterInTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitInTable(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitInTable(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitInTable(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inTable() throws -> InTableContext {
		var _localctx: InTableContext = InTableContext(_ctx, getState())
		try enterRule(_localctx, 1112, Cobol85Parser.RULE_inTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6116)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.OF.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(6117)
		 	try tableCall()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlphabetNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_alphabetName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAlphabetName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAlphabetName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAlphabetName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAlphabetName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func alphabetName() throws -> AlphabetNameContext {
		var _localctx: AlphabetNameContext = AlphabetNameContext(_ctx, getState())
		try enterRule(_localctx, 1114, Cobol85Parser.RULE_alphabetName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6119)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AssignmentNameContext: ParserRuleContext {
			open
			func systemName() -> SystemNameContext? {
				return getRuleContext(SystemNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_assignmentName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterAssignmentName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitAssignmentName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitAssignmentName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitAssignmentName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func assignmentName() throws -> AssignmentNameContext {
		var _localctx: AssignmentNameContext = AssignmentNameContext(_ctx, getState())
		try enterRule(_localctx, 1116, Cobol85Parser.RULE_assignmentName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6121)
		 	try systemName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BasisNameContext: ParserRuleContext {
			open
			func programName() -> ProgramNameContext? {
				return getRuleContext(ProgramNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_basisName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterBasisName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitBasisName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitBasisName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitBasisName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func basisName() throws -> BasisNameContext {
		var _localctx: BasisNameContext = BasisNameContext(_ctx, getState())
		try enterRule(_localctx, 1118, Cobol85Parser.RULE_basisName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6123)
		 	try programName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CdNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_cdName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCdName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCdName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCdName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCdName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cdName() throws -> CdNameContext {
		var _localctx: CdNameContext = CdNameContext(_ctx, getState())
		try enterRule(_localctx, 1120, Cobol85Parser.RULE_cdName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6125)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClassNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_className
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterClassName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitClassName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitClassName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitClassName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func className() throws -> ClassNameContext {
		var _localctx: ClassNameContext = ClassNameContext(_ctx, getState())
		try enterRule(_localctx, 1122, Cobol85Parser.RULE_className)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6127)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ComputerNameContext: ParserRuleContext {
			open
			func systemName() -> SystemNameContext? {
				return getRuleContext(SystemNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_computerName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterComputerName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitComputerName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitComputerName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitComputerName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func computerName() throws -> ComputerNameContext {
		var _localctx: ComputerNameContext = ComputerNameContext(_ctx, getState())
		try enterRule(_localctx, 1124, Cobol85Parser.RULE_computerName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6129)
		 	try systemName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConditionNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_conditionName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterConditionName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitConditionName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitConditionName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitConditionName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func conditionName() throws -> ConditionNameContext {
		var _localctx: ConditionNameContext = ConditionNameContext(_ctx, getState())
		try enterRule(_localctx, 1126, Cobol85Parser.RULE_conditionName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6131)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataName() throws -> DataNameContext {
		var _localctx: DataNameContext = DataNameContext(_ctx, getState())
		try enterRule(_localctx, 1128, Cobol85Parser.RULE_dataName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6133)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataDescNameContext: ParserRuleContext {
			open
			func FILLER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FILLER.rawValue, 0)
			}
			open
			func CURSOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CURSOR.rawValue, 0)
			}
			open
			func dataName() -> DataNameContext? {
				return getRuleContext(DataNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_dataDescName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterDataDescName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitDataDescName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitDataDescName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitDataDescName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataDescName() throws -> DataDescNameContext {
		var _localctx: DataDescNameContext = DataDescNameContext(_ctx, getState())
		try enterRule(_localctx, 1130, Cobol85Parser.RULE_dataDescName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6138)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,964, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6135)
		 		try match(Cobol85Parser.Tokens.FILLER.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6136)
		 		try match(Cobol85Parser.Tokens.CURSOR.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6137)
		 		try dataName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EnvironmentNameContext: ParserRuleContext {
			open
			func systemName() -> SystemNameContext? {
				return getRuleContext(SystemNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_environmentName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterEnvironmentName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitEnvironmentName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitEnvironmentName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitEnvironmentName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func environmentName() throws -> EnvironmentNameContext {
		var _localctx: EnvironmentNameContext = EnvironmentNameContext(_ctx, getState())
		try enterRule(_localctx, 1132, Cobol85Parser.RULE_environmentName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6140)
		 	try systemName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FileNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_fileName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterFileName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitFileName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitFileName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitFileName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fileName() throws -> FileNameContext {
		var _localctx: FileNameContext = FileNameContext(_ctx, getState())
		try enterRule(_localctx, 1134, Cobol85Parser.RULE_fileName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6142)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FunctionNameContext: ParserRuleContext {
			open
			func INTEGER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTEGER.rawValue, 0)
			}
			open
			func LENGTH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LENGTH.rawValue, 0)
			}
			open
			func RANDOM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RANDOM.rawValue, 0)
			}
			open
			func SUM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SUM.rawValue, 0)
			}
			open
			func WHEN_COMPILED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WHEN_COMPILED.rawValue, 0)
			}
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_functionName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterFunctionName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitFunctionName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitFunctionName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitFunctionName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func functionName() throws -> FunctionNameContext {
		var _localctx: FunctionNameContext = FunctionNameContext(_ctx, getState())
		try enterRule(_localctx, 1136, Cobol85Parser.RULE_functionName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6150)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,965, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6144)
		 		try match(Cobol85Parser.Tokens.INTEGER.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6145)
		 		try match(Cobol85Parser.Tokens.LENGTH.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6146)
		 		try match(Cobol85Parser.Tokens.RANDOM.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6147)
		 		try match(Cobol85Parser.Tokens.SUM.rawValue)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6148)
		 		try match(Cobol85Parser.Tokens.WHEN_COMPILED.rawValue)

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6149)
		 		try cobolWord()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_indexName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterIndexName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitIndexName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitIndexName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitIndexName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func indexName() throws -> IndexNameContext {
		var _localctx: IndexNameContext = IndexNameContext(_ctx, getState())
		try enterRule(_localctx, 1138, Cobol85Parser.RULE_indexName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6152)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LanguageNameContext: ParserRuleContext {
			open
			func systemName() -> SystemNameContext? {
				return getRuleContext(SystemNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_languageName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLanguageName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLanguageName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLanguageName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLanguageName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func languageName() throws -> LanguageNameContext {
		var _localctx: LanguageNameContext = LanguageNameContext(_ctx, getState())
		try enterRule(_localctx, 1140, Cobol85Parser.RULE_languageName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6154)
		 	try systemName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_libraryName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLibraryName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLibraryName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLibraryName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLibraryName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryName() throws -> LibraryNameContext {
		var _localctx: LibraryNameContext = LibraryNameContext(_ctx, getState())
		try enterRule(_localctx, 1142, Cobol85Parser.RULE_libraryName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6156)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LocalNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_localName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLocalName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLocalName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLocalName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLocalName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func localName() throws -> LocalNameContext {
		var _localctx: LocalNameContext = LocalNameContext(_ctx, getState())
		try enterRule(_localctx, 1144, Cobol85Parser.RULE_localName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6158)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MnemonicNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_mnemonicName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterMnemonicName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitMnemonicName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitMnemonicName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitMnemonicName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mnemonicName() throws -> MnemonicNameContext {
		var _localctx: MnemonicNameContext = MnemonicNameContext(_ctx, getState())
		try enterRule(_localctx, 1146, Cobol85Parser.RULE_mnemonicName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6160)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ParagraphNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_paragraphName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterParagraphName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitParagraphName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitParagraphName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitParagraphName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func paragraphName() throws -> ParagraphNameContext {
		var _localctx: ParagraphNameContext = ParagraphNameContext(_ctx, getState())
		try enterRule(_localctx, 1148, Cobol85Parser.RULE_paragraphName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6164)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6162)
		 		try cobolWord()

		 		break
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6163)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureNameContext: ParserRuleContext {
			open
			func paragraphName() -> ParagraphNameContext? {
				return getRuleContext(ParagraphNameContext.self, 0)
			}
			open
			func inSection() -> InSectionContext? {
				return getRuleContext(InSectionContext.self, 0)
			}
			open
			func sectionName() -> SectionNameContext? {
				return getRuleContext(SectionNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_procedureName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProcedureName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProcedureName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProcedureName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProcedureName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func procedureName() throws -> ProcedureNameContext {
		var _localctx: ProcedureNameContext = ProcedureNameContext(_ctx, getState())
		try enterRule(_localctx, 1150, Cobol85Parser.RULE_procedureName)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6171)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,968, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6166)
		 		try paragraphName()
		 		setState(6168)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == Cobol85Parser.Tokens.IN.rawValue
		 		          testSet = testSet || _la == Cobol85Parser.Tokens.OF.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(6167)
		 			try inSection()

		 		}


		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6170)
		 		try sectionName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProgramNameContext: ParserRuleContext {
			open
			func NONNUMERICLITERAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue, 0)
			}
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_programName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterProgramName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitProgramName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitProgramName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitProgramName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func programName() throws -> ProgramNameContext {
		var _localctx: ProgramNameContext = ProgramNameContext(_ctx, getState())
		try enterRule(_localctx, 1152, Cobol85Parser.RULE_programName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6175)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NONNUMERICLITERAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6173)
		 		try match(Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue)

		 		break
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6174)
		 		try cobolWord()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RecordNameContext: ParserRuleContext {
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_recordName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRecordName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRecordName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRecordName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRecordName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func recordName() throws -> RecordNameContext {
		var _localctx: RecordNameContext = RecordNameContext(_ctx, getState())
		try enterRule(_localctx, 1154, Cobol85Parser.RULE_recordName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6177)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReportNameContext: ParserRuleContext {
			open
			func qualifiedDataName() -> QualifiedDataNameContext? {
				return getRuleContext(QualifiedDataNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_reportName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterReportName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitReportName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitReportName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitReportName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reportName() throws -> ReportNameContext {
		var _localctx: ReportNameContext = ReportNameContext(_ctx, getState())
		try enterRule(_localctx, 1156, Cobol85Parser.RULE_reportName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6179)
		 	try qualifiedDataName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RoutineNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_routineName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterRoutineName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitRoutineName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitRoutineName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitRoutineName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func routineName() throws -> RoutineNameContext {
		var _localctx: RoutineNameContext = RoutineNameContext(_ctx, getState())
		try enterRule(_localctx, 1158, Cobol85Parser.RULE_routineName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6181)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScreenNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_screenName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterScreenName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitScreenName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitScreenName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitScreenName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func screenName() throws -> ScreenNameContext {
		var _localctx: ScreenNameContext = ScreenNameContext(_ctx, getState())
		try enterRule(_localctx, 1160, Cobol85Parser.RULE_screenName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6183)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SectionNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_sectionName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSectionName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSectionName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSectionName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSectionName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sectionName() throws -> SectionNameContext {
		var _localctx: SectionNameContext = SectionNameContext(_ctx, getState())
		try enterRule(_localctx, 1162, Cobol85Parser.RULE_sectionName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6187)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ABORT:fallthrough
		 	case .AS:fallthrough
		 	case .ASCII:fallthrough
		 	case .ASSOCIATED_DATA:fallthrough
		 	case .ASSOCIATED_DATA_LENGTH:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTO_SKIP:fallthrough
		 	case .BACKGROUND_COLOR:fallthrough
		 	case .BACKGROUND_COLOUR:fallthrough
		 	case .BEEP:fallthrough
		 	case .BELL:fallthrough
		 	case .BINARY:fallthrough
		 	case .BIT:fallthrough
		 	case .BLINK:fallthrough
		 	case .BOUNDS:fallthrough
		 	case .CAPABLE:fallthrough
		 	case .CCSVERSION:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CLOSE_DISPOSITION:fallthrough
		 	case .COBOL:fallthrough
		 	case .COMMITMENT:fallthrough
		 	case .CONTROL_POINT:fallthrough
		 	case .CONVENTION:fallthrough
		 	case .CRUNCH:fallthrough
		 	case .CURSOR:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULT_DISPLAY:fallthrough
		 	case .DEFINITION:fallthrough
		 	case .DFHRESP:fallthrough
		 	case .DFHVALUE:fallthrough
		 	case .DISK:fallthrough
		 	case .DONTCARE:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .EBCDIC:fallthrough
		 	case .EMPTY_CHECK:fallthrough
		 	case .ENTER:fallthrough
		 	case .ENTRY_PROCEDURE:fallthrough
		 	case .ERASE:fallthrough
		 	case .EOL:fallthrough
		 	case .EOS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVENT:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .FOREGROUND_COLOR:fallthrough
		 	case .FOREGROUND_COLOUR:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTIONNAME:fallthrough
		 	case .FUNCTION_POINTER:fallthrough
		 	case .GRID:fallthrough
		 	case .HIGHLIGHT:fallthrough
		 	case .IMPLICIT:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .KEPT:fallthrough
		 	case .KEYBOARD:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LB:fallthrough
		 	case .LD:fallthrough
		 	case .LEFTLINE:fallthrough
		 	case .LENGTH_CHECK:fallthrough
		 	case .LIBACCESS:fallthrough
		 	case .LIBPARAMETER:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LONG_DATE:fallthrough
		 	case .LONG_TIME:fallthrough
		 	case .LOWER:fallthrough
		 	case .LOWLIGHT:fallthrough
		 	case .MMDDYYYY:fallthrough
		 	case .NAMED:fallthrough
		 	case .NATIONAL:fallthrough
		 	case .NATIONAL_EDITED:fallthrough
		 	case .NETWORK:fallthrough
		 	case .NO_ECHO:fallthrough
		 	case .NUMERIC_DATE:fallthrough
		 	case .NUMERIC_TIME:fallthrough
		 	case .ODT:fallthrough
		 	case .ORDERLY:fallthrough
		 	case .OVERLINE:fallthrough
		 	case .OWN:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PORT:fallthrough
		 	case .PRINTER:fallthrough
		 	case .PRIVATE:fallthrough
		 	case .PROCESS:fallthrough
		 	case .PROGRAM:fallthrough
		 	case .PROMPT:fallthrough
		 	case .READER:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REAL:fallthrough
		 	case .RECEIVED:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REF:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REQUIRED:fallthrough
		 	case .REVERSE_VIDEO:fallthrough
		 	case .SAVE:fallthrough
		 	case .SECURE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SHAREDBYALL:fallthrough
		 	case .SHAREDBYRUNUNIT:fallthrough
		 	case .SHARING:fallthrough
		 	case .SHORT_DATE:fallthrough
		 	case .SYMBOL:fallthrough
		 	case .TASK:fallthrough
		 	case .THREAD:fallthrough
		 	case .THREAD_LOCAL:fallthrough
		 	case .TIMER:fallthrough
		 	case .TODAYS_DATE:fallthrough
		 	case .TODAYS_NAME:fallthrough
		 	case .TRUNCATED:fallthrough
		 	case .TYPEDEF:fallthrough
		 	case .UNDERLINE:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .WAIT:fallthrough
		 	case .YEAR:fallthrough
		 	case .YYYYMMDD:fallthrough
		 	case .YYYYDDD:fallthrough
		 	case .ZERO_FILL:fallthrough
		 	case .IDENTIFIER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6185)
		 		try cobolWord()

		 		break
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6186)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SystemNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_systemName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSystemName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSystemName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSystemName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSystemName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func systemName() throws -> SystemNameContext {
		var _localctx: SystemNameContext = SystemNameContext(_ctx, getState())
		try enterRule(_localctx, 1164, Cobol85Parser.RULE_systemName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6189)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolicCharacterContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_symbolicCharacter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSymbolicCharacter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSymbolicCharacter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSymbolicCharacter(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSymbolicCharacter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolicCharacter() throws -> SymbolicCharacterContext {
		var _localctx: SymbolicCharacterContext = SymbolicCharacterContext(_ctx, getState())
		try enterRule(_localctx, 1166, Cobol85Parser.RULE_symbolicCharacter)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6191)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TextNameContext: ParserRuleContext {
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_textName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterTextName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitTextName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitTextName(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitTextName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func textName() throws -> TextNameContext {
		var _localctx: TextNameContext = TextNameContext(_ctx, getState())
		try enterRule(_localctx, 1168, Cobol85Parser.RULE_textName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6193)
		 	try cobolWord()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CobolWordContext: ParserRuleContext {
			open
			func IDENTIFIER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IDENTIFIER.rawValue, 0)
			}
			open
			func COBOL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COBOL.rawValue, 0)
			}
			open
			func PROGRAM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROGRAM.rawValue, 0)
			}
			open
			func ABORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ABORT.rawValue, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AS.rawValue, 0)
			}
			open
			func ASCII() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASCII.rawValue, 0)
			}
			open
			func ASSOCIATED_DATA() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue, 0)
			}
			open
			func ASSOCIATED_DATA_LENGTH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue, 0)
			}
			open
			func ATTRIBUTE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ATTRIBUTE.rawValue, 0)
			}
			open
			func AUTO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AUTO.rawValue, 0)
			}
			open
			func AUTO_SKIP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.AUTO_SKIP.rawValue, 0)
			}
			open
			func BACKGROUND_COLOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue, 0)
			}
			open
			func BACKGROUND_COLOUR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue, 0)
			}
			open
			func BEEP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BEEP.rawValue, 0)
			}
			open
			func BELL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BELL.rawValue, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BINARY.rawValue, 0)
			}
			open
			func BIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BIT.rawValue, 0)
			}
			open
			func BLINK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BLINK.rawValue, 0)
			}
			open
			func BOUNDS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.BOUNDS.rawValue, 0)
			}
			open
			func CAPABLE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CAPABLE.rawValue, 0)
			}
			open
			func CCSVERSION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CCSVERSION.rawValue, 0)
			}
			open
			func CHANGED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHANGED.rawValue, 0)
			}
			open
			func CHANNEL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CHANNEL.rawValue, 0)
			}
			open
			func CLOSE_DISPOSITION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue, 0)
			}
			open
			func COMMITMENT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMITMENT.rawValue, 0)
			}
			open
			func CONTROL_POINT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONTROL_POINT.rawValue, 0)
			}
			open
			func CONVENTION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CONVENTION.rawValue, 0)
			}
			open
			func CRUNCH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CRUNCH.rawValue, 0)
			}
			open
			func CURSOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.CURSOR.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func DEFAULT_DISPLAY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue, 0)
			}
			open
			func DEFINITION() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEFINITION.rawValue, 0)
			}
			open
			func DFHRESP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DFHRESP.rawValue, 0)
			}
			open
			func DFHVALUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DFHVALUE.rawValue, 0)
			}
			open
			func DISK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DISK.rawValue, 0)
			}
			open
			func DONTCARE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DONTCARE.rawValue, 0)
			}
			open
			func DOUBLE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DOUBLE.rawValue, 0)
			}
			open
			func EBCDIC() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EBCDIC.rawValue, 0)
			}
			open
			func EMPTY_CHECK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EMPTY_CHECK.rawValue, 0)
			}
			open
			func ENTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ENTER.rawValue, 0)
			}
			open
			func ENTRY_PROCEDURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue, 0)
			}
			open
			func EOL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EOL.rawValue, 0)
			}
			open
			func EOS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EOS.rawValue, 0)
			}
			open
			func ERASE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ERASE.rawValue, 0)
			}
			open
			func ESCAPE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ESCAPE.rawValue, 0)
			}
			open
			func EVENT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EVENT.rawValue, 0)
			}
			open
			func EXCLUSIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXCLUSIVE.rawValue, 0)
			}
			open
			func EXPORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXPORT.rawValue, 0)
			}
			open
			func EXTENDED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.EXTENDED.rawValue, 0)
			}
			open
			func FOREGROUND_COLOR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue, 0)
			}
			open
			func FOREGROUND_COLOUR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue, 0)
			}
			open
			func FULL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FULL.rawValue, 0)
			}
			open
			func FUNCTIONNAME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FUNCTIONNAME.rawValue, 0)
			}
			open
			func FUNCTION_POINTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue, 0)
			}
			open
			func GRID() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.GRID.rawValue, 0)
			}
			open
			func HIGHLIGHT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.HIGHLIGHT.rawValue, 0)
			}
			open
			func IMPLICIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IMPLICIT.rawValue, 0)
			}
			open
			func IMPORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.IMPORT.rawValue, 0)
			}
			open
			func INTEGER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTEGER.rawValue, 0)
			}
			open
			func KEPT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEPT.rawValue, 0)
			}
			open
			func KEYBOARD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.KEYBOARD.rawValue, 0)
			}
			open
			func LANGUAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LANGUAGE.rawValue, 0)
			}
			open
			func LB() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LB.rawValue, 0)
			}
			open
			func LD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LD.rawValue, 0)
			}
			open
			func LEFTLINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEFTLINE.rawValue, 0)
			}
			open
			func LENGTH_CHECK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LENGTH_CHECK.rawValue, 0)
			}
			open
			func LIBACCESS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LIBACCESS.rawValue, 0)
			}
			open
			func LIBPARAMETER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LIBPARAMETER.rawValue, 0)
			}
			open
			func LIBRARY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LIBRARY.rawValue, 0)
			}
			open
			func LIST() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LIST.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOCAL.rawValue, 0)
			}
			open
			func LONG_DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LONG_DATE.rawValue, 0)
			}
			open
			func LONG_TIME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LONG_TIME.rawValue, 0)
			}
			open
			func LOWER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOWER.rawValue, 0)
			}
			open
			func LOWLIGHT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOWLIGHT.rawValue, 0)
			}
			open
			func MMDDYYYY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.MMDDYYYY.rawValue, 0)
			}
			open
			func NAMED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NAMED.rawValue, 0)
			}
			open
			func NATIONAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIONAL.rawValue, 0)
			}
			open
			func NATIONAL_EDITED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue, 0)
			}
			open
			func NETWORK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NETWORK.rawValue, 0)
			}
			open
			func NO_ECHO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NO_ECHO.rawValue, 0)
			}
			open
			func NUMERIC_DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMERIC_DATE.rawValue, 0)
			}
			open
			func NUMERIC_TIME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMERIC_TIME.rawValue, 0)
			}
			open
			func ODT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ODT.rawValue, 0)
			}
			open
			func ORDERLY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ORDERLY.rawValue, 0)
			}
			open
			func OVERLINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OVERLINE.rawValue, 0)
			}
			open
			func OWN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OWN.rawValue, 0)
			}
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PASSWORD.rawValue, 0)
			}
			open
			func PORT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PORT.rawValue, 0)
			}
			open
			func PRINTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PRINTER.rawValue, 0)
			}
			open
			func PRIVATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PRIVATE.rawValue, 0)
			}
			open
			func PROCESS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROCESS.rawValue, 0)
			}
			open
			func PROMPT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PROMPT.rawValue, 0)
			}
			open
			func READER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.READER.rawValue, 0)
			}
			open
			func REAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REAL.rawValue, 0)
			}
			open
			func RECEIVED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECEIVED.rawValue, 0)
			}
			open
			func RECURSIVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RECURSIVE.rawValue, 0)
			}
			open
			func REF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REF.rawValue, 0)
			}
			open
			func REMOTE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REMOTE.rawValue, 0)
			}
			open
			func REMOVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REMOVE.rawValue, 0)
			}
			open
			func REQUIRED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REQUIRED.rawValue, 0)
			}
			open
			func REVERSE_VIDEO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue, 0)
			}
			open
			func SAVE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SAVE.rawValue, 0)
			}
			open
			func SECURE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SECURE.rawValue, 0)
			}
			open
			func SHARED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SHARED.rawValue, 0)
			}
			open
			func SHAREDBYALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SHAREDBYALL.rawValue, 0)
			}
			open
			func SHAREDBYRUNUNIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue, 0)
			}
			open
			func SHARING() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SHARING.rawValue, 0)
			}
			open
			func SHORT_DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SHORT_DATE.rawValue, 0)
			}
			open
			func SYMBOL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SYMBOL.rawValue, 0)
			}
			open
			func TASK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TASK.rawValue, 0)
			}
			open
			func THREAD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THREAD.rawValue, 0)
			}
			open
			func THREAD_LOCAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.THREAD_LOCAL.rawValue, 0)
			}
			open
			func TIMER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TIMER.rawValue, 0)
			}
			open
			func TODAYS_DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TODAYS_DATE.rawValue, 0)
			}
			open
			func TODAYS_NAME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TODAYS_NAME.rawValue, 0)
			}
			open
			func TRUNCATED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TRUNCATED.rawValue, 0)
			}
			open
			func TYPEDEF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TYPEDEF.rawValue, 0)
			}
			open
			func UNDERLINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.UNDERLINE.rawValue, 0)
			}
			open
			func VIRTUAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.VIRTUAL.rawValue, 0)
			}
			open
			func WAIT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WAIT.rawValue, 0)
			}
			open
			func YEAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.YEAR.rawValue, 0)
			}
			open
			func YYYYMMDD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.YYYYMMDD.rawValue, 0)
			}
			open
			func YYYYDDD() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.YYYYDDD.rawValue, 0)
			}
			open
			func ZERO_FILL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZERO_FILL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_cobolWord
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCobolWord(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCobolWord(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCobolWord(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCobolWord(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cobolWord() throws -> CobolWordContext {
		var _localctx: CobolWordContext = CobolWordContext(_ctx, getState())
		try enterRule(_localctx, 1170, Cobol85Parser.RULE_cobolWord)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6195)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.ABORT.rawValue,Cobol85Parser.Tokens.AS.rawValue,Cobol85Parser.Tokens.ASCII.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA.rawValue,Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.rawValue,Cobol85Parser.Tokens.ATTRIBUTE.rawValue,Cobol85Parser.Tokens.AUTO.rawValue,Cobol85Parser.Tokens.AUTO_SKIP.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOR.rawValue,Cobol85Parser.Tokens.BACKGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.BEEP.rawValue,Cobol85Parser.Tokens.BELL.rawValue,Cobol85Parser.Tokens.BINARY.rawValue,Cobol85Parser.Tokens.BIT.rawValue,Cobol85Parser.Tokens.BLINK.rawValue,Cobol85Parser.Tokens.BOUNDS.rawValue,Cobol85Parser.Tokens.CAPABLE.rawValue,Cobol85Parser.Tokens.CCSVERSION.rawValue,Cobol85Parser.Tokens.CHANGED.rawValue,Cobol85Parser.Tokens.CHANNEL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.CLOSE_DISPOSITION.rawValue,Cobol85Parser.Tokens.COBOL.rawValue,Cobol85Parser.Tokens.COMMITMENT.rawValue,Cobol85Parser.Tokens.CONTROL_POINT.rawValue,Cobol85Parser.Tokens.CONVENTION.rawValue,Cobol85Parser.Tokens.CRUNCH.rawValue,Cobol85Parser.Tokens.CURSOR.rawValue,Cobol85Parser.Tokens.DEFAULT.rawValue,Cobol85Parser.Tokens.DEFAULT_DISPLAY.rawValue,Cobol85Parser.Tokens.DEFINITION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 68)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.DFHRESP.rawValue,Cobol85Parser.Tokens.DFHVALUE.rawValue,Cobol85Parser.Tokens.DISK.rawValue,Cobol85Parser.Tokens.DONTCARE.rawValue,Cobol85Parser.Tokens.DOUBLE.rawValue,Cobol85Parser.Tokens.EBCDIC.rawValue,Cobol85Parser.Tokens.EMPTY_CHECK.rawValue,Cobol85Parser.Tokens.ENTER.rawValue,Cobol85Parser.Tokens.ENTRY_PROCEDURE.rawValue,Cobol85Parser.Tokens.ERASE.rawValue,Cobol85Parser.Tokens.EOL.rawValue,Cobol85Parser.Tokens.EOS.rawValue,Cobol85Parser.Tokens.ESCAPE.rawValue,Cobol85Parser.Tokens.EVENT.rawValue,Cobol85Parser.Tokens.EXCLUSIVE.rawValue,Cobol85Parser.Tokens.EXPORT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 138)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.EXTENDED.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOR.rawValue,Cobol85Parser.Tokens.FOREGROUND_COLOUR.rawValue,Cobol85Parser.Tokens.FULL.rawValue,Cobol85Parser.Tokens.FUNCTIONNAME.rawValue,Cobol85Parser.Tokens.FUNCTION_POINTER.rawValue,Cobol85Parser.Tokens.GRID.rawValue,Cobol85Parser.Tokens.HIGHLIGHT.rawValue,Cobol85Parser.Tokens.IMPLICIT.rawValue,Cobol85Parser.Tokens.IMPORT.rawValue,Cobol85Parser.Tokens.INTEGER.rawValue,Cobol85Parser.Tokens.KEPT.rawValue,Cobol85Parser.Tokens.KEYBOARD.rawValue,Cobol85Parser.Tokens.LANGUAGE.rawValue,Cobol85Parser.Tokens.LB.rawValue,Cobol85Parser.Tokens.LD.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 202)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEFTLINE.rawValue,Cobol85Parser.Tokens.LENGTH_CHECK.rawValue,Cobol85Parser.Tokens.LIBACCESS.rawValue,Cobol85Parser.Tokens.LIBPARAMETER.rawValue,Cobol85Parser.Tokens.LIBRARY.rawValue,Cobol85Parser.Tokens.LIST.rawValue,Cobol85Parser.Tokens.LOCAL.rawValue,Cobol85Parser.Tokens.LONG_DATE.rawValue,Cobol85Parser.Tokens.LONG_TIME.rawValue,Cobol85Parser.Tokens.LOWER.rawValue,Cobol85Parser.Tokens.LOWLIGHT.rawValue,Cobol85Parser.Tokens.MMDDYYYY.rawValue,Cobol85Parser.Tokens.NAMED.rawValue,Cobol85Parser.Tokens.NATIONAL.rawValue,Cobol85Parser.Tokens.NATIONAL_EDITED.rawValue,Cobol85Parser.Tokens.NETWORK.rawValue,Cobol85Parser.Tokens.NO_ECHO.rawValue,Cobol85Parser.Tokens.NUMERIC_DATE.rawValue,Cobol85Parser.Tokens.NUMERIC_TIME.rawValue,Cobol85Parser.Tokens.ODT.rawValue,Cobol85Parser.Tokens.ORDERLY.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 268)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.OVERLINE.rawValue,Cobol85Parser.Tokens.OWN.rawValue,Cobol85Parser.Tokens.PASSWORD.rawValue,Cobol85Parser.Tokens.PORT.rawValue,Cobol85Parser.Tokens.PRINTER.rawValue,Cobol85Parser.Tokens.PRIVATE.rawValue,Cobol85Parser.Tokens.PROCESS.rawValue,Cobol85Parser.Tokens.PROGRAM.rawValue,Cobol85Parser.Tokens.PROMPT.rawValue,Cobol85Parser.Tokens.READER.rawValue,Cobol85Parser.Tokens.REMOTE.rawValue,Cobol85Parser.Tokens.REAL.rawValue,Cobol85Parser.Tokens.RECEIVED.rawValue,Cobol85Parser.Tokens.RECURSIVE.rawValue,Cobol85Parser.Tokens.REF.rawValue,Cobol85Parser.Tokens.REMOVE.rawValue,Cobol85Parser.Tokens.REQUIRED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 336)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.REVERSE_VIDEO.rawValue,Cobol85Parser.Tokens.SAVE.rawValue,Cobol85Parser.Tokens.SECURE.rawValue,Cobol85Parser.Tokens.SHARED.rawValue,Cobol85Parser.Tokens.SHAREDBYALL.rawValue,Cobol85Parser.Tokens.SHAREDBYRUNUNIT.rawValue,Cobol85Parser.Tokens.SHARING.rawValue,Cobol85Parser.Tokens.SHORT_DATE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 401)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, Cobol85Parser.Tokens.SYMBOL.rawValue,Cobol85Parser.Tokens.TASK.rawValue,Cobol85Parser.Tokens.THREAD.rawValue,Cobol85Parser.Tokens.THREAD_LOCAL.rawValue,Cobol85Parser.Tokens.TIMER.rawValue,Cobol85Parser.Tokens.TODAYS_DATE.rawValue,Cobol85Parser.Tokens.TODAYS_NAME.rawValue,Cobol85Parser.Tokens.TRUNCATED.rawValue,Cobol85Parser.Tokens.TYPEDEF.rawValue,Cobol85Parser.Tokens.UNDERLINE.rawValue,Cobol85Parser.Tokens.VIRTUAL.rawValue,Cobol85Parser.Tokens.WAIT.rawValue,Cobol85Parser.Tokens.YEAR.rawValue,Cobol85Parser.Tokens.YYYYMMDD.rawValue,Cobol85Parser.Tokens.YYYYDDD.rawValue,Cobol85Parser.Tokens.ZERO_FILL.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LiteralContext: ParserRuleContext {
			open
			func NONNUMERICLITERAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue, 0)
			}
			open
			func figurativeConstant() -> FigurativeConstantContext? {
				return getRuleContext(FigurativeConstantContext.self, 0)
			}
			open
			func numericLiteral() -> NumericLiteralContext? {
				return getRuleContext(NumericLiteralContext.self, 0)
			}
			open
			func booleanLiteral() -> BooleanLiteralContext? {
				return getRuleContext(BooleanLiteralContext.self, 0)
			}
			open
			func cicsDfhRespLiteral() -> CicsDfhRespLiteralContext? {
				return getRuleContext(CicsDfhRespLiteralContext.self, 0)
			}
			open
			func cicsDfhValueLiteral() -> CicsDfhValueLiteralContext? {
				return getRuleContext(CicsDfhValueLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_literal
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterLiteral(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitLiteral(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitLiteral(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitLiteral(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func literal() throws -> LiteralContext {
		var _localctx: LiteralContext = LiteralContext(_ctx, getState())
		try enterRule(_localctx, 1172, Cobol85Parser.RULE_literal)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6203)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,971, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6197)
		 		try match(Cobol85Parser.Tokens.NONNUMERICLITERAL.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6198)
		 		try figurativeConstant()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6199)
		 		try numericLiteral()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6200)
		 		try booleanLiteral()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6201)
		 		try cicsDfhRespLiteral()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6202)
		 		try cicsDfhValueLiteral()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BooleanLiteralContext: ParserRuleContext {
			open
			func TRUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TRUE.rawValue, 0)
			}
			open
			func FALSE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.FALSE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_booleanLiteral
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterBooleanLiteral(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitBooleanLiteral(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitBooleanLiteral(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitBooleanLiteral(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func booleanLiteral() throws -> BooleanLiteralContext {
		var _localctx: BooleanLiteralContext = BooleanLiteralContext(_ctx, getState())
		try enterRule(_localctx, 1174, Cobol85Parser.RULE_booleanLiteral)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6205)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == Cobol85Parser.Tokens.FALSE.rawValue
		 	          testSet = testSet || _la == Cobol85Parser.Tokens.TRUE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NumericLiteralContext: ParserRuleContext {
			open
			func NUMERICLITERAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NUMERICLITERAL.rawValue, 0)
			}
			open
			func ZERO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZERO.rawValue, 0)
			}
			open
			func integerLiteral() -> IntegerLiteralContext? {
				return getRuleContext(IntegerLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_numericLiteral
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterNumericLiteral(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitNumericLiteral(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitNumericLiteral(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitNumericLiteral(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func numericLiteral() throws -> NumericLiteralContext {
		var _localctx: NumericLiteralContext = NumericLiteralContext(_ctx, getState())
		try enterRule(_localctx, 1176, Cobol85Parser.RULE_numericLiteral)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6210)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NUMERICLITERAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6207)
		 		try match(Cobol85Parser.Tokens.NUMERICLITERAL.rawValue)

		 		break

		 	case .ZERO:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6208)
		 		try match(Cobol85Parser.Tokens.ZERO.rawValue)

		 		break
		 	case .LEVEL_NUMBER_66:fallthrough
		 	case .LEVEL_NUMBER_77:fallthrough
		 	case .LEVEL_NUMBER_88:fallthrough
		 	case .INTEGERLITERAL:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6209)
		 		try integerLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerLiteralContext: ParserRuleContext {
			open
			func INTEGERLITERAL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.INTEGERLITERAL.rawValue, 0)
			}
			open
			func LEVEL_NUMBER_66() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue, 0)
			}
			open
			func LEVEL_NUMBER_77() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue, 0)
			}
			open
			func LEVEL_NUMBER_88() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_integerLiteral
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterIntegerLiteral(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitIntegerLiteral(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitIntegerLiteral(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitIntegerLiteral(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerLiteral() throws -> IntegerLiteralContext {
		var _localctx: IntegerLiteralContext = IntegerLiteralContext(_ctx, getState())
		try enterRule(_localctx, 1178, Cobol85Parser.RULE_integerLiteral)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6212)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, Cobol85Parser.Tokens.LEVEL_NUMBER_66.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_77.rawValue,Cobol85Parser.Tokens.LEVEL_NUMBER_88.rawValue,Cobol85Parser.Tokens.INTEGERLITERAL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 552)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CicsDfhRespLiteralContext: ParserRuleContext {
			open
			func DFHRESP() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DFHRESP.rawValue, 0)
			}
			open
			func LPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, 0)
			}
			open
			func RPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, 0)
			}
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_cicsDfhRespLiteral
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCicsDfhRespLiteral(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCicsDfhRespLiteral(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCicsDfhRespLiteral(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCicsDfhRespLiteral(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cicsDfhRespLiteral() throws -> CicsDfhRespLiteralContext {
		var _localctx: CicsDfhRespLiteralContext = CicsDfhRespLiteralContext(_ctx, getState())
		try enterRule(_localctx, 1180, Cobol85Parser.RULE_cicsDfhRespLiteral)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6214)
		 	try match(Cobol85Parser.Tokens.DFHRESP.rawValue)
		 	setState(6215)
		 	try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
		 	setState(6218)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,973, _ctx)) {
		 	case 1:
		 		setState(6216)
		 		try cobolWord()

		 		break
		 	case 2:
		 		setState(6217)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(6220)
		 	try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CicsDfhValueLiteralContext: ParserRuleContext {
			open
			func DFHVALUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DFHVALUE.rawValue, 0)
			}
			open
			func LPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LPARENCHAR.rawValue, 0)
			}
			open
			func RPARENCHAR() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RPARENCHAR.rawValue, 0)
			}
			open
			func cobolWord() -> CobolWordContext? {
				return getRuleContext(CobolWordContext.self, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_cicsDfhValueLiteral
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCicsDfhValueLiteral(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCicsDfhValueLiteral(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCicsDfhValueLiteral(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCicsDfhValueLiteral(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cicsDfhValueLiteral() throws -> CicsDfhValueLiteralContext {
		var _localctx: CicsDfhValueLiteralContext = CicsDfhValueLiteralContext(_ctx, getState())
		try enterRule(_localctx, 1182, Cobol85Parser.RULE_cicsDfhValueLiteral)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6222)
		 	try match(Cobol85Parser.Tokens.DFHVALUE.rawValue)
		 	setState(6223)
		 	try match(Cobol85Parser.Tokens.LPARENCHAR.rawValue)
		 	setState(6226)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,974, _ctx)) {
		 	case 1:
		 		setState(6224)
		 		try cobolWord()

		 		break
		 	case 2:
		 		setState(6225)
		 		try literal()

		 		break
		 	default: break
		 	}
		 	setState(6228)
		 	try match(Cobol85Parser.Tokens.RPARENCHAR.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FigurativeConstantContext: ParserRuleContext {
			open
			func ALL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ALL.rawValue, 0)
			}
			open
			func literal() -> LiteralContext? {
				return getRuleContext(LiteralContext.self, 0)
			}
			open
			func HIGH_VALUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.HIGH_VALUE.rawValue, 0)
			}
			open
			func HIGH_VALUES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.HIGH_VALUES.rawValue, 0)
			}
			open
			func LOW_VALUE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOW_VALUE.rawValue, 0)
			}
			open
			func LOW_VALUES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LOW_VALUES.rawValue, 0)
			}
			open
			func NULL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NULL.rawValue, 0)
			}
			open
			func NULLS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.NULLS.rawValue, 0)
			}
			open
			func QUOTE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.QUOTE.rawValue, 0)
			}
			open
			func QUOTES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.QUOTES.rawValue, 0)
			}
			open
			func SPACE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SPACE.rawValue, 0)
			}
			open
			func SPACES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SPACES.rawValue, 0)
			}
			open
			func ZERO() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZERO.rawValue, 0)
			}
			open
			func ZEROS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZEROS.rawValue, 0)
			}
			open
			func ZEROES() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ZEROES.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_figurativeConstant
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterFigurativeConstant(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitFigurativeConstant(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitFigurativeConstant(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitFigurativeConstant(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func figurativeConstant() throws -> FigurativeConstantContext {
		var _localctx: FigurativeConstantContext = FigurativeConstantContext(_ctx, getState())
		try enterRule(_localctx, 1184, Cobol85Parser.RULE_figurativeConstant)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6245)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ALL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6230)
		 		try match(Cobol85Parser.Tokens.ALL.rawValue)
		 		setState(6231)
		 		try literal()

		 		break

		 	case .HIGH_VALUE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6232)
		 		try match(Cobol85Parser.Tokens.HIGH_VALUE.rawValue)

		 		break

		 	case .HIGH_VALUES:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6233)
		 		try match(Cobol85Parser.Tokens.HIGH_VALUES.rawValue)

		 		break

		 	case .LOW_VALUE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6234)
		 		try match(Cobol85Parser.Tokens.LOW_VALUE.rawValue)

		 		break

		 	case .LOW_VALUES:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6235)
		 		try match(Cobol85Parser.Tokens.LOW_VALUES.rawValue)

		 		break

		 	case .NULL:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6236)
		 		try match(Cobol85Parser.Tokens.NULL.rawValue)

		 		break

		 	case .NULLS:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(6237)
		 		try match(Cobol85Parser.Tokens.NULLS.rawValue)

		 		break

		 	case .QUOTE:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(6238)
		 		try match(Cobol85Parser.Tokens.QUOTE.rawValue)

		 		break

		 	case .QUOTES:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(6239)
		 		try match(Cobol85Parser.Tokens.QUOTES.rawValue)

		 		break

		 	case .SPACE:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(6240)
		 		try match(Cobol85Parser.Tokens.SPACE.rawValue)

		 		break

		 	case .SPACES:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(6241)
		 		try match(Cobol85Parser.Tokens.SPACES.rawValue)

		 		break

		 	case .ZERO:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(6242)
		 		try match(Cobol85Parser.Tokens.ZERO.rawValue)

		 		break

		 	case .ZEROS:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(6243)
		 		try match(Cobol85Parser.Tokens.ZEROS.rawValue)

		 		break

		 	case .ZEROES:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(6244)
		 		try match(Cobol85Parser.Tokens.ZEROES.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SpecialRegisterContext: ParserRuleContext {
			open
			func ADDRESS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.ADDRESS.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.OF.rawValue, 0)
			}
			open
			func identifier() -> IdentifierContext? {
				return getRuleContext(IdentifierContext.self, 0)
			}
			open
			func DATE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DATE.rawValue, 0)
			}
			open
			func DAY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DAY.rawValue, 0)
			}
			open
			func DAY_OF_WEEK() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue, 0)
			}
			open
			func DEBUG_CONTENTS() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue, 0)
			}
			open
			func DEBUG_ITEM() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEBUG_ITEM.rawValue, 0)
			}
			open
			func DEBUG_LINE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEBUG_LINE.rawValue, 0)
			}
			open
			func DEBUG_NAME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEBUG_NAME.rawValue, 0)
			}
			open
			func DEBUG_SUB_1() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue, 0)
			}
			open
			func DEBUG_SUB_2() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue, 0)
			}
			open
			func DEBUG_SUB_3() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue, 0)
			}
			open
			func LENGTH() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LENGTH.rawValue, 0)
			}
			open
			func LINAGE_COUNTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue, 0)
			}
			open
			func LINE_COUNTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.LINE_COUNTER.rawValue, 0)
			}
			open
			func PAGE_COUNTER() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.PAGE_COUNTER.rawValue, 0)
			}
			open
			func RETURN_CODE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.RETURN_CODE.rawValue, 0)
			}
			open
			func SHIFT_IN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SHIFT_IN.rawValue, 0)
			}
			open
			func SHIFT_OUT() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SHIFT_OUT.rawValue, 0)
			}
			open
			func SORT_CONTROL() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SORT_CONTROL.rawValue, 0)
			}
			open
			func SORT_CORE_SIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue, 0)
			}
			open
			func SORT_FILE_SIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue, 0)
			}
			open
			func SORT_MESSAGE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SORT_MESSAGE.rawValue, 0)
			}
			open
			func SORT_MODE_SIZE() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue, 0)
			}
			open
			func SORT_RETURN() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.SORT_RETURN.rawValue, 0)
			}
			open
			func TALLY() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TALLY.rawValue, 0)
			}
			open
			func TIME() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.TIME.rawValue, 0)
			}
			open
			func WHEN_COMPILED() -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.WHEN_COMPILED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_specialRegister
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterSpecialRegister(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitSpecialRegister(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitSpecialRegister(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitSpecialRegister(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func specialRegister() throws -> SpecialRegisterContext {
		var _localctx: SpecialRegisterContext = SpecialRegisterContext(_ctx, getState())
		try enterRule(_localctx, 1186, Cobol85Parser.RULE_specialRegister)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6280)
		 	try _errHandler.sync(self)
		 	switch (Cobol85Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ADDRESS:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6247)
		 		try match(Cobol85Parser.Tokens.ADDRESS.rawValue)
		 		setState(6248)
		 		try match(Cobol85Parser.Tokens.OF.rawValue)
		 		setState(6249)
		 		try identifier()

		 		break

		 	case .DATE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6250)
		 		try match(Cobol85Parser.Tokens.DATE.rawValue)

		 		break

		 	case .DAY:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6251)
		 		try match(Cobol85Parser.Tokens.DAY.rawValue)

		 		break

		 	case .DAY_OF_WEEK:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6252)
		 		try match(Cobol85Parser.Tokens.DAY_OF_WEEK.rawValue)

		 		break

		 	case .DEBUG_CONTENTS:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6253)
		 		try match(Cobol85Parser.Tokens.DEBUG_CONTENTS.rawValue)

		 		break

		 	case .DEBUG_ITEM:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6254)
		 		try match(Cobol85Parser.Tokens.DEBUG_ITEM.rawValue)

		 		break

		 	case .DEBUG_LINE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(6255)
		 		try match(Cobol85Parser.Tokens.DEBUG_LINE.rawValue)

		 		break

		 	case .DEBUG_NAME:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(6256)
		 		try match(Cobol85Parser.Tokens.DEBUG_NAME.rawValue)

		 		break

		 	case .DEBUG_SUB_1:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(6257)
		 		try match(Cobol85Parser.Tokens.DEBUG_SUB_1.rawValue)

		 		break

		 	case .DEBUG_SUB_2:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(6258)
		 		try match(Cobol85Parser.Tokens.DEBUG_SUB_2.rawValue)

		 		break

		 	case .DEBUG_SUB_3:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(6259)
		 		try match(Cobol85Parser.Tokens.DEBUG_SUB_3.rawValue)

		 		break

		 	case .LENGTH:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(6260)
		 		try match(Cobol85Parser.Tokens.LENGTH.rawValue)
		 		setState(6262)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == Cobol85Parser.Tokens.OF.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(6261)
		 			try match(Cobol85Parser.Tokens.OF.rawValue)

		 		}

		 		setState(6264)
		 		try identifier()

		 		break

		 	case .LINAGE_COUNTER:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(6265)
		 		try match(Cobol85Parser.Tokens.LINAGE_COUNTER.rawValue)

		 		break

		 	case .LINE_COUNTER:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(6266)
		 		try match(Cobol85Parser.Tokens.LINE_COUNTER.rawValue)

		 		break

		 	case .PAGE_COUNTER:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(6267)
		 		try match(Cobol85Parser.Tokens.PAGE_COUNTER.rawValue)

		 		break

		 	case .RETURN_CODE:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(6268)
		 		try match(Cobol85Parser.Tokens.RETURN_CODE.rawValue)

		 		break

		 	case .SHIFT_IN:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(6269)
		 		try match(Cobol85Parser.Tokens.SHIFT_IN.rawValue)

		 		break

		 	case .SHIFT_OUT:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(6270)
		 		try match(Cobol85Parser.Tokens.SHIFT_OUT.rawValue)

		 		break

		 	case .SORT_CONTROL:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(6271)
		 		try match(Cobol85Parser.Tokens.SORT_CONTROL.rawValue)

		 		break

		 	case .SORT_CORE_SIZE:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(6272)
		 		try match(Cobol85Parser.Tokens.SORT_CORE_SIZE.rawValue)

		 		break

		 	case .SORT_FILE_SIZE:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(6273)
		 		try match(Cobol85Parser.Tokens.SORT_FILE_SIZE.rawValue)

		 		break

		 	case .SORT_MESSAGE:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(6274)
		 		try match(Cobol85Parser.Tokens.SORT_MESSAGE.rawValue)

		 		break

		 	case .SORT_MODE_SIZE:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(6275)
		 		try match(Cobol85Parser.Tokens.SORT_MODE_SIZE.rawValue)

		 		break

		 	case .SORT_RETURN:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(6276)
		 		try match(Cobol85Parser.Tokens.SORT_RETURN.rawValue)

		 		break

		 	case .TALLY:
		 		try enterOuterAlt(_localctx, 25)
		 		setState(6277)
		 		try match(Cobol85Parser.Tokens.TALLY.rawValue)

		 		break

		 	case .TIME:
		 		try enterOuterAlt(_localctx, 26)
		 		setState(6278)
		 		try match(Cobol85Parser.Tokens.TIME.rawValue)

		 		break

		 	case .WHEN_COMPILED:
		 		try enterOuterAlt(_localctx, 27)
		 		setState(6279)
		 		try match(Cobol85Parser.Tokens.WHEN_COMPILED.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CommentEntryContext: ParserRuleContext {
			open
			func COMMENTENTRYLINE() -> [TerminalNode] {
				return getTokens(Cobol85Parser.Tokens.COMMENTENTRYLINE.rawValue)
			}
			open
			func COMMENTENTRYLINE(_ i:Int) -> TerminalNode? {
				return getToken(Cobol85Parser.Tokens.COMMENTENTRYLINE.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return Cobol85Parser.RULE_commentEntry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.enterCommentEntry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? Cobol85Listener {
				listener.exitCommentEntry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? Cobol85Visitor {
			    return visitor.visitCommentEntry(self)
			}
			else if let visitor = visitor as? Cobol85BaseVisitor {
			    return visitor.visitCommentEntry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func commentEntry() throws -> CommentEntryContext {
		var _localctx: CommentEntryContext = CommentEntryContext(_ctx, getState())
		try enterRule(_localctx, 1188, Cobol85Parser.RULE_commentEntry)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6283) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(6282)
		 		try match(Cobol85Parser.Tokens.COMMENTENTRYLINE.rawValue)


		 		setState(6285); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == Cobol85Parser.Tokens.COMMENTENTRYLINE.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}


	public
	static let _serializedATN = Cobol85ParserATN().jsonString

	public
	static let _ATN = ATNDeserializer().deserializeFromJson(_serializedATN)
}