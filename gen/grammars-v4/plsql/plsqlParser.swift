// Generated from ./grammars-v4/plsql/plsql.g4 by ANTLR 4.7
import Antlr4

open class plsqlParser: Parser {

	internal static var _decisionToDFA: [DFA] = {
          var decisionToDFA = [DFA]()
          let length = plsqlParser._ATN.getNumberOfDecisions()
          for i in 0..<length {
            decisionToDFA.append(DFA(plsqlParser._ATN.getDecisionState(i)!, i))
           }
           return decisionToDFA
     }()
	internal static let _sharedContextCache: PredictionContextCache = PredictionContextCache()
	public enum Tokens: Int {
		case EOF = -1, T__0 = 1, A_LETTER = 2, ADD = 3, AFTER = 4, AGENT = 5, 
                 AGGREGATE = 6, ALL = 7, ALTER = 8, ANALYZE = 9, AND = 10, 
                 ANY = 11, ARRAY = 12, AS = 13, ASC = 14, ASSOCIATE = 15, 
                 AT = 16, ATTRIBUTE = 17, AUDIT = 18, AUTHID = 19, AUTO = 20, 
                 AUTOMATIC = 21, AUTONOMOUS_TRANSACTION = 22, BATCH = 23, 
                 BEFORE = 24, BEGIN = 25, BETWEEN = 26, BFILE = 27, BINARY_DOUBLE = 28, 
                 BINARY_FLOAT = 29, BINARY_INTEGER = 30, BLOB = 31, BLOCK = 32, 
                 BODY = 33, BOOLEAN = 34, BOTH = 35, BREADTH = 36, BULK = 37, 
                 BY = 38, BYTE = 39, C_LETTER = 40, CACHE = 41, CALL = 42, 
                 CANONICAL = 43, CASCADE = 44, CASE = 45, CAST = 46, CHAR = 47, 
                 CHAR_CS = 48, CHARACTER = 49, CHECK = 50, CHR = 51, CLOB = 52, 
                 CLOSE = 53, CLUSTER = 54, COALESCE = 55, COLLECT = 56, 
                 COLUMNS = 57, COMMENT = 58, COMMIT = 59, COMMITTED = 60, 
                 COMPATIBILITY = 61, COMPILE = 62, COMPOUND = 63, CONNECT = 64, 
                 CONNECT_BY_ROOT = 65, CONSTANT = 66, CONSTRAINT = 67, CONSTRAINTS = 68, 
                 CONSTRUCTOR = 69, CONTENT = 70, CONTEXT = 71, CONTINUE = 72, 
                 CONVERT = 73, CORRUPT_XID = 74, CORRUPT_XID_ALL = 75, COST = 76, 
                 COUNT = 77, CREATE = 78, CROSS = 79, CUBE = 80, CURRENT = 81, 
                 CURRENT_USER = 82, CURSOR = 83, CUSTOMDATUM = 84, CYCLE = 85, 
                 DATA = 86, DATABASE = 87, DATE = 88, DAY = 89, DB_ROLE_CHANGE = 90, 
                 DBTIMEZONE = 91, DDL = 92, DEBUG = 93, DEC = 94, DECIMAL = 95, 
                 DECLARE = 96, DECOMPOSE = 97, DECREMENT = 98, DEFAULT = 99, 
                 DEFAULTS = 100, DEFERRED = 101, DEFINER = 102, DELETE = 103, 
                 DEPTH = 104, DESC = 105, DETERMINISTIC = 106, DIMENSION = 107, 
                 DISABLE = 108, DISASSOCIATE = 109, DISTINCT = 110, DOCUMENT = 111, 
                 DOUBLE = 112, DROP = 113, DSINTERVAL_UNCONSTRAINED = 114, 
                 EACH = 115, ELEMENT = 116, ELSE = 117, ELSIF = 118, EMPTY = 119, 
                 ENABLE = 120, ENCODING = 121, END = 122, ENTITYESCAPING = 123, 
                 ERR = 124, ERRORS = 125, ESCAPE = 126, EVALNAME = 127, 
                 EXCEPTION = 128, EXCEPTION_INIT = 129, EXCEPTIONS = 130, 
                 EXCLUDE = 131, EXCLUSIVE = 132, EXECUTE = 133, EXISTS = 134, 
                 EXIT = 135, EXPLAIN = 136, EXTERNAL = 137, EXTRACT = 138, 
                 FAILURE = 139, FALSE = 140, FETCH = 141, FINAL = 142, FIRST = 143, 
                 FIRST_VALUE = 144, FLOAT = 145, FOLLOWING = 146, FOLLOWS = 147, 
                 FOR = 148, FORALL = 149, FORCE = 150, FROM = 151, FULL = 152, 
                 FUNCTION = 153, GOTO = 154, GRANT = 155, GROUP = 156, GROUPING = 157, 
                 HASH = 158, HAVING = 159, HIDE = 160, HOUR = 161, IF = 162, 
                 IGNORE = 163, IMMEDIATE = 164, IN = 165, INCLUDE = 166, 
                 INCLUDING = 167, INCREMENT = 168, INDENT = 169, INDEX = 170, 
                 INDEXED = 171, INDICATOR = 172, INDICES = 173, INFINITE = 174, 
                 INLINE = 175, INNER = 176, INOUT = 177, INSERT = 178, INSTANTIABLE = 179, 
                 INSTEAD = 180, INT = 181, INTEGER = 182, INTERSECT = 183, 
                 INTERVAL = 184, INTO = 185, INVALIDATE = 186, IS = 187, 
                 ISOLATION = 188, ITERATE = 189, JAVA = 190, JOIN = 191, 
                 KEEP = 192, LANGUAGE = 193, LAST = 194, LAST_VALUE = 195, 
                 LEADING = 196, LEFT = 197, LEVEL = 198, LIBRARY = 199, 
                 LIKE = 200, LIKE2 = 201, LIKE4 = 202, LIKEC = 203, LIMIT = 204, 
                 LOCAL = 205, LOCK = 206, LOCKED = 207, LOG = 208, LOGOFF = 209, 
                 LOGON = 210, LONG = 211, LOOP = 212, MAIN = 213, MAP = 214, 
                 MATCHED = 215, MAXVALUE = 216, MEASURES = 217, MEMBER = 218, 
                 MERGE = 219, MINUS = 220, MINUTE = 221, MINVALUE = 222, 
                 MLSLABEL = 223, MODE = 224, MODEL = 225, MODIFY = 226, 
                 MONTH = 227, MULTISET = 228, NAME = 229, NAN = 230, NATURAL = 231, 
                 NATURALN = 232, NAV = 233, NCHAR = 234, NCHAR_CS = 235, 
                 NCLOB = 236, NESTED = 237, NEW = 238, NO = 239, NOAUDIT = 240, 
                 NOCACHE = 241, NOCOPY = 242, NOCYCLE = 243, NOENTITYESCAPING = 244, 
                 NOMAXVALUE = 245, NOMINVALUE = 246, NONE = 247, NOORDER = 248, 
                 NOSCHEMACHECK = 249, NOT = 250, NOWAIT = 251, NULL = 252, 
                 NULLS = 253, NUMBER = 254, NUMERIC = 255, NVARCHAR2 = 256, 
                 OBJECT = 257, OF = 258, OFF = 259, OID = 260, OLD = 261, 
                 ON = 262, ONLY = 263, OPEN = 264, OPTION = 265, OR = 266, 
                 ORADATA = 267, ORDER = 268, ORDINALITY = 269, OSERROR = 270, 
                 OUT = 271, OUTER = 272, OVER = 273, OVERRIDING = 274, PACKAGE = 275, 
                 PARALLEL_ENABLE = 276, PARAMETERS = 277, PARENT = 278, 
                 PARTITION = 279, PASSING = 280, PATH = 281, PERCENT_ISOPEN = 282, 
                 PERCENT_FOUND = 283, PERCENT_NOTFOUND = 284, PERCENT_ROWCOUNT = 285, 
                 PERCENT_ROWTYPE = 286, PERCENT_TYPE = 287, PIPELINED = 288, 
                 PIVOT = 289, PLAN = 290, PLS_INTEGER = 291, POSITIVE = 292, 
                 POSITIVEN = 293, PRAGMA = 294, PRECEDING = 295, PRECISION = 296, 
                 PRESENT = 297, PRIOR = 298, PROCEDURE = 299, RAISE = 300, 
                 RANGE = 301, RAW = 302, READ = 303, REAL = 304, RECORD = 305, 
                 REF = 306, REFERENCE = 307, REFERENCING = 308, REJECT = 309, 
                 RELIES_ON = 310, RENAME = 311, REPLACE = 312, RESPECT = 313, 
                 RESTRICT_REFERENCES = 314, RESULT = 315, RESULT_CACHE = 316, 
                 RETURN = 317, RETURNING = 318, REUSE = 319, REVERSE = 320, 
                 REVOKE = 321, RIGHT = 322, ROLLBACK = 323, ROLLUP = 324, 
                 ROW = 325, ROWID = 326, ROWS = 327, RULES = 328, SAMPLE = 329, 
                 SAVE = 330, SAVEPOINT = 331, SCHEMA = 332, SCHEMACHECK = 333, 
                 SCN = 334, SEARCH = 335, SECOND = 336, SEED = 337, SEGMENT = 338, 
                 SELECT = 339, SELF = 340, SEQUENCE = 341, SEQUENTIAL = 342, 
                 SERIALIZABLE = 343, SERIALLY_REUSABLE = 344, SERVERERROR = 345, 
                 SESSIONTIMEZONE = 346, SET = 347, SETS = 348, SETTINGS = 349, 
                 SHARE = 350, SHOW = 351, SHUTDOWN = 352, SIBLINGS = 353, 
                 SIGNTYPE = 354, SIMPLE_INTEGER = 355, SINGLE = 356, SIZE = 357, 
                 SKIP_ = 358, SMALLINT = 359, SNAPSHOT = 360, SOME = 361, 
                 SPECIFICATION = 362, SQLDATA = 363, SQLERROR = 364, STANDALONE = 365, 
                 START = 366, STARTUP = 367, STATEMENT = 368, STATEMENT_ID = 369, 
                 STATIC = 370, STATISTICS = 371, STRING = 372, SUBMULTISET = 373, 
                 SUBPARTITION = 374, SUBSTITUTABLE = 375, SUBTYPE = 376, 
                 SUCCESS = 377, SUSPEND = 378, TABLE = 379, THE = 380, THEN = 381, 
                 TIME = 382, TIMESTAMP = 383, TIMESTAMP_LTZ_UNCONSTRAINED = 384, 
                 TIMESTAMP_TZ_UNCONSTRAINED = 385, TIMESTAMP_UNCONSTRAINED = 386, 
                 TIMEZONE_ABBR = 387, TIMEZONE_HOUR = 388, TIMEZONE_MINUTE = 389, 
                 TIMEZONE_REGION = 390, TO = 391, TRAILING = 392, TRANSACTION = 393, 
                 TRANSLATE = 394, TREAT = 395, TRIGGER = 396, TRUE = 397, 
                 TRUNCATE = 398, TYPE = 399, UNBOUNDED = 400, UNDER = 401, 
                 UNION = 402, UNIQUE = 403, UNLIMITED = 404, UNPIVOT = 405, 
                 UNTIL = 406, UPDATE = 407, UPDATED = 408, UPSERT = 409, 
                 UROWID = 410, USE = 411, USING = 412, VALIDATE = 413, VALUE = 414, 
                 VALUES = 415, VARCHAR = 416, VARCHAR2 = 417, VARIABLE = 418, 
                 VARRAY = 419, VARYING = 420, VERSION = 421, VERSIONS = 422, 
                 WAIT = 423, WARNING = 424, WELLFORMED = 425, WHEN = 426, 
                 WHENEVER = 427, WHERE = 428, WHILE = 429, WITH = 430, WITHIN = 431, 
                 WORK = 432, WRITE = 433, XML = 434, XMLAGG = 435, XMLATTRIBUTES = 436, 
                 XMLCAST = 437, XMLCOLATTVAL = 438, XMLELEMENT = 439, XMLEXISTS = 440, 
                 XMLFOREST = 441, XMLNAMESPACES = 442, XMLPARSE = 443, XMLPI = 444, 
                 XMLQUERY = 445, XMLROOT = 446, XMLSERIALIZE = 447, XMLTABLE = 448, 
                 YEAR = 449, YES = 450, YMINTERVAL_UNCONSTRAINED = 451, 
                 ZONE = 452, PREDICTION = 453, PREDICTION_BOUNDS = 454, 
                 PREDICTION_COST = 455, PREDICTION_DETAILS = 456, PREDICTION_PROBABILITY = 457, 
                 PREDICTION_SET = 458, CUME_DIST = 459, DENSE_RANK = 460, 
                 LISTAGG = 461, PERCENT_RANK = 462, PERCENTILE_CONT = 463, 
                 PERCENTILE_DISC = 464, RANK = 465, AVG = 466, CORR = 467, 
                 COVAR_ = 468, DECODE = 469, LAG = 470, LEAD = 471, MAX = 472, 
                 MEDIAN = 473, MIN = 474, NTILE = 475, NVL = 476, RATIO_TO_REPORT = 477, 
                 REGR_ = 478, ROUND = 479, ROW_NUMBER = 480, SUBSTR = 481, 
                 TO_CHAR = 482, TRIM = 483, SUM = 484, STDDEV = 485, VAR_ = 486, 
                 VARIANCE = 487, NATIONAL_CHAR_STRING_LIT = 488, BIT_STRING_LIT = 489, 
                 HEX_STRING_LIT = 490, DOUBLE_PERIOD = 491, PERIOD = 492, 
                 UNSIGNED_INTEGER = 493, APPROXIMATE_NUM_LIT = 494, CHAR_STRING = 495, 
                 DELIMITED_ID = 496, PERCENT = 497, AMPERSAND = 498, LEFT_PAREN = 499, 
                 RIGHT_PAREN = 500, DOUBLE_ASTERISK = 501, ASTERISK = 502, 
                 PLUS_SIGN = 503, MINUS_SIGN = 504, COMMA = 505, SOLIDUS = 506, 
                 AT_SIGN = 507, ASSIGN_OP = 508, BINDVAR = 509, COLON = 510, 
                 SEMICOLON = 511, LESS_THAN_OR_EQUALS_OP = 512, LESS_THAN_OP = 513, 
                 GREATER_THAN_OR_EQUALS_OP = 514, NOT_EQUAL_OP = 515, CARRET_OPERATOR_PART = 516, 
                 TILDE_OPERATOR_PART = 517, EXCLAMATION_OPERATOR_PART = 518, 
                 GREATER_THAN_OP = 519, CONCATENATION_OP = 520, VERTICAL_BAR = 521, 
                 EQUALS_OP = 522, LEFT_BRACKET = 523, RIGHT_BRACKET = 524, 
                 INTRODUCER = 525, SPACES = 526, SINGLE_LINE_COMMENT = 527, 
                 MULTI_LINE_COMMENT = 528, PROMPT = 529, REGULAR_ID = 530, 
                 ZV = 531
	}
	public static let RULE_swallow_to_semi = 0, RULE_compilation_unit = 1, 
                   RULE_sql_script = 2, RULE_unit_statement = 3, RULE_drop_function = 4, 
                   RULE_alter_function = 5, RULE_create_function_body = 6, 
                   RULE_parallel_enable_clause = 7, RULE_partition_by_clause = 8, 
                   RULE_result_cache_clause = 9, RULE_relies_on_part = 10, 
                   RULE_streaming_clause = 11, RULE_drop_package = 12, RULE_alter_package = 13, 
                   RULE_create_package = 14, RULE_create_package_body = 15, 
                   RULE_package_obj_spec = 16, RULE_procedure_spec = 17, 
                   RULE_function_spec = 18, RULE_package_obj_body = 19, 
                   RULE_drop_procedure = 20, RULE_alter_procedure = 21, 
                   RULE_function_body = 22, RULE_procedure_body = 23, RULE_create_procedure_body = 24, 
                   RULE_drop_trigger = 25, RULE_alter_trigger = 26, RULE_create_trigger = 27, 
                   RULE_trigger_follows_clause = 28, RULE_trigger_when_clause = 29, 
                   RULE_simple_dml_trigger = 30, RULE_for_each_row = 31, 
                   RULE_compound_dml_trigger = 32, RULE_non_dml_trigger = 33, 
                   RULE_trigger_body = 34, RULE_routine_clause = 35, RULE_compound_trigger_block = 36, 
                   RULE_timing_point_section = 37, RULE_non_dml_event = 38, 
                   RULE_dml_event_clause = 39, RULE_dml_event_element = 40, 
                   RULE_dml_event_nested_clause = 41, RULE_referencing_clause = 42, 
                   RULE_referencing_element = 43, RULE_drop_type = 44, RULE_alter_type = 45, 
                   RULE_compile_type_clause = 46, RULE_replace_type_clause = 47, 
                   RULE_alter_method_spec = 48, RULE_alter_method_element = 49, 
                   RULE_alter_attribute_definition = 50, RULE_attribute_definition = 51, 
                   RULE_alter_collection_clauses = 52, RULE_dependent_handling_clause = 53, 
                   RULE_dependent_exceptions_part = 54, RULE_create_type = 55, 
                   RULE_type_definition = 56, RULE_object_type_def = 57, 
                   RULE_object_as_part = 58, RULE_object_under_part = 59, 
                   RULE_nested_table_type_def = 60, RULE_sqlj_object_type = 61, 
                   RULE_type_body = 62, RULE_type_body_elements = 63, RULE_map_order_func_declaration = 64, 
                   RULE_subprog_decl_in_type = 65, RULE_proc_decl_in_type = 66, 
                   RULE_func_decl_in_type = 67, RULE_constructor_declaration = 68, 
                   RULE_modifier_clause = 69, RULE_object_member_spec = 70, 
                   RULE_sqlj_object_type_attr = 71, RULE_element_spec = 72, 
                   RULE_element_spec_options = 73, RULE_subprogram_spec = 74, 
                   RULE_type_procedure_spec = 75, RULE_type_function_spec = 76, 
                   RULE_constructor_spec = 77, RULE_map_order_function_spec = 78, 
                   RULE_pragma_clause = 79, RULE_pragma_elements = 80, RULE_type_elements_parameter = 81, 
                   RULE_drop_sequence = 82, RULE_alter_sequence = 83, RULE_create_sequence = 84, 
                   RULE_sequence_spec = 85, RULE_sequence_start_clause = 86, 
                   RULE_invoker_rights_clause = 87, RULE_compiler_parameters_clause = 88, 
                   RULE_call_spec = 89, RULE_java_spec = 90, RULE_c_spec = 91, 
                   RULE_c_agent_in_clause = 92, RULE_c_parameters_clause = 93, 
                   RULE_parameter = 94, RULE_default_value_part = 95, RULE_declare_spec = 96, 
                   RULE_variable_declaration = 97, RULE_subtype_declaration = 98, 
                   RULE_cursor_declaration = 99, RULE_parameter_spec = 100, 
                   RULE_exception_declaration = 101, RULE_pragma_declaration = 102, 
                   RULE_record_type_def = 103, RULE_field_spec = 104, RULE_ref_cursor_type_def = 105, 
                   RULE_type_declaration = 106, RULE_table_type_def = 107, 
                   RULE_table_indexed_by_part = 108, RULE_varray_type_def = 109, 
                   RULE_seq_of_statements = 110, RULE_label_declaration = 111, 
                   RULE_statement = 112, RULE_assignment_statement = 113, 
                   RULE_continue_statement = 114, RULE_exit_statement = 115, 
                   RULE_goto_statement = 116, RULE_if_statement = 117, RULE_elsif_part = 118, 
                   RULE_else_part = 119, RULE_loop_statement = 120, RULE_cursor_loop_param = 121, 
                   RULE_forall_statement = 122, RULE_bounds_clause = 123, 
                   RULE_between_bound = 124, RULE_lower_bound = 125, RULE_upper_bound = 126, 
                   RULE_null_statement = 127, RULE_raise_statement = 128, 
                   RULE_return_statement = 129, RULE_function_call = 130, 
                   RULE_body = 131, RULE_exception_handler = 132, RULE_trigger_block = 133, 
                   RULE_block = 134, RULE_sql_statement = 135, RULE_execute_immediate = 136, 
                   RULE_dynamic_returning_clause = 137, RULE_data_manipulation_language_statements = 138, 
                   RULE_cursor_manipulation_statements = 139, RULE_close_statement = 140, 
                   RULE_open_statement = 141, RULE_fetch_statement = 142, 
                   RULE_open_for_statement = 143, RULE_transaction_control_statements = 144, 
                   RULE_set_transaction_command = 145, RULE_set_constraint_command = 146, 
                   RULE_commit_statement = 147, RULE_write_clause = 148, 
                   RULE_rollback_statement = 149, RULE_savepoint_statement = 150, 
                   RULE_explain_statement = 151, RULE_select_statement = 152, 
                   RULE_subquery_factoring_clause = 153, RULE_factoring_element = 154, 
                   RULE_search_clause = 155, RULE_cycle_clause = 156, RULE_subquery = 157, 
                   RULE_subquery_operation_part = 158, RULE_subquery_basic_elements = 159, 
                   RULE_query_block = 160, RULE_selected_element = 161, 
                   RULE_from_clause = 162, RULE_select_list_elements = 163, 
                   RULE_table_ref_list = 164, RULE_table_ref = 165, RULE_table_ref_aux = 166, 
                   RULE_table_ref_aux_internal = 167, RULE_join_clause = 168, 
                   RULE_join_on_part = 169, RULE_join_using_part = 170, 
                   RULE_outer_join_type = 171, RULE_query_partition_clause = 172, 
                   RULE_flashback_query_clause = 173, RULE_pivot_clause = 174, 
                   RULE_pivot_element = 175, RULE_pivot_for_clause = 176, 
                   RULE_pivot_in_clause = 177, RULE_pivot_in_clause_element = 178, 
                   RULE_pivot_in_clause_elements = 179, RULE_unpivot_clause = 180, 
                   RULE_unpivot_in_clause = 181, RULE_unpivot_in_elements = 182, 
                   RULE_hierarchical_query_clause = 183, RULE_start_part = 184, 
                   RULE_group_by_clause = 185, RULE_group_by_elements = 186, 
                   RULE_rollup_cube_clause = 187, RULE_grouping_sets_clause = 188, 
                   RULE_grouping_sets_elements = 189, RULE_having_clause = 190, 
                   RULE_model_clause = 191, RULE_cell_reference_options = 192, 
                   RULE_return_rows_clause = 193, RULE_reference_model = 194, 
                   RULE_main_model = 195, RULE_model_column_clauses = 196, 
                   RULE_model_column_partition_part = 197, RULE_model_column_list = 198, 
                   RULE_model_column = 199, RULE_model_rules_clause = 200, 
                   RULE_model_rules_part = 201, RULE_model_rules_element = 202, 
                   RULE_cell_assignment = 203, RULE_model_iterate_clause = 204, 
                   RULE_until_part = 205, RULE_order_by_clause = 206, RULE_order_by_elements = 207, 
                   RULE_for_update_clause = 208, RULE_for_update_of_part = 209, 
                   RULE_for_update_options = 210, RULE_update_statement = 211, 
                   RULE_update_set_clause = 212, RULE_column_based_update_set_clause = 213, 
                   RULE_delete_statement = 214, RULE_insert_statement = 215, 
                   RULE_single_table_insert = 216, RULE_multi_table_insert = 217, 
                   RULE_multi_table_element = 218, RULE_conditional_insert_clause = 219, 
                   RULE_conditional_insert_when_part = 220, RULE_conditional_insert_else_part = 221, 
                   RULE_insert_into_clause = 222, RULE_values_clause = 223, 
                   RULE_merge_statement = 224, RULE_merge_update_clause = 225, 
                   RULE_merge_element = 226, RULE_merge_update_delete_part = 227, 
                   RULE_merge_insert_clause = 228, RULE_selected_tableview = 229, 
                   RULE_lock_table_statement = 230, RULE_wait_nowait_part = 231, 
                   RULE_lock_table_element = 232, RULE_lock_mode = 233, 
                   RULE_general_table_ref = 234, RULE_static_returning_clause = 235, 
                   RULE_error_logging_clause = 236, RULE_error_logging_into_part = 237, 
                   RULE_error_logging_reject_part = 238, RULE_dml_table_expression_clause = 239, 
                   RULE_table_collection_expression = 240, RULE_subquery_restriction_clause = 241, 
                   RULE_sample_clause = 242, RULE_seed_part = 243, RULE_cursor_expression = 244, 
                   RULE_expression_list = 245, RULE_condition = 246, RULE_expression = 247, 
                   RULE_logical_or_expression = 248, RULE_logical_and_expression = 249, 
                   RULE_negated_expression = 250, RULE_equality_expression = 251, 
                   RULE_multiset_expression = 252, RULE_multiset_type = 253, 
                   RULE_relational_expression = 254, RULE_compound_expression = 255, 
                   RULE_relational_operator = 256, RULE_like_type = 257, 
                   RULE_like_escape_part = 258, RULE_in_elements = 259, 
                   RULE_between_elements = 260, RULE_concatenation = 261, 
                   RULE_additive_expression = 262, RULE_multiply_expression = 263, 
                   RULE_datetime_expression = 264, RULE_interval_expression = 265, 
                   RULE_model_expression = 266, RULE_model_expression_element = 267, 
                   RULE_single_column_for_loop = 268, RULE_for_like_part = 269, 
                   RULE_for_increment_decrement_type = 270, RULE_multi_column_for_loop = 271, 
                   RULE_unary_expression = 272, RULE_case_statement = 273, 
                   RULE_simple_case_statement = 274, RULE_simple_case_when_part = 275, 
                   RULE_searched_case_statement = 276, RULE_searched_case_when_part = 277, 
                   RULE_case_else_part = 278, RULE_atom = 279, RULE_expression_or_vector = 280, 
                   RULE_vector_expr = 281, RULE_quantified_expression = 282, 
                   RULE_string_function = 283, RULE_standard_function = 284, 
                   RULE_numeric_function_wrapper = 285, RULE_numeric_function = 286, 
                   RULE_other_function = 287, RULE_over_clause_keyword = 288, 
                   RULE_within_or_over_clause_keyword = 289, RULE_standard_prediction_function_keyword = 290, 
                   RULE_over_clause = 291, RULE_windowing_clause = 292, 
                   RULE_windowing_type = 293, RULE_windowing_elements = 294, 
                   RULE_using_clause = 295, RULE_using_element = 296, RULE_collect_order_by_part = 297, 
                   RULE_within_or_over_part = 298, RULE_cost_matrix_clause = 299, 
                   RULE_xml_passing_clause = 300, RULE_xml_attributes_clause = 301, 
                   RULE_xml_namespaces_clause = 302, RULE_xml_table_column = 303, 
                   RULE_xml_general_default_part = 304, RULE_xml_multiuse_expression_element = 305, 
                   RULE_xmlroot_param_version_part = 306, RULE_xmlroot_param_standalone_part = 307, 
                   RULE_xmlserialize_param_enconding_part = 308, RULE_xmlserialize_param_version_part = 309, 
                   RULE_xmlserialize_param_ident_part = 310, RULE_sql_plus_command = 311, 
                   RULE_whenever_command = 312, RULE_set_command = 313, 
                   RULE_exit_command = 314, RULE_prompt_command = 315, RULE_show_errors_command = 316, 
                   RULE_partition_extension_clause = 317, RULE_column_alias = 318, 
                   RULE_table_alias = 319, RULE_alias_quoted_string = 320, 
                   RULE_where_clause = 321, RULE_current_of_clause = 322, 
                   RULE_into_clause = 323, RULE_xml_column_name = 324, RULE_cost_class_name = 325, 
                   RULE_attribute_name = 326, RULE_savepoint_name = 327, 
                   RULE_rollback_segment_name = 328, RULE_table_var_name = 329, 
                   RULE_schema_name = 330, RULE_routine_name = 331, RULE_package_name = 332, 
                   RULE_implementation_type_name = 333, RULE_parameter_name = 334, 
                   RULE_reference_model_name = 335, RULE_main_model_name = 336, 
                   RULE_aggregate_function_name = 337, RULE_query_name = 338, 
                   RULE_constraint_name = 339, RULE_label_name = 340, RULE_type_name = 341, 
                   RULE_sequence_name = 342, RULE_exception_name = 343, 
                   RULE_function_name = 344, RULE_procedure_name = 345, 
                   RULE_trigger_name = 346, RULE_variable_name = 347, RULE_index_name = 348, 
                   RULE_cursor_name = 349, RULE_record_name = 350, RULE_collection_name = 351, 
                   RULE_link_name = 352, RULE_column_name = 353, RULE_tableview_name = 354, 
                   RULE_char_set_name = 355, RULE_keep_clause = 356, RULE_function_argument = 357, 
                   RULE_function_argument_analytic = 358, RULE_function_argument_modeling = 359, 
                   RULE_respect_or_ignore_nulls = 360, RULE_argument = 361, 
                   RULE_type_spec = 362, RULE_datatype = 363, RULE_precision_part = 364, 
                   RULE_native_datatype_element = 365, RULE_bind_variable = 366, 
                   RULE_general_element = 367, RULE_general_element_part = 368, 
                   RULE_table_element = 369, RULE_constant = 370, RULE_numeric = 371, 
                   RULE_numeric_negative = 372, RULE_quoted_string = 373, 
                   RULE_identifier = 374, RULE_id_expression = 375, RULE_not_equal_op = 376, 
                   RULE_greater_than_or_equals_op = 377, RULE_less_than_or_equals_op = 378, 
                   RULE_concatenation_op = 379, RULE_outer_join_sign = 380, 
                   RULE_regular_id = 381, RULE_string_function_name = 382, 
                   RULE_numeric_function_name = 383
	public static let ruleNames: [String] = [
		"swallow_to_semi", "compilation_unit", "sql_script", "unit_statement", 
		"drop_function", "alter_function", "create_function_body", "parallel_enable_clause", 
		"partition_by_clause", "result_cache_clause", "relies_on_part", "streaming_clause", 
		"drop_package", "alter_package", "create_package", "create_package_body", 
		"package_obj_spec", "procedure_spec", "function_spec", "package_obj_body", 
		"drop_procedure", "alter_procedure", "function_body", "procedure_body", 
		"create_procedure_body", "drop_trigger", "alter_trigger", "create_trigger", 
		"trigger_follows_clause", "trigger_when_clause", "simple_dml_trigger", 
		"for_each_row", "compound_dml_trigger", "non_dml_trigger", "trigger_body", 
		"routine_clause", "compound_trigger_block", "timing_point_section", "non_dml_event", 
		"dml_event_clause", "dml_event_element", "dml_event_nested_clause", "referencing_clause", 
		"referencing_element", "drop_type", "alter_type", "compile_type_clause", 
		"replace_type_clause", "alter_method_spec", "alter_method_element", "alter_attribute_definition", 
		"attribute_definition", "alter_collection_clauses", "dependent_handling_clause", 
		"dependent_exceptions_part", "create_type", "type_definition", "object_type_def", 
		"object_as_part", "object_under_part", "nested_table_type_def", "sqlj_object_type", 
		"type_body", "type_body_elements", "map_order_func_declaration", "subprog_decl_in_type", 
		"proc_decl_in_type", "func_decl_in_type", "constructor_declaration", "modifier_clause", 
		"object_member_spec", "sqlj_object_type_attr", "element_spec", "element_spec_options", 
		"subprogram_spec", "type_procedure_spec", "type_function_spec", "constructor_spec", 
		"map_order_function_spec", "pragma_clause", "pragma_elements", "type_elements_parameter", 
		"drop_sequence", "alter_sequence", "create_sequence", "sequence_spec", 
		"sequence_start_clause", "invoker_rights_clause", "compiler_parameters_clause", 
		"call_spec", "java_spec", "c_spec", "c_agent_in_clause", "c_parameters_clause", 
		"parameter", "default_value_part", "declare_spec", "variable_declaration", 
		"subtype_declaration", "cursor_declaration", "parameter_spec", "exception_declaration", 
		"pragma_declaration", "record_type_def", "field_spec", "ref_cursor_type_def", 
		"type_declaration", "table_type_def", "table_indexed_by_part", "varray_type_def", 
		"seq_of_statements", "label_declaration", "statement", "assignment_statement", 
		"continue_statement", "exit_statement", "goto_statement", "if_statement", 
		"elsif_part", "else_part", "loop_statement", "cursor_loop_param", "forall_statement", 
		"bounds_clause", "between_bound", "lower_bound", "upper_bound", "null_statement", 
		"raise_statement", "return_statement", "function_call", "body", "exception_handler", 
		"trigger_block", "block", "sql_statement", "execute_immediate", "dynamic_returning_clause", 
		"data_manipulation_language_statements", "cursor_manipulation_statements", 
		"close_statement", "open_statement", "fetch_statement", "open_for_statement", 
		"transaction_control_statements", "set_transaction_command", "set_constraint_command", 
		"commit_statement", "write_clause", "rollback_statement", "savepoint_statement", 
		"explain_statement", "select_statement", "subquery_factoring_clause", 
		"factoring_element", "search_clause", "cycle_clause", "subquery", "subquery_operation_part", 
		"subquery_basic_elements", "query_block", "selected_element", "from_clause", 
		"select_list_elements", "table_ref_list", "table_ref", "table_ref_aux", 
		"table_ref_aux_internal", "join_clause", "join_on_part", "join_using_part", 
		"outer_join_type", "query_partition_clause", "flashback_query_clause", 
		"pivot_clause", "pivot_element", "pivot_for_clause", "pivot_in_clause", 
		"pivot_in_clause_element", "pivot_in_clause_elements", "unpivot_clause", 
		"unpivot_in_clause", "unpivot_in_elements", "hierarchical_query_clause", 
		"start_part", "group_by_clause", "group_by_elements", "rollup_cube_clause", 
		"grouping_sets_clause", "grouping_sets_elements", "having_clause", "model_clause", 
		"cell_reference_options", "return_rows_clause", "reference_model", "main_model", 
		"model_column_clauses", "model_column_partition_part", "model_column_list", 
		"model_column", "model_rules_clause", "model_rules_part", "model_rules_element", 
		"cell_assignment", "model_iterate_clause", "until_part", "order_by_clause", 
		"order_by_elements", "for_update_clause", "for_update_of_part", "for_update_options", 
		"update_statement", "update_set_clause", "column_based_update_set_clause", 
		"delete_statement", "insert_statement", "single_table_insert", "multi_table_insert", 
		"multi_table_element", "conditional_insert_clause", "conditional_insert_when_part", 
		"conditional_insert_else_part", "insert_into_clause", "values_clause", 
		"merge_statement", "merge_update_clause", "merge_element", "merge_update_delete_part", 
		"merge_insert_clause", "selected_tableview", "lock_table_statement", "wait_nowait_part", 
		"lock_table_element", "lock_mode", "general_table_ref", "static_returning_clause", 
		"error_logging_clause", "error_logging_into_part", "error_logging_reject_part", 
		"dml_table_expression_clause", "table_collection_expression", "subquery_restriction_clause", 
		"sample_clause", "seed_part", "cursor_expression", "expression_list", 
		"condition", "expression", "logical_or_expression", "logical_and_expression", 
		"negated_expression", "equality_expression", "multiset_expression", "multiset_type", 
		"relational_expression", "compound_expression", "relational_operator", 
		"like_type", "like_escape_part", "in_elements", "between_elements", "concatenation", 
		"additive_expression", "multiply_expression", "datetime_expression", "interval_expression", 
		"model_expression", "model_expression_element", "single_column_for_loop", 
		"for_like_part", "for_increment_decrement_type", "multi_column_for_loop", 
		"unary_expression", "case_statement", "simple_case_statement", "simple_case_when_part", 
		"searched_case_statement", "searched_case_when_part", "case_else_part", 
		"atom", "expression_or_vector", "vector_expr", "quantified_expression", 
		"string_function", "standard_function", "numeric_function_wrapper", "numeric_function", 
		"other_function", "over_clause_keyword", "within_or_over_clause_keyword", 
		"standard_prediction_function_keyword", "over_clause", "windowing_clause", 
		"windowing_type", "windowing_elements", "using_clause", "using_element", 
		"collect_order_by_part", "within_or_over_part", "cost_matrix_clause", 
		"xml_passing_clause", "xml_attributes_clause", "xml_namespaces_clause", 
		"xml_table_column", "xml_general_default_part", "xml_multiuse_expression_element", 
		"xmlroot_param_version_part", "xmlroot_param_standalone_part", "xmlserialize_param_enconding_part", 
		"xmlserialize_param_version_part", "xmlserialize_param_ident_part", "sql_plus_command", 
		"whenever_command", "set_command", "exit_command", "prompt_command", "show_errors_command", 
		"partition_extension_clause", "column_alias", "table_alias", "alias_quoted_string", 
		"where_clause", "current_of_clause", "into_clause", "xml_column_name", 
		"cost_class_name", "attribute_name", "savepoint_name", "rollback_segment_name", 
		"table_var_name", "schema_name", "routine_name", "package_name", "implementation_type_name", 
		"parameter_name", "reference_model_name", "main_model_name", "aggregate_function_name", 
		"query_name", "constraint_name", "label_name", "type_name", "sequence_name", 
		"exception_name", "function_name", "procedure_name", "trigger_name", "variable_name", 
		"index_name", "cursor_name", "record_name", "collection_name", "link_name", 
		"column_name", "tableview_name", "char_set_name", "keep_clause", "function_argument", 
		"function_argument_analytic", "function_argument_modeling", "respect_or_ignore_nulls", 
		"argument", "type_spec", "datatype", "precision_part", "native_datatype_element", 
		"bind_variable", "general_element", "general_element_part", "table_element", 
		"constant", "numeric", "numeric_negative", "quoted_string", "identifier", 
		"id_expression", "not_equal_op", "greater_than_or_equals_op", "less_than_or_equals_op", 
		"concatenation_op", "outer_join_sign", "regular_id", "string_function_name", 
		"numeric_function_name"
	]

	private static let _LITERAL_NAMES: [String?] = [
		nil, "'..'", nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, "'.'", nil, nil, nil, nil, "'%'", "'&'", "'('", "')'", "'**'", 
		"'*'", "'+'", "'-'", "','", "'/'", "'@'", "':='", nil, "':'", "';'", "'<='", 
		"'<'", "'>='", nil, "'^'", "'~'", "'!'", "'>'", "'||'", "'|'", "'='", 
		"'['", "']'", "'_'", nil, nil, nil, nil, nil, "'@!'"
	]
	private static let _SYMBOLIC_NAMES: [String?] = [
		nil, nil, "A_LETTER", "ADD", "AFTER", "AGENT", "AGGREGATE", "ALL", "ALTER", 
		"ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "ASSOCIATE", "AT", "ATTRIBUTE", 
		"AUDIT", "AUTHID", "AUTO", "AUTOMATIC", "AUTONOMOUS_TRANSACTION", "BATCH", 
		"BEFORE", "BEGIN", "BETWEEN", "BFILE", "BINARY_DOUBLE", "BINARY_FLOAT", 
		"BINARY_INTEGER", "BLOB", "BLOCK", "BODY", "BOOLEAN", "BOTH", "BREADTH", 
		"BULK", "BY", "BYTE", "C_LETTER", "CACHE", "CALL", "CANONICAL", "CASCADE", 
		"CASE", "CAST", "CHAR", "CHAR_CS", "CHARACTER", "CHECK", "CHR", "CLOB", 
		"CLOSE", "CLUSTER", "COALESCE", "COLLECT", "COLUMNS", "COMMENT", "COMMIT", 
		"COMMITTED", "COMPATIBILITY", "COMPILE", "COMPOUND", "CONNECT", "CONNECT_BY_ROOT", 
		"CONSTANT", "CONSTRAINT", "CONSTRAINTS", "CONSTRUCTOR", "CONTENT", "CONTEXT", 
		"CONTINUE", "CONVERT", "CORRUPT_XID", "CORRUPT_XID_ALL", "COST", "COUNT", 
		"CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_USER", "CURSOR", "CUSTOMDATUM", 
		"CYCLE", "DATA", "DATABASE", "DATE", "DAY", "DB_ROLE_CHANGE", "DBTIMEZONE", 
		"DDL", "DEBUG", "DEC", "DECIMAL", "DECLARE", "DECOMPOSE", "DECREMENT", 
		"DEFAULT", "DEFAULTS", "DEFERRED", "DEFINER", "DELETE", "DEPTH", "DESC", 
		"DETERMINISTIC", "DIMENSION", "DISABLE", "DISASSOCIATE", "DISTINCT", "DOCUMENT", 
		"DOUBLE", "DROP", "DSINTERVAL_UNCONSTRAINED", "EACH", "ELEMENT", "ELSE", 
		"ELSIF", "EMPTY", "ENABLE", "ENCODING", "END", "ENTITYESCAPING", "ERR", 
		"ERRORS", "ESCAPE", "EVALNAME", "EXCEPTION", "EXCEPTION_INIT", "EXCEPTIONS", 
		"EXCLUDE", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPLAIN", "EXTERNAL", 
		"EXTRACT", "FAILURE", "FALSE", "FETCH", "FINAL", "FIRST", "FIRST_VALUE", 
		"FLOAT", "FOLLOWING", "FOLLOWS", "FOR", "FORALL", "FORCE", "FROM", "FULL", 
		"FUNCTION", "GOTO", "GRANT", "GROUP", "GROUPING", "HASH", "HAVING", "HIDE", 
		"HOUR", "IF", "IGNORE", "IMMEDIATE", "IN", "INCLUDE", "INCLUDING", "INCREMENT", 
		"INDENT", "INDEX", "INDEXED", "INDICATOR", "INDICES", "INFINITE", "INLINE", 
		"INNER", "INOUT", "INSERT", "INSTANTIABLE", "INSTEAD", "INT", "INTEGER", 
		"INTERSECT", "INTERVAL", "INTO", "INVALIDATE", "IS", "ISOLATION", "ITERATE", 
		"JAVA", "JOIN", "KEEP", "LANGUAGE", "LAST", "LAST_VALUE", "LEADING", "LEFT", 
		"LEVEL", "LIBRARY", "LIKE", "LIKE2", "LIKE4", "LIKEC", "LIMIT", "LOCAL", 
		"LOCK", "LOCKED", "LOG", "LOGOFF", "LOGON", "LONG", "LOOP", "MAIN", "MAP", 
		"MATCHED", "MAXVALUE", "MEASURES", "MEMBER", "MERGE", "MINUS", "MINUTE", 
		"MINVALUE", "MLSLABEL", "MODE", "MODEL", "MODIFY", "MONTH", "MULTISET", 
		"NAME", "NAN", "NATURAL", "NATURALN", "NAV", "NCHAR", "NCHAR_CS", "NCLOB", 
		"NESTED", "NEW", "NO", "NOAUDIT", "NOCACHE", "NOCOPY", "NOCYCLE", "NOENTITYESCAPING", 
		"NOMAXVALUE", "NOMINVALUE", "NONE", "NOORDER", "NOSCHEMACHECK", "NOT", 
		"NOWAIT", "NULL", "NULLS", "NUMBER", "NUMERIC", "NVARCHAR2", "OBJECT", 
		"OF", "OFF", "OID", "OLD", "ON", "ONLY", "OPEN", "OPTION", "OR", "ORADATA", 
		"ORDER", "ORDINALITY", "OSERROR", "OUT", "OUTER", "OVER", "OVERRIDING", 
		"PACKAGE", "PARALLEL_ENABLE", "PARAMETERS", "PARENT", "PARTITION", "PASSING", 
		"PATH", "PERCENT_ISOPEN", "PERCENT_FOUND", "PERCENT_NOTFOUND", "PERCENT_ROWCOUNT", 
		"PERCENT_ROWTYPE", "PERCENT_TYPE", "PIPELINED", "PIVOT", "PLAN", "PLS_INTEGER", 
		"POSITIVE", "POSITIVEN", "PRAGMA", "PRECEDING", "PRECISION", "PRESENT", 
		"PRIOR", "PROCEDURE", "RAISE", "RANGE", "RAW", "READ", "REAL", "RECORD", 
		"REF", "REFERENCE", "REFERENCING", "REJECT", "RELIES_ON", "RENAME", "REPLACE", 
		"RESPECT", "RESTRICT_REFERENCES", "RESULT", "RESULT_CACHE", "RETURN", 
		"RETURNING", "REUSE", "REVERSE", "REVOKE", "RIGHT", "ROLLBACK", "ROLLUP", 
		"ROW", "ROWID", "ROWS", "RULES", "SAMPLE", "SAVE", "SAVEPOINT", "SCHEMA", 
		"SCHEMACHECK", "SCN", "SEARCH", "SECOND", "SEED", "SEGMENT", "SELECT", 
		"SELF", "SEQUENCE", "SEQUENTIAL", "SERIALIZABLE", "SERIALLY_REUSABLE", 
		"SERVERERROR", "SESSIONTIMEZONE", "SET", "SETS", "SETTINGS", "SHARE", 
		"SHOW", "SHUTDOWN", "SIBLINGS", "SIGNTYPE", "SIMPLE_INTEGER", "SINGLE", 
		"SIZE", "SKIP_", "SMALLINT", "SNAPSHOT", "SOME", "SPECIFICATION", "SQLDATA", 
		"SQLERROR", "STANDALONE", "START", "STARTUP", "STATEMENT", "STATEMENT_ID", 
		"STATIC", "STATISTICS", "STRING", "SUBMULTISET", "SUBPARTITION", "SUBSTITUTABLE", 
		"SUBTYPE", "SUCCESS", "SUSPEND", "TABLE", "THE", "THEN", "TIME", "TIMESTAMP", 
		"TIMESTAMP_LTZ_UNCONSTRAINED", "TIMESTAMP_TZ_UNCONSTRAINED", "TIMESTAMP_UNCONSTRAINED", 
		"TIMEZONE_ABBR", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TIMEZONE_REGION", 
		"TO", "TRAILING", "TRANSACTION", "TRANSLATE", "TREAT", "TRIGGER", "TRUE", 
		"TRUNCATE", "TYPE", "UNBOUNDED", "UNDER", "UNION", "UNIQUE", "UNLIMITED", 
		"UNPIVOT", "UNTIL", "UPDATE", "UPDATED", "UPSERT", "UROWID", "USE", "USING", 
		"VALIDATE", "VALUE", "VALUES", "VARCHAR", "VARCHAR2", "VARIABLE", "VARRAY", 
		"VARYING", "VERSION", "VERSIONS", "WAIT", "WARNING", "WELLFORMED", "WHEN", 
		"WHENEVER", "WHERE", "WHILE", "WITH", "WITHIN", "WORK", "WRITE", "XML", 
		"XMLAGG", "XMLATTRIBUTES", "XMLCAST", "XMLCOLATTVAL", "XMLELEMENT", "XMLEXISTS", 
		"XMLFOREST", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROOT", 
		"XMLSERIALIZE", "XMLTABLE", "YEAR", "YES", "YMINTERVAL_UNCONSTRAINED", 
		"ZONE", "PREDICTION", "PREDICTION_BOUNDS", "PREDICTION_COST", "PREDICTION_DETAILS", 
		"PREDICTION_PROBABILITY", "PREDICTION_SET", "CUME_DIST", "DENSE_RANK", 
		"LISTAGG", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", 
		"AVG", "CORR", "COVAR_", "DECODE", "LAG", "LEAD", "MAX", "MEDIAN", "MIN", 
		"NTILE", "NVL", "RATIO_TO_REPORT", "REGR_", "ROUND", "ROW_NUMBER", "SUBSTR", 
		"TO_CHAR", "TRIM", "SUM", "STDDEV", "VAR_", "VARIANCE", "NATIONAL_CHAR_STRING_LIT", 
		"BIT_STRING_LIT", "HEX_STRING_LIT", "DOUBLE_PERIOD", "PERIOD", "UNSIGNED_INTEGER", 
		"APPROXIMATE_NUM_LIT", "CHAR_STRING", "DELIMITED_ID", "PERCENT", "AMPERSAND", 
		"LEFT_PAREN", "RIGHT_PAREN", "DOUBLE_ASTERISK", "ASTERISK", "PLUS_SIGN", 
		"MINUS_SIGN", "COMMA", "SOLIDUS", "AT_SIGN", "ASSIGN_OP", "BINDVAR", "COLON", 
		"SEMICOLON", "LESS_THAN_OR_EQUALS_OP", "LESS_THAN_OP", "GREATER_THAN_OR_EQUALS_OP", 
		"NOT_EQUAL_OP", "CARRET_OPERATOR_PART", "TILDE_OPERATOR_PART", "EXCLAMATION_OPERATOR_PART", 
		"GREATER_THAN_OP", "CONCATENATION_OP", "VERTICAL_BAR", "EQUALS_OP", "LEFT_BRACKET", 
		"RIGHT_BRACKET", "INTRODUCER", "SPACES", "SINGLE_LINE_COMMENT", "MULTI_LINE_COMMENT", 
		"PROMPT", "REGULAR_ID", "ZV"
	]
	public static let VOCABULARY: Vocabulary = Vocabulary(_LITERAL_NAMES, _SYMBOLIC_NAMES)

	/**
	 * @deprecated Use {@link #VOCABULARY} instead.
	 */
	//@Deprecated
	public let tokenNames: [String?]? = {
	    let length = _SYMBOLIC_NAMES.count
	    var tokenNames = [String?](repeating: nil, count: length)
		for i in 0..<length {
			var name = VOCABULARY.getLiteralName(i)
			if name == nil {
				name = VOCABULARY.getSymbolicName(i)
			}
			if name == nil {
				name = "<INVALID>"
			}
			tokenNames[i] = name
		}
		return tokenNames
	}()

	override
	open func getTokenNames() -> [String?]? {
		return tokenNames
	}

	override
	open func getGrammarFileName() -> String { return "plsql.g4" }

	override
	open func getRuleNames() -> [String] { return plsqlParser.ruleNames }

	override
	open func getSerializedATN() -> String { return plsqlParser._serializedATN }

	override
	open func getATN() -> ATN { return plsqlParser._ATN }

	open override func getVocabulary() -> Vocabulary {
	    return plsqlParser.VOCABULARY
	}

	public override init(_ input:TokenStream)throws {
	    RuntimeMetaData.checkVersion("4.7", RuntimeMetaData.VERSION)
		try super.init(input)
		_interp = ParserATNSimulator(self,plsqlParser._ATN,plsqlParser._decisionToDFA, plsqlParser._sharedContextCache)
	}
	open class Swallow_to_semiContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_swallow_to_semi }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSwallow_to_semi(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSwallow_to_semi(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSwallow_to_semi(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSwallow_to_semi(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func swallow_to_semi() throws -> Swallow_to_semiContext {
		var _localctx: Swallow_to_semiContext = Swallow_to_semiContext(_ctx, getState())
		try enterRule(_localctx, 0, plsqlParser.RULE_swallow_to_semi)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(769) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(768)
		 		_la = try _input.LA(1)
		 		if (_la <= 0 || (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.SEMICOLON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}


		 		setState(771); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.T__0.rawValue,plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ALL.rawValue,plsqlParser.Tokens.ALTER.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.AND.rawValue,plsqlParser.Tokens.ANY.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.AS.rawValue,plsqlParser.Tokens.ASC.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BEGIN.rawValue,plsqlParser.Tokens.BETWEEN.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BREADTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BY.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CACHE.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CASE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHECK.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COALESCE.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONNECT.rawValue,plsqlParser.Tokens.CONNECT_BY_ROOT.rawValue,plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CREATE.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DATE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECLARE.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DELETE.rawValue,plsqlParser.Tokens.DEPTH.rawValue,plsqlParser.Tokens.DESC.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DISTINCT.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DROP.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.ELSE.rawValue,plsqlParser.Tokens.ELSIF.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.END.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 64)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue,plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXCLUSIVE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXISTS.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FALSE.rawValue,plsqlParser.Tokens.FETCH.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FOR.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FROM.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GOTO.rawValue,plsqlParser.Tokens.GRANT.rawValue,plsqlParser.Tokens.GROUP.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HAVING.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IF.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.IN.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEX.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSERT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERSECT.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INTO.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.IS.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 128)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue,plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCK.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUS.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODE.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCACHE.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NOMAXVALUE.rawValue,plsqlParser.Tokens.NOMINVALUE.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOORDER.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NOT.rawValue,plsqlParser.Tokens.NOWAIT.rawValue,plsqlParser.Tokens.NULL.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 192)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue,plsqlParser.Tokens.OF.rawValue,plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ON.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.OPTION.rawValue,plsqlParser.Tokens.OR.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDER.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PERCENT_ISOPEN.rawValue,plsqlParser.Tokens.PERCENT_FOUND.rawValue,plsqlParser.Tokens.PERCENT_NOTFOUND.rawValue,plsqlParser.Tokens.PERCENT_ROWCOUNT.rawValue,plsqlParser.Tokens.PERCENT_ROWTYPE.rawValue,plsqlParser.Tokens.PERCENT_TYPE.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PIVOT.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PRIOR.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 256)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.REVOKE.rawValue,plsqlParser.Tokens.RIGHT.rawValue,plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SEARCH.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELECT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENCE.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHARE.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SIZE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.START.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TABLE.rawValue,plsqlParser.Tokens.THE.rawValue,plsqlParser.Tokens.THEN.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 320)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TO.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUE.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNION.rawValue,plsqlParser.Tokens.UNIQUE.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNPIVOT.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATE.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.USING.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VALUES.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHEN.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHERE.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITH.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 384)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue,plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.DECODE.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.NVL.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROUND.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.SUBSTR.rawValue,plsqlParser.Tokens.TO_CHAR.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.BIT_STRING_LIT.rawValue,plsqlParser.Tokens.HEX_STRING_LIT.rawValue,plsqlParser.Tokens.DOUBLE_PERIOD.rawValue,plsqlParser.Tokens.PERIOD.rawValue,plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue,plsqlParser.Tokens.APPROXIMATE_NUM_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue,plsqlParser.Tokens.PERCENT.rawValue,plsqlParser.Tokens.AMPERSAND.rawValue,plsqlParser.Tokens.LEFT_PAREN.rawValue,plsqlParser.Tokens.RIGHT_PAREN.rawValue,plsqlParser.Tokens.DOUBLE_ASTERISK.rawValue,plsqlParser.Tokens.ASTERISK.rawValue,plsqlParser.Tokens.PLUS_SIGN.rawValue,plsqlParser.Tokens.MINUS_SIGN.rawValue,plsqlParser.Tokens.COMMA.rawValue,plsqlParser.Tokens.SOLIDUS.rawValue,plsqlParser.Tokens.AT_SIGN.rawValue,plsqlParser.Tokens.ASSIGN_OP.rawValue,plsqlParser.Tokens.BINDVAR.rawValue,plsqlParser.Tokens.COLON.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 448)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LESS_THAN_OR_EQUALS_OP.rawValue,plsqlParser.Tokens.LESS_THAN_OP.rawValue,plsqlParser.Tokens.GREATER_THAN_OR_EQUALS_OP.rawValue,plsqlParser.Tokens.NOT_EQUAL_OP.rawValue,plsqlParser.Tokens.CARRET_OPERATOR_PART.rawValue,plsqlParser.Tokens.TILDE_OPERATOR_PART.rawValue,plsqlParser.Tokens.EXCLAMATION_OPERATOR_PART.rawValue,plsqlParser.Tokens.GREATER_THAN_OP.rawValue,plsqlParser.Tokens.CONCATENATION_OP.rawValue,plsqlParser.Tokens.VERTICAL_BAR.rawValue,plsqlParser.Tokens.EQUALS_OP.rawValue,plsqlParser.Tokens.LEFT_BRACKET.rawValue,plsqlParser.Tokens.RIGHT_BRACKET.rawValue,plsqlParser.Tokens.INTRODUCER.rawValue,plsqlParser.Tokens.SPACES.rawValue,plsqlParser.Tokens.SINGLE_LINE_COMMENT.rawValue,plsqlParser.Tokens.MULTI_LINE_COMMENT.rawValue,plsqlParser.Tokens.PROMPT.rawValue,plsqlParser.Tokens.REGULAR_ID.rawValue,plsqlParser.Tokens.ZV.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 512)
		 	          }()
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Compilation_unitContext:ParserRuleContext {
		open func EOF() -> TerminalNode? { return getToken(plsqlParser.Tokens.EOF.rawValue, 0) }
		open func unit_statement() -> Array<Unit_statementContext> {
			return getRuleContexts(Unit_statementContext.self)
		}
		open func unit_statement(_ i: Int) -> Unit_statementContext? {
			return getRuleContext(Unit_statementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compilation_unit }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompilation_unit(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompilation_unit(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompilation_unit(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompilation_unit(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compilation_unit() throws -> Compilation_unitContext {
		var _localctx: Compilation_unitContext = Compilation_unitContext(_ctx, getState())
		try enterRule(_localctx, 2, plsqlParser.RULE_compilation_unit)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(776)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.ALTER.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CREATE.rawValue,plsqlParser.Tokens.DELETE.rawValue,plsqlParser.Tokens.DROP.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 78)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.INSERT.rawValue,plsqlParser.Tokens.LOCK.rawValue,plsqlParser.Tokens.MERGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 178)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.SELECT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.UPDATE.rawValue || _la == plsqlParser.Tokens.WITH.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(773)
		 		try unit_statement()


		 		setState(778)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(779)
		 	try match(plsqlParser.Tokens.EOF.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sql_scriptContext:ParserRuleContext {
		open func EOF() -> TerminalNode? { return getToken(plsqlParser.Tokens.EOF.rawValue, 0) }
		open func unit_statement() -> Array<Unit_statementContext> {
			return getRuleContexts(Unit_statementContext.self)
		}
		open func unit_statement(_ i: Int) -> Unit_statementContext? {
			return getRuleContext(Unit_statementContext.self,i)
		}
		open func sql_plus_command() -> Array<Sql_plus_commandContext> {
			return getRuleContexts(Sql_plus_commandContext.self)
		}
		open func sql_plus_command(_ i: Int) -> Sql_plus_commandContext? {
			return getRuleContext(Sql_plus_commandContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sql_script }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSql_script(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSql_script(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSql_script(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSql_script(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sql_script() throws -> Sql_scriptContext {
		var _localctx: Sql_scriptContext = Sql_scriptContext(_ctx, getState())
		try enterRule(_localctx, 4, plsqlParser.RULE_sql_script)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(785)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.ALTER.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CREATE.rawValue,plsqlParser.Tokens.DELETE.rawValue,plsqlParser.Tokens.DROP.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 78)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.INSERT.rawValue,plsqlParser.Tokens.LOCK.rawValue,plsqlParser.Tokens.MERGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 178)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.SELECT.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SHOW.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 339)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.UPDATE.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WITH.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 407)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LEFT_PAREN.rawValue,plsqlParser.Tokens.SOLIDUS.rawValue,plsqlParser.Tokens.PROMPT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 499)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(783)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ALTER:fallthrough
		 		case .CREATE:fallthrough
		 		case .DELETE:fallthrough
		 		case .DROP:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .INSERT:fallthrough
		 		case .LOCK:fallthrough
		 		case .MERGE:fallthrough
		 		case .SELECT:fallthrough
		 		case .UPDATE:fallthrough
		 		case .WITH:fallthrough
		 		case .LEFT_PAREN:
		 			setState(781)
		 			try unit_statement()

		 			break
		 		case .EXIT:fallthrough
		 		case .SET:fallthrough
		 		case .SHOW:fallthrough
		 		case .WHENEVER:fallthrough
		 		case .SOLIDUS:fallthrough
		 		case .PROMPT:
		 			setState(782)
		 			try sql_plus_command()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(787)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(788)
		 	try match(plsqlParser.Tokens.EOF.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Unit_statementContext:ParserRuleContext {
		open func alter_function() -> Alter_functionContext? {
			return getRuleContext(Alter_functionContext.self,0)
		}
		open func alter_package() -> Alter_packageContext? {
			return getRuleContext(Alter_packageContext.self,0)
		}
		open func alter_procedure() -> Alter_procedureContext? {
			return getRuleContext(Alter_procedureContext.self,0)
		}
		open func alter_sequence() -> Alter_sequenceContext? {
			return getRuleContext(Alter_sequenceContext.self,0)
		}
		open func alter_trigger() -> Alter_triggerContext? {
			return getRuleContext(Alter_triggerContext.self,0)
		}
		open func alter_type() -> Alter_typeContext? {
			return getRuleContext(Alter_typeContext.self,0)
		}
		open func create_function_body() -> Create_function_bodyContext? {
			return getRuleContext(Create_function_bodyContext.self,0)
		}
		open func create_procedure_body() -> Create_procedure_bodyContext? {
			return getRuleContext(Create_procedure_bodyContext.self,0)
		}
		open func create_package() -> Create_packageContext? {
			return getRuleContext(Create_packageContext.self,0)
		}
		open func create_package_body() -> Create_package_bodyContext? {
			return getRuleContext(Create_package_bodyContext.self,0)
		}
		open func create_sequence() -> Create_sequenceContext? {
			return getRuleContext(Create_sequenceContext.self,0)
		}
		open func create_trigger() -> Create_triggerContext? {
			return getRuleContext(Create_triggerContext.self,0)
		}
		open func create_type() -> Create_typeContext? {
			return getRuleContext(Create_typeContext.self,0)
		}
		open func drop_function() -> Drop_functionContext? {
			return getRuleContext(Drop_functionContext.self,0)
		}
		open func drop_package() -> Drop_packageContext? {
			return getRuleContext(Drop_packageContext.self,0)
		}
		open func drop_procedure() -> Drop_procedureContext? {
			return getRuleContext(Drop_procedureContext.self,0)
		}
		open func drop_sequence() -> Drop_sequenceContext? {
			return getRuleContext(Drop_sequenceContext.self,0)
		}
		open func drop_trigger() -> Drop_triggerContext? {
			return getRuleContext(Drop_triggerContext.self,0)
		}
		open func drop_type() -> Drop_typeContext? {
			return getRuleContext(Drop_typeContext.self,0)
		}
		open func data_manipulation_language_statements() -> Data_manipulation_language_statementsContext? {
			return getRuleContext(Data_manipulation_language_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_unit_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUnit_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUnit_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUnit_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUnit_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unit_statement() throws -> Unit_statementContext {
		var _localctx: Unit_statementContext = Unit_statementContext(_ctx, getState())
		try enterRule(_localctx, 6, plsqlParser.RULE_unit_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(810)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,4, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(790)
		 		try alter_function()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(791)
		 		try alter_package()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(792)
		 		try alter_procedure()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(793)
		 		try alter_sequence()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(794)
		 		try alter_trigger()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(795)
		 		try alter_type()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(796)
		 		try create_function_body()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(797)
		 		try create_procedure_body()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(798)
		 		try create_package()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(799)
		 		try create_package_body()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(800)
		 		try create_sequence()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(801)
		 		try create_trigger()

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(802)
		 		try create_type()

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(803)
		 		try drop_function()

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(804)
		 		try drop_package()

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(805)
		 		try drop_procedure()

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(806)
		 		try drop_sequence()

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(807)
		 		try drop_trigger()

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(808)
		 		try drop_type()

		 		break
		 	case 20:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(809)
		 		try data_manipulation_language_statements()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_functionContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.Tokens.DROP.rawValue, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func function_name() -> Function_nameContext? {
			return getRuleContext(Function_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_function(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_function() throws -> Drop_functionContext {
		var _localctx: Drop_functionContext = Drop_functionContext(_ctx, getState())
		try enterRule(_localctx, 8, plsqlParser.RULE_drop_function)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(812)
		 	try match(plsqlParser.Tokens.DROP.rawValue)
		 	setState(813)
		 	try match(plsqlParser.Tokens.FUNCTION.rawValue)
		 	setState(814)
		 	try function_name()
		 	setState(815)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_functionContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALTER.rawValue, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func function_name() -> Function_nameContext? {
			return getRuleContext(Function_nameContext.self,0)
		}
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMPILE.rawValue, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEBUG.rawValue, 0) }
		open func compiler_parameters_clause() -> Array<Compiler_parameters_clauseContext> {
			return getRuleContexts(Compiler_parameters_clauseContext.self)
		}
		open func compiler_parameters_clause(_ i: Int) -> Compiler_parameters_clauseContext? {
			return getRuleContext(Compiler_parameters_clauseContext.self,i)
		}
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REUSE.rawValue, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SETTINGS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_function(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_function() throws -> Alter_functionContext {
		var _localctx: Alter_functionContext = Alter_functionContext(_ctx, getState())
		try enterRule(_localctx, 10, plsqlParser.RULE_alter_function)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(817)
		 	try match(plsqlParser.Tokens.ALTER.rawValue)
		 	setState(818)
		 	try match(plsqlParser.Tokens.FUNCTION.rawValue)
		 	setState(819)
		 	try function_name()
		 	setState(820)
		 	try match(plsqlParser.Tokens.COMPILE.rawValue)
		 	setState(822)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,5,_ctx)) {
		 	case 1:
		 		setState(821)
		 		try match(plsqlParser.Tokens.DEBUG.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(827)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,6,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(824)
		 			try compiler_parameters_clause()

		 	 
		 		}
		 		setState(829)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,6,_ctx)
		 	}
		 	setState(832)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.REUSE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(830)
		 		try match(plsqlParser.Tokens.REUSE.rawValue)
		 		setState(831)
		 		try match(plsqlParser.Tokens.SETTINGS.rawValue)

		 	}

		 	setState(834)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_function_bodyContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CREATE.rawValue, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func function_name() -> Function_nameContext? {
			return getRuleContext(Function_nameContext.self,0)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func USING() -> TerminalNode? { return getToken(plsqlParser.Tokens.USING.rawValue, 0) }
		open func implementation_type_name() -> Implementation_type_nameContext? {
			return getRuleContext(Implementation_type_nameContext.self,0)
		}
		open func OR() -> TerminalNode? { return getToken(plsqlParser.Tokens.OR.rawValue, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REPLACE.rawValue, 0) }
		open func parameter() -> Array<ParameterContext> {
			return getRuleContexts(ParameterContext.self)
		}
		open func parameter(_ i: Int) -> ParameterContext? {
			return getRuleContext(ParameterContext.self,i)
		}
		open func invoker_rights_clause() -> Array<Invoker_rights_clauseContext> {
			return getRuleContexts(Invoker_rights_clauseContext.self)
		}
		open func invoker_rights_clause(_ i: Int) -> Invoker_rights_clauseContext? {
			return getRuleContext(Invoker_rights_clauseContext.self,i)
		}
		open func parallel_enable_clause() -> Array<Parallel_enable_clauseContext> {
			return getRuleContexts(Parallel_enable_clauseContext.self)
		}
		open func parallel_enable_clause(_ i: Int) -> Parallel_enable_clauseContext? {
			return getRuleContext(Parallel_enable_clauseContext.self,i)
		}
		open func result_cache_clause() -> Array<Result_cache_clauseContext> {
			return getRuleContexts(Result_cache_clauseContext.self)
		}
		open func result_cache_clause(_ i: Int) -> Result_cache_clauseContext? {
			return getRuleContext(Result_cache_clauseContext.self,i)
		}
		open func DETERMINISTIC() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.DETERMINISTIC.rawValue) }
		open func DETERMINISTIC(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.DETERMINISTIC.rawValue, i)
		}
		open func PIPELINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.PIPELINED.rawValue, 0) }
		open func AGGREGATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.AGGREGATE.rawValue, 0) }
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECLARE.rawValue, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_function_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_function_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_function_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_function_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_function_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_function_body() throws -> Create_function_bodyContext {
		var _localctx: Create_function_bodyContext = Create_function_bodyContext(_ctx, getState())
		try enterRule(_localctx, 12, plsqlParser.RULE_create_function_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(836)
		 	try match(plsqlParser.Tokens.CREATE.rawValue)
		 	setState(839)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(837)
		 		try match(plsqlParser.Tokens.OR.rawValue)
		 		setState(838)
		 		try match(plsqlParser.Tokens.REPLACE.rawValue)

		 	}

		 	setState(841)
		 	try match(plsqlParser.Tokens.FUNCTION.rawValue)
		 	setState(842)
		 	try function_name()
		 	setState(854)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(843)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(844)
		 		try parameter()
		 		setState(849)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(845)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(846)
		 			try parameter()


		 			setState(851)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(852)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(856)
		 	try match(plsqlParser.Tokens.RETURN.rawValue)
		 	setState(857)
		 	try type_spec()
		 	setState(864)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AUTHID.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.DETERMINISTIC.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.PARALLEL_ENABLE.rawValue || _la == plsqlParser.Tokens.RESULT_CACHE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(862)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .AUTHID:
		 			setState(858)
		 			try invoker_rights_clause()

		 			break

		 		case .PARALLEL_ENABLE:
		 			setState(859)
		 			try parallel_enable_clause()

		 			break

		 		case .RESULT_CACHE:
		 			setState(860)
		 			try result_cache_clause()

		 			break

		 		case .DETERMINISTIC:
		 			setState(861)
		 			try match(plsqlParser.Tokens.DETERMINISTIC.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(866)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(887)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,17, _ctx)) {
		 	case 1:
		 		setState(868)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.PIPELINED.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(867)
		 			try match(plsqlParser.Tokens.PIPELINED.rawValue)

		 		}

		 		setState(870)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(882)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,16, _ctx)) {
		 		case 1:
		 			setState(872)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.DECLARE.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(871)
		 				try match(plsqlParser.Tokens.DECLARE.rawValue)

		 			}

		 			setState(877)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 66)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 130)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 194)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 259)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 323)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 387)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 451)
		 			          }()
		 			          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(874)
		 				try declare_spec()


		 				setState(879)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(880)
		 			try body()

		 			break
		 		case 2:
		 			setState(881)
		 			try call_spec()

		 			break
		 		default: break
		 		}


		 		break
		 	case 2:
		 		setState(884)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.AGGREGATE.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.PIPELINED.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(885)
		 		try match(plsqlParser.Tokens.USING.rawValue)
		 		setState(886)
		 		try implementation_type_name()

		 		break
		 	default: break
		 	}
		 	setState(889)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Parallel_enable_clauseContext:ParserRuleContext {
		open func PARALLEL_ENABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PARALLEL_ENABLE.rawValue, 0) }
		open func partition_by_clause() -> Partition_by_clauseContext? {
			return getRuleContext(Partition_by_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_parallel_enable_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterParallel_enable_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitParallel_enable_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitParallel_enable_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitParallel_enable_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func parallel_enable_clause() throws -> Parallel_enable_clauseContext {
		var _localctx: Parallel_enable_clauseContext = Parallel_enable_clauseContext(_ctx, getState())
		try enterRule(_localctx, 14, plsqlParser.RULE_parallel_enable_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(891)
		 	try match(plsqlParser.Tokens.PARALLEL_ENABLE.rawValue)
		 	setState(893)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(892)
		 		try partition_by_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Partition_by_clauseContext:ParserRuleContext {
		open func PARTITION() -> TerminalNode? { return getToken(plsqlParser.Tokens.PARTITION.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func ANY() -> TerminalNode? { return getToken(plsqlParser.Tokens.ANY.rawValue, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func HASH() -> TerminalNode? { return getToken(plsqlParser.Tokens.HASH.rawValue, 0) }
		open func RANGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.RANGE.rawValue, 0) }
		open func streaming_clause() -> Streaming_clauseContext? {
			return getRuleContext(Streaming_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_partition_by_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPartition_by_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPartition_by_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPartition_by_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPartition_by_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func partition_by_clause() throws -> Partition_by_clauseContext {
		var _localctx: Partition_by_clauseContext = Partition_by_clauseContext(_ctx, getState())
		try enterRule(_localctx, 16, plsqlParser.RULE_partition_by_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(895)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(896)
		 	try match(plsqlParser.Tokens.PARTITION.rawValue)
		 	setState(897)
		 	try expression()
		 	setState(898)
		 	try match(plsqlParser.Tokens.BY.rawValue)
		 	setState(912)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ANY:
		 		setState(899)
		 		try match(plsqlParser.Tokens.ANY.rawValue)

		 		break
		 	case .HASH:fallthrough
		 	case .RANGE:
		 		setState(900)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.HASH.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.RANGE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(901)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(902)
		 		try column_name()
		 		setState(907)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(903)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(904)
		 			try column_name()


		 			setState(909)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(910)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(915)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.CLUSTER.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.ORDER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(914)
		 		try streaming_clause()

		 	}

		 	setState(917)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Result_cache_clauseContext:ParserRuleContext {
		open func RESULT_CACHE() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESULT_CACHE.rawValue, 0) }
		open func relies_on_part() -> Relies_on_partContext? {
			return getRuleContext(Relies_on_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_result_cache_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterResult_cache_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitResult_cache_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitResult_cache_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitResult_cache_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func result_cache_clause() throws -> Result_cache_clauseContext {
		var _localctx: Result_cache_clauseContext = Result_cache_clauseContext(_ctx, getState())
		try enterRule(_localctx, 18, plsqlParser.RULE_result_cache_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(919)
		 	try match(plsqlParser.Tokens.RESULT_CACHE.rawValue)
		 	setState(921)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RELIES_ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(920)
		 		try relies_on_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Relies_on_partContext:ParserRuleContext {
		open func RELIES_ON() -> TerminalNode? { return getToken(plsqlParser.Tokens.RELIES_ON.rawValue, 0) }
		open func tableview_name() -> Array<Tableview_nameContext> {
			return getRuleContexts(Tableview_nameContext.self)
		}
		open func tableview_name(_ i: Int) -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_relies_on_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRelies_on_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRelies_on_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRelies_on_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRelies_on_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func relies_on_part() throws -> Relies_on_partContext {
		var _localctx: Relies_on_partContext = Relies_on_partContext(_ctx, getState())
		try enterRule(_localctx, 20, plsqlParser.RULE_relies_on_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(923)
		 	try match(plsqlParser.Tokens.RELIES_ON.rawValue)
		 	setState(924)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(925)
		 	try tableview_name()
		 	setState(930)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(926)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(927)
		 		try tableview_name()


		 		setState(932)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(933)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Streaming_clauseContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ORDER.rawValue, 0) }
		open func CLUSTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.CLUSTER.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_streaming_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStreaming_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStreaming_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStreaming_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStreaming_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func streaming_clause() throws -> Streaming_clauseContext {
		var _localctx: Streaming_clauseContext = Streaming_clauseContext(_ctx, getState())
		try enterRule(_localctx, 22, plsqlParser.RULE_streaming_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(935)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.CLUSTER.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.ORDER.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(936)
		 	try expression()
		 	setState(937)
		 	try match(plsqlParser.Tokens.BY.rawValue)
		 	setState(938)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(939)
		 	try column_name()
		 	setState(944)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(940)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(941)
		 		try column_name()


		 		setState(946)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(947)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_packageContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.Tokens.DROP.rawValue, 0) }
		open func PACKAGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PACKAGE.rawValue, 0) }
		open func package_name() -> Package_nameContext? {
			return getRuleContext(Package_nameContext.self,0)
		}
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BODY.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_package }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_package(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_package(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_package(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_package(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_package() throws -> Drop_packageContext {
		var _localctx: Drop_packageContext = Drop_packageContext(_ctx, getState())
		try enterRule(_localctx, 24, plsqlParser.RULE_drop_package)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(949)
		 	try match(plsqlParser.Tokens.DROP.rawValue)
		 	setState(950)
		 	try match(plsqlParser.Tokens.PACKAGE.rawValue)
		 	setState(952)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,25,_ctx)) {
		 	case 1:
		 		setState(951)
		 		try match(plsqlParser.Tokens.BODY.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(954)
		 	try package_name()
		 	setState(955)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_packageContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALTER.rawValue, 0) }
		open func PACKAGE() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.PACKAGE.rawValue) }
		open func PACKAGE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.PACKAGE.rawValue, i)
		}
		open func package_name() -> Package_nameContext? {
			return getRuleContext(Package_nameContext.self,0)
		}
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMPILE.rawValue, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEBUG.rawValue, 0) }
		open func compiler_parameters_clause() -> Array<Compiler_parameters_clauseContext> {
			return getRuleContexts(Compiler_parameters_clauseContext.self)
		}
		open func compiler_parameters_clause(_ i: Int) -> Compiler_parameters_clauseContext? {
			return getRuleContext(Compiler_parameters_clauseContext.self,i)
		}
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REUSE.rawValue, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SETTINGS.rawValue, 0) }
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BODY.rawValue, 0) }
		open func SPECIFICATION() -> TerminalNode? { return getToken(plsqlParser.Tokens.SPECIFICATION.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_package }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_package(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_package(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_package(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_package(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_package() throws -> Alter_packageContext {
		var _localctx: Alter_packageContext = Alter_packageContext(_ctx, getState())
		try enterRule(_localctx, 26, plsqlParser.RULE_alter_package)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(957)
		 	try match(plsqlParser.Tokens.ALTER.rawValue)
		 	setState(958)
		 	try match(plsqlParser.Tokens.PACKAGE.rawValue)
		 	setState(959)
		 	try package_name()
		 	setState(960)
		 	try match(plsqlParser.Tokens.COMPILE.rawValue)
		 	setState(962)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,26,_ctx)) {
		 	case 1:
		 		setState(961)
		 		try match(plsqlParser.Tokens.DEBUG.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(965)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,27,_ctx)) {
		 	case 1:
		 		setState(964)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.BODY.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.PACKAGE.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.SPECIFICATION.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(970)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,28,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(967)
		 			try compiler_parameters_clause()

		 	 
		 		}
		 		setState(972)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,28,_ctx)
		 	}
		 	setState(975)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.REUSE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(973)
		 		try match(plsqlParser.Tokens.REUSE.rawValue)
		 		setState(974)
		 		try match(plsqlParser.Tokens.SETTINGS.rawValue)

		 	}

		 	setState(977)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_packageContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CREATE.rawValue, 0) }
		open func PACKAGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PACKAGE.rawValue, 0) }
		open func package_name() -> Array<Package_nameContext> {
			return getRuleContexts(Package_nameContext.self)
		}
		open func package_name(_ i: Int) -> Package_nameContext? {
			return getRuleContext(Package_nameContext.self,i)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.Tokens.END.rawValue, 0) }
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func OR() -> TerminalNode? { return getToken(plsqlParser.Tokens.OR.rawValue, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REPLACE.rawValue, 0) }
		open func invoker_rights_clause() -> Invoker_rights_clauseContext? {
			return getRuleContext(Invoker_rights_clauseContext.self,0)
		}
		open func package_obj_spec() -> Array<Package_obj_specContext> {
			return getRuleContexts(Package_obj_specContext.self)
		}
		open func package_obj_spec(_ i: Int) -> Package_obj_specContext? {
			return getRuleContext(Package_obj_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_package }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_package(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_package(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_package(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_package(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_package() throws -> Create_packageContext {
		var _localctx: Create_packageContext = Create_packageContext(_ctx, getState())
		try enterRule(_localctx, 28, plsqlParser.RULE_create_package)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(979)
		 	try match(plsqlParser.Tokens.CREATE.rawValue)
		 	setState(982)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(980)
		 		try match(plsqlParser.Tokens.OR.rawValue)
		 		setState(981)
		 		try match(plsqlParser.Tokens.REPLACE.rawValue)

		 	}

		 	setState(984)
		 	try match(plsqlParser.Tokens.PACKAGE.rawValue)
		 	setState(985)
		 	try package_name()
		 	setState(987)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.AUTHID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(986)
		 		try invoker_rights_clause()

		 	}

		 	setState(989)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(993)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(990)
		 		try package_obj_spec()


		 		setState(995)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(996)
		 	try match(plsqlParser.Tokens.END.rawValue)
		 	setState(998)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(997)
		 		try package_name()

		 	}

		 	setState(1000)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_package_bodyContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CREATE.rawValue, 0) }
		open func PACKAGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PACKAGE.rawValue, 0) }
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BODY.rawValue, 0) }
		open func package_name() -> Array<Package_nameContext> {
			return getRuleContexts(Package_nameContext.self)
		}
		open func package_name(_ i: Int) -> Package_nameContext? {
			return getRuleContext(Package_nameContext.self,i)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func BEGIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.BEGIN.rawValue, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.Tokens.END.rawValue, 0) }
		open func OR() -> TerminalNode? { return getToken(plsqlParser.Tokens.OR.rawValue, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REPLACE.rawValue, 0) }
		open func package_obj_body() -> Array<Package_obj_bodyContext> {
			return getRuleContexts(Package_obj_bodyContext.self)
		}
		open func package_obj_body(_ i: Int) -> Package_obj_bodyContext? {
			return getRuleContext(Package_obj_bodyContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_package_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_package_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_package_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_package_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_package_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_package_body() throws -> Create_package_bodyContext {
		var _localctx: Create_package_bodyContext = Create_package_bodyContext(_ctx, getState())
		try enterRule(_localctx, 30, plsqlParser.RULE_create_package_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1002)
		 	try match(plsqlParser.Tokens.CREATE.rawValue)
		 	setState(1005)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1003)
		 		try match(plsqlParser.Tokens.OR.rawValue)
		 		setState(1004)
		 		try match(plsqlParser.Tokens.REPLACE.rawValue)

		 	}

		 	setState(1007)
		 	try match(plsqlParser.Tokens.PACKAGE.rawValue)
		 	setState(1008)
		 	try match(plsqlParser.Tokens.BODY.rawValue)
		 	setState(1009)
		 	try package_name()
		 	setState(1010)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1014)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1011)
		 		try package_obj_body()


		 		setState(1016)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1023)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .BEGIN:
		 		setState(1017)
		 		try match(plsqlParser.Tokens.BEGIN.rawValue)
		 		setState(1018)
		 		try seq_of_statements()

		 		break

		 	case .END:
		 		setState(1019)
		 		try match(plsqlParser.Tokens.END.rawValue)
		 		setState(1021)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 66)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 130)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 194)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 259)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 323)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 387)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 451)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1020)
		 			try package_name()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1025)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Package_obj_specContext:ParserRuleContext {
		open func variable_declaration() -> Variable_declarationContext? {
			return getRuleContext(Variable_declarationContext.self,0)
		}
		open func subtype_declaration() -> Subtype_declarationContext? {
			return getRuleContext(Subtype_declarationContext.self,0)
		}
		open func cursor_declaration() -> Cursor_declarationContext? {
			return getRuleContext(Cursor_declarationContext.self,0)
		}
		open func exception_declaration() -> Exception_declarationContext? {
			return getRuleContext(Exception_declarationContext.self,0)
		}
		open func pragma_declaration() -> Pragma_declarationContext? {
			return getRuleContext(Pragma_declarationContext.self,0)
		}
		open func type_declaration() -> Type_declarationContext? {
			return getRuleContext(Type_declarationContext.self,0)
		}
		open func procedure_spec() -> Procedure_specContext? {
			return getRuleContext(Procedure_specContext.self,0)
		}
		open func function_spec() -> Function_specContext? {
			return getRuleContext(Function_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_package_obj_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPackage_obj_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPackage_obj_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPackage_obj_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPackage_obj_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func package_obj_spec() throws -> Package_obj_specContext {
		var _localctx: Package_obj_specContext = Package_obj_specContext(_ctx, getState())
		try enterRule(_localctx, 32, plsqlParser.RULE_package_obj_spec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1035)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,38, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1027)
		 		try variable_declaration()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1028)
		 		try subtype_declaration()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1029)
		 		try cursor_declaration()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1030)
		 		try exception_declaration()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1031)
		 		try pragma_declaration()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1032)
		 		try type_declaration()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1033)
		 		try procedure_spec()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1034)
		 		try function_spec()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Procedure_specContext:ParserRuleContext {
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PROCEDURE.rawValue, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func parameter() -> Array<ParameterContext> {
			return getRuleContexts(ParameterContext.self)
		}
		open func parameter(_ i: Int) -> ParameterContext? {
			return getRuleContext(ParameterContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_procedure_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterProcedure_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitProcedure_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitProcedure_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitProcedure_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedure_spec() throws -> Procedure_specContext {
		var _localctx: Procedure_specContext = Procedure_specContext(_ctx, getState())
		try enterRule(_localctx, 34, plsqlParser.RULE_procedure_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1037)
		 	try match(plsqlParser.Tokens.PROCEDURE.rawValue)
		 	setState(1038)
		 	try identifier()
		 	setState(1050)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1039)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(1040)
		 		try parameter()
		 		setState(1045)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1041)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1042)
		 			try parameter()


		 			setState(1047)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1048)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(1052)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_specContext:ParserRuleContext {
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func parameter() -> Array<ParameterContext> {
			return getRuleContexts(ParameterContext.self)
		}
		open func parameter(_ i: Int) -> ParameterContext? {
			return getRuleContext(ParameterContext.self,i)
		}
		open func DETERMINISTIC() -> TerminalNode? { return getToken(plsqlParser.Tokens.DETERMINISTIC.rawValue, 0) }
		open func RESULT_CACHE() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESULT_CACHE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_spec() throws -> Function_specContext {
		var _localctx: Function_specContext = Function_specContext(_ctx, getState())
		try enterRule(_localctx, 36, plsqlParser.RULE_function_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1054)
		 	try match(plsqlParser.Tokens.FUNCTION.rawValue)
		 	setState(1055)
		 	try identifier()
		 	setState(1067)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1056)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(1057)
		 		try parameter()
		 		setState(1062)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1058)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1059)
		 			try parameter()


		 			setState(1064)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1065)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(1069)
		 	try match(plsqlParser.Tokens.RETURN.rawValue)
		 	setState(1070)
		 	try type_spec()
		 	setState(1072)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.DETERMINISTIC.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1071)
		 		try match(plsqlParser.Tokens.DETERMINISTIC.rawValue)

		 	}

		 	setState(1075)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RESULT_CACHE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1074)
		 		try match(plsqlParser.Tokens.RESULT_CACHE.rawValue)

		 	}

		 	setState(1077)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Package_obj_bodyContext:ParserRuleContext {
		open func variable_declaration() -> Variable_declarationContext? {
			return getRuleContext(Variable_declarationContext.self,0)
		}
		open func subtype_declaration() -> Subtype_declarationContext? {
			return getRuleContext(Subtype_declarationContext.self,0)
		}
		open func cursor_declaration() -> Cursor_declarationContext? {
			return getRuleContext(Cursor_declarationContext.self,0)
		}
		open func exception_declaration() -> Exception_declarationContext? {
			return getRuleContext(Exception_declarationContext.self,0)
		}
		open func type_declaration() -> Type_declarationContext? {
			return getRuleContext(Type_declarationContext.self,0)
		}
		open func procedure_body() -> Procedure_bodyContext? {
			return getRuleContext(Procedure_bodyContext.self,0)
		}
		open func function_body() -> Function_bodyContext? {
			return getRuleContext(Function_bodyContext.self,0)
		}
		open func procedure_spec() -> Procedure_specContext? {
			return getRuleContext(Procedure_specContext.self,0)
		}
		open func function_spec() -> Function_specContext? {
			return getRuleContext(Function_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_package_obj_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPackage_obj_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPackage_obj_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPackage_obj_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPackage_obj_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func package_obj_body() throws -> Package_obj_bodyContext {
		var _localctx: Package_obj_bodyContext = Package_obj_bodyContext(_ctx, getState())
		try enterRule(_localctx, 38, plsqlParser.RULE_package_obj_body)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1088)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,45, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1079)
		 		try variable_declaration()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1080)
		 		try subtype_declaration()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1081)
		 		try cursor_declaration()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1082)
		 		try exception_declaration()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1083)
		 		try type_declaration()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1084)
		 		try procedure_body()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1085)
		 		try function_body()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1086)
		 		try procedure_spec()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1087)
		 		try function_spec()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_procedureContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.Tokens.DROP.rawValue, 0) }
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PROCEDURE.rawValue, 0) }
		open func procedure_name() -> Procedure_nameContext? {
			return getRuleContext(Procedure_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_procedure }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_procedure(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_procedure(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_procedure(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_procedure(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_procedure() throws -> Drop_procedureContext {
		var _localctx: Drop_procedureContext = Drop_procedureContext(_ctx, getState())
		try enterRule(_localctx, 40, plsqlParser.RULE_drop_procedure)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1090)
		 	try match(plsqlParser.Tokens.DROP.rawValue)
		 	setState(1091)
		 	try match(plsqlParser.Tokens.PROCEDURE.rawValue)
		 	setState(1092)
		 	try procedure_name()
		 	setState(1093)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_procedureContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALTER.rawValue, 0) }
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PROCEDURE.rawValue, 0) }
		open func procedure_name() -> Procedure_nameContext? {
			return getRuleContext(Procedure_nameContext.self,0)
		}
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMPILE.rawValue, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEBUG.rawValue, 0) }
		open func compiler_parameters_clause() -> Array<Compiler_parameters_clauseContext> {
			return getRuleContexts(Compiler_parameters_clauseContext.self)
		}
		open func compiler_parameters_clause(_ i: Int) -> Compiler_parameters_clauseContext? {
			return getRuleContext(Compiler_parameters_clauseContext.self,i)
		}
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REUSE.rawValue, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SETTINGS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_procedure }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_procedure(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_procedure(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_procedure(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_procedure(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_procedure() throws -> Alter_procedureContext {
		var _localctx: Alter_procedureContext = Alter_procedureContext(_ctx, getState())
		try enterRule(_localctx, 42, plsqlParser.RULE_alter_procedure)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1095)
		 	try match(plsqlParser.Tokens.ALTER.rawValue)
		 	setState(1096)
		 	try match(plsqlParser.Tokens.PROCEDURE.rawValue)
		 	setState(1097)
		 	try procedure_name()
		 	setState(1098)
		 	try match(plsqlParser.Tokens.COMPILE.rawValue)
		 	setState(1100)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,46,_ctx)) {
		 	case 1:
		 		setState(1099)
		 		try match(plsqlParser.Tokens.DEBUG.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1105)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,47,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1102)
		 			try compiler_parameters_clause()

		 	 
		 		}
		 		setState(1107)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,47,_ctx)
		 	}
		 	setState(1110)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.REUSE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1108)
		 		try match(plsqlParser.Tokens.REUSE.rawValue)
		 		setState(1109)
		 		try match(plsqlParser.Tokens.SETTINGS.rawValue)

		 	}

		 	setState(1112)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_bodyContext:ParserRuleContext {
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func USING() -> TerminalNode? { return getToken(plsqlParser.Tokens.USING.rawValue, 0) }
		open func implementation_type_name() -> Implementation_type_nameContext? {
			return getRuleContext(Implementation_type_nameContext.self,0)
		}
		open func parameter() -> Array<ParameterContext> {
			return getRuleContexts(ParameterContext.self)
		}
		open func parameter(_ i: Int) -> ParameterContext? {
			return getRuleContext(ParameterContext.self,i)
		}
		open func invoker_rights_clause() -> Array<Invoker_rights_clauseContext> {
			return getRuleContexts(Invoker_rights_clauseContext.self)
		}
		open func invoker_rights_clause(_ i: Int) -> Invoker_rights_clauseContext? {
			return getRuleContext(Invoker_rights_clauseContext.self,i)
		}
		open func parallel_enable_clause() -> Array<Parallel_enable_clauseContext> {
			return getRuleContexts(Parallel_enable_clauseContext.self)
		}
		open func parallel_enable_clause(_ i: Int) -> Parallel_enable_clauseContext? {
			return getRuleContext(Parallel_enable_clauseContext.self,i)
		}
		open func result_cache_clause() -> Array<Result_cache_clauseContext> {
			return getRuleContexts(Result_cache_clauseContext.self)
		}
		open func result_cache_clause(_ i: Int) -> Result_cache_clauseContext? {
			return getRuleContext(Result_cache_clauseContext.self,i)
		}
		open func DETERMINISTIC() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.DETERMINISTIC.rawValue) }
		open func DETERMINISTIC(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.DETERMINISTIC.rawValue, i)
		}
		open func PIPELINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.PIPELINED.rawValue, 0) }
		open func AGGREGATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.AGGREGATE.rawValue, 0) }
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECLARE.rawValue, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_body() throws -> Function_bodyContext {
		var _localctx: Function_bodyContext = Function_bodyContext(_ctx, getState())
		try enterRule(_localctx, 44, plsqlParser.RULE_function_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1114)
		 	try match(plsqlParser.Tokens.FUNCTION.rawValue)
		 	setState(1115)
		 	try identifier()
		 	setState(1127)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1116)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(1117)
		 		try parameter()
		 		setState(1122)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1118)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1119)
		 			try parameter()


		 			setState(1124)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1125)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(1129)
		 	try match(plsqlParser.Tokens.RETURN.rawValue)
		 	setState(1130)
		 	try type_spec()
		 	setState(1137)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AUTHID.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.DETERMINISTIC.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.PARALLEL_ENABLE.rawValue || _la == plsqlParser.Tokens.RESULT_CACHE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1135)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .AUTHID:
		 			setState(1131)
		 			try invoker_rights_clause()

		 			break

		 		case .PARALLEL_ENABLE:
		 			setState(1132)
		 			try parallel_enable_clause()

		 			break

		 		case .RESULT_CACHE:
		 			setState(1133)
		 			try result_cache_clause()

		 			break

		 		case .DETERMINISTIC:
		 			setState(1134)
		 			try match(plsqlParser.Tokens.DETERMINISTIC.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(1139)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1160)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,57, _ctx)) {
		 	case 1:
		 		setState(1141)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.PIPELINED.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1140)
		 			try match(plsqlParser.Tokens.PIPELINED.rawValue)

		 		}

		 		setState(1143)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1155)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,56, _ctx)) {
		 		case 1:
		 			setState(1145)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.DECLARE.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(1144)
		 				try match(plsqlParser.Tokens.DECLARE.rawValue)

		 			}

		 			setState(1150)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 66)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 130)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 194)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 259)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 323)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 387)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 451)
		 			          }()
		 			          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(1147)
		 				try declare_spec()


		 				setState(1152)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(1153)
		 			try body()

		 			break
		 		case 2:
		 			setState(1154)
		 			try call_spec()

		 			break
		 		default: break
		 		}


		 		break
		 	case 2:
		 		setState(1157)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.AGGREGATE.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.PIPELINED.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1158)
		 		try match(plsqlParser.Tokens.USING.rawValue)
		 		setState(1159)
		 		try implementation_type_name()

		 		break
		 	default: break
		 	}
		 	setState(1162)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Procedure_bodyContext:ParserRuleContext {
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PROCEDURE.rawValue, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func EXTERNAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXTERNAL.rawValue, 0) }
		open func parameter() -> Array<ParameterContext> {
			return getRuleContexts(ParameterContext.self)
		}
		open func parameter(_ i: Int) -> ParameterContext? {
			return getRuleContext(ParameterContext.self,i)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECLARE.rawValue, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_procedure_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterProcedure_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitProcedure_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitProcedure_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitProcedure_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedure_body() throws -> Procedure_bodyContext {
		var _localctx: Procedure_bodyContext = Procedure_bodyContext(_ctx, getState())
		try enterRule(_localctx, 46, plsqlParser.RULE_procedure_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1164)
		 	try match(plsqlParser.Tokens.PROCEDURE.rawValue)
		 	setState(1165)
		 	try identifier()
		 	setState(1177)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1166)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(1167)
		 		try parameter()
		 		setState(1172)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1168)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1169)
		 			try parameter()


		 			setState(1174)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1175)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(1179)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1192)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,62, _ctx)) {
		 	case 1:
		 		setState(1181)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.DECLARE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1180)
		 			try match(plsqlParser.Tokens.DECLARE.rawValue)

		 		}

		 		setState(1186)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 66)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 130)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 194)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 259)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 323)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 387)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 451)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1183)
		 			try declare_spec()


		 			setState(1188)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1189)
		 		try body()

		 		break
		 	case 2:
		 		setState(1190)
		 		try call_spec()

		 		break
		 	case 3:
		 		setState(1191)
		 		try match(plsqlParser.Tokens.EXTERNAL.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1194)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_procedure_bodyContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CREATE.rawValue, 0) }
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PROCEDURE.rawValue, 0) }
		open func procedure_name() -> Procedure_nameContext? {
			return getRuleContext(Procedure_nameContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func EXTERNAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXTERNAL.rawValue, 0) }
		open func OR() -> TerminalNode? { return getToken(plsqlParser.Tokens.OR.rawValue, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REPLACE.rawValue, 0) }
		open func parameter() -> Array<ParameterContext> {
			return getRuleContexts(ParameterContext.self)
		}
		open func parameter(_ i: Int) -> ParameterContext? {
			return getRuleContext(ParameterContext.self,i)
		}
		open func invoker_rights_clause() -> Invoker_rights_clauseContext? {
			return getRuleContext(Invoker_rights_clauseContext.self,0)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECLARE.rawValue, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_procedure_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_procedure_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_procedure_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_procedure_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_procedure_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_procedure_body() throws -> Create_procedure_bodyContext {
		var _localctx: Create_procedure_bodyContext = Create_procedure_bodyContext(_ctx, getState())
		try enterRule(_localctx, 48, plsqlParser.RULE_create_procedure_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1196)
		 	try match(plsqlParser.Tokens.CREATE.rawValue)
		 	setState(1199)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1197)
		 		try match(plsqlParser.Tokens.OR.rawValue)
		 		setState(1198)
		 		try match(plsqlParser.Tokens.REPLACE.rawValue)

		 	}

		 	setState(1201)
		 	try match(plsqlParser.Tokens.PROCEDURE.rawValue)
		 	setState(1202)
		 	try procedure_name()
		 	setState(1214)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1203)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(1204)
		 		try parameter()
		 		setState(1209)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1205)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1206)
		 			try parameter()


		 			setState(1211)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1212)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(1217)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.AUTHID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1216)
		 		try invoker_rights_clause()

		 	}

		 	setState(1219)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1232)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,69, _ctx)) {
		 	case 1:
		 		setState(1221)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.DECLARE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1220)
		 			try match(plsqlParser.Tokens.DECLARE.rawValue)

		 		}

		 		setState(1226)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 66)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 130)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 194)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 259)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 323)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 387)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 451)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1223)
		 			try declare_spec()


		 			setState(1228)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1229)
		 		try body()

		 		break
		 	case 2:
		 		setState(1230)
		 		try call_spec()

		 		break
		 	case 3:
		 		setState(1231)
		 		try match(plsqlParser.Tokens.EXTERNAL.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1234)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_triggerContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.Tokens.DROP.rawValue, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRIGGER.rawValue, 0) }
		open func trigger_name() -> Trigger_nameContext? {
			return getRuleContext(Trigger_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_trigger() throws -> Drop_triggerContext {
		var _localctx: Drop_triggerContext = Drop_triggerContext(_ctx, getState())
		try enterRule(_localctx, 50, plsqlParser.RULE_drop_trigger)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1236)
		 	try match(plsqlParser.Tokens.DROP.rawValue)
		 	setState(1237)
		 	try match(plsqlParser.Tokens.TRIGGER.rawValue)
		 	setState(1238)
		 	try trigger_name()
		 	setState(1239)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_triggerContext:ParserRuleContext {
		public var tn1: Trigger_nameContext!
		public var tn2: Trigger_nameContext!
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALTER.rawValue, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRIGGER.rawValue, 0) }
		open func trigger_name() -> Array<Trigger_nameContext> {
			return getRuleContexts(Trigger_nameContext.self)
		}
		open func trigger_name(_ i: Int) -> Trigger_nameContext? {
			return getRuleContext(Trigger_nameContext.self,i)
		}
		open func RENAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.RENAME.rawValue, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.Tokens.TO.rawValue, 0) }
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMPILE.rawValue, 0) }
		open func ENABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ENABLE.rawValue, 0) }
		open func DISABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DISABLE.rawValue, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEBUG.rawValue, 0) }
		open func compiler_parameters_clause() -> Array<Compiler_parameters_clauseContext> {
			return getRuleContexts(Compiler_parameters_clauseContext.self)
		}
		open func compiler_parameters_clause(_ i: Int) -> Compiler_parameters_clauseContext? {
			return getRuleContext(Compiler_parameters_clauseContext.self,i)
		}
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REUSE.rawValue, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SETTINGS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_trigger() throws -> Alter_triggerContext {
		var _localctx: Alter_triggerContext = Alter_triggerContext(_ctx, getState())
		try enterRule(_localctx, 52, plsqlParser.RULE_alter_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1241)
		 	try match(plsqlParser.Tokens.ALTER.rawValue)
		 	setState(1242)
		 	try match(plsqlParser.Tokens.TRIGGER.rawValue)
		 	setState(1243)
		 	try {
		 			let assignmentValue = try trigger_name()
		 			_localctx.castdown(Alter_triggerContext.self).tn1 = assignmentValue
		 	     }()

		 	setState(1262)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DISABLE:fallthrough
		 	case .ENABLE:
		 		setState(1244)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.DISABLE.rawValue || _la == plsqlParser.Tokens.ENABLE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .RENAME:
		 		setState(1245)
		 		try match(plsqlParser.Tokens.RENAME.rawValue)
		 		setState(1246)
		 		try match(plsqlParser.Tokens.TO.rawValue)
		 		setState(1247)
		 		try {
		 				let assignmentValue = try trigger_name()
		 				_localctx.castdown(Alter_triggerContext.self).tn2 = assignmentValue
		 		     }()


		 		break

		 	case .COMPILE:
		 		setState(1248)
		 		try match(plsqlParser.Tokens.COMPILE.rawValue)
		 		setState(1250)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,70,_ctx)) {
		 		case 1:
		 			setState(1249)
		 			try match(plsqlParser.Tokens.DEBUG.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(1255)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,71,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(1252)
		 				try compiler_parameters_clause()

		 		 
		 			}
		 			setState(1257)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,71,_ctx)
		 		}
		 		setState(1260)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.REUSE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1258)
		 			try match(plsqlParser.Tokens.REUSE.rawValue)
		 			setState(1259)
		 			try match(plsqlParser.Tokens.SETTINGS.rawValue)

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1264)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_triggerContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CREATE.rawValue, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRIGGER.rawValue, 0) }
		open func trigger_name() -> Trigger_nameContext? {
			return getRuleContext(Trigger_nameContext.self,0)
		}
		open func trigger_body() -> Trigger_bodyContext? {
			return getRuleContext(Trigger_bodyContext.self,0)
		}
		open func simple_dml_trigger() -> Simple_dml_triggerContext? {
			return getRuleContext(Simple_dml_triggerContext.self,0)
		}
		open func compound_dml_trigger() -> Compound_dml_triggerContext? {
			return getRuleContext(Compound_dml_triggerContext.self,0)
		}
		open func non_dml_trigger() -> Non_dml_triggerContext? {
			return getRuleContext(Non_dml_triggerContext.self,0)
		}
		open func OR() -> TerminalNode? { return getToken(plsqlParser.Tokens.OR.rawValue, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REPLACE.rawValue, 0) }
		open func trigger_follows_clause() -> Trigger_follows_clauseContext? {
			return getRuleContext(Trigger_follows_clauseContext.self,0)
		}
		open func trigger_when_clause() -> Trigger_when_clauseContext? {
			return getRuleContext(Trigger_when_clauseContext.self,0)
		}
		open func ENABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ENABLE.rawValue, 0) }
		open func DISABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DISABLE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_trigger() throws -> Create_triggerContext {
		var _localctx: Create_triggerContext = Create_triggerContext(_ctx, getState())
		try enterRule(_localctx, 54, plsqlParser.RULE_create_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1266)
		 	try match(plsqlParser.Tokens.CREATE.rawValue)
		 	setState(1269)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1267)
		 		try match(plsqlParser.Tokens.OR.rawValue)
		 		setState(1268)
		 		try match(plsqlParser.Tokens.REPLACE.rawValue)

		 	}

		 	setState(1271)
		 	try match(plsqlParser.Tokens.TRIGGER.rawValue)
		 	setState(1272)
		 	try trigger_name()
		 	setState(1276)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,75, _ctx)) {
		 	case 1:
		 		setState(1273)
		 		try simple_dml_trigger()

		 		break
		 	case 2:
		 		setState(1274)
		 		try compound_dml_trigger()

		 		break
		 	case 3:
		 		setState(1275)
		 		try non_dml_trigger()

		 		break
		 	default: break
		 	}
		 	setState(1279)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,76,_ctx)) {
		 	case 1:
		 		setState(1278)
		 		try trigger_follows_clause()

		 		break
		 	default: break
		 	}
		 	setState(1282)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,77,_ctx)) {
		 	case 1:
		 		setState(1281)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.DISABLE.rawValue || _la == plsqlParser.Tokens.ENABLE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(1285)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WHEN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1284)
		 		try trigger_when_clause()

		 	}

		 	setState(1287)
		 	try trigger_body()
		 	setState(1288)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Trigger_follows_clauseContext:ParserRuleContext {
		open func FOLLOWS() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOLLOWS.rawValue, 0) }
		open func trigger_name() -> Array<Trigger_nameContext> {
			return getRuleContexts(Trigger_nameContext.self)
		}
		open func trigger_name(_ i: Int) -> Trigger_nameContext? {
			return getRuleContext(Trigger_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_trigger_follows_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTrigger_follows_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTrigger_follows_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTrigger_follows_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTrigger_follows_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func trigger_follows_clause() throws -> Trigger_follows_clauseContext {
		var _localctx: Trigger_follows_clauseContext = Trigger_follows_clauseContext(_ctx, getState())
		try enterRule(_localctx, 56, plsqlParser.RULE_trigger_follows_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1290)
		 	try match(plsqlParser.Tokens.FOLLOWS.rawValue)
		 	setState(1291)
		 	try trigger_name()
		 	setState(1296)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1292)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(1293)
		 		try trigger_name()


		 		setState(1298)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Trigger_when_clauseContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHEN.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_trigger_when_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTrigger_when_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTrigger_when_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTrigger_when_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTrigger_when_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func trigger_when_clause() throws -> Trigger_when_clauseContext {
		var _localctx: Trigger_when_clauseContext = Trigger_when_clauseContext(_ctx, getState())
		try enterRule(_localctx, 58, plsqlParser.RULE_trigger_when_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1299)
		 	try match(plsqlParser.Tokens.WHEN.rawValue)
		 	setState(1300)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(1301)
		 	try condition()
		 	setState(1302)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Simple_dml_triggerContext:ParserRuleContext {
		open func dml_event_clause() -> Dml_event_clauseContext? {
			return getRuleContext(Dml_event_clauseContext.self,0)
		}
		open func BEFORE() -> TerminalNode? { return getToken(plsqlParser.Tokens.BEFORE.rawValue, 0) }
		open func AFTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.AFTER.rawValue, 0) }
		open func INSTEAD() -> TerminalNode? { return getToken(plsqlParser.Tokens.INSTEAD.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OF.rawValue, 0) }
		open func referencing_clause() -> Referencing_clauseContext? {
			return getRuleContext(Referencing_clauseContext.self,0)
		}
		open func for_each_row() -> For_each_rowContext? {
			return getRuleContext(For_each_rowContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_simple_dml_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSimple_dml_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSimple_dml_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSimple_dml_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSimple_dml_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func simple_dml_trigger() throws -> Simple_dml_triggerContext {
		var _localctx: Simple_dml_triggerContext = Simple_dml_triggerContext(_ctx, getState())
		try enterRule(_localctx, 60, plsqlParser.RULE_simple_dml_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1308)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .BEFORE:
		 		setState(1304)
		 		try match(plsqlParser.Tokens.BEFORE.rawValue)

		 		break

		 	case .AFTER:
		 		setState(1305)
		 		try match(plsqlParser.Tokens.AFTER.rawValue)

		 		break

		 	case .INSTEAD:
		 		setState(1306)
		 		try match(plsqlParser.Tokens.INSTEAD.rawValue)
		 		setState(1307)
		 		try match(plsqlParser.Tokens.OF.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1310)
		 	try dml_event_clause()
		 	setState(1312)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,81,_ctx)) {
		 	case 1:
		 		setState(1311)
		 		try referencing_clause()

		 		break
		 	default: break
		 	}
		 	setState(1315)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1314)
		 		try for_each_row()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_each_rowContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOR.rawValue, 0) }
		open func EACH() -> TerminalNode? { return getToken(plsqlParser.Tokens.EACH.rawValue, 0) }
		open func ROW() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROW.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_each_row }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_each_row(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_each_row(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_each_row(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_each_row(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_each_row() throws -> For_each_rowContext {
		var _localctx: For_each_rowContext = For_each_rowContext(_ctx, getState())
		try enterRule(_localctx, 62, plsqlParser.RULE_for_each_row)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1317)
		 	try match(plsqlParser.Tokens.FOR.rawValue)
		 	setState(1318)
		 	try match(plsqlParser.Tokens.EACH.rawValue)
		 	setState(1319)
		 	try match(plsqlParser.Tokens.ROW.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Compound_dml_triggerContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOR.rawValue, 0) }
		open func dml_event_clause() -> Dml_event_clauseContext? {
			return getRuleContext(Dml_event_clauseContext.self,0)
		}
		open func referencing_clause() -> Referencing_clauseContext? {
			return getRuleContext(Referencing_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compound_dml_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompound_dml_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompound_dml_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompound_dml_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompound_dml_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compound_dml_trigger() throws -> Compound_dml_triggerContext {
		var _localctx: Compound_dml_triggerContext = Compound_dml_triggerContext(_ctx, getState())
		try enterRule(_localctx, 64, plsqlParser.RULE_compound_dml_trigger)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1321)
		 	try match(plsqlParser.Tokens.FOR.rawValue)
		 	setState(1322)
		 	try dml_event_clause()
		 	setState(1324)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,83,_ctx)) {
		 	case 1:
		 		setState(1323)
		 		try referencing_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Non_dml_triggerContext:ParserRuleContext {
		open func non_dml_event() -> Array<Non_dml_eventContext> {
			return getRuleContexts(Non_dml_eventContext.self)
		}
		open func non_dml_event(_ i: Int) -> Non_dml_eventContext? {
			return getRuleContext(Non_dml_eventContext.self,i)
		}
		open func ON() -> TerminalNode? { return getToken(plsqlParser.Tokens.ON.rawValue, 0) }
		open func BEFORE() -> TerminalNode? { return getToken(plsqlParser.Tokens.BEFORE.rawValue, 0) }
		open func AFTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.AFTER.rawValue, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DATABASE.rawValue, 0) }
		open func SCHEMA() -> TerminalNode? { return getToken(plsqlParser.Tokens.SCHEMA.rawValue, 0) }
		open func OR() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.OR.rawValue) }
		open func OR(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.OR.rawValue, i)
		}
		open func schema_name() -> Schema_nameContext? {
			return getRuleContext(Schema_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_non_dml_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNon_dml_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNon_dml_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNon_dml_trigger(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNon_dml_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func non_dml_trigger() throws -> Non_dml_triggerContext {
		var _localctx: Non_dml_triggerContext = Non_dml_triggerContext(_ctx, getState())
		try enterRule(_localctx, 66, plsqlParser.RULE_non_dml_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1326)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.AFTER.rawValue || _la == plsqlParser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1327)
		 	try non_dml_event()
		 	setState(1332)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1328)
		 		try match(plsqlParser.Tokens.OR.rawValue)
		 		setState(1329)
		 		try non_dml_event()


		 		setState(1334)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1335)
		 	try match(plsqlParser.Tokens.ON.rawValue)
		 	setState(1343)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,86, _ctx)) {
		 	case 1:
		 		setState(1336)
		 		try match(plsqlParser.Tokens.DATABASE.rawValue)

		 		break
		 	case 2:
		 		setState(1340)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,85,_ctx)) {
		 		case 1:
		 			setState(1337)
		 			try schema_name()
		 			setState(1338)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(1342)
		 		try match(plsqlParser.Tokens.SCHEMA.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Trigger_bodyContext:ParserRuleContext {
		open func COMPOUND() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMPOUND.rawValue, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRIGGER.rawValue, 0) }
		open func CALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.CALL.rawValue, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func trigger_block() -> Trigger_blockContext? {
			return getRuleContext(Trigger_blockContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_trigger_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTrigger_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTrigger_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTrigger_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTrigger_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func trigger_body() throws -> Trigger_bodyContext {
		var _localctx: Trigger_bodyContext = Trigger_bodyContext(_ctx, getState())
		try enterRule(_localctx, 68, plsqlParser.RULE_trigger_body)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1350)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,87, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1345)
		 		try match(plsqlParser.Tokens.COMPOUND.rawValue)
		 		setState(1346)
		 		try match(plsqlParser.Tokens.TRIGGER.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1347)
		 		try match(plsqlParser.Tokens.CALL.rawValue)
		 		setState(1348)
		 		try identifier()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1349)
		 		try trigger_block()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Routine_clauseContext:ParserRuleContext {
		open func routine_name() -> Routine_nameContext? {
			return getRuleContext(Routine_nameContext.self,0)
		}
		open func function_argument() -> Function_argumentContext? {
			return getRuleContext(Function_argumentContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_routine_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRoutine_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRoutine_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRoutine_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRoutine_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func routine_clause() throws -> Routine_clauseContext {
		var _localctx: Routine_clauseContext = Routine_clauseContext(_ctx, getState())
		try enterRule(_localctx, 70, plsqlParser.RULE_routine_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1352)
		 	try routine_name()
		 	setState(1354)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1353)
		 		try function_argument()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Compound_trigger_blockContext:ParserRuleContext {
		open func COMPOUND() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMPOUND.rawValue, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRIGGER.rawValue, 0) }
		open func END() -> TerminalNode? { return getToken(plsqlParser.Tokens.END.rawValue, 0) }
		open func trigger_name() -> Trigger_nameContext? {
			return getRuleContext(Trigger_nameContext.self,0)
		}
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open func timing_point_section() -> Array<Timing_point_sectionContext> {
			return getRuleContexts(Timing_point_sectionContext.self)
		}
		open func timing_point_section(_ i: Int) -> Timing_point_sectionContext? {
			return getRuleContext(Timing_point_sectionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compound_trigger_block }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompound_trigger_block(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompound_trigger_block(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompound_trigger_block(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompound_trigger_block(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compound_trigger_block() throws -> Compound_trigger_blockContext {
		var _localctx: Compound_trigger_blockContext = Compound_trigger_blockContext(_ctx, getState())
		try enterRule(_localctx, 72, plsqlParser.RULE_compound_trigger_block)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1356)
		 	try match(plsqlParser.Tokens.COMPOUND.rawValue)
		 	setState(1357)
		 	try match(plsqlParser.Tokens.TRIGGER.rawValue)
		 	setState(1361)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,89,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1358)
		 			try declare_spec()

		 	 
		 		}
		 		setState(1363)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,89,_ctx)
		 	}
		 	setState(1365) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1364)
		 		try timing_point_section()


		 		setState(1367); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.AFTER.rawValue || _la == plsqlParser.Tokens.BEFORE.rawValue
		 	      return testSet
		 	 }())
		 	setState(1369)
		 	try match(plsqlParser.Tokens.END.rawValue)
		 	setState(1370)
		 	try trigger_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Timing_point_sectionContext:ParserRuleContext {
		public var bk: Token!
		public var ak: Token!
		open func STATEMENT() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.STATEMENT.rawValue) }
		open func STATEMENT(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.STATEMENT.rawValue, i)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func trigger_block() -> Trigger_blockContext? {
			return getRuleContext(Trigger_blockContext.self,0)
		}
		open func BEFORE() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.BEFORE.rawValue) }
		open func BEFORE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.BEFORE.rawValue, i)
		}
		open func EACH() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.EACH.rawValue) }
		open func EACH(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.EACH.rawValue, i)
		}
		open func ROW() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.ROW.rawValue) }
		open func ROW(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.ROW.rawValue, i)
		}
		open func AFTER() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.AFTER.rawValue) }
		open func AFTER(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.AFTER.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_timing_point_section }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTiming_point_section(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTiming_point_section(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTiming_point_section(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTiming_point_section(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func timing_point_section() throws -> Timing_point_sectionContext {
		var _localctx: Timing_point_sectionContext = Timing_point_sectionContext(_ctx, getState())
		try enterRule(_localctx, 74, plsqlParser.RULE_timing_point_section)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1408)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,91, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1372)
		 		try {
		 				let assignmentValue = try match(plsqlParser.Tokens.BEFORE.rawValue)
		 				_localctx.castdown(Timing_point_sectionContext.self).bk = assignmentValue
		 		     }()

		 		setState(1373)
		 		try match(plsqlParser.Tokens.STATEMENT.rawValue)
		 		setState(1374)
		 		try match(plsqlParser.Tokens.IS.rawValue)
		 		setState(1375)
		 		try trigger_block()
		 		setState(1376)
		 		try match(plsqlParser.Tokens.BEFORE.rawValue)
		 		setState(1377)
		 		try match(plsqlParser.Tokens.STATEMENT.rawValue)
		 		setState(1378)
		 		try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1380)
		 		try {
		 				let assignmentValue = try match(plsqlParser.Tokens.BEFORE.rawValue)
		 				_localctx.castdown(Timing_point_sectionContext.self).bk = assignmentValue
		 		     }()

		 		setState(1381)
		 		try match(plsqlParser.Tokens.EACH.rawValue)
		 		setState(1382)
		 		try match(plsqlParser.Tokens.ROW.rawValue)
		 		setState(1383)
		 		try match(plsqlParser.Tokens.IS.rawValue)
		 		setState(1384)
		 		try trigger_block()
		 		setState(1385)
		 		try match(plsqlParser.Tokens.BEFORE.rawValue)
		 		setState(1386)
		 		try match(plsqlParser.Tokens.EACH.rawValue)
		 		setState(1387)
		 		try match(plsqlParser.Tokens.ROW.rawValue)
		 		setState(1388)
		 		try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1390)
		 		try {
		 				let assignmentValue = try match(plsqlParser.Tokens.AFTER.rawValue)
		 				_localctx.castdown(Timing_point_sectionContext.self).ak = assignmentValue
		 		     }()

		 		setState(1391)
		 		try match(plsqlParser.Tokens.STATEMENT.rawValue)
		 		setState(1392)
		 		try match(plsqlParser.Tokens.IS.rawValue)
		 		setState(1393)
		 		try trigger_block()
		 		setState(1394)
		 		try match(plsqlParser.Tokens.AFTER.rawValue)
		 		setState(1395)
		 		try match(plsqlParser.Tokens.STATEMENT.rawValue)
		 		setState(1396)
		 		try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1398)
		 		try {
		 				let assignmentValue = try match(plsqlParser.Tokens.AFTER.rawValue)
		 				_localctx.castdown(Timing_point_sectionContext.self).ak = assignmentValue
		 		     }()

		 		setState(1399)
		 		try match(plsqlParser.Tokens.EACH.rawValue)
		 		setState(1400)
		 		try match(plsqlParser.Tokens.ROW.rawValue)
		 		setState(1401)
		 		try match(plsqlParser.Tokens.IS.rawValue)
		 		setState(1402)
		 		try trigger_block()
		 		setState(1403)
		 		try match(plsqlParser.Tokens.AFTER.rawValue)
		 		setState(1404)
		 		try match(plsqlParser.Tokens.EACH.rawValue)
		 		setState(1405)
		 		try match(plsqlParser.Tokens.ROW.rawValue)
		 		setState(1406)
		 		try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Non_dml_eventContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALTER.rawValue, 0) }
		open func ANALYZE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ANALYZE.rawValue, 0) }
		open func ASSOCIATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ASSOCIATE.rawValue, 0) }
		open func STATISTICS() -> TerminalNode? { return getToken(plsqlParser.Tokens.STATISTICS.rawValue, 0) }
		open func AUDIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.AUDIT.rawValue, 0) }
		open func COMMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMMENT.rawValue, 0) }
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CREATE.rawValue, 0) }
		open func DISASSOCIATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DISASSOCIATE.rawValue, 0) }
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.Tokens.DROP.rawValue, 0) }
		open func GRANT() -> TerminalNode? { return getToken(plsqlParser.Tokens.GRANT.rawValue, 0) }
		open func NOAUDIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOAUDIT.rawValue, 0) }
		open func RENAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.RENAME.rawValue, 0) }
		open func REVOKE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REVOKE.rawValue, 0) }
		open func TRUNCATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRUNCATE.rawValue, 0) }
		open func DDL() -> TerminalNode? { return getToken(plsqlParser.Tokens.DDL.rawValue, 0) }
		open func STARTUP() -> TerminalNode? { return getToken(plsqlParser.Tokens.STARTUP.rawValue, 0) }
		open func SHUTDOWN() -> TerminalNode? { return getToken(plsqlParser.Tokens.SHUTDOWN.rawValue, 0) }
		open func DB_ROLE_CHANGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue, 0) }
		open func LOGON() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOGON.rawValue, 0) }
		open func LOGOFF() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOGOFF.rawValue, 0) }
		open func SERVERERROR() -> TerminalNode? { return getToken(plsqlParser.Tokens.SERVERERROR.rawValue, 0) }
		open func SUSPEND() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUSPEND.rawValue, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DATABASE.rawValue, 0) }
		open func SCHEMA() -> TerminalNode? { return getToken(plsqlParser.Tokens.SCHEMA.rawValue, 0) }
		open func FOLLOWS() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOLLOWS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_non_dml_event }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNon_dml_event(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNon_dml_event(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNon_dml_event(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNon_dml_event(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func non_dml_event() throws -> Non_dml_eventContext {
		var _localctx: Non_dml_eventContext = Non_dml_eventContext(_ctx, getState())
		try enterRule(_localctx, 76, plsqlParser.RULE_non_dml_event)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1436)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ALTER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1410)
		 		try match(plsqlParser.Tokens.ALTER.rawValue)

		 		break

		 	case .ANALYZE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1411)
		 		try match(plsqlParser.Tokens.ANALYZE.rawValue)

		 		break

		 	case .ASSOCIATE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1412)
		 		try match(plsqlParser.Tokens.ASSOCIATE.rawValue)
		 		setState(1413)
		 		try match(plsqlParser.Tokens.STATISTICS.rawValue)

		 		break

		 	case .AUDIT:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1414)
		 		try match(plsqlParser.Tokens.AUDIT.rawValue)

		 		break

		 	case .COMMENT:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1415)
		 		try match(plsqlParser.Tokens.COMMENT.rawValue)

		 		break

		 	case .CREATE:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1416)
		 		try match(plsqlParser.Tokens.CREATE.rawValue)

		 		break

		 	case .DISASSOCIATE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1417)
		 		try match(plsqlParser.Tokens.DISASSOCIATE.rawValue)
		 		setState(1418)
		 		try match(plsqlParser.Tokens.STATISTICS.rawValue)

		 		break

		 	case .DROP:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1419)
		 		try match(plsqlParser.Tokens.DROP.rawValue)

		 		break

		 	case .GRANT:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1420)
		 		try match(plsqlParser.Tokens.GRANT.rawValue)

		 		break

		 	case .NOAUDIT:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1421)
		 		try match(plsqlParser.Tokens.NOAUDIT.rawValue)

		 		break

		 	case .RENAME:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1422)
		 		try match(plsqlParser.Tokens.RENAME.rawValue)

		 		break

		 	case .REVOKE:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(1423)
		 		try match(plsqlParser.Tokens.REVOKE.rawValue)

		 		break

		 	case .TRUNCATE:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(1424)
		 		try match(plsqlParser.Tokens.TRUNCATE.rawValue)

		 		break

		 	case .DDL:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(1425)
		 		try match(plsqlParser.Tokens.DDL.rawValue)

		 		break

		 	case .STARTUP:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(1426)
		 		try match(plsqlParser.Tokens.STARTUP.rawValue)

		 		break

		 	case .SHUTDOWN:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(1427)
		 		try match(plsqlParser.Tokens.SHUTDOWN.rawValue)

		 		break

		 	case .DB_ROLE_CHANGE:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(1428)
		 		try match(plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue)

		 		break

		 	case .LOGON:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(1429)
		 		try match(plsqlParser.Tokens.LOGON.rawValue)

		 		break

		 	case .LOGOFF:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(1430)
		 		try match(plsqlParser.Tokens.LOGOFF.rawValue)

		 		break

		 	case .SERVERERROR:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(1431)
		 		try match(plsqlParser.Tokens.SERVERERROR.rawValue)

		 		break

		 	case .SUSPEND:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(1432)
		 		try match(plsqlParser.Tokens.SUSPEND.rawValue)

		 		break

		 	case .DATABASE:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(1433)
		 		try match(plsqlParser.Tokens.DATABASE.rawValue)

		 		break

		 	case .SCHEMA:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(1434)
		 		try match(plsqlParser.Tokens.SCHEMA.rawValue)

		 		break

		 	case .FOLLOWS:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(1435)
		 		try match(plsqlParser.Tokens.FOLLOWS.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_event_clauseContext:ParserRuleContext {
		open func dml_event_element() -> Array<Dml_event_elementContext> {
			return getRuleContexts(Dml_event_elementContext.self)
		}
		open func dml_event_element(_ i: Int) -> Dml_event_elementContext? {
			return getRuleContext(Dml_event_elementContext.self,i)
		}
		open func ON() -> TerminalNode? { return getToken(plsqlParser.Tokens.ON.rawValue, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func OR() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.OR.rawValue) }
		open func OR(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.OR.rawValue, i)
		}
		open func dml_event_nested_clause() -> Dml_event_nested_clauseContext? {
			return getRuleContext(Dml_event_nested_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dml_event_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDml_event_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDml_event_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDml_event_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDml_event_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_event_clause() throws -> Dml_event_clauseContext {
		var _localctx: Dml_event_clauseContext = Dml_event_clauseContext(_ctx, getState())
		try enterRule(_localctx, 78, plsqlParser.RULE_dml_event_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1438)
		 	try dml_event_element()
		 	setState(1443)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1439)
		 		try match(plsqlParser.Tokens.OR.rawValue)
		 		setState(1440)
		 		try dml_event_element()


		 		setState(1445)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1446)
		 	try match(plsqlParser.Tokens.ON.rawValue)
		 	setState(1448)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,94,_ctx)) {
		 	case 1:
		 		setState(1447)
		 		try dml_event_nested_clause()

		 		break
		 	default: break
		 	}
		 	setState(1450)
		 	try tableview_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_event_elementContext:ParserRuleContext {
		open func DELETE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DELETE.rawValue, 0) }
		open func INSERT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INSERT.rawValue, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OF.rawValue, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dml_event_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDml_event_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDml_event_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDml_event_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDml_event_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_event_element() throws -> Dml_event_elementContext {
		var _localctx: Dml_event_elementContext = Dml_event_elementContext(_ctx, getState())
		try enterRule(_localctx, 80, plsqlParser.RULE_dml_event_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1452)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.DELETE.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.INSERT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.UPDATE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1462)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1453)
		 		try match(plsqlParser.Tokens.OF.rawValue)
		 		setState(1454)
		 		try column_name()
		 		setState(1459)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1455)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1456)
		 			try column_name()


		 			setState(1461)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_event_nested_clauseContext:ParserRuleContext {
		open func NESTED() -> TerminalNode? { return getToken(plsqlParser.Tokens.NESTED.rawValue, 0) }
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TABLE.rawValue, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func OF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OF.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dml_event_nested_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDml_event_nested_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDml_event_nested_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDml_event_nested_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDml_event_nested_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_event_nested_clause() throws -> Dml_event_nested_clauseContext {
		var _localctx: Dml_event_nested_clauseContext = Dml_event_nested_clauseContext(_ctx, getState())
		try enterRule(_localctx, 82, plsqlParser.RULE_dml_event_nested_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1464)
		 	try match(plsqlParser.Tokens.NESTED.rawValue)
		 	setState(1465)
		 	try match(plsqlParser.Tokens.TABLE.rawValue)
		 	setState(1466)
		 	try tableview_name()
		 	setState(1467)
		 	try match(plsqlParser.Tokens.OF.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Referencing_clauseContext:ParserRuleContext {
		open func REFERENCING() -> TerminalNode? { return getToken(plsqlParser.Tokens.REFERENCING.rawValue, 0) }
		open func referencing_element() -> Array<Referencing_elementContext> {
			return getRuleContexts(Referencing_elementContext.self)
		}
		open func referencing_element(_ i: Int) -> Referencing_elementContext? {
			return getRuleContext(Referencing_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_referencing_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReferencing_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReferencing_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReferencing_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReferencing_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func referencing_clause() throws -> Referencing_clauseContext {
		var _localctx: Referencing_clauseContext = Referencing_clauseContext(_ctx, getState())
		try enterRule(_localctx, 84, plsqlParser.RULE_referencing_clause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1469)
		 	try match(plsqlParser.Tokens.REFERENCING.rawValue)
		 	setState(1471); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(1470)
		 			try referencing_element()


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1473); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,97,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Referencing_elementContext:ParserRuleContext {
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open func NEW() -> TerminalNode? { return getToken(plsqlParser.Tokens.NEW.rawValue, 0) }
		open func OLD() -> TerminalNode? { return getToken(plsqlParser.Tokens.OLD.rawValue, 0) }
		open func PARENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.PARENT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_referencing_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReferencing_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReferencing_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReferencing_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReferencing_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func referencing_element() throws -> Referencing_elementContext {
		var _localctx: Referencing_elementContext = Referencing_elementContext(_ctx, getState())
		try enterRule(_localctx, 86, plsqlParser.RULE_referencing_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1475)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.PARENT.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 238)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1476)
		 	try column_alias()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_typeContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.Tokens.DROP.rawValue, 0) }
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TYPE.rawValue, 0) }
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BODY.rawValue, 0) }
		open func FORCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.FORCE.rawValue, 0) }
		open func VALIDATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.VALIDATE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_type() throws -> Drop_typeContext {
		var _localctx: Drop_typeContext = Drop_typeContext(_ctx, getState())
		try enterRule(_localctx, 88, plsqlParser.RULE_drop_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1478)
		 	try match(plsqlParser.Tokens.DROP.rawValue)
		 	setState(1479)
		 	try match(plsqlParser.Tokens.TYPE.rawValue)
		 	setState(1481)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,98,_ctx)) {
		 	case 1:
		 		setState(1480)
		 		try match(plsqlParser.Tokens.BODY.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1483)
		 	try type_name()
		 	setState(1485)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.FORCE.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.VALIDATE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1484)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.FORCE.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.VALIDATE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(1487)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_typeContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALTER.rawValue, 0) }
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TYPE.rawValue, 0) }
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func compile_type_clause() -> Compile_type_clauseContext? {
			return getRuleContext(Compile_type_clauseContext.self,0)
		}
		open func replace_type_clause() -> Replace_type_clauseContext? {
			return getRuleContext(Replace_type_clauseContext.self,0)
		}
		open func alter_method_spec() -> Alter_method_specContext? {
			return getRuleContext(Alter_method_specContext.self,0)
		}
		open func alter_collection_clauses() -> Alter_collection_clausesContext? {
			return getRuleContext(Alter_collection_clausesContext.self,0)
		}
		open func modifier_clause() -> Modifier_clauseContext? {
			return getRuleContext(Modifier_clauseContext.self,0)
		}
		open func dependent_handling_clause() -> Dependent_handling_clauseContext? {
			return getRuleContext(Dependent_handling_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_type() throws -> Alter_typeContext {
		var _localctx: Alter_typeContext = Alter_typeContext(_ctx, getState())
		try enterRule(_localctx, 90, plsqlParser.RULE_alter_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1489)
		 	try match(plsqlParser.Tokens.ALTER.rawValue)
		 	setState(1490)
		 	try match(plsqlParser.Tokens.TYPE.rawValue)
		 	setState(1491)
		 	try type_name()
		 	setState(1497)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .COMPILE:
		 		setState(1492)
		 		try compile_type_clause()

		 		break

		 	case .REPLACE:
		 		setState(1493)
		 		try replace_type_clause()

		 		break
		 	case .ADD:fallthrough
		 	case .DROP:
		 		setState(1494)
		 		try alter_method_spec()

		 		break

		 	case .MODIFY:
		 		setState(1495)
		 		try alter_collection_clauses()

		 		break
		 	case .FINAL:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .NOT:fallthrough
		 	case .OVERRIDING:
		 		setState(1496)
		 		try modifier_clause()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1500)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.CASCADE.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.INVALIDATE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1499)
		 		try dependent_handling_clause()

		 	}

		 	setState(1502)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Compile_type_clauseContext:ParserRuleContext {
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMPILE.rawValue, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEBUG.rawValue, 0) }
		open func compiler_parameters_clause() -> Array<Compiler_parameters_clauseContext> {
			return getRuleContexts(Compiler_parameters_clauseContext.self)
		}
		open func compiler_parameters_clause(_ i: Int) -> Compiler_parameters_clauseContext? {
			return getRuleContext(Compiler_parameters_clauseContext.self,i)
		}
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REUSE.rawValue, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SETTINGS.rawValue, 0) }
		open func SPECIFICATION() -> TerminalNode? { return getToken(plsqlParser.Tokens.SPECIFICATION.rawValue, 0) }
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BODY.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compile_type_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompile_type_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompile_type_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompile_type_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompile_type_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compile_type_clause() throws -> Compile_type_clauseContext {
		var _localctx: Compile_type_clauseContext = Compile_type_clauseContext(_ctx, getState())
		try enterRule(_localctx, 92, plsqlParser.RULE_compile_type_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1504)
		 	try match(plsqlParser.Tokens.COMPILE.rawValue)
		 	setState(1506)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,102,_ctx)) {
		 	case 1:
		 		setState(1505)
		 		try match(plsqlParser.Tokens.DEBUG.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1509)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,103,_ctx)) {
		 	case 1:
		 		setState(1508)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.BODY.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.SPECIFICATION.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(1514)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,104,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1511)
		 			try compiler_parameters_clause()

		 	 
		 		}
		 		setState(1516)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,104,_ctx)
		 	}
		 	setState(1519)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.REUSE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1517)
		 		try match(plsqlParser.Tokens.REUSE.rawValue)
		 		setState(1518)
		 		try match(plsqlParser.Tokens.SETTINGS.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Replace_type_clauseContext:ParserRuleContext {
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REPLACE.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func OBJECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.OBJECT.rawValue, 0) }
		open func object_member_spec() -> Array<Object_member_specContext> {
			return getRuleContexts(Object_member_specContext.self)
		}
		open func object_member_spec(_ i: Int) -> Object_member_specContext? {
			return getRuleContext(Object_member_specContext.self,i)
		}
		open func invoker_rights_clause() -> Invoker_rights_clauseContext? {
			return getRuleContext(Invoker_rights_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_replace_type_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReplace_type_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReplace_type_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReplace_type_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReplace_type_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func replace_type_clause() throws -> Replace_type_clauseContext {
		var _localctx: Replace_type_clauseContext = Replace_type_clauseContext(_ctx, getState())
		try enterRule(_localctx, 94, plsqlParser.RULE_replace_type_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1521)
		 	try match(plsqlParser.Tokens.REPLACE.rawValue)
		 	setState(1523)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.AUTHID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1522)
		 		try invoker_rights_clause()

		 	}

		 	setState(1525)
		 	try match(plsqlParser.Tokens.AS.rawValue)
		 	setState(1526)
		 	try match(plsqlParser.Tokens.OBJECT.rawValue)
		 	setState(1527)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(1528)
		 	try object_member_spec()
		 	setState(1533)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1529)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(1530)
		 		try object_member_spec()


		 		setState(1535)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1536)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_method_specContext:ParserRuleContext {
		open func alter_method_element() -> Array<Alter_method_elementContext> {
			return getRuleContexts(Alter_method_elementContext.self)
		}
		open func alter_method_element(_ i: Int) -> Alter_method_elementContext? {
			return getRuleContext(Alter_method_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_method_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_method_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_method_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_method_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_method_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_method_spec() throws -> Alter_method_specContext {
		var _localctx: Alter_method_specContext = Alter_method_specContext(_ctx, getState())
		try enterRule(_localctx, 96, plsqlParser.RULE_alter_method_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1538)
		 	try alter_method_element()
		 	setState(1543)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1539)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(1540)
		 		try alter_method_element()


		 		setState(1545)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_method_elementContext:ParserRuleContext {
		open func ADD() -> TerminalNode? { return getToken(plsqlParser.Tokens.ADD.rawValue, 0) }
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.Tokens.DROP.rawValue, 0) }
		open func map_order_function_spec() -> Map_order_function_specContext? {
			return getRuleContext(Map_order_function_specContext.self,0)
		}
		open func subprogram_spec() -> Subprogram_specContext? {
			return getRuleContext(Subprogram_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_method_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_method_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_method_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_method_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_method_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_method_element() throws -> Alter_method_elementContext {
		var _localctx: Alter_method_elementContext = Alter_method_elementContext(_ctx, getState())
		try enterRule(_localctx, 98, plsqlParser.RULE_alter_method_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1546)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.ADD.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.DROP.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1549)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .MAP:fallthrough
		 	case .ORDER:
		 		setState(1547)
		 		try map_order_function_spec()

		 		break
		 	case .MEMBER:fallthrough
		 	case .STATIC:
		 		setState(1548)
		 		try subprogram_spec()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_attribute_definitionContext:ParserRuleContext {
		open func ATTRIBUTE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ATTRIBUTE.rawValue, 0) }
		open func ADD() -> TerminalNode? { return getToken(plsqlParser.Tokens.ADD.rawValue, 0) }
		open func MODIFY() -> TerminalNode? { return getToken(plsqlParser.Tokens.MODIFY.rawValue, 0) }
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.Tokens.DROP.rawValue, 0) }
		open func attribute_definition() -> Array<Attribute_definitionContext> {
			return getRuleContexts(Attribute_definitionContext.self)
		}
		open func attribute_definition(_ i: Int) -> Attribute_definitionContext? {
			return getRuleContext(Attribute_definitionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_attribute_definition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_attribute_definition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_attribute_definition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_attribute_definition(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_attribute_definition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_attribute_definition() throws -> Alter_attribute_definitionContext {
		var _localctx: Alter_attribute_definitionContext = Alter_attribute_definitionContext(_ctx, getState())
		try enterRule(_localctx, 100, plsqlParser.RULE_alter_attribute_definition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1551)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.ADD.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.DROP.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.MODIFY.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1552)
		 	try match(plsqlParser.Tokens.ATTRIBUTE.rawValue)
		 	setState(1565)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(1553)
		 		try attribute_definition()

		 		break

		 	case .LEFT_PAREN:
		 		setState(1554)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(1555)
		 		try attribute_definition()
		 		setState(1560)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1556)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1557)
		 			try attribute_definition()


		 			setState(1562)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1563)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Attribute_definitionContext:ParserRuleContext {
		open func attribute_name() -> Attribute_nameContext? {
			return getRuleContext(Attribute_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_attribute_definition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAttribute_definition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAttribute_definition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAttribute_definition(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAttribute_definition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func attribute_definition() throws -> Attribute_definitionContext {
		var _localctx: Attribute_definitionContext = Attribute_definitionContext(_ctx, getState())
		try enterRule(_localctx, 102, plsqlParser.RULE_attribute_definition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1567)
		 	try attribute_name()
		 	setState(1569)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DATE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1568)
		 		try type_spec()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_collection_clausesContext:ParserRuleContext {
		open func MODIFY() -> TerminalNode? { return getToken(plsqlParser.Tokens.MODIFY.rawValue, 0) }
		open func LIMIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIMIT.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func ELEMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.ELEMENT.rawValue, 0) }
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TYPE.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_collection_clauses }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_collection_clauses(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_collection_clauses(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_collection_clauses(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_collection_clauses(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_collection_clauses() throws -> Alter_collection_clausesContext {
		var _localctx: Alter_collection_clausesContext = Alter_collection_clausesContext(_ctx, getState())
		try enterRule(_localctx, 104, plsqlParser.RULE_alter_collection_clauses)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1571)
		 	try match(plsqlParser.Tokens.MODIFY.rawValue)
		 	setState(1577)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LIMIT:
		 		setState(1572)
		 		try match(plsqlParser.Tokens.LIMIT.rawValue)
		 		setState(1573)
		 		try expression()

		 		break

		 	case .ELEMENT:
		 		setState(1574)
		 		try match(plsqlParser.Tokens.ELEMENT.rawValue)
		 		setState(1575)
		 		try match(plsqlParser.Tokens.TYPE.rawValue)
		 		setState(1576)
		 		try type_spec()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dependent_handling_clauseContext:ParserRuleContext {
		open func INVALIDATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.INVALIDATE.rawValue, 0) }
		open func CASCADE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CASCADE.rawValue, 0) }
		open func CONVERT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONVERT.rawValue, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.Tokens.TO.rawValue, 0) }
		open func SUBSTITUTABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUBSTITUTABLE.rawValue, 0) }
		open func INCLUDING() -> TerminalNode? { return getToken(plsqlParser.Tokens.INCLUDING.rawValue, 0) }
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TABLE.rawValue, 0) }
		open func DATA() -> TerminalNode? { return getToken(plsqlParser.Tokens.DATA.rawValue, 0) }
		open func dependent_exceptions_part() -> Dependent_exceptions_partContext? {
			return getRuleContext(Dependent_exceptions_partContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dependent_handling_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDependent_handling_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDependent_handling_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDependent_handling_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDependent_handling_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dependent_handling_clause() throws -> Dependent_handling_clauseContext {
		var _localctx: Dependent_handling_clauseContext = Dependent_handling_clauseContext(_ctx, getState())
		try enterRule(_localctx, 106, plsqlParser.RULE_dependent_handling_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1595)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .INVALIDATE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1579)
		 		try match(plsqlParser.Tokens.INVALIDATE.rawValue)

		 		break

		 	case .CASCADE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1580)
		 		try match(plsqlParser.Tokens.CASCADE.rawValue)
		 		setState(1590)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CONVERT:
		 		 	setState(1581)
		 		 	try match(plsqlParser.Tokens.CONVERT.rawValue)
		 		 	setState(1582)
		 		 	try match(plsqlParser.Tokens.TO.rawValue)
		 		 	setState(1583)
		 		 	try match(plsqlParser.Tokens.SUBSTITUTABLE.rawValue)

		 			break
		 		case .INCLUDING:fallthrough
		 		case .NOT:
		 		 	setState(1585)
		 		 	try _errHandler.sync(self)
		 		 	_la = try _input.LA(1)
		 		 	if (//closure
		 		 	 { () -> Bool in
		 		 	      let testSet: Bool = _la == plsqlParser.Tokens.NOT.rawValue
		 		 	      return testSet
		 		 	 }()) {
		 		 		setState(1584)
		 		 		try match(plsqlParser.Tokens.NOT.rawValue)

		 		 	}

		 		 	setState(1587)
		 		 	try match(plsqlParser.Tokens.INCLUDING.rawValue)
		 		 	setState(1588)
		 		 	try match(plsqlParser.Tokens.TABLE.rawValue)
		 		 	setState(1589)
		 		 	try match(plsqlParser.Tokens.DATA.rawValue)

		 			break
		 		case .EXCEPTIONS:fallthrough
		 		case .FORCE:fallthrough
		 		case .SEMICOLON:
		 			break
		 		default:
		 			break
		 		}
		 		setState(1593)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.EXCEPTIONS.rawValue || _la == plsqlParser.Tokens.FORCE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1592)
		 			try dependent_exceptions_part()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dependent_exceptions_partContext:ParserRuleContext {
		open func EXCEPTIONS() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXCEPTIONS.rawValue, 0) }
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTO.rawValue, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func FORCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.FORCE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dependent_exceptions_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDependent_exceptions_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDependent_exceptions_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDependent_exceptions_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDependent_exceptions_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dependent_exceptions_part() throws -> Dependent_exceptions_partContext {
		var _localctx: Dependent_exceptions_partContext = Dependent_exceptions_partContext(_ctx, getState())
		try enterRule(_localctx, 108, plsqlParser.RULE_dependent_exceptions_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1598)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.FORCE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1597)
		 		try match(plsqlParser.Tokens.FORCE.rawValue)

		 	}

		 	setState(1600)
		 	try match(plsqlParser.Tokens.EXCEPTIONS.rawValue)
		 	setState(1601)
		 	try match(plsqlParser.Tokens.INTO.rawValue)
		 	setState(1602)
		 	try tableview_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_typeContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CREATE.rawValue, 0) }
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TYPE.rawValue, 0) }
		open func type_definition() -> Type_definitionContext? {
			return getRuleContext(Type_definitionContext.self,0)
		}
		open func type_body() -> Type_bodyContext? {
			return getRuleContext(Type_bodyContext.self,0)
		}
		open func OR() -> TerminalNode? { return getToken(plsqlParser.Tokens.OR.rawValue, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REPLACE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_type() throws -> Create_typeContext {
		var _localctx: Create_typeContext = Create_typeContext(_ctx, getState())
		try enterRule(_localctx, 110, plsqlParser.RULE_create_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1604)
		 	try match(plsqlParser.Tokens.CREATE.rawValue)
		 	setState(1607)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1605)
		 		try match(plsqlParser.Tokens.OR.rawValue)
		 		setState(1606)
		 		try match(plsqlParser.Tokens.REPLACE.rawValue)

		 	}

		 	setState(1609)
		 	try match(plsqlParser.Tokens.TYPE.rawValue)
		 	setState(1612)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,120, _ctx)) {
		 	case 1:
		 		setState(1610)
		 		try type_definition()

		 		break
		 	case 2:
		 		setState(1611)
		 		try type_body()

		 		break
		 	default: break
		 	}
		 	setState(1614)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_definitionContext:ParserRuleContext {
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func OID() -> TerminalNode? { return getToken(plsqlParser.Tokens.OID.rawValue, 0) }
		open func CHAR_STRING() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHAR_STRING.rawValue, 0) }
		open func object_type_def() -> Object_type_defContext? {
			return getRuleContext(Object_type_defContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_definition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_definition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_definition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_definition(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_definition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_definition() throws -> Type_definitionContext {
		var _localctx: Type_definitionContext = Type_definitionContext(_ctx, getState())
		try enterRule(_localctx, 112, plsqlParser.RULE_type_definition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1616)
		 	try type_name()
		 	setState(1619)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1617)
		 		try match(plsqlParser.Tokens.OID.rawValue)
		 		setState(1618)
		 		try match(plsqlParser.Tokens.CHAR_STRING.rawValue)

		 	}

		 	setState(1622)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue || _la == plsqlParser.Tokens.AUTHID.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.UNDER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1621)
		 		try object_type_def()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Object_type_defContext:ParserRuleContext {
		open func object_as_part() -> Object_as_partContext? {
			return getRuleContext(Object_as_partContext.self,0)
		}
		open func object_under_part() -> Object_under_partContext? {
			return getRuleContext(Object_under_partContext.self,0)
		}
		open func invoker_rights_clause() -> Invoker_rights_clauseContext? {
			return getRuleContext(Invoker_rights_clauseContext.self,0)
		}
		open func sqlj_object_type() -> Sqlj_object_typeContext? {
			return getRuleContext(Sqlj_object_typeContext.self,0)
		}
		open func object_member_spec() -> Array<Object_member_specContext> {
			return getRuleContexts(Object_member_specContext.self)
		}
		open func object_member_spec(_ i: Int) -> Object_member_specContext? {
			return getRuleContext(Object_member_specContext.self,i)
		}
		open func modifier_clause() -> Array<Modifier_clauseContext> {
			return getRuleContexts(Modifier_clauseContext.self)
		}
		open func modifier_clause(_ i: Int) -> Modifier_clauseContext? {
			return getRuleContext(Modifier_clauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_object_type_def }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterObject_type_def(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitObject_type_def(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitObject_type_def(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitObject_type_def(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func object_type_def() throws -> Object_type_defContext {
		var _localctx: Object_type_defContext = Object_type_defContext(_ctx, getState())
		try enterRule(_localctx, 114, plsqlParser.RULE_object_type_def)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1625)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.AUTHID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1624)
		 		try invoker_rights_clause()

		 	}

		 	setState(1629)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .AS:fallthrough
		 	case .IS:
		 		setState(1627)
		 		try object_as_part()

		 		break

		 	case .UNDER:
		 		setState(1628)
		 		try object_under_part()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1632)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.EXTERNAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1631)
		 		try sqlj_object_type()

		 	}

		 	setState(1645)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1634)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(1635)
		 		try object_member_spec()
		 		setState(1640)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1636)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1637)
		 			try object_member_spec()


		 			setState(1642)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1643)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(1650)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.FINAL.rawValue || _la == plsqlParser.Tokens.INSTANTIABLE.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.NOT.rawValue || _la == plsqlParser.Tokens.OVERRIDING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1647)
		 		try modifier_clause()


		 		setState(1652)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Object_as_partContext:ParserRuleContext {
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func OBJECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.OBJECT.rawValue, 0) }
		open func varray_type_def() -> Varray_type_defContext? {
			return getRuleContext(Varray_type_defContext.self,0)
		}
		open func nested_table_type_def() -> Nested_table_type_defContext? {
			return getRuleContext(Nested_table_type_defContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_object_as_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterObject_as_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitObject_as_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitObject_as_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitObject_as_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func object_as_part() throws -> Object_as_partContext {
		var _localctx: Object_as_partContext = Object_as_partContext(_ctx, getState())
		try enterRule(_localctx, 116, plsqlParser.RULE_object_as_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1653)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1657)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .OBJECT:
		 		setState(1654)
		 		try match(plsqlParser.Tokens.OBJECT.rawValue)

		 		break
		 	case .VARRAY:fallthrough
		 	case .VARYING:
		 		setState(1655)
		 		try varray_type_def()

		 		break

		 	case .TABLE:
		 		setState(1656)
		 		try nested_table_type_def()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Object_under_partContext:ParserRuleContext {
		open func UNDER() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNDER.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_object_under_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterObject_under_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitObject_under_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitObject_under_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitObject_under_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func object_under_part() throws -> Object_under_partContext {
		var _localctx: Object_under_partContext = Object_under_partContext(_ctx, getState())
		try enterRule(_localctx, 118, plsqlParser.RULE_object_under_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1659)
		 	try match(plsqlParser.Tokens.UNDER.rawValue)
		 	setState(1660)
		 	try type_spec()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Nested_table_type_defContext:ParserRuleContext {
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TABLE.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OF.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_nested_table_type_def }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNested_table_type_def(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNested_table_type_def(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNested_table_type_def(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNested_table_type_def(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func nested_table_type_def() throws -> Nested_table_type_defContext {
		var _localctx: Nested_table_type_defContext = Nested_table_type_defContext(_ctx, getState())
		try enterRule(_localctx, 120, plsqlParser.RULE_nested_table_type_def)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1662)
		 	try match(plsqlParser.Tokens.TABLE.rawValue)
		 	setState(1663)
		 	try match(plsqlParser.Tokens.OF.rawValue)
		 	setState(1664)
		 	try type_spec()
		 	setState(1667)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,130,_ctx)) {
		 	case 1:
		 		setState(1665)
		 		try match(plsqlParser.Tokens.NOT.rawValue)
		 		setState(1666)
		 		try match(plsqlParser.Tokens.NULL.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sqlj_object_typeContext:ParserRuleContext {
		open func EXTERNAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXTERNAL.rawValue, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.NAME.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func LANGUAGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.LANGUAGE.rawValue, 0) }
		open func JAVA() -> TerminalNode? { return getToken(plsqlParser.Tokens.JAVA.rawValue, 0) }
		open func USING() -> TerminalNode? { return getToken(plsqlParser.Tokens.USING.rawValue, 0) }
		open func SQLDATA() -> TerminalNode? { return getToken(plsqlParser.Tokens.SQLDATA.rawValue, 0) }
		open func CUSTOMDATUM() -> TerminalNode? { return getToken(plsqlParser.Tokens.CUSTOMDATUM.rawValue, 0) }
		open func ORADATA() -> TerminalNode? { return getToken(plsqlParser.Tokens.ORADATA.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sqlj_object_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSqlj_object_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSqlj_object_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSqlj_object_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSqlj_object_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sqlj_object_type() throws -> Sqlj_object_typeContext {
		var _localctx: Sqlj_object_typeContext = Sqlj_object_typeContext(_ctx, getState())
		try enterRule(_localctx, 122, plsqlParser.RULE_sqlj_object_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1669)
		 	try match(plsqlParser.Tokens.EXTERNAL.rawValue)
		 	setState(1670)
		 	try match(plsqlParser.Tokens.NAME.rawValue)
		 	setState(1671)
		 	try expression()
		 	setState(1672)
		 	try match(plsqlParser.Tokens.LANGUAGE.rawValue)
		 	setState(1673)
		 	try match(plsqlParser.Tokens.JAVA.rawValue)
		 	setState(1674)
		 	try match(plsqlParser.Tokens.USING.rawValue)
		 	setState(1675)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.CUSTOMDATUM.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.ORADATA.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.SQLDATA.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_bodyContext:ParserRuleContext {
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BODY.rawValue, 0) }
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.Tokens.END.rawValue, 0) }
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func type_body_elements() -> Array<Type_body_elementsContext> {
			return getRuleContexts(Type_body_elementsContext.self)
		}
		open func type_body_elements(_ i: Int) -> Type_body_elementsContext? {
			return getRuleContext(Type_body_elementsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_body(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_body(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_body(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_body(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_body() throws -> Type_bodyContext {
		var _localctx: Type_bodyContext = Type_bodyContext(_ctx, getState())
		try enterRule(_localctx, 124, plsqlParser.RULE_type_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1677)
		 	try match(plsqlParser.Tokens.BODY.rawValue)
		 	setState(1678)
		 	try type_name()
		 	setState(1679)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1681) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1680)
		 		try type_body_elements()


		 		setState(1683); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.ORDER.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 214)
		 	}()
		 	          testSet = testSet || _la == plsqlParser.Tokens.STATIC.rawValue
		 	      return testSet
		 	 }())
		 	setState(1685)
		 	try match(plsqlParser.Tokens.END.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_body_elementsContext:ParserRuleContext {
		open func map_order_func_declaration() -> Map_order_func_declarationContext? {
			return getRuleContext(Map_order_func_declarationContext.self,0)
		}
		open func subprog_decl_in_type() -> Subprog_decl_in_typeContext? {
			return getRuleContext(Subprog_decl_in_typeContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_body_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_body_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_body_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_body_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_body_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_body_elements() throws -> Type_body_elementsContext {
		var _localctx: Type_body_elementsContext = Type_body_elementsContext(_ctx, getState())
		try enterRule(_localctx, 126, plsqlParser.RULE_type_body_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1689)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .MAP:fallthrough
		 	case .ORDER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1687)
		 		try map_order_func_declaration()

		 		break
		 	case .MEMBER:fallthrough
		 	case .STATIC:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1688)
		 		try subprog_decl_in_type()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Map_order_func_declarationContext:ParserRuleContext {
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.Tokens.MEMBER.rawValue, 0) }
		open func func_decl_in_type() -> Func_decl_in_typeContext? {
			return getRuleContext(Func_decl_in_typeContext.self,0)
		}
		open func MAP() -> TerminalNode? { return getToken(plsqlParser.Tokens.MAP.rawValue, 0) }
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ORDER.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_map_order_func_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMap_order_func_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMap_order_func_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMap_order_func_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMap_order_func_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func map_order_func_declaration() throws -> Map_order_func_declarationContext {
		var _localctx: Map_order_func_declarationContext = Map_order_func_declarationContext(_ctx, getState())
		try enterRule(_localctx, 128, plsqlParser.RULE_map_order_func_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1691)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.MAP.rawValue || _la == plsqlParser.Tokens.ORDER.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1692)
		 	try match(plsqlParser.Tokens.MEMBER.rawValue)
		 	setState(1693)
		 	try func_decl_in_type()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subprog_decl_in_typeContext:ParserRuleContext {
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.Tokens.MEMBER.rawValue, 0) }
		open func STATIC() -> TerminalNode? { return getToken(plsqlParser.Tokens.STATIC.rawValue, 0) }
		open func proc_decl_in_type() -> Proc_decl_in_typeContext? {
			return getRuleContext(Proc_decl_in_typeContext.self,0)
		}
		open func func_decl_in_type() -> Func_decl_in_typeContext? {
			return getRuleContext(Func_decl_in_typeContext.self,0)
		}
		open func constructor_declaration() -> Constructor_declarationContext? {
			return getRuleContext(Constructor_declarationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subprog_decl_in_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubprog_decl_in_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubprog_decl_in_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubprog_decl_in_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubprog_decl_in_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subprog_decl_in_type() throws -> Subprog_decl_in_typeContext {
		var _localctx: Subprog_decl_in_typeContext = Subprog_decl_in_typeContext(_ctx, getState())
		try enterRule(_localctx, 130, plsqlParser.RULE_subprog_decl_in_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1695)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.MEMBER.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.STATIC.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1699)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .PROCEDURE:
		 		setState(1696)
		 		try proc_decl_in_type()

		 		break

		 	case .FUNCTION:
		 		setState(1697)
		 		try func_decl_in_type()

		 		break
		 	case .CONSTRUCTOR:fallthrough
		 	case .FINAL:fallthrough
		 	case .INSTANTIABLE:
		 		setState(1698)
		 		try constructor_declaration()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Proc_decl_in_typeContext:ParserRuleContext {
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PROCEDURE.rawValue, 0) }
		open func procedure_name() -> Procedure_nameContext? {
			return getRuleContext(Procedure_nameContext.self,0)
		}
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECLARE.rawValue, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_proc_decl_in_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterProc_decl_in_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitProc_decl_in_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitProc_decl_in_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitProc_decl_in_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func proc_decl_in_type() throws -> Proc_decl_in_typeContext {
		var _localctx: Proc_decl_in_typeContext = Proc_decl_in_typeContext(_ctx, getState())
		try enterRule(_localctx, 132, plsqlParser.RULE_proc_decl_in_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1701)
		 	try match(plsqlParser.Tokens.PROCEDURE.rawValue)
		 	setState(1702)
		 	try procedure_name()
		 	setState(1703)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(1704)
		 	try type_elements_parameter()
		 	setState(1709)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1705)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(1706)
		 		try type_elements_parameter()


		 		setState(1711)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1712)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(1713)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1727)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,137, _ctx)) {
		 	case 1:
		 		setState(1714)
		 		try call_spec()

		 		break
		 	case 2:
		 		setState(1716)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.DECLARE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1715)
		 			try match(plsqlParser.Tokens.DECLARE.rawValue)

		 		}

		 		setState(1721)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 66)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 130)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 194)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 259)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 323)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 387)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 451)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1718)
		 			try declare_spec()


		 			setState(1723)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1724)
		 		try body()
		 		setState(1725)
		 		try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Func_decl_in_typeContext:ParserRuleContext {
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func function_name() -> Function_nameContext? {
			return getRuleContext(Function_nameContext.self,0)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECLARE.rawValue, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_func_decl_in_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunc_decl_in_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunc_decl_in_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunc_decl_in_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunc_decl_in_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func func_decl_in_type() throws -> Func_decl_in_typeContext {
		var _localctx: Func_decl_in_typeContext = Func_decl_in_typeContext(_ctx, getState())
		try enterRule(_localctx, 134, plsqlParser.RULE_func_decl_in_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1729)
		 	try match(plsqlParser.Tokens.FUNCTION.rawValue)
		 	setState(1730)
		 	try function_name()
		 	setState(1742)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1731)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(1732)
		 		try type_elements_parameter()
		 		setState(1737)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1733)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1734)
		 			try type_elements_parameter()


		 			setState(1739)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1740)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(1744)
		 	try match(plsqlParser.Tokens.RETURN.rawValue)
		 	setState(1745)
		 	try type_spec()
		 	setState(1746)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1760)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,142, _ctx)) {
		 	case 1:
		 		setState(1747)
		 		try call_spec()

		 		break
		 	case 2:
		 		setState(1749)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.DECLARE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1748)
		 			try match(plsqlParser.Tokens.DECLARE.rawValue)

		 		}

		 		setState(1754)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 66)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 130)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 194)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 259)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 323)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 387)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 451)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1751)
		 			try declare_spec()


		 			setState(1756)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1757)
		 		try body()
		 		setState(1758)
		 		try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Constructor_declarationContext:ParserRuleContext {
		open func CONSTRUCTOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONSTRUCTOR.rawValue, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func type_spec() -> Array<Type_specContext> {
			return getRuleContexts(Type_specContext.self)
		}
		open func type_spec(_ i: Int) -> Type_specContext? {
			return getRuleContext(Type_specContext.self,i)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func SELF() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.SELF.rawValue) }
		open func SELF(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.SELF.rawValue, i)
		}
		open func AS() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.AS.rawValue) }
		open func AS(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.AS.rawValue, i)
		}
		open func RESULT() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESULT.rawValue, 0) }
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func FINAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.FINAL.rawValue, 0) }
		open func INSTANTIABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.INSTANTIABLE.rawValue, 0) }
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func OUT() -> TerminalNode? { return getToken(plsqlParser.Tokens.OUT.rawValue, 0) }
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECLARE.rawValue, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_constructor_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConstructor_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConstructor_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConstructor_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConstructor_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func constructor_declaration() throws -> Constructor_declarationContext {
		var _localctx: Constructor_declarationContext = Constructor_declarationContext(_ctx, getState())
		try enterRule(_localctx, 136, plsqlParser.RULE_constructor_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1763)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.FINAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1762)
		 		try match(plsqlParser.Tokens.FINAL.rawValue)

		 	}

		 	setState(1766)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.INSTANTIABLE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1765)
		 		try match(plsqlParser.Tokens.INSTANTIABLE.rawValue)

		 	}

		 	setState(1768)
		 	try match(plsqlParser.Tokens.CONSTRUCTOR.rawValue)
		 	setState(1769)
		 	try match(plsqlParser.Tokens.FUNCTION.rawValue)
		 	setState(1770)
		 	try type_spec()
		 	setState(1788)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1771)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)

		 		setState(1772)
		 		try match(plsqlParser.Tokens.SELF.rawValue)
		 		setState(1773)
		 		try match(plsqlParser.Tokens.IN.rawValue)
		 		setState(1774)
		 		try match(plsqlParser.Tokens.OUT.rawValue)
		 		setState(1775)
		 		try type_spec()
		 		setState(1776)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)

		 		setState(1778)
		 		try type_elements_parameter()
		 		setState(1783)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1779)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1780)
		 			try type_elements_parameter()


		 			setState(1785)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1786)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(1790)
		 	try match(plsqlParser.Tokens.RETURN.rawValue)
		 	setState(1791)
		 	try match(plsqlParser.Tokens.SELF.rawValue)
		 	setState(1792)
		 	try match(plsqlParser.Tokens.AS.rawValue)
		 	setState(1793)
		 	try match(plsqlParser.Tokens.RESULT.rawValue)
		 	setState(1794)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1808)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,149, _ctx)) {
		 	case 1:
		 		setState(1795)
		 		try call_spec()

		 		break
		 	case 2:
		 		setState(1797)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.DECLARE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1796)
		 			try match(plsqlParser.Tokens.DECLARE.rawValue)

		 		}

		 		setState(1802)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 66)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 130)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 194)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 259)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 323)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 387)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 451)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1799)
		 			try declare_spec()


		 			setState(1804)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1805)
		 		try body()
		 		setState(1806)
		 		try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Modifier_clauseContext:ParserRuleContext {
		open func INSTANTIABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.INSTANTIABLE.rawValue, 0) }
		open func FINAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.FINAL.rawValue, 0) }
		open func OVERRIDING() -> TerminalNode? { return getToken(plsqlParser.Tokens.OVERRIDING.rawValue, 0) }
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_modifier_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModifier_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModifier_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModifier_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModifier_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func modifier_clause() throws -> Modifier_clauseContext {
		var _localctx: Modifier_clauseContext = Modifier_clauseContext(_ctx, getState())
		try enterRule(_localctx, 138, plsqlParser.RULE_modifier_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1811)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.NOT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1810)
		 		try match(plsqlParser.Tokens.NOT.rawValue)

		 	}

		 	setState(1813)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.FINAL.rawValue || _la == plsqlParser.Tokens.INSTANTIABLE.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.OVERRIDING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Object_member_specContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func sqlj_object_type_attr() -> Sqlj_object_type_attrContext? {
			return getRuleContext(Sqlj_object_type_attrContext.self,0)
		}
		open func element_spec() -> Element_specContext? {
			return getRuleContext(Element_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_object_member_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterObject_member_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitObject_member_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitObject_member_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitObject_member_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func object_member_spec() throws -> Object_member_specContext {
		var _localctx: Object_member_specContext = Object_member_specContext(_ctx, getState())
		try enterRule(_localctx, 140, plsqlParser.RULE_object_member_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1821)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,152, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1815)
		 		try identifier()
		 		setState(1816)
		 		try type_spec()
		 		setState(1818)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.EXTERNAL.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1817)
		 			try sqlj_object_type_attr()

		 		}


		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1820)
		 		try element_spec()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sqlj_object_type_attrContext:ParserRuleContext {
		open func EXTERNAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXTERNAL.rawValue, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.NAME.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sqlj_object_type_attr }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSqlj_object_type_attr(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSqlj_object_type_attr(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSqlj_object_type_attr(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSqlj_object_type_attr(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sqlj_object_type_attr() throws -> Sqlj_object_type_attrContext {
		var _localctx: Sqlj_object_type_attrContext = Sqlj_object_type_attrContext(_ctx, getState())
		try enterRule(_localctx, 142, plsqlParser.RULE_sqlj_object_type_attr)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1823)
		 	try match(plsqlParser.Tokens.EXTERNAL.rawValue)
		 	setState(1824)
		 	try match(plsqlParser.Tokens.NAME.rawValue)
		 	setState(1825)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Element_specContext:ParserRuleContext {
		open func modifier_clause() -> Modifier_clauseContext? {
			return getRuleContext(Modifier_clauseContext.self,0)
		}
		open func element_spec_options() -> Array<Element_spec_optionsContext> {
			return getRuleContexts(Element_spec_optionsContext.self)
		}
		open func element_spec_options(_ i: Int) -> Element_spec_optionsContext? {
			return getRuleContext(Element_spec_optionsContext.self,i)
		}
		open func pragma_clause() -> Pragma_clauseContext? {
			return getRuleContext(Pragma_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_element_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterElement_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitElement_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitElement_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitElement_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func element_spec() throws -> Element_specContext {
		var _localctx: Element_specContext = Element_specContext(_ctx, getState())
		try enterRule(_localctx, 144, plsqlParser.RULE_element_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1828)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,153,_ctx)) {
		 	case 1:
		 		setState(1827)
		 		try modifier_clause()

		 		break
		 	default: break
		 	}
		 	setState(1831) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1830)
		 		try element_spec_options()


		 		setState(1833); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.CONSTRUCTOR.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.FINAL.rawValue || _la == plsqlParser.Tokens.INSTANTIABLE.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.ORDER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 214)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.STATIC.rawValue
		 	      return testSet
		 	 }())
		 	setState(1837)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,155,_ctx)) {
		 	case 1:
		 		setState(1835)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(1836)
		 		try pragma_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Element_spec_optionsContext:ParserRuleContext {
		open func subprogram_spec() -> Subprogram_specContext? {
			return getRuleContext(Subprogram_specContext.self,0)
		}
		open func constructor_spec() -> Constructor_specContext? {
			return getRuleContext(Constructor_specContext.self,0)
		}
		open func map_order_function_spec() -> Map_order_function_specContext? {
			return getRuleContext(Map_order_function_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_element_spec_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterElement_spec_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitElement_spec_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitElement_spec_options(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitElement_spec_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func element_spec_options() throws -> Element_spec_optionsContext {
		var _localctx: Element_spec_optionsContext = Element_spec_optionsContext(_ctx, getState())
		try enterRule(_localctx, 146, plsqlParser.RULE_element_spec_options)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1842)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .MEMBER:fallthrough
		 	case .STATIC:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1839)
		 		try subprogram_spec()

		 		break
		 	case .CONSTRUCTOR:fallthrough
		 	case .FINAL:fallthrough
		 	case .INSTANTIABLE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1840)
		 		try constructor_spec()

		 		break
		 	case .MAP:fallthrough
		 	case .ORDER:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1841)
		 		try map_order_function_spec()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subprogram_specContext:ParserRuleContext {
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.Tokens.MEMBER.rawValue, 0) }
		open func STATIC() -> TerminalNode? { return getToken(plsqlParser.Tokens.STATIC.rawValue, 0) }
		open func type_procedure_spec() -> Type_procedure_specContext? {
			return getRuleContext(Type_procedure_specContext.self,0)
		}
		open func type_function_spec() -> Type_function_specContext? {
			return getRuleContext(Type_function_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subprogram_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubprogram_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubprogram_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubprogram_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubprogram_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subprogram_spec() throws -> Subprogram_specContext {
		var _localctx: Subprogram_specContext = Subprogram_specContext(_ctx, getState())
		try enterRule(_localctx, 148, plsqlParser.RULE_subprogram_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1844)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.MEMBER.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.STATIC.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1847)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .PROCEDURE:
		 		setState(1845)
		 		try type_procedure_spec()

		 		break

		 	case .FUNCTION:
		 		setState(1846)
		 		try type_function_spec()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_procedure_specContext:ParserRuleContext {
		open func PROCEDURE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PROCEDURE.rawValue, 0) }
		open func procedure_name() -> Procedure_nameContext? {
			return getRuleContext(Procedure_nameContext.self,0)
		}
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_procedure_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_procedure_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_procedure_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_procedure_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_procedure_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_procedure_spec() throws -> Type_procedure_specContext {
		var _localctx: Type_procedure_specContext = Type_procedure_specContext(_ctx, getState())
		try enterRule(_localctx, 150, plsqlParser.RULE_type_procedure_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1849)
		 	try match(plsqlParser.Tokens.PROCEDURE.rawValue)
		 	setState(1850)
		 	try procedure_name()
		 	setState(1851)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(1852)
		 	try type_elements_parameter()
		 	setState(1857)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1853)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(1854)
		 		try type_elements_parameter()


		 		setState(1859)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1860)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(1863)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1861)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1862)
		 		try call_spec()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_function_specContext:ParserRuleContext {
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func function_name() -> Function_nameContext? {
			return getRuleContext(Function_nameContext.self,0)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func SELF() -> TerminalNode? { return getToken(plsqlParser.Tokens.SELF.rawValue, 0) }
		open func AS() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.AS.rawValue) }
		open func AS(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.AS.rawValue, i)
		}
		open func RESULT() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESULT.rawValue, 0) }
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func EXTERNAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXTERNAL.rawValue, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.NAME.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func VARIABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARIABLE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_function_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_function_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_function_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_function_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_function_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_function_spec() throws -> Type_function_specContext {
		var _localctx: Type_function_specContext = Type_function_specContext(_ctx, getState())
		try enterRule(_localctx, 152, plsqlParser.RULE_type_function_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1865)
		 	try match(plsqlParser.Tokens.FUNCTION.rawValue)
		 	setState(1866)
		 	try function_name()
		 	setState(1878)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1867)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(1868)
		 		try type_elements_parameter()
		 		setState(1873)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1869)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1870)
		 			try type_elements_parameter()


		 			setState(1875)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1876)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(1880)
		 	try match(plsqlParser.Tokens.RETURN.rawValue)
		 	setState(1885)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,162, _ctx)) {
		 	case 1:
		 		setState(1881)
		 		try type_spec()

		 		break
		 	case 2:
		 		setState(1882)
		 		try match(plsqlParser.Tokens.SELF.rawValue)
		 		setState(1883)
		 		try match(plsqlParser.Tokens.AS.rawValue)
		 		setState(1884)
		 		try match(plsqlParser.Tokens.RESULT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1895)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .AS:fallthrough
		 	case .IS:
		 	 	setState(1887)
		 	 	_la = try _input.LA(1)
		 	 	if (!(//closure
		 	 	 { () -> Bool in
		 	 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	 	      return testSet
		 	 	 }())) {
		 	 	try _errHandler.recoverInline(self)
		 	 	}
		 	 	else {
		 	 		_errHandler.reportMatch(self)
		 	 		try consume()
		 	 	}
		 	 	setState(1888)
		 	 	try call_spec()

		 		break

		 	case .EXTERNAL:
		 	 	setState(1889)
		 	 	try match(plsqlParser.Tokens.EXTERNAL.rawValue)
		 	 	setState(1891)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == plsqlParser.Tokens.VARIABLE.rawValue
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(1890)
		 	 		try match(plsqlParser.Tokens.VARIABLE.rawValue)

		 	 	}

		 	 	setState(1893)
		 	 	try match(plsqlParser.Tokens.NAME.rawValue)
		 	 	setState(1894)
		 	 	try expression()

		 		break
		 	case .CASCADE:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .FINAL:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .MAP:fallthrough
		 	case .MEMBER:fallthrough
		 	case .ORDER:fallthrough
		 	case .STATIC:fallthrough
		 	case .RIGHT_PAREN:fallthrough
		 	case .COMMA:fallthrough
		 	case .SEMICOLON:
		 		break
		 	default:
		 		break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Constructor_specContext:ParserRuleContext {
		open func CONSTRUCTOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONSTRUCTOR.rawValue, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func type_spec() -> Array<Type_specContext> {
			return getRuleContexts(Type_specContext.self)
		}
		open func type_spec(_ i: Int) -> Type_specContext? {
			return getRuleContext(Type_specContext.self,i)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func SELF() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.SELF.rawValue) }
		open func SELF(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.SELF.rawValue, i)
		}
		open func AS() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.AS.rawValue) }
		open func AS(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.AS.rawValue, i)
		}
		open func RESULT() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESULT.rawValue, 0) }
		open func FINAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.FINAL.rawValue, 0) }
		open func INSTANTIABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.INSTANTIABLE.rawValue, 0) }
		open func type_elements_parameter() -> Array<Type_elements_parameterContext> {
			return getRuleContexts(Type_elements_parameterContext.self)
		}
		open func type_elements_parameter(_ i: Int) -> Type_elements_parameterContext? {
			return getRuleContext(Type_elements_parameterContext.self,i)
		}
		open func call_spec() -> Call_specContext? {
			return getRuleContext(Call_specContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func OUT() -> TerminalNode? { return getToken(plsqlParser.Tokens.OUT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_constructor_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConstructor_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConstructor_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConstructor_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConstructor_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func constructor_spec() throws -> Constructor_specContext {
		var _localctx: Constructor_specContext = Constructor_specContext(_ctx, getState())
		try enterRule(_localctx, 154, plsqlParser.RULE_constructor_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1898)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.FINAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1897)
		 		try match(plsqlParser.Tokens.FINAL.rawValue)

		 	}

		 	setState(1901)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.INSTANTIABLE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1900)
		 		try match(plsqlParser.Tokens.INSTANTIABLE.rawValue)

		 	}

		 	setState(1903)
		 	try match(plsqlParser.Tokens.CONSTRUCTOR.rawValue)
		 	setState(1904)
		 	try match(plsqlParser.Tokens.FUNCTION.rawValue)
		 	setState(1905)
		 	try type_spec()
		 	setState(1923)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1906)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)

		 		setState(1907)
		 		try match(plsqlParser.Tokens.SELF.rawValue)
		 		setState(1908)
		 		try match(plsqlParser.Tokens.IN.rawValue)
		 		setState(1909)
		 		try match(plsqlParser.Tokens.OUT.rawValue)
		 		setState(1910)
		 		try type_spec()
		 		setState(1911)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)

		 		setState(1913)
		 		try type_elements_parameter()
		 		setState(1918)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1914)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(1915)
		 			try type_elements_parameter()


		 			setState(1920)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1921)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(1925)
		 	try match(plsqlParser.Tokens.RETURN.rawValue)
		 	setState(1926)
		 	try match(plsqlParser.Tokens.SELF.rawValue)
		 	setState(1927)
		 	try match(plsqlParser.Tokens.AS.rawValue)
		 	setState(1928)
		 	try match(plsqlParser.Tokens.RESULT.rawValue)
		 	setState(1931)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1929)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.IS.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1930)
		 		try call_spec()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Map_order_function_specContext:ParserRuleContext {
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.Tokens.MEMBER.rawValue, 0) }
		open func type_function_spec() -> Type_function_specContext? {
			return getRuleContext(Type_function_specContext.self,0)
		}
		open func MAP() -> TerminalNode? { return getToken(plsqlParser.Tokens.MAP.rawValue, 0) }
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ORDER.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_map_order_function_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMap_order_function_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMap_order_function_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMap_order_function_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMap_order_function_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func map_order_function_spec() throws -> Map_order_function_specContext {
		var _localctx: Map_order_function_specContext = Map_order_function_specContext(_ctx, getState())
		try enterRule(_localctx, 156, plsqlParser.RULE_map_order_function_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1933)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.MAP.rawValue || _la == plsqlParser.Tokens.ORDER.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1934)
		 	try match(plsqlParser.Tokens.MEMBER.rawValue)
		 	setState(1935)
		 	try type_function_spec()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pragma_clauseContext:ParserRuleContext {
		open func PRAGMA() -> TerminalNode? { return getToken(plsqlParser.Tokens.PRAGMA.rawValue, 0) }
		open func RESTRICT_REFERENCES() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue, 0) }
		open func pragma_elements() -> Array<Pragma_elementsContext> {
			return getRuleContexts(Pragma_elementsContext.self)
		}
		open func pragma_elements(_ i: Int) -> Pragma_elementsContext? {
			return getRuleContext(Pragma_elementsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pragma_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPragma_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPragma_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPragma_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPragma_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pragma_clause() throws -> Pragma_clauseContext {
		var _localctx: Pragma_clauseContext = Pragma_clauseContext(_ctx, getState())
		try enterRule(_localctx, 158, plsqlParser.RULE_pragma_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1937)
		 	try match(plsqlParser.Tokens.PRAGMA.rawValue)
		 	setState(1938)
		 	try match(plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue)
		 	setState(1939)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(1940)
		 	try pragma_elements()
		 	setState(1945)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1941)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(1942)
		 		try pragma_elements()


		 		setState(1947)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1948)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pragma_elementsContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pragma_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPragma_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPragma_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPragma_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPragma_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pragma_elements() throws -> Pragma_elementsContext {
		var _localctx: Pragma_elementsContext = Pragma_elementsContext(_ctx, getState())
		try enterRule(_localctx, 160, plsqlParser.RULE_pragma_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1952)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1950)
		 		try identifier()

		 		break

		 	case .DEFAULT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1951)
		 		try match(plsqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_elements_parameterContext:ParserRuleContext {
		open func parameter_name() -> Parameter_nameContext? {
			return getRuleContext(Parameter_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_elements_parameter }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_elements_parameter(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_elements_parameter(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_elements_parameter(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_elements_parameter(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_elements_parameter() throws -> Type_elements_parameterContext {
		var _localctx: Type_elements_parameterContext = Type_elements_parameterContext(_ctx, getState())
		try enterRule(_localctx, 162, plsqlParser.RULE_type_elements_parameter)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1954)
		 	try parameter_name()
		 	setState(1955)
		 	try type_spec()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_sequenceContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(plsqlParser.Tokens.DROP.rawValue, 0) }
		open func SEQUENCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SEQUENCE.rawValue, 0) }
		open func sequence_name() -> Sequence_nameContext? {
			return getRuleContext(Sequence_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_drop_sequence }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDrop_sequence(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDrop_sequence(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDrop_sequence(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDrop_sequence(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_sequence() throws -> Drop_sequenceContext {
		var _localctx: Drop_sequenceContext = Drop_sequenceContext(_ctx, getState())
		try enterRule(_localctx, 164, plsqlParser.RULE_drop_sequence)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1957)
		 	try match(plsqlParser.Tokens.DROP.rawValue)
		 	setState(1958)
		 	try match(plsqlParser.Tokens.SEQUENCE.rawValue)
		 	setState(1959)
		 	try sequence_name()
		 	setState(1960)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_sequenceContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALTER.rawValue, 0) }
		open func SEQUENCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SEQUENCE.rawValue, 0) }
		open func sequence_name() -> Sequence_nameContext? {
			return getRuleContext(Sequence_nameContext.self,0)
		}
		open func sequence_spec() -> Array<Sequence_specContext> {
			return getRuleContexts(Sequence_specContext.self)
		}
		open func sequence_spec(_ i: Int) -> Sequence_specContext? {
			return getRuleContext(Sequence_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alter_sequence }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlter_sequence(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlter_sequence(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlter_sequence(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlter_sequence(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_sequence() throws -> Alter_sequenceContext {
		var _localctx: Alter_sequenceContext = Alter_sequenceContext(_ctx, getState())
		try enterRule(_localctx, 166, plsqlParser.RULE_alter_sequence)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1962)
		 	try match(plsqlParser.Tokens.ALTER.rawValue)
		 	setState(1963)
		 	try match(plsqlParser.Tokens.SEQUENCE.rawValue)
		 	setState(1964)
		 	try sequence_name()
		 	setState(1966) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(1965)
		 		try sequence_spec()


		 		setState(1968); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.CACHE.rawValue || _la == plsqlParser.Tokens.CYCLE.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 168)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.NOCACHE.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOMAXVALUE.rawValue,plsqlParser.Tokens.NOMINVALUE.rawValue,plsqlParser.Tokens.NOORDER.rawValue,plsqlParser.Tokens.ORDER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 241)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(1970)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_sequenceContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CREATE.rawValue, 0) }
		open func SEQUENCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SEQUENCE.rawValue, 0) }
		open func sequence_name() -> Sequence_nameContext? {
			return getRuleContext(Sequence_nameContext.self,0)
		}
		open func sequence_start_clause() -> Array<Sequence_start_clauseContext> {
			return getRuleContexts(Sequence_start_clauseContext.self)
		}
		open func sequence_start_clause(_ i: Int) -> Sequence_start_clauseContext? {
			return getRuleContext(Sequence_start_clauseContext.self,i)
		}
		open func sequence_spec() -> Array<Sequence_specContext> {
			return getRuleContexts(Sequence_specContext.self)
		}
		open func sequence_spec(_ i: Int) -> Sequence_specContext? {
			return getRuleContext(Sequence_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_create_sequence }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCreate_sequence(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCreate_sequence(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCreate_sequence(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCreate_sequence(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_sequence() throws -> Create_sequenceContext {
		var _localctx: Create_sequenceContext = Create_sequenceContext(_ctx, getState())
		try enterRule(_localctx, 168, plsqlParser.RULE_create_sequence)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1972)
		 	try match(plsqlParser.Tokens.CREATE.rawValue)
		 	setState(1973)
		 	try match(plsqlParser.Tokens.SEQUENCE.rawValue)
		 	setState(1974)
		 	try sequence_name()
		 	setState(1979)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.CACHE.rawValue || _la == plsqlParser.Tokens.CYCLE.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 168)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.NOCACHE.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOMAXVALUE.rawValue,plsqlParser.Tokens.NOMINVALUE.rawValue,plsqlParser.Tokens.NOORDER.rawValue,plsqlParser.Tokens.ORDER.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 241)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.START.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1977)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .START:
		 			setState(1975)
		 			try sequence_start_clause()

		 			break
		 		case .CACHE:fallthrough
		 		case .CYCLE:fallthrough
		 		case .INCREMENT:fallthrough
		 		case .MAXVALUE:fallthrough
		 		case .MINVALUE:fallthrough
		 		case .NOCACHE:fallthrough
		 		case .NOCYCLE:fallthrough
		 		case .NOMAXVALUE:fallthrough
		 		case .NOMINVALUE:fallthrough
		 		case .NOORDER:fallthrough
		 		case .ORDER:
		 			setState(1976)
		 			try sequence_spec()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(1981)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1982)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sequence_specContext:ParserRuleContext {
		open func INCREMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INCREMENT.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func UNSIGNED_INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue, 0) }
		open func MAXVALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.MAXVALUE.rawValue, 0) }
		open func NOMAXVALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOMAXVALUE.rawValue, 0) }
		open func MINVALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.MINVALUE.rawValue, 0) }
		open func NOMINVALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOMINVALUE.rawValue, 0) }
		open func CYCLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CYCLE.rawValue, 0) }
		open func NOCYCLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOCYCLE.rawValue, 0) }
		open func CACHE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CACHE.rawValue, 0) }
		open func NOCACHE() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOCACHE.rawValue, 0) }
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ORDER.rawValue, 0) }
		open func NOORDER() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOORDER.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sequence_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSequence_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSequence_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSequence_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSequence_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sequence_spec() throws -> Sequence_specContext {
		var _localctx: Sequence_specContext = Sequence_specContext(_ctx, getState())
		try enterRule(_localctx, 170, plsqlParser.RULE_sequence_spec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2000)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .INCREMENT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1984)
		 		try match(plsqlParser.Tokens.INCREMENT.rawValue)
		 		setState(1985)
		 		try match(plsqlParser.Tokens.BY.rawValue)
		 		setState(1986)
		 		try match(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue)

		 		break

		 	case .MAXVALUE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1987)
		 		try match(plsqlParser.Tokens.MAXVALUE.rawValue)
		 		setState(1988)
		 		try match(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue)

		 		break

		 	case .NOMAXVALUE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1989)
		 		try match(plsqlParser.Tokens.NOMAXVALUE.rawValue)

		 		break

		 	case .MINVALUE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1990)
		 		try match(plsqlParser.Tokens.MINVALUE.rawValue)
		 		setState(1991)
		 		try match(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue)

		 		break

		 	case .NOMINVALUE:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1992)
		 		try match(plsqlParser.Tokens.NOMINVALUE.rawValue)

		 		break

		 	case .CYCLE:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1993)
		 		try match(plsqlParser.Tokens.CYCLE.rawValue)

		 		break

		 	case .NOCYCLE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1994)
		 		try match(plsqlParser.Tokens.NOCYCLE.rawValue)

		 		break

		 	case .CACHE:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1995)
		 		try match(plsqlParser.Tokens.CACHE.rawValue)
		 		setState(1996)
		 		try match(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue)

		 		break

		 	case .NOCACHE:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1997)
		 		try match(plsqlParser.Tokens.NOCACHE.rawValue)

		 		break

		 	case .ORDER:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1998)
		 		try match(plsqlParser.Tokens.ORDER.rawValue)

		 		break

		 	case .NOORDER:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1999)
		 		try match(plsqlParser.Tokens.NOORDER.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sequence_start_clauseContext:ParserRuleContext {
		open func START() -> TerminalNode? { return getToken(plsqlParser.Tokens.START.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.Tokens.WITH.rawValue, 0) }
		open func UNSIGNED_INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sequence_start_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSequence_start_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSequence_start_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSequence_start_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSequence_start_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sequence_start_clause() throws -> Sequence_start_clauseContext {
		var _localctx: Sequence_start_clauseContext = Sequence_start_clauseContext(_ctx, getState())
		try enterRule(_localctx, 172, plsqlParser.RULE_sequence_start_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2002)
		 	try match(plsqlParser.Tokens.START.rawValue)
		 	setState(2003)
		 	try match(plsqlParser.Tokens.WITH.rawValue)
		 	setState(2004)
		 	try match(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Invoker_rights_clauseContext:ParserRuleContext {
		open func AUTHID() -> TerminalNode? { return getToken(plsqlParser.Tokens.AUTHID.rawValue, 0) }
		open func CURRENT_USER() -> TerminalNode? { return getToken(plsqlParser.Tokens.CURRENT_USER.rawValue, 0) }
		open func DEFINER() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFINER.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_invoker_rights_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterInvoker_rights_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitInvoker_rights_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitInvoker_rights_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitInvoker_rights_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func invoker_rights_clause() throws -> Invoker_rights_clauseContext {
		var _localctx: Invoker_rights_clauseContext = Invoker_rights_clauseContext(_ctx, getState())
		try enterRule(_localctx, 174, plsqlParser.RULE_invoker_rights_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2006)
		 	try match(plsqlParser.Tokens.AUTHID.rawValue)
		 	setState(2007)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.CURRENT_USER.rawValue || _la == plsqlParser.Tokens.DEFINER.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Compiler_parameters_clauseContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compiler_parameters_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompiler_parameters_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompiler_parameters_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompiler_parameters_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompiler_parameters_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compiler_parameters_clause() throws -> Compiler_parameters_clauseContext {
		var _localctx: Compiler_parameters_clauseContext = Compiler_parameters_clauseContext(_ctx, getState())
		try enterRule(_localctx, 176, plsqlParser.RULE_compiler_parameters_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2009)
		 	try identifier()
		 	setState(2010)
		 	try match(plsqlParser.Tokens.EQUALS_OP.rawValue)
		 	setState(2011)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Call_specContext:ParserRuleContext {
		open func LANGUAGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.LANGUAGE.rawValue, 0) }
		open func java_spec() -> Java_specContext? {
			return getRuleContext(Java_specContext.self,0)
		}
		open func c_spec() -> C_specContext? {
			return getRuleContext(C_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_call_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCall_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCall_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCall_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCall_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func call_spec() throws -> Call_specContext {
		var _localctx: Call_specContext = Call_specContext(_ctx, getState())
		try enterRule(_localctx, 178, plsqlParser.RULE_call_spec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2013)
		 	try match(plsqlParser.Tokens.LANGUAGE.rawValue)
		 	setState(2016)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .JAVA:
		 		setState(2014)
		 		try java_spec()

		 		break

		 	case .C_LETTER:
		 		setState(2015)
		 		try c_spec()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Java_specContext:ParserRuleContext {
		open func JAVA() -> TerminalNode? { return getToken(plsqlParser.Tokens.JAVA.rawValue, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.NAME.rawValue, 0) }
		open func CHAR_STRING() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHAR_STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_java_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterJava_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitJava_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitJava_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitJava_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func java_spec() throws -> Java_specContext {
		var _localctx: Java_specContext = Java_specContext(_ctx, getState())
		try enterRule(_localctx, 180, plsqlParser.RULE_java_spec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2018)
		 	try match(plsqlParser.Tokens.JAVA.rawValue)
		 	setState(2019)
		 	try match(plsqlParser.Tokens.NAME.rawValue)
		 	setState(2020)
		 	try match(plsqlParser.Tokens.CHAR_STRING.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class C_specContext:ParserRuleContext {
		open func C_LETTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.C_LETTER.rawValue, 0) }
		open func LIBRARY() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIBRARY.rawValue, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.NAME.rawValue, 0) }
		open func CHAR_STRING() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHAR_STRING.rawValue, 0) }
		open func c_agent_in_clause() -> C_agent_in_clauseContext? {
			return getRuleContext(C_agent_in_clauseContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.Tokens.WITH.rawValue, 0) }
		open func CONTEXT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONTEXT.rawValue, 0) }
		open func c_parameters_clause() -> C_parameters_clauseContext? {
			return getRuleContext(C_parameters_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_c_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterC_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitC_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitC_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitC_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func c_spec() throws -> C_specContext {
		var _localctx: C_specContext = C_specContext(_ctx, getState())
		try enterRule(_localctx, 182, plsqlParser.RULE_c_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2022)
		 	try match(plsqlParser.Tokens.C_LETTER.rawValue)
		 	setState(2025)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.NAME.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2023)
		 		try match(plsqlParser.Tokens.NAME.rawValue)
		 		setState(2024)
		 		try match(plsqlParser.Tokens.CHAR_STRING.rawValue)

		 	}

		 	setState(2027)
		 	try match(plsqlParser.Tokens.LIBRARY.rawValue)
		 	setState(2028)
		 	try identifier()
		 	setState(2030)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.AGENT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2029)
		 		try c_agent_in_clause()

		 	}

		 	setState(2034)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2032)
		 		try match(plsqlParser.Tokens.WITH.rawValue)
		 		setState(2033)
		 		try match(plsqlParser.Tokens.CONTEXT.rawValue)

		 	}

		 	setState(2037)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PARAMETERS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2036)
		 		try c_parameters_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class C_agent_in_clauseContext:ParserRuleContext {
		open func AGENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.AGENT.rawValue, 0) }
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_c_agent_in_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterC_agent_in_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitC_agent_in_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitC_agent_in_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitC_agent_in_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func c_agent_in_clause() throws -> C_agent_in_clauseContext {
		var _localctx: C_agent_in_clauseContext = C_agent_in_clauseContext(_ctx, getState())
		try enterRule(_localctx, 184, plsqlParser.RULE_c_agent_in_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2039)
		 	try match(plsqlParser.Tokens.AGENT.rawValue)
		 	setState(2040)
		 	try match(plsqlParser.Tokens.IN.rawValue)
		 	setState(2041)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(2042)
		 	try expression()
		 	setState(2047)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2043)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(2044)
		 		try expression()


		 		setState(2049)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2050)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class C_parameters_clauseContext:ParserRuleContext {
		open func PARAMETERS() -> TerminalNode? { return getToken(plsqlParser.Tokens.PARAMETERS.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_c_parameters_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterC_parameters_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitC_parameters_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitC_parameters_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitC_parameters_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func c_parameters_clause() throws -> C_parameters_clauseContext {
		var _localctx: C_parameters_clauseContext = C_parameters_clauseContext(_ctx, getState())
		try enterRule(_localctx, 186, plsqlParser.RULE_c_parameters_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2052)
		 	try match(plsqlParser.Tokens.PARAMETERS.rawValue)
		 	setState(2053)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(2065)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALL:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ANY:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CASE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COALESCE:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONNECT_BY_ROOT:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DISTINCT:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXISTS:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FALSE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NOT:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .PRIOR:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .DECODE:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NVL:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .TO_CHAR:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case .UNSIGNED_INTEGER:fallthrough
		 	case .APPROXIMATE_NUM_LIT:fallthrough
		 	case .CHAR_STRING:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .LEFT_PAREN:fallthrough
		 	case .PLUS_SIGN:fallthrough
		 	case .MINUS_SIGN:fallthrough
		 	case .BINDVAR:fallthrough
		 	case .COLON:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(2054)
		 		try expression()
		 		setState(2059)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2055)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(2056)
		 			try expression()


		 			setState(2061)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break

		 	case .PERIOD:
		 		setState(2062)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(2063)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(2064)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2067)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ParameterContext:ParserRuleContext {
		open func parameter_name() -> Parameter_nameContext? {
			return getRuleContext(Parameter_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func default_value_part() -> Default_value_partContext? {
			return getRuleContext(Default_value_partContext.self,0)
		}
		open func IN() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.IN.rawValue) }
		open func IN(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.IN.rawValue, i)
		}
		open func OUT() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.OUT.rawValue) }
		open func OUT(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.OUT.rawValue, i)
		}
		open func INOUT() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.INOUT.rawValue) }
		open func INOUT(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.INOUT.rawValue, i)
		}
		open func NOCOPY() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.NOCOPY.rawValue) }
		open func NOCOPY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.NOCOPY.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_parameter }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterParameter(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitParameter(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitParameter(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitParameter(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func parameter() throws -> ParameterContext {
		var _localctx: ParameterContext = ParameterContext(_ctx, getState())
		try enterRule(_localctx, 188, plsqlParser.RULE_parameter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2069)
		 	try parameter_name()
		 	setState(2073)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,184,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2070)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.Tokens.IN.rawValue || _la == plsqlParser.Tokens.INOUT.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.NOCOPY.rawValue || _la == plsqlParser.Tokens.OUT.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 	 
		 		}
		 		setState(2075)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,184,_ctx)
		 	}
		 	setState(2077)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DATE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2076)
		 		try type_spec()

		 	}

		 	setState(2080)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.DEFAULT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.ASSIGN_OP.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2079)
		 		try default_value_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Default_value_partContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func ASSIGN_OP() -> TerminalNode? { return getToken(plsqlParser.Tokens.ASSIGN_OP.rawValue, 0) }
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_default_value_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDefault_value_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDefault_value_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDefault_value_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDefault_value_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func default_value_part() throws -> Default_value_partContext {
		var _localctx: Default_value_partContext = Default_value_partContext(_ctx, getState())
		try enterRule(_localctx, 190, plsqlParser.RULE_default_value_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2082)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.DEFAULT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.ASSIGN_OP.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2083)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Declare_specContext:ParserRuleContext {
		open func variable_declaration() -> Variable_declarationContext? {
			return getRuleContext(Variable_declarationContext.self,0)
		}
		open func subtype_declaration() -> Subtype_declarationContext? {
			return getRuleContext(Subtype_declarationContext.self,0)
		}
		open func cursor_declaration() -> Cursor_declarationContext? {
			return getRuleContext(Cursor_declarationContext.self,0)
		}
		open func exception_declaration() -> Exception_declarationContext? {
			return getRuleContext(Exception_declarationContext.self,0)
		}
		open func pragma_declaration() -> Pragma_declarationContext? {
			return getRuleContext(Pragma_declarationContext.self,0)
		}
		open func type_declaration() -> Type_declarationContext? {
			return getRuleContext(Type_declarationContext.self,0)
		}
		open func procedure_spec() -> Procedure_specContext? {
			return getRuleContext(Procedure_specContext.self,0)
		}
		open func function_spec() -> Function_specContext? {
			return getRuleContext(Function_specContext.self,0)
		}
		open func procedure_body() -> Procedure_bodyContext? {
			return getRuleContext(Procedure_bodyContext.self,0)
		}
		open func function_body() -> Function_bodyContext? {
			return getRuleContext(Function_bodyContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_declare_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDeclare_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDeclare_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDeclare_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDeclare_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func declare_spec() throws -> Declare_specContext {
		var _localctx: Declare_specContext = Declare_specContext(_ctx, getState())
		try enterRule(_localctx, 192, plsqlParser.RULE_declare_spec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2095)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,187, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2085)
		 		try variable_declaration()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2086)
		 		try subtype_declaration()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2087)
		 		try cursor_declaration()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2088)
		 		try exception_declaration()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2089)
		 		try pragma_declaration()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2090)
		 		try type_declaration()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2091)
		 		try procedure_spec()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(2092)
		 		try function_spec()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(2093)
		 		try procedure_body()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(2094)
		 		try function_body()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Variable_declarationContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func CONSTANT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONSTANT.rawValue, 0) }
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULL.rawValue, 0) }
		open func default_value_part() -> Default_value_partContext? {
			return getRuleContext(Default_value_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_variable_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterVariable_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitVariable_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitVariable_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitVariable_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func variable_declaration() throws -> Variable_declarationContext {
		var _localctx: Variable_declarationContext = Variable_declarationContext(_ctx, getState())
		try enterRule(_localctx, 194, plsqlParser.RULE_variable_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2097)
		 	try identifier()
		 	setState(2099)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,188,_ctx)) {
		 	case 1:
		 		setState(2098)
		 		try match(plsqlParser.Tokens.CONSTANT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(2101)
		 	try type_spec()
		 	setState(2104)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.NOT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2102)
		 		try match(plsqlParser.Tokens.NOT.rawValue)
		 		setState(2103)
		 		try match(plsqlParser.Tokens.NULL.rawValue)

		 	}

		 	setState(2107)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.DEFAULT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.ASSIGN_OP.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2106)
		 		try default_value_part()

		 	}

		 	setState(2109)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subtype_declarationContext:ParserRuleContext {
		open func SUBTYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUBTYPE.rawValue, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func RANGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.RANGE.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subtype_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubtype_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubtype_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubtype_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubtype_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subtype_declaration() throws -> Subtype_declarationContext {
		var _localctx: Subtype_declarationContext = Subtype_declarationContext(_ctx, getState())
		try enterRule(_localctx, 196, plsqlParser.RULE_subtype_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2111)
		 	try match(plsqlParser.Tokens.SUBTYPE.rawValue)
		 	setState(2112)
		 	try identifier()
		 	setState(2113)
		 	try match(plsqlParser.Tokens.IS.rawValue)
		 	setState(2114)
		 	try type_spec()
		 	setState(2120)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RANGE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2115)
		 		try match(plsqlParser.Tokens.RANGE.rawValue)
		 		setState(2116)
		 		try expression()
		 		setState(2117)
		 		try match(plsqlParser.Tokens.T__0.rawValue)
		 		setState(2118)
		 		try expression()

		 	}

		 	setState(2124)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.NOT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2122)
		 		try match(plsqlParser.Tokens.NOT.rawValue)
		 		setState(2123)
		 		try match(plsqlParser.Tokens.NULL.rawValue)

		 	}

		 	setState(2126)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_declarationContext:ParserRuleContext {
		open func CURSOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CURSOR.rawValue, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func parameter_spec() -> Array<Parameter_specContext> {
			return getRuleContexts(Parameter_specContext.self)
		}
		open func parameter_spec(_ i: Int) -> Parameter_specContext? {
			return getRuleContext(Parameter_specContext.self,i)
		}
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cursor_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCursor_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCursor_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCursor_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCursor_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_declaration() throws -> Cursor_declarationContext {
		var _localctx: Cursor_declarationContext = Cursor_declarationContext(_ctx, getState())
		try enterRule(_localctx, 198, plsqlParser.RULE_cursor_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2128)
		 	try match(plsqlParser.Tokens.CURSOR.rawValue)
		 	setState(2129)
		 	try identifier()
		 	setState(2141)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2130)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(2131)
		 		try parameter_spec()
		 		setState(2136)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2132)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(2133)
		 			try parameter_spec()


		 			setState(2138)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2139)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(2145)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RETURN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2143)
		 		try match(plsqlParser.Tokens.RETURN.rawValue)
		 		setState(2144)
		 		try type_spec()

		 	}

		 	setState(2149)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.IS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2147)
		 		try match(plsqlParser.Tokens.IS.rawValue)
		 		setState(2148)
		 		try select_statement()

		 	}

		 	setState(2151)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Parameter_specContext:ParserRuleContext {
		open func parameter_name() -> Parameter_nameContext? {
			return getRuleContext(Parameter_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func default_value_part() -> Default_value_partContext? {
			return getRuleContext(Default_value_partContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_parameter_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterParameter_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitParameter_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitParameter_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitParameter_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func parameter_spec() throws -> Parameter_specContext {
		var _localctx: Parameter_specContext = Parameter_specContext(_ctx, getState())
		try enterRule(_localctx, 200, plsqlParser.RULE_parameter_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2153)
		 	try parameter_name()
		 	setState(2158)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DATE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.IN.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2155)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.IN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2154)
		 			try match(plsqlParser.Tokens.IN.rawValue)

		 		}

		 		setState(2157)
		 		try type_spec()

		 	}

		 	setState(2161)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.DEFAULT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.ASSIGN_OP.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2160)
		 		try default_value_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Exception_declarationContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func EXCEPTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXCEPTION.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_exception_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterException_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitException_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitException_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitException_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exception_declaration() throws -> Exception_declarationContext {
		var _localctx: Exception_declarationContext = Exception_declarationContext(_ctx, getState())
		try enterRule(_localctx, 202, plsqlParser.RULE_exception_declaration)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2163)
		 	try identifier()
		 	setState(2164)
		 	try match(plsqlParser.Tokens.EXCEPTION.rawValue)
		 	setState(2165)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pragma_declarationContext:ParserRuleContext {
		public var id1: IdentifierContext!
		open func PRAGMA() -> TerminalNode? { return getToken(plsqlParser.Tokens.PRAGMA.rawValue, 0) }
		open func SERIALLY_REUSABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue, 0) }
		open func AUTONOMOUS_TRANSACTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue, 0) }
		open func EXCEPTION_INIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXCEPTION_INIT.rawValue, 0) }
		open func exception_name() -> Exception_nameContext? {
			return getRuleContext(Exception_nameContext.self,0)
		}
		open func numeric_negative() -> Numeric_negativeContext? {
			return getRuleContext(Numeric_negativeContext.self,0)
		}
		open func INLINE() -> TerminalNode? { return getToken(plsqlParser.Tokens.INLINE.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func RESTRICT_REFERENCES() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue, 0) }
		open func identifier() -> Array<IdentifierContext> {
			return getRuleContexts(IdentifierContext.self)
		}
		open func identifier(_ i: Int) -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,i)
		}
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pragma_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPragma_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPragma_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPragma_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPragma_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pragma_declaration() throws -> Pragma_declarationContext {
		var _localctx: Pragma_declarationContext = Pragma_declarationContext(_ctx, getState())
		try enterRule(_localctx, 204, plsqlParser.RULE_pragma_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2167)
		 	try match(plsqlParser.Tokens.PRAGMA.rawValue)
		 	setState(2198)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SERIALLY_REUSABLE:
		 		setState(2168)
		 		try match(plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue)

		 		break

		 	case .AUTONOMOUS_TRANSACTION:
		 		setState(2169)
		 		try match(plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue)

		 		break

		 	case .EXCEPTION_INIT:
		 		setState(2170)
		 		try match(plsqlParser.Tokens.EXCEPTION_INIT.rawValue)
		 		setState(2171)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(2172)
		 		try exception_name()
		 		setState(2173)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(2174)
		 		try numeric_negative()
		 		setState(2175)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break

		 	case .INLINE:
		 		setState(2177)
		 		try match(plsqlParser.Tokens.INLINE.rawValue)
		 		setState(2178)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(2179)
		 		try {
		 				let assignmentValue = try identifier()
		 				_localctx.castdown(Pragma_declarationContext.self).id1 = assignmentValue
		 		     }()

		 		setState(2180)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(2181)
		 		try expression()
		 		setState(2182)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break

		 	case .RESTRICT_REFERENCES:
		 		setState(2184)
		 		try match(plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue)
		 		setState(2185)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(2188)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .A_LETTER:fallthrough
		 		case .ADD:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGENT:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .ARRAY:fallthrough
		 		case .ASSOCIATE:fallthrough
		 		case .AT:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .AUDIT:fallthrough
		 		case .AUTHID:fallthrough
		 		case .AUTO:fallthrough
		 		case .AUTOMATIC:fallthrough
		 		case .AUTONOMOUS_TRANSACTION:fallthrough
		 		case .BATCH:fallthrough
		 		case .BEFORE:fallthrough
		 		case .BFILE:fallthrough
		 		case .BINARY_DOUBLE:fallthrough
		 		case .BINARY_FLOAT:fallthrough
		 		case .BINARY_INTEGER:fallthrough
		 		case .BLOB:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BODY:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BOTH:fallthrough
		 		case .BULK:fallthrough
		 		case .BYTE:fallthrough
		 		case .C_LETTER:fallthrough
		 		case .CALL:fallthrough
		 		case .CANONICAL:fallthrough
		 		case .CASCADE:fallthrough
		 		case .CAST:fallthrough
		 		case .CHAR:fallthrough
		 		case .CHAR_CS:fallthrough
		 		case .CHARACTER:fallthrough
		 		case .CHR:fallthrough
		 		case .CLOB:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTER:fallthrough
		 		case .COLLECT:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .COMPATIBILITY:fallthrough
		 		case .COMPILE:fallthrough
		 		case .COMPOUND:fallthrough
		 		case .CONSTANT:fallthrough
		 		case .CONSTRAINT:fallthrough
		 		case .CONSTRAINTS:fallthrough
		 		case .CONSTRUCTOR:fallthrough
		 		case .CONTENT:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTINUE:fallthrough
		 		case .CONVERT:fallthrough
		 		case .CORRUPT_XID:fallthrough
		 		case .CORRUPT_XID_ALL:fallthrough
		 		case .COST:fallthrough
		 		case .COUNT:fallthrough
		 		case .CROSS:fallthrough
		 		case .CUBE:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .CURSOR:fallthrough
		 		case .CUSTOMDATUM:fallthrough
		 		case .CYCLE:fallthrough
		 		case .DATA:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DAY:fallthrough
		 		case .DB_ROLE_CHANGE:fallthrough
		 		case .DBTIMEZONE:fallthrough
		 		case .DDL:fallthrough
		 		case .DEBUG:fallthrough
		 		case .DEC:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .DECOMPOSE:fallthrough
		 		case .DECREMENT:fallthrough
		 		case .DEFAULTS:fallthrough
		 		case .DEFERRED:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DETERMINISTIC:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISASSOCIATE:fallthrough
		 		case .DOCUMENT:fallthrough
		 		case .DOUBLE:fallthrough
		 		case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 		case .EACH:fallthrough
		 		case .ELEMENT:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCODING:fallthrough
		 		case .ENTITYESCAPING:fallthrough
		 		case .ERR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVALNAME:fallthrough
		 		case .EXCEPTION:fallthrough
		 		case .EXCEPTION_INIT:fallthrough
		 		case .EXCEPTIONS:fallthrough
		 		case .EXCLUDE:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .EXIT:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .EXTERNAL:fallthrough
		 		case .EXTRACT:fallthrough
		 		case .FAILURE:fallthrough
		 		case .FINAL:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .FLOAT:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FORALL:fallthrough
		 		case .FORCE:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GROUPING:fallthrough
		 		case .HASH:fallthrough
		 		case .HIDE:fallthrough
		 		case .HOUR:fallthrough
		 		case .IGNORE:fallthrough
		 		case .IMMEDIATE:fallthrough
		 		case .INCLUDE:fallthrough
		 		case .INCLUDING:fallthrough
		 		case .INCREMENT:fallthrough
		 		case .INDENT:fallthrough
		 		case .INDEXED:fallthrough
		 		case .INDICATOR:fallthrough
		 		case .INDICES:fallthrough
		 		case .INFINITE:fallthrough
		 		case .INLINE:fallthrough
		 		case .INNER:fallthrough
		 		case .INOUT:fallthrough
		 		case .INSTANTIABLE:fallthrough
		 		case .INSTEAD:fallthrough
		 		case .INT:fallthrough
		 		case .INTEGER:fallthrough
		 		case .INTERVAL:fallthrough
		 		case .INVALIDATE:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ITERATE:fallthrough
		 		case .JAVA:fallthrough
		 		case .JOIN:fallthrough
		 		case .KEEP:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEADING:fallthrough
		 		case .LEFT:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIBRARY:fallthrough
		 		case .LIKE2:fallthrough
		 		case .LIKE4:fallthrough
		 		case .LIKEC:fallthrough
		 		case .LIMIT:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCKED:fallthrough
		 		case .LOG:fallthrough
		 		case .LOGOFF:fallthrough
		 		case .LOGON:fallthrough
		 		case .LONG:fallthrough
		 		case .LOOP:fallthrough
		 		case .MAIN:fallthrough
		 		case .MAP:fallthrough
		 		case .MATCHED:fallthrough
		 		case .MAXVALUE:fallthrough
		 		case .MEASURES:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MINUTE:fallthrough
		 		case .MINVALUE:fallthrough
		 		case .MLSLABEL:fallthrough
		 		case .MODEL:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MONTH:fallthrough
		 		case .MULTISET:fallthrough
		 		case .NAME:fallthrough
		 		case .NAN:fallthrough
		 		case .NATURAL:fallthrough
		 		case .NATURALN:fallthrough
		 		case .NAV:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NCHAR_CS:fallthrough
		 		case .NCLOB:fallthrough
		 		case .NESTED:fallthrough
		 		case .NEW:fallthrough
		 		case .NO:fallthrough
		 		case .NOAUDIT:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOCYCLE:fallthrough
		 		case .NOENTITYESCAPING:fallthrough
		 		case .NONE:fallthrough
		 		case .NOSCHEMACHECK:fallthrough
		 		case .NULLS:fallthrough
		 		case .NUMBER:fallthrough
		 		case .NUMERIC:fallthrough
		 		case .NVARCHAR2:fallthrough
		 		case .OBJECT:fallthrough
		 		case .OFF:fallthrough
		 		case .OID:fallthrough
		 		case .OLD:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .ORADATA:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .OSERROR:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTER:fallthrough
		 		case .OVER:fallthrough
		 		case .OVERRIDING:fallthrough
		 		case .PACKAGE:fallthrough
		 		case .PARALLEL_ENABLE:fallthrough
		 		case .PARAMETERS:fallthrough
		 		case .PARENT:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PASSING:fallthrough
		 		case .PATH:fallthrough
		 		case .PIPELINED:fallthrough
		 		case .PLAN:fallthrough
		 		case .PLS_INTEGER:fallthrough
		 		case .POSITIVE:fallthrough
		 		case .POSITIVEN:fallthrough
		 		case .PRAGMA:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRECISION:fallthrough
		 		case .PRESENT:fallthrough
		 		case .RAISE:fallthrough
		 		case .RANGE:fallthrough
		 		case .RAW:fallthrough
		 		case .READ:fallthrough
		 		case .REAL:fallthrough
		 		case .RECORD:fallthrough
		 		case .REF:fallthrough
		 		case .REFERENCE:fallthrough
		 		case .REFERENCING:fallthrough
		 		case .REJECT:fallthrough
		 		case .RELIES_ON:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESPECT:fallthrough
		 		case .RESTRICT_REFERENCES:fallthrough
		 		case .RESULT:fallthrough
		 		case .RESULT_CACHE:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNING:fallthrough
		 		case .REUSE:fallthrough
		 		case .REVERSE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWID:fallthrough
		 		case .ROWS:fallthrough
		 		case .RULES:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SAVE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SCHEMACHECK:fallthrough
		 		case .SCN:fallthrough
		 		case .SECOND:fallthrough
		 		case .SEED:fallthrough
		 		case .SEGMENT:fallthrough
		 		case .SELF:fallthrough
		 		case .SEQUENTIAL:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SERIALLY_REUSABLE:fallthrough
		 		case .SERVERERROR:fallthrough
		 		case .SESSIONTIMEZONE:fallthrough
		 		case .SET:fallthrough
		 		case .SETS:fallthrough
		 		case .SETTINGS:fallthrough
		 		case .SHOW:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SIBLINGS:fallthrough
		 		case .SIGNTYPE:fallthrough
		 		case .SIMPLE_INTEGER:fallthrough
		 		case .SINGLE:fallthrough
		 		case .SKIP_:fallthrough
		 		case .SMALLINT:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOME:fallthrough
		 		case .SPECIFICATION:fallthrough
		 		case .SQLDATA:fallthrough
		 		case .SQLERROR:fallthrough
		 		case .STANDALONE:fallthrough
		 		case .STARTUP:fallthrough
		 		case .STATEMENT:fallthrough
		 		case .STATEMENT_ID:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATISTICS:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBMULTISET:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBSTITUTABLE:fallthrough
		 		case .SUBTYPE:fallthrough
		 		case .SUCCESS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 		case .TIMEZONE_ABBR:fallthrough
		 		case .TIMEZONE_HOUR:fallthrough
		 		case .TIMEZONE_MINUTE:fallthrough
		 		case .TIMEZONE_REGION:fallthrough
		 		case .TRAILING:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSLATE:fallthrough
		 		case .TREAT:fallthrough
		 		case .TRIGGER:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .TYPE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDER:fallthrough
		 		case .UNLIMITED:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPDATED:fallthrough
		 		case .UPSERT:fallthrough
		 		case .UROWID:fallthrough
		 		case .USE:fallthrough
		 		case .VALIDATE:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARCHAR:fallthrough
		 		case .VARCHAR2:fallthrough
		 		case .VARIABLE:fallthrough
		 		case .VARRAY:fallthrough
		 		case .VARYING:fallthrough
		 		case .VERSION:fallthrough
		 		case .VERSIONS:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNING:fallthrough
		 		case .WELLFORMED:fallthrough
		 		case .WHENEVER:fallthrough
		 		case .WHILE:fallthrough
		 		case .WITHIN:fallthrough
		 		case .WORK:fallthrough
		 		case .WRITE:fallthrough
		 		case .XML:fallthrough
		 		case .XMLAGG:fallthrough
		 		case .XMLATTRIBUTES:fallthrough
		 		case .XMLCAST:fallthrough
		 		case .XMLCOLATTVAL:fallthrough
		 		case .XMLELEMENT:fallthrough
		 		case .XMLEXISTS:fallthrough
		 		case .XMLFOREST:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .XMLPARSE:fallthrough
		 		case .XMLPI:fallthrough
		 		case .XMLQUERY:fallthrough
		 		case .XMLROOT:fallthrough
		 		case .XMLSERIALIZE:fallthrough
		 		case .XMLTABLE:fallthrough
		 		case .YEAR:fallthrough
		 		case .YES:fallthrough
		 		case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 		case .ZONE:fallthrough
		 		case .PREDICTION:fallthrough
		 		case .PREDICTION_BOUNDS:fallthrough
		 		case .PREDICTION_COST:fallthrough
		 		case .PREDICTION_DETAILS:fallthrough
		 		case .PREDICTION_PROBABILITY:fallthrough
		 		case .PREDICTION_SET:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .LISTAGG:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .PERCENTILE_CONT:fallthrough
		 		case .PERCENTILE_DISC:fallthrough
		 		case .RANK:fallthrough
		 		case .AVG:fallthrough
		 		case .CORR:fallthrough
		 		case .COVAR_:fallthrough
		 		case .LAG:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MEDIAN:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .RATIO_TO_REPORT:fallthrough
		 		case .REGR_:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .TRIM:fallthrough
		 		case .SUM:fallthrough
		 		case .STDDEV:fallthrough
		 		case .VAR_:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .DELIMITED_ID:fallthrough
		 		case .INTRODUCER:fallthrough
		 		case .REGULAR_ID:
		 			setState(2186)
		 			try identifier()

		 			break

		 		case .DEFAULT:
		 			setState(2187)
		 			try match(plsqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(2192) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2190)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(2191)
		 			try identifier()


		 			setState(2194); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }())
		 		setState(2196)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2200)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Record_type_defContext:ParserRuleContext {
		open func RECORD() -> TerminalNode? { return getToken(plsqlParser.Tokens.RECORD.rawValue, 0) }
		open func field_spec() -> Array<Field_specContext> {
			return getRuleContexts(Field_specContext.self)
		}
		open func field_spec(_ i: Int) -> Field_specContext? {
			return getRuleContext(Field_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_record_type_def }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRecord_type_def(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRecord_type_def(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRecord_type_def(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRecord_type_def(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func record_type_def() throws -> Record_type_defContext {
		var _localctx: Record_type_defContext = Record_type_defContext(_ctx, getState())
		try enterRule(_localctx, 206, plsqlParser.RULE_record_type_def)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2202)
		 	try match(plsqlParser.Tokens.RECORD.rawValue)
		 	setState(2203)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(2204)
		 	try field_spec()
		 	setState(2209)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2205)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(2206)
		 		try field_spec()


		 		setState(2211)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2212)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Field_specContext:ParserRuleContext {
		open func column_name() -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,0)
		}
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULL.rawValue, 0) }
		open func default_value_part() -> Default_value_partContext? {
			return getRuleContext(Default_value_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_field_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterField_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitField_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitField_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitField_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func field_spec() throws -> Field_specContext {
		var _localctx: Field_specContext = Field_specContext(_ctx, getState())
		try enterRule(_localctx, 208, plsqlParser.RULE_field_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2214)
		 	try column_name()
		 	setState(2216)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DATE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2215)
		 		try type_spec()

		 	}

		 	setState(2220)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.NOT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2218)
		 		try match(plsqlParser.Tokens.NOT.rawValue)
		 		setState(2219)
		 		try match(plsqlParser.Tokens.NULL.rawValue)

		 	}

		 	setState(2223)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.DEFAULT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.ASSIGN_OP.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2222)
		 		try default_value_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Ref_cursor_type_defContext:ParserRuleContext {
		open func REF() -> TerminalNode? { return getToken(plsqlParser.Tokens.REF.rawValue, 0) }
		open func CURSOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CURSOR.rawValue, 0) }
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_ref_cursor_type_def }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRef_cursor_type_def(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRef_cursor_type_def(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRef_cursor_type_def(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRef_cursor_type_def(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func ref_cursor_type_def() throws -> Ref_cursor_type_defContext {
		var _localctx: Ref_cursor_type_defContext = Ref_cursor_type_defContext(_ctx, getState())
		try enterRule(_localctx, 210, plsqlParser.RULE_ref_cursor_type_def)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2225)
		 	try match(plsqlParser.Tokens.REF.rawValue)
		 	setState(2226)
		 	try match(plsqlParser.Tokens.CURSOR.rawValue)
		 	setState(2229)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RETURN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2227)
		 		try match(plsqlParser.Tokens.RETURN.rawValue)
		 		setState(2228)
		 		try type_spec()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_declarationContext:ParserRuleContext {
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TYPE.rawValue, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func IS() -> TerminalNode? { return getToken(plsqlParser.Tokens.IS.rawValue, 0) }
		open func table_type_def() -> Table_type_defContext? {
			return getRuleContext(Table_type_defContext.self,0)
		}
		open func varray_type_def() -> Varray_type_defContext? {
			return getRuleContext(Varray_type_defContext.self,0)
		}
		open func record_type_def() -> Record_type_defContext? {
			return getRuleContext(Record_type_defContext.self,0)
		}
		open func ref_cursor_type_def() -> Ref_cursor_type_defContext? {
			return getRuleContext(Ref_cursor_type_defContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_declaration() throws -> Type_declarationContext {
		var _localctx: Type_declarationContext = Type_declarationContext(_ctx, getState())
		try enterRule(_localctx, 212, plsqlParser.RULE_type_declaration)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2231)
		 	try match(plsqlParser.Tokens.TYPE.rawValue)
		 	setState(2232)
		 	try identifier()
		 	setState(2233)
		 	try match(plsqlParser.Tokens.IS.rawValue)
		 	setState(2238)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .TABLE:
		 		setState(2234)
		 		try table_type_def()

		 		break
		 	case .VARRAY:fallthrough
		 	case .VARYING:
		 		setState(2235)
		 		try varray_type_def()

		 		break

		 	case .RECORD:
		 		setState(2236)
		 		try record_type_def()

		 		break

		 	case .REF:
		 		setState(2237)
		 		try ref_cursor_type_def()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2240)
		 	try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_type_defContext:ParserRuleContext {
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TABLE.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OF.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func table_indexed_by_part() -> Table_indexed_by_partContext? {
			return getRuleContext(Table_indexed_by_partContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_type_def }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_type_def(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_type_def(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_type_def(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_type_def(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_type_def() throws -> Table_type_defContext {
		var _localctx: Table_type_defContext = Table_type_defContext(_ctx, getState())
		try enterRule(_localctx, 214, plsqlParser.RULE_table_type_def)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2242)
		 	try match(plsqlParser.Tokens.TABLE.rawValue)
		 	setState(2243)
		 	try match(plsqlParser.Tokens.OF.rawValue)
		 	setState(2244)
		 	try type_spec()
		 	setState(2246)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.INDEX.rawValue || _la == plsqlParser.Tokens.INDEXED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2245)
		 		try table_indexed_by_part()

		 	}

		 	setState(2250)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.NOT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2248)
		 		try match(plsqlParser.Tokens.NOT.rawValue)
		 		setState(2249)
		 		try match(plsqlParser.Tokens.NULL.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_indexed_by_partContext:ParserRuleContext {
		public var idx1: Token!
		public var idx2: Token!
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func INDEXED() -> TerminalNode? { return getToken(plsqlParser.Tokens.INDEXED.rawValue, 0) }
		open func INDEX() -> TerminalNode? { return getToken(plsqlParser.Tokens.INDEX.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_indexed_by_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_indexed_by_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_indexed_by_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_indexed_by_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_indexed_by_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_indexed_by_part() throws -> Table_indexed_by_partContext {
		var _localctx: Table_indexed_by_partContext = Table_indexed_by_partContext(_ctx, getState())
		try enterRule(_localctx, 216, plsqlParser.RULE_table_indexed_by_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2254)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .INDEXED:
		 		setState(2252)
		 		try {
		 				let assignmentValue = try match(plsqlParser.Tokens.INDEXED.rawValue)
		 				_localctx.castdown(Table_indexed_by_partContext.self).idx1 = assignmentValue
		 		     }()


		 		break

		 	case .INDEX:
		 		setState(2253)
		 		try {
		 				let assignmentValue = try match(plsqlParser.Tokens.INDEX.rawValue)
		 				_localctx.castdown(Table_indexed_by_partContext.self).idx2 = assignmentValue
		 		     }()


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2256)
		 	try match(plsqlParser.Tokens.BY.rawValue)
		 	setState(2257)
		 	try type_spec()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Varray_type_defContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func OF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OF.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func VARRAY() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARRAY.rawValue, 0) }
		open func VARYING() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARYING.rawValue, 0) }
		open func ARRAY() -> TerminalNode? { return getToken(plsqlParser.Tokens.ARRAY.rawValue, 0) }
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_varray_type_def }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterVarray_type_def(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitVarray_type_def(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitVarray_type_def(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitVarray_type_def(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func varray_type_def() throws -> Varray_type_defContext {
		var _localctx: Varray_type_defContext = Varray_type_defContext(_ctx, getState())
		try enterRule(_localctx, 218, plsqlParser.RULE_varray_type_def)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2262)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .VARRAY:
		 		setState(2259)
		 		try match(plsqlParser.Tokens.VARRAY.rawValue)

		 		break

		 	case .VARYING:
		 		setState(2260)
		 		try match(plsqlParser.Tokens.VARYING.rawValue)
		 		setState(2261)
		 		try match(plsqlParser.Tokens.ARRAY.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2264)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(2265)
		 	try expression()
		 	setState(2266)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(2267)
		 	try match(plsqlParser.Tokens.OF.rawValue)
		 	setState(2268)
		 	try type_spec()
		 	setState(2271)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,213,_ctx)) {
		 	case 1:
		 		setState(2269)
		 		try match(plsqlParser.Tokens.NOT.rawValue)
		 		setState(2270)
		 		try match(plsqlParser.Tokens.NULL.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Seq_of_statementsContext:ParserRuleContext {
		open func statement() -> Array<StatementContext> {
			return getRuleContexts(StatementContext.self)
		}
		open func statement(_ i: Int) -> StatementContext? {
			return getRuleContext(StatementContext.self,i)
		}
		open func label_declaration() -> Array<Label_declarationContext> {
			return getRuleContexts(Label_declarationContext.self)
		}
		open func label_declaration(_ i: Int) -> Label_declarationContext? {
			return getRuleContext(Label_declarationContext.self,i)
		}
		open func EOF() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.EOF.rawValue) }
		open func EOF(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.EOF.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_seq_of_statements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSeq_of_statements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSeq_of_statements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSeq_of_statements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSeq_of_statements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func seq_of_statements() throws -> Seq_of_statementsContext {
		var _localctx: Seq_of_statementsContext = Seq_of_statementsContext(_ctx, getState())
		try enterRule(_localctx, 220, plsqlParser.RULE_seq_of_statements)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2277); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(2277)
		 			try _errHandler.sync(self)
		 			switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .A_LETTER:fallthrough
		 			case .ADD:fallthrough
		 			case .AFTER:fallthrough
		 			case .AGENT:fallthrough
		 			case .AGGREGATE:fallthrough
		 			case .ALTER:fallthrough
		 			case .ANALYZE:fallthrough
		 			case .ARRAY:fallthrough
		 			case .ASSOCIATE:fallthrough
		 			case .AT:fallthrough
		 			case .ATTRIBUTE:fallthrough
		 			case .AUDIT:fallthrough
		 			case .AUTHID:fallthrough
		 			case .AUTO:fallthrough
		 			case .AUTOMATIC:fallthrough
		 			case .AUTONOMOUS_TRANSACTION:fallthrough
		 			case .BATCH:fallthrough
		 			case .BEFORE:fallthrough
		 			case .BEGIN:fallthrough
		 			case .BFILE:fallthrough
		 			case .BINARY_DOUBLE:fallthrough
		 			case .BINARY_FLOAT:fallthrough
		 			case .BINARY_INTEGER:fallthrough
		 			case .BLOB:fallthrough
		 			case .BLOCK:fallthrough
		 			case .BODY:fallthrough
		 			case .BOOLEAN:fallthrough
		 			case .BOTH:fallthrough
		 			case .BULK:fallthrough
		 			case .BYTE:fallthrough
		 			case .C_LETTER:fallthrough
		 			case .CALL:fallthrough
		 			case .CANONICAL:fallthrough
		 			case .CASCADE:fallthrough
		 			case .CASE:fallthrough
		 			case .CAST:fallthrough
		 			case .CHAR:fallthrough
		 			case .CHAR_CS:fallthrough
		 			case .CHARACTER:fallthrough
		 			case .CHR:fallthrough
		 			case .CLOB:fallthrough
		 			case .CLOSE:fallthrough
		 			case .CLUSTER:fallthrough
		 			case .COLLECT:fallthrough
		 			case .COLUMNS:fallthrough
		 			case .COMMENT:fallthrough
		 			case .COMMIT:fallthrough
		 			case .COMMITTED:fallthrough
		 			case .COMPATIBILITY:fallthrough
		 			case .COMPILE:fallthrough
		 			case .COMPOUND:fallthrough
		 			case .CONSTANT:fallthrough
		 			case .CONSTRAINT:fallthrough
		 			case .CONSTRAINTS:fallthrough
		 			case .CONSTRUCTOR:fallthrough
		 			case .CONTENT:fallthrough
		 			case .CONTEXT:fallthrough
		 			case .CONTINUE:fallthrough
		 			case .CONVERT:fallthrough
		 			case .CORRUPT_XID:fallthrough
		 			case .CORRUPT_XID_ALL:fallthrough
		 			case .COST:fallthrough
		 			case .COUNT:fallthrough
		 			case .CREATE:fallthrough
		 			case .CROSS:fallthrough
		 			case .CUBE:fallthrough
		 			case .CURRENT_USER:fallthrough
		 			case .CURSOR:fallthrough
		 			case .CUSTOMDATUM:fallthrough
		 			case .CYCLE:fallthrough
		 			case .DATA:fallthrough
		 			case .DATABASE:fallthrough
		 			case .DAY:fallthrough
		 			case .DB_ROLE_CHANGE:fallthrough
		 			case .DBTIMEZONE:fallthrough
		 			case .DDL:fallthrough
		 			case .DEBUG:fallthrough
		 			case .DEC:fallthrough
		 			case .DECIMAL:fallthrough
		 			case .DECLARE:fallthrough
		 			case .DECOMPOSE:fallthrough
		 			case .DECREMENT:fallthrough
		 			case .DEFAULTS:fallthrough
		 			case .DEFERRED:fallthrough
		 			case .DEFINER:fallthrough
		 			case .DELETE:fallthrough
		 			case .DETERMINISTIC:fallthrough
		 			case .DIMENSION:fallthrough
		 			case .DISABLE:fallthrough
		 			case .DISASSOCIATE:fallthrough
		 			case .DOCUMENT:fallthrough
		 			case .DOUBLE:fallthrough
		 			case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 			case .EACH:fallthrough
		 			case .ELEMENT:fallthrough
		 			case .EMPTY:fallthrough
		 			case .ENABLE:fallthrough
		 			case .ENCODING:fallthrough
		 			case .ENTITYESCAPING:fallthrough
		 			case .ERR:fallthrough
		 			case .ERRORS:fallthrough
		 			case .ESCAPE:fallthrough
		 			case .EVALNAME:fallthrough
		 			case .EXCEPTION:fallthrough
		 			case .EXCEPTION_INIT:fallthrough
		 			case .EXCEPTIONS:fallthrough
		 			case .EXCLUDE:fallthrough
		 			case .EXECUTE:fallthrough
		 			case .EXIT:fallthrough
		 			case .EXPLAIN:fallthrough
		 			case .EXTERNAL:fallthrough
		 			case .EXTRACT:fallthrough
		 			case .FAILURE:fallthrough
		 			case .FETCH:fallthrough
		 			case .FINAL:fallthrough
		 			case .FIRST:fallthrough
		 			case .FIRST_VALUE:fallthrough
		 			case .FLOAT:fallthrough
		 			case .FOLLOWING:fallthrough
		 			case .FOLLOWS:fallthrough
		 			case .FOR:fallthrough
		 			case .FORALL:fallthrough
		 			case .FORCE:fallthrough
		 			case .FULL:fallthrough
		 			case .FUNCTION:fallthrough
		 			case .GOTO:fallthrough
		 			case .GRANT:fallthrough
		 			case .GROUPING:fallthrough
		 			case .HASH:fallthrough
		 			case .HIDE:fallthrough
		 			case .HOUR:fallthrough
		 			case .IF:fallthrough
		 			case .IGNORE:fallthrough
		 			case .IMMEDIATE:fallthrough
		 			case .INCLUDE:fallthrough
		 			case .INCLUDING:fallthrough
		 			case .INCREMENT:fallthrough
		 			case .INDENT:fallthrough
		 			case .INDEXED:fallthrough
		 			case .INDICATOR:fallthrough
		 			case .INDICES:fallthrough
		 			case .INFINITE:fallthrough
		 			case .INLINE:fallthrough
		 			case .INNER:fallthrough
		 			case .INOUT:fallthrough
		 			case .INSERT:fallthrough
		 			case .INSTANTIABLE:fallthrough
		 			case .INSTEAD:fallthrough
		 			case .INT:fallthrough
		 			case .INTEGER:fallthrough
		 			case .INTERVAL:fallthrough
		 			case .INVALIDATE:fallthrough
		 			case .ISOLATION:fallthrough
		 			case .ITERATE:fallthrough
		 			case .JAVA:fallthrough
		 			case .JOIN:fallthrough
		 			case .KEEP:fallthrough
		 			case .LANGUAGE:fallthrough
		 			case .LAST:fallthrough
		 			case .LAST_VALUE:fallthrough
		 			case .LEADING:fallthrough
		 			case .LEFT:fallthrough
		 			case .LEVEL:fallthrough
		 			case .LIBRARY:fallthrough
		 			case .LIKE2:fallthrough
		 			case .LIKE4:fallthrough
		 			case .LIKEC:fallthrough
		 			case .LIMIT:fallthrough
		 			case .LOCAL:fallthrough
		 			case .LOCK:fallthrough
		 			case .LOCKED:fallthrough
		 			case .LOG:fallthrough
		 			case .LOGOFF:fallthrough
		 			case .LOGON:fallthrough
		 			case .LONG:fallthrough
		 			case .LOOP:fallthrough
		 			case .MAIN:fallthrough
		 			case .MAP:fallthrough
		 			case .MATCHED:fallthrough
		 			case .MAXVALUE:fallthrough
		 			case .MEASURES:fallthrough
		 			case .MEMBER:fallthrough
		 			case .MERGE:fallthrough
		 			case .MINUTE:fallthrough
		 			case .MINVALUE:fallthrough
		 			case .MLSLABEL:fallthrough
		 			case .MODEL:fallthrough
		 			case .MODIFY:fallthrough
		 			case .MONTH:fallthrough
		 			case .MULTISET:fallthrough
		 			case .NAME:fallthrough
		 			case .NAN:fallthrough
		 			case .NATURAL:fallthrough
		 			case .NATURALN:fallthrough
		 			case .NAV:fallthrough
		 			case .NCHAR:fallthrough
		 			case .NCHAR_CS:fallthrough
		 			case .NCLOB:fallthrough
		 			case .NESTED:fallthrough
		 			case .NEW:fallthrough
		 			case .NO:fallthrough
		 			case .NOAUDIT:fallthrough
		 			case .NOCOPY:fallthrough
		 			case .NOCYCLE:fallthrough
		 			case .NOENTITYESCAPING:fallthrough
		 			case .NONE:fallthrough
		 			case .NOSCHEMACHECK:fallthrough
		 			case .NULL:fallthrough
		 			case .NULLS:fallthrough
		 			case .NUMBER:fallthrough
		 			case .NUMERIC:fallthrough
		 			case .NVARCHAR2:fallthrough
		 			case .OBJECT:fallthrough
		 			case .OFF:fallthrough
		 			case .OID:fallthrough
		 			case .OLD:fallthrough
		 			case .ONLY:fallthrough
		 			case .OPEN:fallthrough
		 			case .ORADATA:fallthrough
		 			case .ORDINALITY:fallthrough
		 			case .OSERROR:fallthrough
		 			case .OUT:fallthrough
		 			case .OUTER:fallthrough
		 			case .OVER:fallthrough
		 			case .OVERRIDING:fallthrough
		 			case .PACKAGE:fallthrough
		 			case .PARALLEL_ENABLE:fallthrough
		 			case .PARAMETERS:fallthrough
		 			case .PARENT:fallthrough
		 			case .PARTITION:fallthrough
		 			case .PASSING:fallthrough
		 			case .PATH:fallthrough
		 			case .PIPELINED:fallthrough
		 			case .PLAN:fallthrough
		 			case .PLS_INTEGER:fallthrough
		 			case .POSITIVE:fallthrough
		 			case .POSITIVEN:fallthrough
		 			case .PRAGMA:fallthrough
		 			case .PRECEDING:fallthrough
		 			case .PRECISION:fallthrough
		 			case .PRESENT:fallthrough
		 			case .PROCEDURE:fallthrough
		 			case .RAISE:fallthrough
		 			case .RANGE:fallthrough
		 			case .RAW:fallthrough
		 			case .READ:fallthrough
		 			case .REAL:fallthrough
		 			case .RECORD:fallthrough
		 			case .REF:fallthrough
		 			case .REFERENCE:fallthrough
		 			case .REFERENCING:fallthrough
		 			case .REJECT:fallthrough
		 			case .RELIES_ON:fallthrough
		 			case .RENAME:fallthrough
		 			case .REPLACE:fallthrough
		 			case .RESPECT:fallthrough
		 			case .RESTRICT_REFERENCES:fallthrough
		 			case .RESULT:fallthrough
		 			case .RESULT_CACHE:fallthrough
		 			case .RETURN:fallthrough
		 			case .RETURNING:fallthrough
		 			case .REUSE:fallthrough
		 			case .REVERSE:fallthrough
		 			case .RIGHT:fallthrough
		 			case .ROLLBACK:fallthrough
		 			case .ROLLUP:fallthrough
		 			case .ROW:fallthrough
		 			case .ROWID:fallthrough
		 			case .ROWS:fallthrough
		 			case .RULES:fallthrough
		 			case .SAMPLE:fallthrough
		 			case .SAVE:fallthrough
		 			case .SAVEPOINT:fallthrough
		 			case .SCHEMA:fallthrough
		 			case .SCHEMACHECK:fallthrough
		 			case .SCN:fallthrough
		 			case .SECOND:fallthrough
		 			case .SEED:fallthrough
		 			case .SEGMENT:fallthrough
		 			case .SELECT:fallthrough
		 			case .SELF:fallthrough
		 			case .SEQUENTIAL:fallthrough
		 			case .SERIALIZABLE:fallthrough
		 			case .SERIALLY_REUSABLE:fallthrough
		 			case .SERVERERROR:fallthrough
		 			case .SESSIONTIMEZONE:fallthrough
		 			case .SET:fallthrough
		 			case .SETS:fallthrough
		 			case .SETTINGS:fallthrough
		 			case .SHOW:fallthrough
		 			case .SHUTDOWN:fallthrough
		 			case .SIBLINGS:fallthrough
		 			case .SIGNTYPE:fallthrough
		 			case .SIMPLE_INTEGER:fallthrough
		 			case .SINGLE:fallthrough
		 			case .SKIP_:fallthrough
		 			case .SMALLINT:fallthrough
		 			case .SNAPSHOT:fallthrough
		 			case .SOME:fallthrough
		 			case .SPECIFICATION:fallthrough
		 			case .SQLDATA:fallthrough
		 			case .SQLERROR:fallthrough
		 			case .STANDALONE:fallthrough
		 			case .STARTUP:fallthrough
		 			case .STATEMENT:fallthrough
		 			case .STATEMENT_ID:fallthrough
		 			case .STATIC:fallthrough
		 			case .STATISTICS:fallthrough
		 			case .STRING:fallthrough
		 			case .SUBMULTISET:fallthrough
		 			case .SUBPARTITION:fallthrough
		 			case .SUBSTITUTABLE:fallthrough
		 			case .SUBTYPE:fallthrough
		 			case .SUCCESS:fallthrough
		 			case .SUSPEND:fallthrough
		 			case .TIME:fallthrough
		 			case .TIMESTAMP:fallthrough
		 			case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 			case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 			case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 			case .TIMEZONE_ABBR:fallthrough
		 			case .TIMEZONE_HOUR:fallthrough
		 			case .TIMEZONE_MINUTE:fallthrough
		 			case .TIMEZONE_REGION:fallthrough
		 			case .TRAILING:fallthrough
		 			case .TRANSACTION:fallthrough
		 			case .TRANSLATE:fallthrough
		 			case .TREAT:fallthrough
		 			case .TRIGGER:fallthrough
		 			case .TRUNCATE:fallthrough
		 			case .TYPE:fallthrough
		 			case .UNBOUNDED:fallthrough
		 			case .UNDER:fallthrough
		 			case .UNLIMITED:fallthrough
		 			case .UNTIL:fallthrough
		 			case .UPDATE:fallthrough
		 			case .UPDATED:fallthrough
		 			case .UPSERT:fallthrough
		 			case .UROWID:fallthrough
		 			case .USE:fallthrough
		 			case .VALIDATE:fallthrough
		 			case .VALUE:fallthrough
		 			case .VARCHAR:fallthrough
		 			case .VARCHAR2:fallthrough
		 			case .VARIABLE:fallthrough
		 			case .VARRAY:fallthrough
		 			case .VARYING:fallthrough
		 			case .VERSION:fallthrough
		 			case .VERSIONS:fallthrough
		 			case .WAIT:fallthrough
		 			case .WARNING:fallthrough
		 			case .WELLFORMED:fallthrough
		 			case .WHENEVER:fallthrough
		 			case .WHILE:fallthrough
		 			case .WITH:fallthrough
		 			case .WITHIN:fallthrough
		 			case .WORK:fallthrough
		 			case .WRITE:fallthrough
		 			case .XML:fallthrough
		 			case .XMLAGG:fallthrough
		 			case .XMLATTRIBUTES:fallthrough
		 			case .XMLCAST:fallthrough
		 			case .XMLCOLATTVAL:fallthrough
		 			case .XMLELEMENT:fallthrough
		 			case .XMLEXISTS:fallthrough
		 			case .XMLFOREST:fallthrough
		 			case .XMLNAMESPACES:fallthrough
		 			case .XMLPARSE:fallthrough
		 			case .XMLPI:fallthrough
		 			case .XMLQUERY:fallthrough
		 			case .XMLROOT:fallthrough
		 			case .XMLSERIALIZE:fallthrough
		 			case .XMLTABLE:fallthrough
		 			case .YEAR:fallthrough
		 			case .YES:fallthrough
		 			case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 			case .ZONE:fallthrough
		 			case .PREDICTION:fallthrough
		 			case .PREDICTION_BOUNDS:fallthrough
		 			case .PREDICTION_COST:fallthrough
		 			case .PREDICTION_DETAILS:fallthrough
		 			case .PREDICTION_PROBABILITY:fallthrough
		 			case .PREDICTION_SET:fallthrough
		 			case .CUME_DIST:fallthrough
		 			case .DENSE_RANK:fallthrough
		 			case .LISTAGG:fallthrough
		 			case .PERCENT_RANK:fallthrough
		 			case .PERCENTILE_CONT:fallthrough
		 			case .PERCENTILE_DISC:fallthrough
		 			case .RANK:fallthrough
		 			case .AVG:fallthrough
		 			case .CORR:fallthrough
		 			case .COVAR_:fallthrough
		 			case .LAG:fallthrough
		 			case .LEAD:fallthrough
		 			case .MAX:fallthrough
		 			case .MEDIAN:fallthrough
		 			case .MIN:fallthrough
		 			case .NTILE:fallthrough
		 			case .RATIO_TO_REPORT:fallthrough
		 			case .REGR_:fallthrough
		 			case .ROW_NUMBER:fallthrough
		 			case .TRIM:fallthrough
		 			case .SUM:fallthrough
		 			case .STDDEV:fallthrough
		 			case .VAR_:fallthrough
		 			case .VARIANCE:fallthrough
		 			case .DELIMITED_ID:fallthrough
		 			case .LEFT_PAREN:fallthrough
		 			case .BINDVAR:fallthrough
		 			case .COLON:fallthrough
		 			case .INTRODUCER:fallthrough
		 			case .REGULAR_ID:
		 				setState(2273)
		 				try statement()
		 				setState(2274)
		 				_la = try _input.LA(1)
		 				if (!(//closure
		 				 { () -> Bool in
		 				      var testSet: Bool = _la == plsqlParser.Tokens.EOF.rawValue
		 				          testSet = testSet || _la == plsqlParser.Tokens.SEMICOLON.rawValue
		 				      return testSet
		 				 }())) {
		 				try _errHandler.recoverInline(self)
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 				break

		 			case .LESS_THAN_OP:
		 				setState(2276)
		 				try label_declaration()

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(2279); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,215,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Label_declarationContext:ParserRuleContext {
		public var ltp1: Token!
		open func label_name() -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_label_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLabel_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLabel_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLabel_declaration(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLabel_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func label_declaration() throws -> Label_declarationContext {
		var _localctx: Label_declarationContext = Label_declarationContext(_ctx, getState())
		try enterRule(_localctx, 222, plsqlParser.RULE_label_declaration)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2281)
		 	try {
		 			let assignmentValue = try match(plsqlParser.Tokens.LESS_THAN_OP.rawValue)
		 			_localctx.castdown(Label_declarationContext.self).ltp1 = assignmentValue
		 	     }()

		 	setState(2282)
		 	try match(plsqlParser.Tokens.LESS_THAN_OP.rawValue)
		 	setState(2283)
		 	try label_name()
		 	setState(2284)
		 	try match(plsqlParser.Tokens.GREATER_THAN_OP.rawValue)
		 	setState(2285)
		 	try match(plsqlParser.Tokens.GREATER_THAN_OP.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class StatementContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CREATE.rawValue, 0) }
		open func swallow_to_semi() -> Swallow_to_semiContext? {
			return getRuleContext(Swallow_to_semiContext.self,0)
		}
		open func ALTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALTER.rawValue, 0) }
		open func GRANT() -> TerminalNode? { return getToken(plsqlParser.Tokens.GRANT.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open func TRUNCATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRUNCATE.rawValue, 0) }
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func block() -> BlockContext? {
			return getRuleContext(BlockContext.self,0)
		}
		open func assignment_statement() -> Assignment_statementContext? {
			return getRuleContext(Assignment_statementContext.self,0)
		}
		open func continue_statement() -> Continue_statementContext? {
			return getRuleContext(Continue_statementContext.self,0)
		}
		open func exit_statement() -> Exit_statementContext? {
			return getRuleContext(Exit_statementContext.self,0)
		}
		open func goto_statement() -> Goto_statementContext? {
			return getRuleContext(Goto_statementContext.self,0)
		}
		open func if_statement() -> If_statementContext? {
			return getRuleContext(If_statementContext.self,0)
		}
		open func loop_statement() -> Loop_statementContext? {
			return getRuleContext(Loop_statementContext.self,0)
		}
		open func forall_statement() -> Forall_statementContext? {
			return getRuleContext(Forall_statementContext.self,0)
		}
		open func null_statement() -> Null_statementContext? {
			return getRuleContext(Null_statementContext.self,0)
		}
		open func raise_statement() -> Raise_statementContext? {
			return getRuleContext(Raise_statementContext.self,0)
		}
		open func return_statement() -> Return_statementContext? {
			return getRuleContext(Return_statementContext.self,0)
		}
		open func case_statement() -> Case_statementContext? {
			return getRuleContext(Case_statementContext.self,0)
		}
		open func sql_statement() -> Sql_statementContext? {
			return getRuleContext(Sql_statementContext.self,0)
		}
		open func function_call() -> Function_callContext? {
			return getRuleContext(Function_callContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStatement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStatement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStatement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStatement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func statement() throws -> StatementContext {
		var _localctx: StatementContext = StatementContext(_ctx, getState())
		try enterRule(_localctx, 224, plsqlParser.RULE_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2313)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,217, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2287)
		 		try match(plsqlParser.Tokens.CREATE.rawValue)
		 		setState(2288)
		 		try swallow_to_semi()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2289)
		 		try match(plsqlParser.Tokens.ALTER.rawValue)
		 		setState(2290)
		 		try swallow_to_semi()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2291)
		 		try match(plsqlParser.Tokens.GRANT.rawValue)
		 		setState(2293)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,216,_ctx)) {
		 		case 1:
		 			setState(2292)
		 			try match(plsqlParser.Tokens.ALL.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2295)
		 		try swallow_to_semi()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2296)
		 		try match(plsqlParser.Tokens.TRUNCATE.rawValue)
		 		setState(2297)
		 		try swallow_to_semi()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2298)
		 		try body()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2299)
		 		try block()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2300)
		 		try assignment_statement()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(2301)
		 		try continue_statement()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(2302)
		 		try exit_statement()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(2303)
		 		try goto_statement()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(2304)
		 		try if_statement()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(2305)
		 		try loop_statement()

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(2306)
		 		try forall_statement()

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(2307)
		 		try null_statement()

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(2308)
		 		try raise_statement()

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(2309)
		 		try return_statement()

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(2310)
		 		try case_statement()

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(2311)
		 		try sql_statement()

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(2312)
		 		try function_call()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Assignment_statementContext:ParserRuleContext {
		open func ASSIGN_OP() -> TerminalNode? { return getToken(plsqlParser.Tokens.ASSIGN_OP.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func general_element() -> General_elementContext? {
			return getRuleContext(General_elementContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_assignment_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAssignment_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAssignment_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAssignment_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAssignment_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func assignment_statement() throws -> Assignment_statementContext {
		var _localctx: Assignment_statementContext = Assignment_statementContext(_ctx, getState())
		try enterRule(_localctx, 226, plsqlParser.RULE_assignment_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2317)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(2315)
		 		try general_element()

		 		break
		 	case .BINDVAR:fallthrough
		 	case .COLON:
		 		setState(2316)
		 		try bind_variable()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2319)
		 	try match(plsqlParser.Tokens.ASSIGN_OP.rawValue)
		 	setState(2320)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Continue_statementContext:ParserRuleContext {
		open func CONTINUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONTINUE.rawValue, 0) }
		open func label_name() -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,0)
		}
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHEN.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_continue_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterContinue_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitContinue_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitContinue_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitContinue_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func continue_statement() throws -> Continue_statementContext {
		var _localctx: Continue_statementContext = Continue_statementContext(_ctx, getState())
		try enterRule(_localctx, 228, plsqlParser.RULE_continue_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2322)
		 	try match(plsqlParser.Tokens.CONTINUE.rawValue)
		 	setState(2324)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2323)
		 		try label_name()

		 	}

		 	setState(2328)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WHEN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2326)
		 		try match(plsqlParser.Tokens.WHEN.rawValue)
		 		setState(2327)
		 		try condition()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Exit_statementContext:ParserRuleContext {
		open func EXIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXIT.rawValue, 0) }
		open func label_name() -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,0)
		}
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHEN.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_exit_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExit_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExit_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExit_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExit_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exit_statement() throws -> Exit_statementContext {
		var _localctx: Exit_statementContext = Exit_statementContext(_ctx, getState())
		try enterRule(_localctx, 230, plsqlParser.RULE_exit_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2330)
		 	try match(plsqlParser.Tokens.EXIT.rawValue)
		 	setState(2332)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2331)
		 		try label_name()

		 	}

		 	setState(2336)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WHEN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2334)
		 		try match(plsqlParser.Tokens.WHEN.rawValue)
		 		setState(2335)
		 		try condition()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Goto_statementContext:ParserRuleContext {
		open func GOTO() -> TerminalNode? { return getToken(plsqlParser.Tokens.GOTO.rawValue, 0) }
		open func label_name() -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_goto_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGoto_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGoto_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGoto_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGoto_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func goto_statement() throws -> Goto_statementContext {
		var _localctx: Goto_statementContext = Goto_statementContext(_ctx, getState())
		try enterRule(_localctx, 232, plsqlParser.RULE_goto_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2338)
		 	try match(plsqlParser.Tokens.GOTO.rawValue)
		 	setState(2339)
		 	try label_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class If_statementContext:ParserRuleContext {
		open func IF() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.IF.rawValue) }
		open func IF(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.IF.rawValue, i)
		}
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.THEN.rawValue, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.Tokens.END.rawValue, 0) }
		open func elsif_part() -> Array<Elsif_partContext> {
			return getRuleContexts(Elsif_partContext.self)
		}
		open func elsif_part(_ i: Int) -> Elsif_partContext? {
			return getRuleContext(Elsif_partContext.self,i)
		}
		open func else_part() -> Else_partContext? {
			return getRuleContext(Else_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_if_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterIf_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitIf_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitIf_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitIf_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func if_statement() throws -> If_statementContext {
		var _localctx: If_statementContext = If_statementContext(_ctx, getState())
		try enterRule(_localctx, 234, plsqlParser.RULE_if_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2341)
		 	try match(plsqlParser.Tokens.IF.rawValue)
		 	setState(2342)
		 	try condition()
		 	setState(2343)
		 	try match(plsqlParser.Tokens.THEN.rawValue)
		 	setState(2344)
		 	try seq_of_statements()
		 	setState(2348)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.ELSIF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2345)
		 		try elsif_part()


		 		setState(2350)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2352)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.ELSE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2351)
		 		try else_part()

		 	}

		 	setState(2354)
		 	try match(plsqlParser.Tokens.END.rawValue)
		 	setState(2355)
		 	try match(plsqlParser.Tokens.IF.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Elsif_partContext:ParserRuleContext {
		open func ELSIF() -> TerminalNode? { return getToken(plsqlParser.Tokens.ELSIF.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.THEN.rawValue, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_elsif_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterElsif_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitElsif_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitElsif_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitElsif_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func elsif_part() throws -> Elsif_partContext {
		var _localctx: Elsif_partContext = Elsif_partContext(_ctx, getState())
		try enterRule(_localctx, 236, plsqlParser.RULE_elsif_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2357)
		 	try match(plsqlParser.Tokens.ELSIF.rawValue)
		 	setState(2358)
		 	try condition()
		 	setState(2359)
		 	try match(plsqlParser.Tokens.THEN.rawValue)
		 	setState(2360)
		 	try seq_of_statements()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Else_partContext:ParserRuleContext {
		open func ELSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ELSE.rawValue, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_else_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterElse_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitElse_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitElse_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitElse_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func else_part() throws -> Else_partContext {
		var _localctx: Else_partContext = Else_partContext(_ctx, getState())
		try enterRule(_localctx, 238, plsqlParser.RULE_else_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2362)
		 	try match(plsqlParser.Tokens.ELSE.rawValue)
		 	setState(2363)
		 	try seq_of_statements()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Loop_statementContext:ParserRuleContext {
		open func LOOP() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.LOOP.rawValue) }
		open func LOOP(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.LOOP.rawValue, i)
		}
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.Tokens.END.rawValue, 0) }
		open func label_name() -> Array<Label_nameContext> {
			return getRuleContexts(Label_nameContext.self)
		}
		open func label_name(_ i: Int) -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,i)
		}
		open func WHILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHILE.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOR.rawValue, 0) }
		open func cursor_loop_param() -> Cursor_loop_paramContext? {
			return getRuleContext(Cursor_loop_paramContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_loop_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLoop_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLoop_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLoop_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLoop_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func loop_statement() throws -> Loop_statementContext {
		var _localctx: Loop_statementContext = Loop_statementContext(_ctx, getState())
		try enterRule(_localctx, 240, plsqlParser.RULE_loop_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2366)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,225,_ctx)) {
		 	case 1:
		 		setState(2365)
		 		try label_name()

		 		break
		 	default: break
		 	}
		 	setState(2372)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .WHILE:
		 	 	setState(2368)
		 	 	try match(plsqlParser.Tokens.WHILE.rawValue)
		 	 	setState(2369)
		 	 	try condition()

		 		break

		 	case .FOR:
		 	 	setState(2370)
		 	 	try match(plsqlParser.Tokens.FOR.rawValue)
		 	 	setState(2371)
		 	 	try cursor_loop_param()

		 		break

		 	case .LOOP:
		 		break
		 	default:
		 		break
		 	}
		 	setState(2374)
		 	try match(plsqlParser.Tokens.LOOP.rawValue)
		 	setState(2375)
		 	try seq_of_statements()
		 	setState(2376)
		 	try match(plsqlParser.Tokens.END.rawValue)
		 	setState(2377)
		 	try match(plsqlParser.Tokens.LOOP.rawValue)
		 	setState(2379)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2378)
		 		try label_name()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_loop_paramContext:ParserRuleContext {
		public var range: Token!
		open func index_name() -> Index_nameContext? {
			return getRuleContext(Index_nameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func lower_bound() -> Lower_boundContext? {
			return getRuleContext(Lower_boundContext.self,0)
		}
		open func upper_bound() -> Upper_boundContext? {
			return getRuleContext(Upper_boundContext.self,0)
		}
		open func REVERSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REVERSE.rawValue, 0) }
		open func record_name() -> Record_nameContext? {
			return getRuleContext(Record_nameContext.self,0)
		}
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cursor_loop_param }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCursor_loop_param(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCursor_loop_param(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCursor_loop_param(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCursor_loop_param(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_loop_param() throws -> Cursor_loop_paramContext {
		var _localctx: Cursor_loop_paramContext = Cursor_loop_paramContext(_ctx, getState())
		try enterRule(_localctx, 242, plsqlParser.RULE_cursor_loop_param)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2402)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,231, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2381)
		 		try index_name()
		 		setState(2382)
		 		try match(plsqlParser.Tokens.IN.rawValue)
		 		setState(2384)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,228,_ctx)) {
		 		case 1:
		 			setState(2383)
		 			try match(plsqlParser.Tokens.REVERSE.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2386)
		 		try lower_bound()
		 		setState(2387)
		 		try {
		 				let assignmentValue = try match(plsqlParser.Tokens.T__0.rawValue)
		 				_localctx.castdown(Cursor_loop_paramContext.self).range = assignmentValue
		 		     }()

		 		setState(2388)
		 		try upper_bound()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2390)
		 		try record_name()
		 		setState(2391)
		 		try match(plsqlParser.Tokens.IN.rawValue)
		 		setState(2400)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .A_LETTER:fallthrough
		 		case .ADD:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGENT:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .ARRAY:fallthrough
		 		case .ASSOCIATE:fallthrough
		 		case .AT:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .AUDIT:fallthrough
		 		case .AUTHID:fallthrough
		 		case .AUTO:fallthrough
		 		case .AUTOMATIC:fallthrough
		 		case .AUTONOMOUS_TRANSACTION:fallthrough
		 		case .BATCH:fallthrough
		 		case .BEFORE:fallthrough
		 		case .BFILE:fallthrough
		 		case .BINARY_DOUBLE:fallthrough
		 		case .BINARY_FLOAT:fallthrough
		 		case .BINARY_INTEGER:fallthrough
		 		case .BLOB:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BODY:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BOTH:fallthrough
		 		case .BULK:fallthrough
		 		case .BYTE:fallthrough
		 		case .C_LETTER:fallthrough
		 		case .CALL:fallthrough
		 		case .CANONICAL:fallthrough
		 		case .CASCADE:fallthrough
		 		case .CAST:fallthrough
		 		case .CHAR:fallthrough
		 		case .CHAR_CS:fallthrough
		 		case .CHARACTER:fallthrough
		 		case .CHR:fallthrough
		 		case .CLOB:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTER:fallthrough
		 		case .COLLECT:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .COMPATIBILITY:fallthrough
		 		case .COMPILE:fallthrough
		 		case .COMPOUND:fallthrough
		 		case .CONSTANT:fallthrough
		 		case .CONSTRAINT:fallthrough
		 		case .CONSTRAINTS:fallthrough
		 		case .CONSTRUCTOR:fallthrough
		 		case .CONTENT:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTINUE:fallthrough
		 		case .CONVERT:fallthrough
		 		case .CORRUPT_XID:fallthrough
		 		case .CORRUPT_XID_ALL:fallthrough
		 		case .COST:fallthrough
		 		case .COUNT:fallthrough
		 		case .CROSS:fallthrough
		 		case .CUBE:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .CURSOR:fallthrough
		 		case .CUSTOMDATUM:fallthrough
		 		case .CYCLE:fallthrough
		 		case .DATA:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DAY:fallthrough
		 		case .DB_ROLE_CHANGE:fallthrough
		 		case .DBTIMEZONE:fallthrough
		 		case .DDL:fallthrough
		 		case .DEBUG:fallthrough
		 		case .DEC:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .DECOMPOSE:fallthrough
		 		case .DECREMENT:fallthrough
		 		case .DEFAULTS:fallthrough
		 		case .DEFERRED:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DETERMINISTIC:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISASSOCIATE:fallthrough
		 		case .DOCUMENT:fallthrough
		 		case .DOUBLE:fallthrough
		 		case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 		case .EACH:fallthrough
		 		case .ELEMENT:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCODING:fallthrough
		 		case .ENTITYESCAPING:fallthrough
		 		case .ERR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVALNAME:fallthrough
		 		case .EXCEPTION:fallthrough
		 		case .EXCEPTION_INIT:fallthrough
		 		case .EXCEPTIONS:fallthrough
		 		case .EXCLUDE:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .EXIT:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .EXTERNAL:fallthrough
		 		case .EXTRACT:fallthrough
		 		case .FAILURE:fallthrough
		 		case .FINAL:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .FLOAT:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FORALL:fallthrough
		 		case .FORCE:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GROUPING:fallthrough
		 		case .HASH:fallthrough
		 		case .HIDE:fallthrough
		 		case .HOUR:fallthrough
		 		case .IGNORE:fallthrough
		 		case .IMMEDIATE:fallthrough
		 		case .INCLUDE:fallthrough
		 		case .INCLUDING:fallthrough
		 		case .INCREMENT:fallthrough
		 		case .INDENT:fallthrough
		 		case .INDEXED:fallthrough
		 		case .INDICATOR:fallthrough
		 		case .INDICES:fallthrough
		 		case .INFINITE:fallthrough
		 		case .INLINE:fallthrough
		 		case .INNER:fallthrough
		 		case .INOUT:fallthrough
		 		case .INSTANTIABLE:fallthrough
		 		case .INSTEAD:fallthrough
		 		case .INT:fallthrough
		 		case .INTEGER:fallthrough
		 		case .INTERVAL:fallthrough
		 		case .INVALIDATE:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ITERATE:fallthrough
		 		case .JAVA:fallthrough
		 		case .JOIN:fallthrough
		 		case .KEEP:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEADING:fallthrough
		 		case .LEFT:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIBRARY:fallthrough
		 		case .LIKE2:fallthrough
		 		case .LIKE4:fallthrough
		 		case .LIKEC:fallthrough
		 		case .LIMIT:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCKED:fallthrough
		 		case .LOG:fallthrough
		 		case .LOGOFF:fallthrough
		 		case .LOGON:fallthrough
		 		case .LONG:fallthrough
		 		case .LOOP:fallthrough
		 		case .MAIN:fallthrough
		 		case .MAP:fallthrough
		 		case .MATCHED:fallthrough
		 		case .MAXVALUE:fallthrough
		 		case .MEASURES:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MINUTE:fallthrough
		 		case .MINVALUE:fallthrough
		 		case .MLSLABEL:fallthrough
		 		case .MODEL:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MONTH:fallthrough
		 		case .MULTISET:fallthrough
		 		case .NAME:fallthrough
		 		case .NAN:fallthrough
		 		case .NATURAL:fallthrough
		 		case .NATURALN:fallthrough
		 		case .NAV:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NCHAR_CS:fallthrough
		 		case .NCLOB:fallthrough
		 		case .NESTED:fallthrough
		 		case .NEW:fallthrough
		 		case .NO:fallthrough
		 		case .NOAUDIT:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOCYCLE:fallthrough
		 		case .NOENTITYESCAPING:fallthrough
		 		case .NONE:fallthrough
		 		case .NOSCHEMACHECK:fallthrough
		 		case .NULLS:fallthrough
		 		case .NUMBER:fallthrough
		 		case .NUMERIC:fallthrough
		 		case .NVARCHAR2:fallthrough
		 		case .OBJECT:fallthrough
		 		case .OFF:fallthrough
		 		case .OID:fallthrough
		 		case .OLD:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .ORADATA:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .OSERROR:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTER:fallthrough
		 		case .OVER:fallthrough
		 		case .OVERRIDING:fallthrough
		 		case .PACKAGE:fallthrough
		 		case .PARALLEL_ENABLE:fallthrough
		 		case .PARAMETERS:fallthrough
		 		case .PARENT:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PASSING:fallthrough
		 		case .PATH:fallthrough
		 		case .PIPELINED:fallthrough
		 		case .PLAN:fallthrough
		 		case .PLS_INTEGER:fallthrough
		 		case .POSITIVE:fallthrough
		 		case .POSITIVEN:fallthrough
		 		case .PRAGMA:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRECISION:fallthrough
		 		case .PRESENT:fallthrough
		 		case .RAISE:fallthrough
		 		case .RANGE:fallthrough
		 		case .RAW:fallthrough
		 		case .READ:fallthrough
		 		case .REAL:fallthrough
		 		case .RECORD:fallthrough
		 		case .REF:fallthrough
		 		case .REFERENCE:fallthrough
		 		case .REFERENCING:fallthrough
		 		case .REJECT:fallthrough
		 		case .RELIES_ON:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESPECT:fallthrough
		 		case .RESTRICT_REFERENCES:fallthrough
		 		case .RESULT:fallthrough
		 		case .RESULT_CACHE:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNING:fallthrough
		 		case .REUSE:fallthrough
		 		case .REVERSE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWID:fallthrough
		 		case .ROWS:fallthrough
		 		case .RULES:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SAVE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SCHEMACHECK:fallthrough
		 		case .SCN:fallthrough
		 		case .SECOND:fallthrough
		 		case .SEED:fallthrough
		 		case .SEGMENT:fallthrough
		 		case .SELF:fallthrough
		 		case .SEQUENTIAL:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SERIALLY_REUSABLE:fallthrough
		 		case .SERVERERROR:fallthrough
		 		case .SESSIONTIMEZONE:fallthrough
		 		case .SET:fallthrough
		 		case .SETS:fallthrough
		 		case .SETTINGS:fallthrough
		 		case .SHOW:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SIBLINGS:fallthrough
		 		case .SIGNTYPE:fallthrough
		 		case .SIMPLE_INTEGER:fallthrough
		 		case .SINGLE:fallthrough
		 		case .SKIP_:fallthrough
		 		case .SMALLINT:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOME:fallthrough
		 		case .SPECIFICATION:fallthrough
		 		case .SQLDATA:fallthrough
		 		case .SQLERROR:fallthrough
		 		case .STANDALONE:fallthrough
		 		case .STARTUP:fallthrough
		 		case .STATEMENT:fallthrough
		 		case .STATEMENT_ID:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATISTICS:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBMULTISET:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBSTITUTABLE:fallthrough
		 		case .SUBTYPE:fallthrough
		 		case .SUCCESS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 		case .TIMEZONE_ABBR:fallthrough
		 		case .TIMEZONE_HOUR:fallthrough
		 		case .TIMEZONE_MINUTE:fallthrough
		 		case .TIMEZONE_REGION:fallthrough
		 		case .TRAILING:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSLATE:fallthrough
		 		case .TREAT:fallthrough
		 		case .TRIGGER:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .TYPE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDER:fallthrough
		 		case .UNLIMITED:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPDATED:fallthrough
		 		case .UPSERT:fallthrough
		 		case .UROWID:fallthrough
		 		case .USE:fallthrough
		 		case .VALIDATE:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARCHAR:fallthrough
		 		case .VARCHAR2:fallthrough
		 		case .VARIABLE:fallthrough
		 		case .VARRAY:fallthrough
		 		case .VARYING:fallthrough
		 		case .VERSION:fallthrough
		 		case .VERSIONS:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNING:fallthrough
		 		case .WELLFORMED:fallthrough
		 		case .WHENEVER:fallthrough
		 		case .WHILE:fallthrough
		 		case .WITHIN:fallthrough
		 		case .WORK:fallthrough
		 		case .WRITE:fallthrough
		 		case .XML:fallthrough
		 		case .XMLAGG:fallthrough
		 		case .XMLATTRIBUTES:fallthrough
		 		case .XMLCAST:fallthrough
		 		case .XMLCOLATTVAL:fallthrough
		 		case .XMLELEMENT:fallthrough
		 		case .XMLEXISTS:fallthrough
		 		case .XMLFOREST:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .XMLPARSE:fallthrough
		 		case .XMLPI:fallthrough
		 		case .XMLQUERY:fallthrough
		 		case .XMLROOT:fallthrough
		 		case .XMLSERIALIZE:fallthrough
		 		case .XMLTABLE:fallthrough
		 		case .YEAR:fallthrough
		 		case .YES:fallthrough
		 		case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 		case .ZONE:fallthrough
		 		case .PREDICTION:fallthrough
		 		case .PREDICTION_BOUNDS:fallthrough
		 		case .PREDICTION_COST:fallthrough
		 		case .PREDICTION_DETAILS:fallthrough
		 		case .PREDICTION_PROBABILITY:fallthrough
		 		case .PREDICTION_SET:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .LISTAGG:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .PERCENTILE_CONT:fallthrough
		 		case .PERCENTILE_DISC:fallthrough
		 		case .RANK:fallthrough
		 		case .AVG:fallthrough
		 		case .CORR:fallthrough
		 		case .COVAR_:fallthrough
		 		case .LAG:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MEDIAN:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .RATIO_TO_REPORT:fallthrough
		 		case .REGR_:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .TRIM:fallthrough
		 		case .SUM:fallthrough
		 		case .STDDEV:fallthrough
		 		case .VAR_:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .DELIMITED_ID:fallthrough
		 		case .BINDVAR:fallthrough
		 		case .COLON:fallthrough
		 		case .INTRODUCER:fallthrough
		 		case .REGULAR_ID:
		 			setState(2392)
		 			try cursor_name()
		 			setState(2394)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(2393)
		 				try expression_list()

		 			}


		 			break

		 		case .LEFT_PAREN:
		 			setState(2396)
		 			try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 			setState(2397)
		 			try select_statement()
		 			setState(2398)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Forall_statementContext:ParserRuleContext {
		open func FORALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.FORALL.rawValue, 0) }
		open func index_name() -> Index_nameContext? {
			return getRuleContext(Index_nameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func bounds_clause() -> Bounds_clauseContext? {
			return getRuleContext(Bounds_clauseContext.self,0)
		}
		open func sql_statement() -> Sql_statementContext? {
			return getRuleContext(Sql_statementContext.self,0)
		}
		open func SAVE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SAVE.rawValue, 0) }
		open func EXCEPTIONS() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXCEPTIONS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_forall_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterForall_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitForall_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitForall_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitForall_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func forall_statement() throws -> Forall_statementContext {
		var _localctx: Forall_statementContext = Forall_statementContext(_ctx, getState())
		try enterRule(_localctx, 244, plsqlParser.RULE_forall_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2404)
		 	try match(plsqlParser.Tokens.FORALL.rawValue)
		 	setState(2405)
		 	try index_name()
		 	setState(2406)
		 	try match(plsqlParser.Tokens.IN.rawValue)
		 	setState(2407)
		 	try bounds_clause()
		 	setState(2408)
		 	try sql_statement()
		 	setState(2411)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.SAVE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2409)
		 		try match(plsqlParser.Tokens.SAVE.rawValue)
		 		setState(2410)
		 		try match(plsqlParser.Tokens.EXCEPTIONS.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Bounds_clauseContext:ParserRuleContext {
		open func lower_bound() -> Lower_boundContext? {
			return getRuleContext(Lower_boundContext.self,0)
		}
		open func upper_bound() -> Upper_boundContext? {
			return getRuleContext(Upper_boundContext.self,0)
		}
		open func INDICES() -> TerminalNode? { return getToken(plsqlParser.Tokens.INDICES.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OF.rawValue, 0) }
		open func collection_name() -> Collection_nameContext? {
			return getRuleContext(Collection_nameContext.self,0)
		}
		open func between_bound() -> Between_boundContext? {
			return getRuleContext(Between_boundContext.self,0)
		}
		open func VALUES() -> TerminalNode? { return getToken(plsqlParser.Tokens.VALUES.rawValue, 0) }
		open func index_name() -> Index_nameContext? {
			return getRuleContext(Index_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_bounds_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBounds_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBounds_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBounds_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBounds_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func bounds_clause() throws -> Bounds_clauseContext {
		var _localctx: Bounds_clauseContext = Bounds_clauseContext(_ctx, getState())
		try enterRule(_localctx, 246, plsqlParser.RULE_bounds_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2426)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,234, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2413)
		 		try lower_bound()
		 		setState(2414)
		 		try match(plsqlParser.Tokens.T__0.rawValue)
		 		setState(2415)
		 		try upper_bound()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2417)
		 		try match(plsqlParser.Tokens.INDICES.rawValue)
		 		setState(2418)
		 		try match(plsqlParser.Tokens.OF.rawValue)
		 		setState(2419)
		 		try collection_name()
		 		setState(2421)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.BETWEEN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2420)
		 			try between_bound()

		 		}


		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2423)
		 		try match(plsqlParser.Tokens.VALUES.rawValue)
		 		setState(2424)
		 		try match(plsqlParser.Tokens.OF.rawValue)
		 		setState(2425)
		 		try index_name()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Between_boundContext:ParserRuleContext {
		open func BETWEEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.BETWEEN.rawValue, 0) }
		open func lower_bound() -> Lower_boundContext? {
			return getRuleContext(Lower_boundContext.self,0)
		}
		open func AND() -> TerminalNode? { return getToken(plsqlParser.Tokens.AND.rawValue, 0) }
		open func upper_bound() -> Upper_boundContext? {
			return getRuleContext(Upper_boundContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_between_bound }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBetween_bound(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBetween_bound(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBetween_bound(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBetween_bound(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func between_bound() throws -> Between_boundContext {
		var _localctx: Between_boundContext = Between_boundContext(_ctx, getState())
		try enterRule(_localctx, 248, plsqlParser.RULE_between_bound)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2428)
		 	try match(plsqlParser.Tokens.BETWEEN.rawValue)
		 	setState(2429)
		 	try lower_bound()
		 	setState(2430)
		 	try match(plsqlParser.Tokens.AND.rawValue)
		 	setState(2431)
		 	try upper_bound()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Lower_boundContext:ParserRuleContext {
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_lower_bound }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLower_bound(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLower_bound(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLower_bound(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLower_bound(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func lower_bound() throws -> Lower_boundContext {
		var _localctx: Lower_boundContext = Lower_boundContext(_ctx, getState())
		try enterRule(_localctx, 250, plsqlParser.RULE_lower_bound)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2433)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Upper_boundContext:ParserRuleContext {
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_upper_bound }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUpper_bound(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUpper_bound(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUpper_bound(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUpper_bound(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func upper_bound() throws -> Upper_boundContext {
		var _localctx: Upper_boundContext = Upper_boundContext(_ctx, getState())
		try enterRule(_localctx, 252, plsqlParser.RULE_upper_bound)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2435)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Null_statementContext:ParserRuleContext {
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_null_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNull_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNull_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNull_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNull_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func null_statement() throws -> Null_statementContext {
		var _localctx: Null_statementContext = Null_statementContext(_ctx, getState())
		try enterRule(_localctx, 254, plsqlParser.RULE_null_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2437)
		 	try match(plsqlParser.Tokens.NULL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Raise_statementContext:ParserRuleContext {
		open func RAISE() -> TerminalNode? { return getToken(plsqlParser.Tokens.RAISE.rawValue, 0) }
		open func exception_name() -> Exception_nameContext? {
			return getRuleContext(Exception_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_raise_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRaise_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRaise_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRaise_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRaise_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func raise_statement() throws -> Raise_statementContext {
		var _localctx: Raise_statementContext = Raise_statementContext(_ctx, getState())
		try enterRule(_localctx, 256, plsqlParser.RULE_raise_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2439)
		 	try match(plsqlParser.Tokens.RAISE.rawValue)
		 	setState(2441)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2440)
		 		try exception_name()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Return_statementContext:ParserRuleContext {
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_return_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReturn_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReturn_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReturn_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReturn_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func return_statement() throws -> Return_statementContext {
		var _localctx: Return_statementContext = Return_statementContext(_ctx, getState())
		try enterRule(_localctx, 258, plsqlParser.RULE_return_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2443)
		 	try match(plsqlParser.Tokens.RETURN.rawValue)
		 	setState(2445)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ALL.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ANY.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CASE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COALESCE.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONNECT_BY_ROOT.rawValue,plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DATE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DISTINCT.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTION_INIT.rawValue,plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXISTS.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FALSE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LANGUAGE.rawValue,plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NOT.rawValue,plsqlParser.Tokens.NULL.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OBJECT.rawValue,plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PRIOR.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 257)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.RIGHT.rawValue,plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUE.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YES.rawValue,plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.DECODE.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.NVL.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROUND.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.SUBSTR.rawValue,plsqlParser.Tokens.TO_CHAR.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue,plsqlParser.Tokens.APPROXIMATE_NUM_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue,plsqlParser.Tokens.LEFT_PAREN.rawValue,plsqlParser.Tokens.PLUS_SIGN.rawValue,plsqlParser.Tokens.MINUS_SIGN.rawValue,plsqlParser.Tokens.BINDVAR.rawValue,plsqlParser.Tokens.COLON.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2444)
		 		try expression()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_callContext:ParserRuleContext {
		open func routine_name() -> Routine_nameContext? {
			return getRuleContext(Routine_nameContext.self,0)
		}
		open func CALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.CALL.rawValue, 0) }
		open func function_argument() -> Function_argumentContext? {
			return getRuleContext(Function_argumentContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_call }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_call(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_call(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_call(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_call(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_call() throws -> Function_callContext {
		var _localctx: Function_callContext = Function_callContext(_ctx, getState())
		try enterRule(_localctx, 260, plsqlParser.RULE_function_call)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2448)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,237,_ctx)) {
		 	case 1:
		 		setState(2447)
		 		try match(plsqlParser.Tokens.CALL.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(2450)
		 	try routine_name()
		 	setState(2452)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2451)
		 		try function_argument()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class BodyContext:ParserRuleContext {
		open func BEGIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.BEGIN.rawValue, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.Tokens.END.rawValue, 0) }
		open func EXCEPTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXCEPTION.rawValue, 0) }
		open func label_name() -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,0)
		}
		open func exception_handler() -> Array<Exception_handlerContext> {
			return getRuleContexts(Exception_handlerContext.self)
		}
		open func exception_handler(_ i: Int) -> Exception_handlerContext? {
			return getRuleContext(Exception_handlerContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_body }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBody(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBody(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBody(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBody(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func body() throws -> BodyContext {
		var _localctx: BodyContext = BodyContext(_ctx, getState())
		try enterRule(_localctx, 262, plsqlParser.RULE_body)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2454)
		 	try match(plsqlParser.Tokens.BEGIN.rawValue)
		 	setState(2455)
		 	try seq_of_statements()
		 	setState(2462)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.EXCEPTION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2456)
		 		try match(plsqlParser.Tokens.EXCEPTION.rawValue)
		 		setState(2458) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2457)
		 			try exception_handler()


		 			setState(2460); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.WHEN.rawValue
		 		      return testSet
		 		 }())

		 	}

		 	setState(2464)
		 	try match(plsqlParser.Tokens.END.rawValue)
		 	setState(2466)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,241,_ctx)) {
		 	case 1:
		 		setState(2465)
		 		try label_name()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Exception_handlerContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHEN.rawValue, 0) }
		open func exception_name() -> Array<Exception_nameContext> {
			return getRuleContexts(Exception_nameContext.self)
		}
		open func exception_name(_ i: Int) -> Exception_nameContext? {
			return getRuleContext(Exception_nameContext.self,i)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.THEN.rawValue, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func OR() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.OR.rawValue) }
		open func OR(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.OR.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_exception_handler }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterException_handler(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitException_handler(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitException_handler(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitException_handler(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exception_handler() throws -> Exception_handlerContext {
		var _localctx: Exception_handlerContext = Exception_handlerContext(_ctx, getState())
		try enterRule(_localctx, 264, plsqlParser.RULE_exception_handler)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2468)
		 	try match(plsqlParser.Tokens.WHEN.rawValue)
		 	setState(2469)
		 	try exception_name()
		 	setState(2474)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2470)
		 		try match(plsqlParser.Tokens.OR.rawValue)
		 		setState(2471)
		 		try exception_name()


		 		setState(2476)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2477)
		 	try match(plsqlParser.Tokens.THEN.rawValue)
		 	setState(2478)
		 	try seq_of_statements()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Trigger_blockContext:ParserRuleContext {
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECLARE.rawValue, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_trigger_block }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTrigger_block(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTrigger_block(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTrigger_block(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTrigger_block(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func trigger_block() throws -> Trigger_blockContext {
		var _localctx: Trigger_blockContext = Trigger_blockContext(_ctx, getState())
		try enterRule(_localctx, 266, plsqlParser.RULE_trigger_block)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2488)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECLARE.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2481)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.DECLARE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2480)
		 			try match(plsqlParser.Tokens.DECLARE.rawValue)

		 		}

		 		setState(2484) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2483)
		 			try declare_spec()


		 			setState(2486); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 66)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 130)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 194)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 259)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 323)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 387)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 451)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 		      return testSet
		 		 }())

		 	}

		 	setState(2490)
		 	try body()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class BlockContext:ParserRuleContext {
		open func body() -> BodyContext? {
			return getRuleContext(BodyContext.self,0)
		}
		open func DECLARE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECLARE.rawValue, 0) }
		open func declare_spec() -> Array<Declare_specContext> {
			return getRuleContexts(Declare_specContext.self)
		}
		open func declare_spec(_ i: Int) -> Declare_specContext? {
			return getRuleContext(Declare_specContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_block }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBlock(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBlock(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBlock(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBlock(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func block() throws -> BlockContext {
		var _localctx: BlockContext = BlockContext(_ctx, getState())
		try enterRule(_localctx, 268, plsqlParser.RULE_block)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2493)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.DECLARE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2492)
		 		try match(plsqlParser.Tokens.DECLARE.rawValue)

		 	}

		 	setState(2496) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(2495)
		 		try declare_spec()


		 		setState(2498); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PROCEDURE.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }())
		 	setState(2500)
		 	try body()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sql_statementContext:ParserRuleContext {
		open func execute_immediate() -> Execute_immediateContext? {
			return getRuleContext(Execute_immediateContext.self,0)
		}
		open func data_manipulation_language_statements() -> Data_manipulation_language_statementsContext? {
			return getRuleContext(Data_manipulation_language_statementsContext.self,0)
		}
		open func cursor_manipulation_statements() -> Cursor_manipulation_statementsContext? {
			return getRuleContext(Cursor_manipulation_statementsContext.self,0)
		}
		open func transaction_control_statements() -> Transaction_control_statementsContext? {
			return getRuleContext(Transaction_control_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sql_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSql_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSql_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSql_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSql_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sql_statement() throws -> Sql_statementContext {
		var _localctx: Sql_statementContext = Sql_statementContext(_ctx, getState())
		try enterRule(_localctx, 270, plsqlParser.RULE_sql_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2506)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .EXECUTE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2502)
		 		try execute_immediate()

		 		break
		 	case .DELETE:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .INSERT:fallthrough
		 	case .LOCK:fallthrough
		 	case .MERGE:fallthrough
		 	case .SELECT:fallthrough
		 	case .UPDATE:fallthrough
		 	case .WITH:fallthrough
		 	case .LEFT_PAREN:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2503)
		 		try data_manipulation_language_statements()

		 		break
		 	case .CLOSE:fallthrough
		 	case .FETCH:fallthrough
		 	case .OPEN:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2504)
		 		try cursor_manipulation_statements()

		 		break
		 	case .COMMIT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SET:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2505)
		 		try transaction_control_statements()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Execute_immediateContext:ParserRuleContext {
		open func EXECUTE() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXECUTE.rawValue, 0) }
		open func IMMEDIATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.IMMEDIATE.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func into_clause() -> Into_clauseContext? {
			return getRuleContext(Into_clauseContext.self,0)
		}
		open func using_clause() -> Using_clauseContext? {
			return getRuleContext(Using_clauseContext.self,0)
		}
		open func dynamic_returning_clause() -> Dynamic_returning_clauseContext? {
			return getRuleContext(Dynamic_returning_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_execute_immediate }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExecute_immediate(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExecute_immediate(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExecute_immediate(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExecute_immediate(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func execute_immediate() throws -> Execute_immediateContext {
		var _localctx: Execute_immediateContext = Execute_immediateContext(_ctx, getState())
		try enterRule(_localctx, 272, plsqlParser.RULE_execute_immediate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2508)
		 	try match(plsqlParser.Tokens.EXECUTE.rawValue)
		 	setState(2509)
		 	try match(plsqlParser.Tokens.IMMEDIATE.rawValue)
		 	setState(2510)
		 	try expression()
		 	setState(2520)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .BULK:fallthrough
		 	case .INTO:
		 	 	setState(2511)
		 	 	try into_clause()
		 	 	setState(2513)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == plsqlParser.Tokens.USING.rawValue
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(2512)
		 	 		try using_clause()

		 	 	}


		 		break

		 	case .USING:
		 	 	setState(2515)
		 	 	try using_clause()
		 	 	setState(2517)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == plsqlParser.Tokens.RETURN.rawValue || _la == plsqlParser.Tokens.RETURNING.rawValue
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(2516)
		 	 		try dynamic_returning_clause()

		 	 	}


		 		break
		 	case .RETURN:fallthrough
		 	case .RETURNING:
		 	 	setState(2519)
		 	 	try dynamic_returning_clause()

		 		break
		 	case .EOF:fallthrough
		 	case .SAVE:fallthrough
		 	case .SEMICOLON:
		 		break
		 	default:
		 		break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dynamic_returning_clauseContext:ParserRuleContext {
		open func into_clause() -> Into_clauseContext? {
			return getRuleContext(Into_clauseContext.self,0)
		}
		open func RETURNING() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURNING.rawValue, 0) }
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dynamic_returning_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDynamic_returning_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDynamic_returning_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDynamic_returning_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDynamic_returning_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dynamic_returning_clause() throws -> Dynamic_returning_clauseContext {
		var _localctx: Dynamic_returning_clauseContext = Dynamic_returning_clauseContext(_ctx, getState())
		try enterRule(_localctx, 274, plsqlParser.RULE_dynamic_returning_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2522)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RETURN.rawValue || _la == plsqlParser.Tokens.RETURNING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2523)
		 	try into_clause()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Data_manipulation_language_statementsContext:ParserRuleContext {
		open func merge_statement() -> Merge_statementContext? {
			return getRuleContext(Merge_statementContext.self,0)
		}
		open func lock_table_statement() -> Lock_table_statementContext? {
			return getRuleContext(Lock_table_statementContext.self,0)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func update_statement() -> Update_statementContext? {
			return getRuleContext(Update_statementContext.self,0)
		}
		open func delete_statement() -> Delete_statementContext? {
			return getRuleContext(Delete_statementContext.self,0)
		}
		open func insert_statement() -> Insert_statementContext? {
			return getRuleContext(Insert_statementContext.self,0)
		}
		open func explain_statement() -> Explain_statementContext? {
			return getRuleContext(Explain_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_data_manipulation_language_statements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterData_manipulation_language_statements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitData_manipulation_language_statements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitData_manipulation_language_statements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitData_manipulation_language_statements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func data_manipulation_language_statements() throws -> Data_manipulation_language_statementsContext {
		var _localctx: Data_manipulation_language_statementsContext = Data_manipulation_language_statementsContext(_ctx, getState())
		try enterRule(_localctx, 276, plsqlParser.RULE_data_manipulation_language_statements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2532)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .MERGE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2525)
		 		try merge_statement()

		 		break

		 	case .LOCK:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2526)
		 		try lock_table_statement()

		 		break
		 	case .SELECT:fallthrough
		 	case .WITH:fallthrough
		 	case .LEFT_PAREN:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2527)
		 		try select_statement()

		 		break

		 	case .UPDATE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2528)
		 		try update_statement()

		 		break

		 	case .DELETE:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2529)
		 		try delete_statement()

		 		break

		 	case .INSERT:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2530)
		 		try insert_statement()

		 		break

		 	case .EXPLAIN:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2531)
		 		try explain_statement()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_manipulation_statementsContext:ParserRuleContext {
		open func close_statement() -> Close_statementContext? {
			return getRuleContext(Close_statementContext.self,0)
		}
		open func open_statement() -> Open_statementContext? {
			return getRuleContext(Open_statementContext.self,0)
		}
		open func fetch_statement() -> Fetch_statementContext? {
			return getRuleContext(Fetch_statementContext.self,0)
		}
		open func open_for_statement() -> Open_for_statementContext? {
			return getRuleContext(Open_for_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cursor_manipulation_statements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCursor_manipulation_statements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCursor_manipulation_statements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCursor_manipulation_statements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCursor_manipulation_statements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_manipulation_statements() throws -> Cursor_manipulation_statementsContext {
		var _localctx: Cursor_manipulation_statementsContext = Cursor_manipulation_statementsContext(_ctx, getState())
		try enterRule(_localctx, 278, plsqlParser.RULE_cursor_manipulation_statements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2538)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,253, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2534)
		 		try close_statement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2535)
		 		try open_statement()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2536)
		 		try fetch_statement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2537)
		 		try open_for_statement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Close_statementContext:ParserRuleContext {
		open func CLOSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CLOSE.rawValue, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_close_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterClose_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitClose_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitClose_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitClose_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func close_statement() throws -> Close_statementContext {
		var _localctx: Close_statementContext = Close_statementContext(_ctx, getState())
		try enterRule(_localctx, 280, plsqlParser.RULE_close_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2540)
		 	try match(plsqlParser.Tokens.CLOSE.rawValue)
		 	setState(2541)
		 	try cursor_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Open_statementContext:ParserRuleContext {
		open func OPEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.OPEN.rawValue, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_open_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOpen_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOpen_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOpen_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOpen_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func open_statement() throws -> Open_statementContext {
		var _localctx: Open_statementContext = Open_statementContext(_ctx, getState())
		try enterRule(_localctx, 282, plsqlParser.RULE_open_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2543)
		 	try match(plsqlParser.Tokens.OPEN.rawValue)
		 	setState(2544)
		 	try cursor_name()
		 	setState(2546)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2545)
		 		try expression_list()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Fetch_statementContext:ParserRuleContext {
		public var it1: Token!
		open func FETCH() -> TerminalNode? { return getToken(plsqlParser.Tokens.FETCH.rawValue, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func variable_name() -> Array<Variable_nameContext> {
			return getRuleContexts(Variable_nameContext.self)
		}
		open func variable_name(_ i: Int) -> Variable_nameContext? {
			return getRuleContext(Variable_nameContext.self,i)
		}
		open func BULK() -> TerminalNode? { return getToken(plsqlParser.Tokens.BULK.rawValue, 0) }
		open func COLLECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COLLECT.rawValue, 0) }
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTO.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_fetch_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFetch_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFetch_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFetch_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFetch_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func fetch_statement() throws -> Fetch_statementContext {
		var _localctx: Fetch_statementContext = Fetch_statementContext(_ctx, getState())
		try enterRule(_localctx, 284, plsqlParser.RULE_fetch_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2548)
		 	try match(plsqlParser.Tokens.FETCH.rawValue)
		 	setState(2549)
		 	try cursor_name()
		 	setState(2570)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .INTO:
		 		setState(2550)
		 		try {
		 				let assignmentValue = try match(plsqlParser.Tokens.INTO.rawValue)
		 				_localctx.castdown(Fetch_statementContext.self).it1 = assignmentValue
		 		     }()

		 		setState(2551)
		 		try variable_name()
		 		setState(2556)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2552)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(2553)
		 			try variable_name()


		 			setState(2558)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break

		 	case .BULK:
		 		setState(2559)
		 		try match(plsqlParser.Tokens.BULK.rawValue)
		 		setState(2560)
		 		try match(plsqlParser.Tokens.COLLECT.rawValue)
		 		setState(2561)
		 		try match(plsqlParser.Tokens.INTO.rawValue)
		 		setState(2562)
		 		try variable_name()
		 		setState(2567)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2563)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(2564)
		 			try variable_name()


		 			setState(2569)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Open_for_statementContext:ParserRuleContext {
		open func OPEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.OPEN.rawValue, 0) }
		open func variable_name() -> Variable_nameContext? {
			return getRuleContext(Variable_nameContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOR.rawValue, 0) }
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func using_clause() -> Using_clauseContext? {
			return getRuleContext(Using_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_open_for_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOpen_for_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOpen_for_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOpen_for_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOpen_for_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func open_for_statement() throws -> Open_for_statementContext {
		var _localctx: Open_for_statementContext = Open_for_statementContext(_ctx, getState())
		try enterRule(_localctx, 286, plsqlParser.RULE_open_for_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2572)
		 	try match(plsqlParser.Tokens.OPEN.rawValue)
		 	setState(2573)
		 	try variable_name()
		 	setState(2574)
		 	try match(plsqlParser.Tokens.FOR.rawValue)
		 	setState(2577)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,258, _ctx)) {
		 	case 1:
		 		setState(2575)
		 		try select_statement()

		 		break
		 	case 2:
		 		setState(2576)
		 		try expression()

		 		break
		 	default: break
		 	}
		 	setState(2580)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.USING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2579)
		 		try using_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Transaction_control_statementsContext:ParserRuleContext {
		open func set_transaction_command() -> Set_transaction_commandContext? {
			return getRuleContext(Set_transaction_commandContext.self,0)
		}
		open func set_constraint_command() -> Set_constraint_commandContext? {
			return getRuleContext(Set_constraint_commandContext.self,0)
		}
		open func commit_statement() -> Commit_statementContext? {
			return getRuleContext(Commit_statementContext.self,0)
		}
		open func rollback_statement() -> Rollback_statementContext? {
			return getRuleContext(Rollback_statementContext.self,0)
		}
		open func savepoint_statement() -> Savepoint_statementContext? {
			return getRuleContext(Savepoint_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_transaction_control_statements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTransaction_control_statements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTransaction_control_statements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTransaction_control_statements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTransaction_control_statements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func transaction_control_statements() throws -> Transaction_control_statementsContext {
		var _localctx: Transaction_control_statementsContext = Transaction_control_statementsContext(_ctx, getState())
		try enterRule(_localctx, 288, plsqlParser.RULE_transaction_control_statements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2587)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,260, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2582)
		 		try set_transaction_command()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2583)
		 		try set_constraint_command()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2584)
		 		try commit_statement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2585)
		 		try rollback_statement()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2586)
		 		try savepoint_statement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Set_transaction_commandContext:ParserRuleContext {
		open func SET() -> TerminalNode? { return getToken(plsqlParser.Tokens.SET.rawValue, 0) }
		open func TRANSACTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRANSACTION.rawValue, 0) }
		open func READ() -> TerminalNode? { return getToken(plsqlParser.Tokens.READ.rawValue, 0) }
		open func ISOLATION() -> TerminalNode? { return getToken(plsqlParser.Tokens.ISOLATION.rawValue, 0) }
		open func LEVEL() -> TerminalNode? { return getToken(plsqlParser.Tokens.LEVEL.rawValue, 0) }
		open func USE() -> TerminalNode? { return getToken(plsqlParser.Tokens.USE.rawValue, 0) }
		open func ROLLBACK() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROLLBACK.rawValue, 0) }
		open func SEGMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.SEGMENT.rawValue, 0) }
		open func rollback_segment_name() -> Rollback_segment_nameContext? {
			return getRuleContext(Rollback_segment_nameContext.self,0)
		}
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.NAME.rawValue, 0) }
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open func ONLY() -> TerminalNode? { return getToken(plsqlParser.Tokens.ONLY.rawValue, 0) }
		open func WRITE() -> TerminalNode? { return getToken(plsqlParser.Tokens.WRITE.rawValue, 0) }
		open func SERIALIZABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SERIALIZABLE.rawValue, 0) }
		open func COMMITTED() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMMITTED.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_set_transaction_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSet_transaction_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSet_transaction_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSet_transaction_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSet_transaction_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func set_transaction_command() throws -> Set_transaction_commandContext {
		var _localctx: Set_transaction_commandContext = Set_transaction_commandContext(_ctx, getState())
		try enterRule(_localctx, 290, plsqlParser.RULE_set_transaction_command)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2589)
		 	try match(plsqlParser.Tokens.SET.rawValue)
		 	setState(2590)
		 	try match(plsqlParser.Tokens.TRANSACTION.rawValue)
		 	setState(2604)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .READ:
		 	 	setState(2591)
		 	 	try match(plsqlParser.Tokens.READ.rawValue)
		 	 	setState(2592)
		 	 	_la = try _input.LA(1)
		 	 	if (!(//closure
		 	 	 { () -> Bool in
		 	 	      var testSet: Bool = _la == plsqlParser.Tokens.ONLY.rawValue
		 	 	          testSet = testSet || _la == plsqlParser.Tokens.WRITE.rawValue
		 	 	      return testSet
		 	 	 }())) {
		 	 	try _errHandler.recoverInline(self)
		 	 	}
		 	 	else {
		 	 		_errHandler.reportMatch(self)
		 	 		try consume()
		 	 	}

		 		break

		 	case .ISOLATION:
		 	 	setState(2593)
		 	 	try match(plsqlParser.Tokens.ISOLATION.rawValue)
		 	 	setState(2594)
		 	 	try match(plsqlParser.Tokens.LEVEL.rawValue)
		 	 	setState(2598)
		 	 	try _errHandler.sync(self)
		 	 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	 	case .SERIALIZABLE:
		 	 		setState(2595)
		 	 		try match(plsqlParser.Tokens.SERIALIZABLE.rawValue)

		 	 		break

		 	 	case .READ:
		 	 		setState(2596)
		 	 		try match(plsqlParser.Tokens.READ.rawValue)
		 	 		setState(2597)
		 	 		try match(plsqlParser.Tokens.COMMITTED.rawValue)

		 	 		break
		 	 	default:
		 	 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	 	}

		 		break

		 	case .USE:
		 	 	setState(2600)
		 	 	try match(plsqlParser.Tokens.USE.rawValue)
		 	 	setState(2601)
		 	 	try match(plsqlParser.Tokens.ROLLBACK.rawValue)
		 	 	setState(2602)
		 	 	try match(plsqlParser.Tokens.SEGMENT.rawValue)
		 	 	setState(2603)
		 	 	try rollback_segment_name()

		 		break
		 	case .EOF:fallthrough
		 	case .NAME:fallthrough
		 	case .SAVE:fallthrough
		 	case .SEMICOLON:
		 		break
		 	default:
		 		break
		 	}
		 	setState(2608)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.NAME.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2606)
		 		try match(plsqlParser.Tokens.NAME.rawValue)
		 		setState(2607)
		 		try quoted_string()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Set_constraint_commandContext:ParserRuleContext {
		open func SET() -> TerminalNode? { return getToken(plsqlParser.Tokens.SET.rawValue, 0) }
		open func CONSTRAINT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONSTRAINT.rawValue, 0) }
		open func CONSTRAINTS() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONSTRAINTS.rawValue, 0) }
		open func IMMEDIATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.IMMEDIATE.rawValue, 0) }
		open func DEFERRED() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFERRED.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open func constraint_name() -> Array<Constraint_nameContext> {
			return getRuleContexts(Constraint_nameContext.self)
		}
		open func constraint_name(_ i: Int) -> Constraint_nameContext? {
			return getRuleContext(Constraint_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_set_constraint_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSet_constraint_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSet_constraint_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSet_constraint_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSet_constraint_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func set_constraint_command() throws -> Set_constraint_commandContext {
		var _localctx: Set_constraint_commandContext = Set_constraint_commandContext(_ctx, getState())
		try enterRule(_localctx, 292, plsqlParser.RULE_set_constraint_command)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2610)
		 	try match(plsqlParser.Tokens.SET.rawValue)
		 	setState(2611)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.CONSTRAINT.rawValue || _la == plsqlParser.Tokens.CONSTRAINTS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2621)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ALL:
		 		setState(2612)
		 		try match(plsqlParser.Tokens.ALL.rawValue)

		 		break
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(2613)
		 		try constraint_name()
		 		setState(2618)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2614)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(2615)
		 			try constraint_name()


		 			setState(2620)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2623)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.DEFERRED.rawValue || _la == plsqlParser.Tokens.IMMEDIATE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Commit_statementContext:ParserRuleContext {
		open func COMMIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMMIT.rawValue, 0) }
		open func WORK() -> TerminalNode? { return getToken(plsqlParser.Tokens.WORK.rawValue, 0) }
		open func COMMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMMENT.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func FORCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.FORCE.rawValue, 0) }
		open func write_clause() -> Write_clauseContext? {
			return getRuleContext(Write_clauseContext.self,0)
		}
		open func CORRUPT_XID() -> TerminalNode? { return getToken(plsqlParser.Tokens.CORRUPT_XID.rawValue, 0) }
		open func CORRUPT_XID_ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_commit_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCommit_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCommit_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCommit_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCommit_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func commit_statement() throws -> Commit_statementContext {
		var _localctx: Commit_statementContext = Commit_statementContext(_ctx, getState())
		try enterRule(_localctx, 294, plsqlParser.RULE_commit_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2625)
		 	try match(plsqlParser.Tokens.COMMIT.rawValue)
		 	setState(2627)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WORK.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2626)
		 		try match(plsqlParser.Tokens.WORK.rawValue)

		 	}

		 	setState(2642)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .COMMENT:
		 	 	setState(2629)
		 	 	try match(plsqlParser.Tokens.COMMENT.rawValue)
		 	 	setState(2630)
		 	 	try expression()

		 		break

		 	case .FORCE:
		 	 	setState(2631)
		 	 	try match(plsqlParser.Tokens.FORCE.rawValue)
		 	 	setState(2640)
		 	 	try _errHandler.sync(self)
		 	 	switch(try getInterpreter().adaptivePredict(_input,268, _ctx)) {
		 	 	case 1:
		 	 		setState(2632)
		 	 		try match(plsqlParser.Tokens.CORRUPT_XID.rawValue)
		 	 		setState(2633)
		 	 		try expression()

		 	 		break
		 	 	case 2:
		 	 		setState(2634)
		 	 		try match(plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue)

		 	 		break
		 	 	case 3:
		 	 		setState(2635)
		 	 		try expression()
		 	 		setState(2638)
		 	 		try _errHandler.sync(self)
		 	 		_la = try _input.LA(1)
		 	 		if (//closure
		 	 		 { () -> Bool in
		 	 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	 		      return testSet
		 	 		 }()) {
		 	 			setState(2636)
		 	 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 	 			setState(2637)
		 	 			try expression()

		 	 		}


		 	 		break
		 	 	default: break
		 	 	}

		 		break
		 	case .EOF:fallthrough
		 	case .SAVE:fallthrough
		 	case .WRITE:fallthrough
		 	case .SEMICOLON:
		 		break
		 	default:
		 		break
		 	}
		 	setState(2645)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WRITE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2644)
		 		try write_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Write_clauseContext:ParserRuleContext {
		open func WRITE() -> TerminalNode? { return getToken(plsqlParser.Tokens.WRITE.rawValue, 0) }
		open func WAIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.WAIT.rawValue, 0) }
		open func NOWAIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOWAIT.rawValue, 0) }
		open func IMMEDIATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.IMMEDIATE.rawValue, 0) }
		open func BATCH() -> TerminalNode? { return getToken(plsqlParser.Tokens.BATCH.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_write_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWrite_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWrite_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWrite_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWrite_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func write_clause() throws -> Write_clauseContext {
		var _localctx: Write_clauseContext = Write_clauseContext(_ctx, getState())
		try enterRule(_localctx, 296, plsqlParser.RULE_write_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2647)
		 	try match(plsqlParser.Tokens.WRITE.rawValue)
		 	setState(2649)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.NOWAIT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.WAIT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2648)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.NOWAIT.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.WAIT.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(2652)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.BATCH.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.IMMEDIATE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2651)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.BATCH.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.IMMEDIATE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Rollback_statementContext:ParserRuleContext {
		open func ROLLBACK() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROLLBACK.rawValue, 0) }
		open func WORK() -> TerminalNode? { return getToken(plsqlParser.Tokens.WORK.rawValue, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.Tokens.TO.rawValue, 0) }
		open func savepoint_name() -> Savepoint_nameContext? {
			return getRuleContext(Savepoint_nameContext.self,0)
		}
		open func FORCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.FORCE.rawValue, 0) }
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open func SAVEPOINT() -> TerminalNode? { return getToken(plsqlParser.Tokens.SAVEPOINT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_rollback_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRollback_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRollback_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRollback_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRollback_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rollback_statement() throws -> Rollback_statementContext {
		var _localctx: Rollback_statementContext = Rollback_statementContext(_ctx, getState())
		try enterRule(_localctx, 298, plsqlParser.RULE_rollback_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2654)
		 	try match(plsqlParser.Tokens.ROLLBACK.rawValue)
		 	setState(2656)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WORK.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2655)
		 		try match(plsqlParser.Tokens.WORK.rawValue)

		 	}

		 	setState(2665)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .TO:
		 	 	setState(2658)
		 	 	try match(plsqlParser.Tokens.TO.rawValue)
		 	 	setState(2660)
		 	 	try _errHandler.sync(self)
		 	 	switch (try getInterpreter().adaptivePredict(_input,274,_ctx)) {
		 	 	case 1:
		 	 		setState(2659)
		 	 		try match(plsqlParser.Tokens.SAVEPOINT.rawValue)

		 	 		break
		 	 	default: break
		 	 	}
		 	 	setState(2662)
		 	 	try savepoint_name()

		 		break

		 	case .FORCE:
		 	 	setState(2663)
		 	 	try match(plsqlParser.Tokens.FORCE.rawValue)
		 	 	setState(2664)
		 	 	try quoted_string()

		 		break
		 	case .EOF:fallthrough
		 	case .SAVE:fallthrough
		 	case .SEMICOLON:
		 		break
		 	default:
		 		break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Savepoint_statementContext:ParserRuleContext {
		open func SAVEPOINT() -> TerminalNode? { return getToken(plsqlParser.Tokens.SAVEPOINT.rawValue, 0) }
		open func savepoint_name() -> Savepoint_nameContext? {
			return getRuleContext(Savepoint_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_savepoint_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSavepoint_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSavepoint_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSavepoint_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSavepoint_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func savepoint_statement() throws -> Savepoint_statementContext {
		var _localctx: Savepoint_statementContext = Savepoint_statementContext(_ctx, getState())
		try enterRule(_localctx, 300, plsqlParser.RULE_savepoint_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2667)
		 	try match(plsqlParser.Tokens.SAVEPOINT.rawValue)
		 	setState(2668)
		 	try savepoint_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Explain_statementContext:ParserRuleContext {
		open func EXPLAIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXPLAIN.rawValue, 0) }
		open func PLAN() -> TerminalNode? { return getToken(plsqlParser.Tokens.PLAN.rawValue, 0) }
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOR.rawValue, 0) }
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func update_statement() -> Update_statementContext? {
			return getRuleContext(Update_statementContext.self,0)
		}
		open func delete_statement() -> Delete_statementContext? {
			return getRuleContext(Delete_statementContext.self,0)
		}
		open func insert_statement() -> Insert_statementContext? {
			return getRuleContext(Insert_statementContext.self,0)
		}
		open func merge_statement() -> Merge_statementContext? {
			return getRuleContext(Merge_statementContext.self,0)
		}
		open func SET() -> TerminalNode? { return getToken(plsqlParser.Tokens.SET.rawValue, 0) }
		open func STATEMENT_ID() -> TerminalNode? { return getToken(plsqlParser.Tokens.STATEMENT_ID.rawValue, 0) }
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTO.rawValue, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_explain_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExplain_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExplain_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExplain_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExplain_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func explain_statement() throws -> Explain_statementContext {
		var _localctx: Explain_statementContext = Explain_statementContext(_ctx, getState())
		try enterRule(_localctx, 302, plsqlParser.RULE_explain_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2670)
		 	try match(plsqlParser.Tokens.EXPLAIN.rawValue)
		 	setState(2671)
		 	try match(plsqlParser.Tokens.PLAN.rawValue)
		 	setState(2676)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.SET.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2672)
		 		try match(plsqlParser.Tokens.SET.rawValue)
		 		setState(2673)
		 		try match(plsqlParser.Tokens.STATEMENT_ID.rawValue)
		 		setState(2674)
		 		try match(plsqlParser.Tokens.EQUALS_OP.rawValue)
		 		setState(2675)
		 		try quoted_string()

		 	}

		 	setState(2680)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2678)
		 		try match(plsqlParser.Tokens.INTO.rawValue)
		 		setState(2679)
		 		try tableview_name()

		 	}

		 	setState(2682)
		 	try match(plsqlParser.Tokens.FOR.rawValue)
		 	setState(2688)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SELECT:fallthrough
		 	case .WITH:fallthrough
		 	case .LEFT_PAREN:
		 		setState(2683)
		 		try select_statement()

		 		break

		 	case .UPDATE:
		 		setState(2684)
		 		try update_statement()

		 		break

		 	case .DELETE:
		 		setState(2685)
		 		try delete_statement()

		 		break

		 	case .INSERT:
		 		setState(2686)
		 		try insert_statement()

		 		break

		 	case .MERGE:
		 		setState(2687)
		 		try merge_statement()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Select_statementContext:ParserRuleContext {
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func subquery_factoring_clause() -> Subquery_factoring_clauseContext? {
			return getRuleContext(Subquery_factoring_clauseContext.self,0)
		}
		open func for_update_clause() -> Array<For_update_clauseContext> {
			return getRuleContexts(For_update_clauseContext.self)
		}
		open func for_update_clause(_ i: Int) -> For_update_clauseContext? {
			return getRuleContext(For_update_clauseContext.self,i)
		}
		open func order_by_clause() -> Array<Order_by_clauseContext> {
			return getRuleContexts(Order_by_clauseContext.self)
		}
		open func order_by_clause(_ i: Int) -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_select_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSelect_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSelect_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSelect_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSelect_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func select_statement() throws -> Select_statementContext {
		var _localctx: Select_statementContext = Select_statementContext(_ctx, getState())
		try enterRule(_localctx, 304, plsqlParser.RULE_select_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2691)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2690)
		 		try subquery_factoring_clause()

		 	}

		 	setState(2693)
		 	try subquery()
		 	setState(2698)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.FOR.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.ORDER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2696)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .FOR:
		 			setState(2694)
		 			try for_update_clause()

		 			break

		 		case .ORDER:
		 			setState(2695)
		 			try order_by_clause()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2700)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subquery_factoring_clauseContext:ParserRuleContext {
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.Tokens.WITH.rawValue, 0) }
		open func factoring_element() -> Array<Factoring_elementContext> {
			return getRuleContexts(Factoring_elementContext.self)
		}
		open func factoring_element(_ i: Int) -> Factoring_elementContext? {
			return getRuleContext(Factoring_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subquery_factoring_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubquery_factoring_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubquery_factoring_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubquery_factoring_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubquery_factoring_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subquery_factoring_clause() throws -> Subquery_factoring_clauseContext {
		var _localctx: Subquery_factoring_clauseContext = Subquery_factoring_clauseContext(_ctx, getState())
		try enterRule(_localctx, 306, plsqlParser.RULE_subquery_factoring_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2701)
		 	try match(plsqlParser.Tokens.WITH.rawValue)
		 	setState(2702)
		 	try factoring_element()
		 	setState(2707)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2703)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(2704)
		 		try factoring_element()


		 		setState(2709)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Factoring_elementContext:ParserRuleContext {
		open func query_name() -> Query_nameContext? {
			return getRuleContext(Query_nameContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func search_clause() -> Search_clauseContext? {
			return getRuleContext(Search_clauseContext.self,0)
		}
		open func cycle_clause() -> Cycle_clauseContext? {
			return getRuleContext(Cycle_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_factoring_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFactoring_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFactoring_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFactoring_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFactoring_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func factoring_element() throws -> Factoring_elementContext {
		var _localctx: Factoring_elementContext = Factoring_elementContext(_ctx, getState())
		try enterRule(_localctx, 308, plsqlParser.RULE_factoring_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2710)
		 	try query_name()
		 	setState(2722)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2711)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(2712)
		 		try column_name()
		 		setState(2717)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2713)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(2714)
		 			try column_name()


		 			setState(2719)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2720)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(2724)
		 	try match(plsqlParser.Tokens.AS.rawValue)
		 	setState(2725)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(2726)
		 	try subquery()
		 	setState(2728)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.ORDER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2727)
		 		try order_by_clause()

		 	}

		 	setState(2730)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(2732)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.SEARCH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2731)
		 		try search_clause()

		 	}

		 	setState(2735)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.CYCLE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2734)
		 		try cycle_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Search_clauseContext:ParserRuleContext {
		open func SEARCH() -> TerminalNode? { return getToken(plsqlParser.Tokens.SEARCH.rawValue, 0) }
		open func FIRST() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.FIRST.rawValue) }
		open func FIRST(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.FIRST.rawValue, i)
		}
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func SET() -> TerminalNode? { return getToken(plsqlParser.Tokens.SET.rawValue, 0) }
		open func DEPTH() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEPTH.rawValue, 0) }
		open func BREADTH() -> TerminalNode? { return getToken(plsqlParser.Tokens.BREADTH.rawValue, 0) }
		open func ASC() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.ASC.rawValue) }
		open func ASC(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.ASC.rawValue, i)
		}
		open func DESC() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.DESC.rawValue) }
		open func DESC(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.DESC.rawValue, i)
		}
		open func NULLS() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.NULLS.rawValue) }
		open func NULLS(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.NULLS.rawValue, i)
		}
		open func LAST() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.LAST.rawValue) }
		open func LAST(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.LAST.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_search_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSearch_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSearch_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSearch_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSearch_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func search_clause() throws -> Search_clauseContext {
		var _localctx: Search_clauseContext = Search_clauseContext(_ctx, getState())
		try enterRule(_localctx, 310, plsqlParser.RULE_search_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2737)
		 	try match(plsqlParser.Tokens.SEARCH.rawValue)
		 	setState(2738)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.BREADTH.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.DEPTH.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2739)
		 	try match(plsqlParser.Tokens.FIRST.rawValue)
		 	setState(2740)
		 	try match(plsqlParser.Tokens.BY.rawValue)
		 	setState(2741)
		 	try column_name()
		 	setState(2743)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.ASC.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2742)
		 		try match(plsqlParser.Tokens.ASC.rawValue)

		 	}

		 	setState(2746)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.DESC.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2745)
		 		try match(plsqlParser.Tokens.DESC.rawValue)

		 	}

		 	setState(2750)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,290,_ctx)) {
		 	case 1:
		 		setState(2748)
		 		try match(plsqlParser.Tokens.NULLS.rawValue)
		 		setState(2749)
		 		try match(plsqlParser.Tokens.FIRST.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(2754)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.NULLS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2752)
		 		try match(plsqlParser.Tokens.NULLS.rawValue)
		 		setState(2753)
		 		try match(plsqlParser.Tokens.LAST.rawValue)

		 	}

		 	setState(2774)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2756)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(2757)
		 		try column_name()
		 		setState(2759)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.ASC.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2758)
		 			try match(plsqlParser.Tokens.ASC.rawValue)

		 		}

		 		setState(2762)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.DESC.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2761)
		 			try match(plsqlParser.Tokens.DESC.rawValue)

		 		}

		 		setState(2766)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,294,_ctx)) {
		 		case 1:
		 			setState(2764)
		 			try match(plsqlParser.Tokens.NULLS.rawValue)
		 			setState(2765)
		 			try match(plsqlParser.Tokens.FIRST.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2770)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.NULLS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2768)
		 			try match(plsqlParser.Tokens.NULLS.rawValue)
		 			setState(2769)
		 			try match(plsqlParser.Tokens.LAST.rawValue)

		 		}



		 		setState(2776)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2777)
		 	try match(plsqlParser.Tokens.SET.rawValue)
		 	setState(2778)
		 	try column_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cycle_clauseContext:ParserRuleContext {
		open func CYCLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CYCLE.rawValue, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func SET() -> TerminalNode? { return getToken(plsqlParser.Tokens.SET.rawValue, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.Tokens.TO.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cycle_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCycle_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCycle_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCycle_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCycle_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cycle_clause() throws -> Cycle_clauseContext {
		var _localctx: Cycle_clauseContext = Cycle_clauseContext(_ctx, getState())
		try enterRule(_localctx, 312, plsqlParser.RULE_cycle_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2780)
		 	try match(plsqlParser.Tokens.CYCLE.rawValue)
		 	setState(2781)
		 	try column_name()
		 	setState(2786)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2782)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(2783)
		 		try column_name()


		 		setState(2788)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2789)
		 	try match(plsqlParser.Tokens.SET.rawValue)
		 	setState(2790)
		 	try column_name()
		 	setState(2791)
		 	try match(plsqlParser.Tokens.TO.rawValue)
		 	setState(2792)
		 	try expression()
		 	setState(2793)
		 	try match(plsqlParser.Tokens.DEFAULT.rawValue)
		 	setState(2794)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubqueryContext:ParserRuleContext {
		open func subquery_basic_elements() -> Subquery_basic_elementsContext? {
			return getRuleContext(Subquery_basic_elementsContext.self,0)
		}
		open func subquery_operation_part() -> Array<Subquery_operation_partContext> {
			return getRuleContexts(Subquery_operation_partContext.self)
		}
		open func subquery_operation_part(_ i: Int) -> Subquery_operation_partContext? {
			return getRuleContext(Subquery_operation_partContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subquery }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubquery(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubquery(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubquery(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubquery(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subquery() throws -> SubqueryContext {
		var _localctx: SubqueryContext = SubqueryContext(_ctx, getState())
		try enterRule(_localctx, 314, plsqlParser.RULE_subquery)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2796)
		 	try subquery_basic_elements()
		 	setState(2800)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.INTERSECT.rawValue || _la == plsqlParser.Tokens.MINUS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.UNION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2797)
		 		try subquery_operation_part()


		 		setState(2802)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subquery_operation_partContext:ParserRuleContext {
		open func subquery_basic_elements() -> Subquery_basic_elementsContext? {
			return getRuleContext(Subquery_basic_elementsContext.self,0)
		}
		open func UNION() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNION.rawValue, 0) }
		open func INTERSECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTERSECT.rawValue, 0) }
		open func MINUS() -> TerminalNode? { return getToken(plsqlParser.Tokens.MINUS.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subquery_operation_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubquery_operation_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubquery_operation_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubquery_operation_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubquery_operation_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subquery_operation_part() throws -> Subquery_operation_partContext {
		var _localctx: Subquery_operation_partContext = Subquery_operation_partContext(_ctx, getState())
		try enterRule(_localctx, 316, plsqlParser.RULE_subquery_operation_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2809)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .UNION:
		 		setState(2803)
		 		try match(plsqlParser.Tokens.UNION.rawValue)
		 		setState(2805)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2804)
		 			try match(plsqlParser.Tokens.ALL.rawValue)

		 		}


		 		break

		 	case .INTERSECT:
		 		setState(2807)
		 		try match(plsqlParser.Tokens.INTERSECT.rawValue)

		 		break

		 	case .MINUS:
		 		setState(2808)
		 		try match(plsqlParser.Tokens.MINUS.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2811)
		 	try subquery_basic_elements()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subquery_basic_elementsContext:ParserRuleContext {
		open func query_block() -> Query_blockContext? {
			return getRuleContext(Query_blockContext.self,0)
		}
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subquery_basic_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubquery_basic_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubquery_basic_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubquery_basic_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubquery_basic_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subquery_basic_elements() throws -> Subquery_basic_elementsContext {
		var _localctx: Subquery_basic_elementsContext = Subquery_basic_elementsContext(_ctx, getState())
		try enterRule(_localctx, 318, plsqlParser.RULE_subquery_basic_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2818)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SELECT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2813)
		 		try query_block()

		 		break

		 	case .LEFT_PAREN:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2814)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(2815)
		 		try subquery()
		 		setState(2816)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Query_blockContext:ParserRuleContext {
		open func SELECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.SELECT.rawValue, 0) }
		open func from_clause() -> From_clauseContext? {
			return getRuleContext(From_clauseContext.self,0)
		}
		open func selected_element() -> Array<Selected_elementContext> {
			return getRuleContexts(Selected_elementContext.self)
		}
		open func selected_element(_ i: Int) -> Selected_elementContext? {
			return getRuleContext(Selected_elementContext.self,i)
		}
		open func into_clause() -> Into_clauseContext? {
			return getRuleContext(Into_clauseContext.self,0)
		}
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open func hierarchical_query_clause() -> Hierarchical_query_clauseContext? {
			return getRuleContext(Hierarchical_query_clauseContext.self,0)
		}
		open func group_by_clause() -> Group_by_clauseContext? {
			return getRuleContext(Group_by_clauseContext.self,0)
		}
		open func model_clause() -> Model_clauseContext? {
			return getRuleContext(Model_clauseContext.self,0)
		}
		open func DISTINCT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DISTINCT.rawValue, 0) }
		open func UNIQUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNIQUE.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_query_block }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterQuery_block(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitQuery_block(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitQuery_block(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitQuery_block(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func query_block() throws -> Query_blockContext {
		var _localctx: Query_blockContext = Query_blockContext(_ctx, getState())
		try enterRule(_localctx, 320, plsqlParser.RULE_query_block)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2820)
		 	try match(plsqlParser.Tokens.SELECT.rawValue)
		 	setState(2822)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,302,_ctx)) {
		 	case 1:
		 		setState(2821)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.DISTINCT.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.UNIQUE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(2833)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ASTERISK:
		 		setState(2824)
		 		try match(plsqlParser.Tokens.ASTERISK.rawValue)

		 		break
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALL:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ANY:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CASE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COALESCE:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONNECT_BY_ROOT:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DISTINCT:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXISTS:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FALSE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NOT:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .PRIOR:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .DECODE:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NVL:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .TO_CHAR:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case .UNSIGNED_INTEGER:fallthrough
		 	case .APPROXIMATE_NUM_LIT:fallthrough
		 	case .CHAR_STRING:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .LEFT_PAREN:fallthrough
		 	case .PLUS_SIGN:fallthrough
		 	case .MINUS_SIGN:fallthrough
		 	case .BINDVAR:fallthrough
		 	case .COLON:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(2825)
		 		try selected_element()
		 		setState(2830)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2826)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(2827)
		 			try selected_element()


		 			setState(2832)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2836)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.BULK.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2835)
		 		try into_clause()

		 	}

		 	setState(2838)
		 	try from_clause()
		 	setState(2840)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,306,_ctx)) {
		 	case 1:
		 		setState(2839)
		 		try where_clause()

		 		break
		 	default: break
		 	}
		 	setState(2843)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,307,_ctx)) {
		 	case 1:
		 		setState(2842)
		 		try hierarchical_query_clause()

		 		break
		 	default: break
		 	}
		 	setState(2846)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,308,_ctx)) {
		 	case 1:
		 		setState(2845)
		 		try group_by_clause()

		 		break
		 	default: break
		 	}
		 	setState(2849)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,309,_ctx)) {
		 	case 1:
		 		setState(2848)
		 		try model_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Selected_elementContext:ParserRuleContext {
		open func select_list_elements() -> Select_list_elementsContext? {
			return getRuleContext(Select_list_elementsContext.self,0)
		}
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_selected_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSelected_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSelected_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSelected_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSelected_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func selected_element() throws -> Selected_elementContext {
		var _localctx: Selected_elementContext = Selected_elementContext(_ctx, getState())
		try enterRule(_localctx, 322, plsqlParser.RULE_selected_element)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2851)
		 	try select_list_elements()
		 	setState(2853)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,310,_ctx)) {
		 	case 1:
		 		setState(2852)
		 		try column_alias()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class From_clauseContext:ParserRuleContext {
		open func FROM() -> TerminalNode? { return getToken(plsqlParser.Tokens.FROM.rawValue, 0) }
		open func table_ref_list() -> Table_ref_listContext? {
			return getRuleContext(Table_ref_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_from_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFrom_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFrom_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFrom_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFrom_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func from_clause() throws -> From_clauseContext {
		var _localctx: From_clauseContext = From_clauseContext(_ctx, getState())
		try enterRule(_localctx, 324, plsqlParser.RULE_from_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2855)
		 	try match(plsqlParser.Tokens.FROM.rawValue)
		 	setState(2856)
		 	try table_ref_list()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Select_list_elementsContext:ParserRuleContext {
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_select_list_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSelect_list_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSelect_list_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSelect_list_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSelect_list_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func select_list_elements() throws -> Select_list_elementsContext {
		var _localctx: Select_list_elementsContext = Select_list_elementsContext(_ctx, getState())
		try enterRule(_localctx, 326, plsqlParser.RULE_select_list_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2863)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,311, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2858)
		 		try tableview_name()
		 		setState(2859)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(2860)
		 		try match(plsqlParser.Tokens.ASTERISK.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2862)
		 		try expression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_ref_listContext:ParserRuleContext {
		open func table_ref() -> Array<Table_refContext> {
			return getRuleContexts(Table_refContext.self)
		}
		open func table_ref(_ i: Int) -> Table_refContext? {
			return getRuleContext(Table_refContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_ref_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_ref_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_ref_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_ref_list(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_ref_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_ref_list() throws -> Table_ref_listContext {
		var _localctx: Table_ref_listContext = Table_ref_listContext(_ctx, getState())
		try enterRule(_localctx, 328, plsqlParser.RULE_table_ref_list)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2865)
		 	try table_ref()
		 	setState(2870)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,312,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2866)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(2867)
		 			try table_ref()

		 	 
		 		}
		 		setState(2872)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,312,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_refContext:ParserRuleContext {
		open func table_ref_aux() -> Table_ref_auxContext? {
			return getRuleContext(Table_ref_auxContext.self,0)
		}
		open func join_clause() -> Array<Join_clauseContext> {
			return getRuleContexts(Join_clauseContext.self)
		}
		open func join_clause(_ i: Int) -> Join_clauseContext? {
			return getRuleContext(Join_clauseContext.self,i)
		}
		open func pivot_clause() -> Pivot_clauseContext? {
			return getRuleContext(Pivot_clauseContext.self,0)
		}
		open func unpivot_clause() -> Unpivot_clauseContext? {
			return getRuleContext(Unpivot_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_ref }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_ref(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_ref(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_ref(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_ref(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_ref() throws -> Table_refContext {
		var _localctx: Table_refContext = Table_refContext(_ctx, getState())
		try enterRule(_localctx, 330, plsqlParser.RULE_table_ref)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2873)
		 	try table_ref_aux()
		 	setState(2877)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,313,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2874)
		 			try join_clause()

		 	 
		 		}
		 		setState(2879)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,313,_ctx)
		 	}
		 	setState(2882)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,314,_ctx)) {
		 	case 1:
		 		setState(2880)
		 		try pivot_clause()

		 		break
		 	case 2:
		 		setState(2881)
		 		try unpivot_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_ref_auxContext:ParserRuleContext {
		open func table_ref_aux_internal() -> Table_ref_aux_internalContext? {
			return getRuleContext(Table_ref_aux_internalContext.self,0)
		}
		open func flashback_query_clause() -> Array<Flashback_query_clauseContext> {
			return getRuleContexts(Flashback_query_clauseContext.self)
		}
		open func flashback_query_clause(_ i: Int) -> Flashback_query_clauseContext? {
			return getRuleContext(Flashback_query_clauseContext.self,i)
		}
		open func table_alias() -> Table_aliasContext? {
			return getRuleContext(Table_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_ref_aux }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_ref_aux(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_ref_aux(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_ref_aux(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_ref_aux(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_ref_aux() throws -> Table_ref_auxContext {
		var _localctx: Table_ref_auxContext = Table_ref_auxContext(_ctx, getState())
		try enterRule(_localctx, 332, plsqlParser.RULE_table_ref_aux)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2884)
		 	try table_ref_aux_internal()
		 	setState(2888)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,315,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2885)
		 			try flashback_query_clause()

		 	 
		 		}
		 		setState(2890)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,315,_ctx)
		 	}
		 	setState(2892)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,316,_ctx)) {
		 	case 1:
		 		setState(2891)
		 		try table_alias()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_ref_aux_internalContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_ref_aux_internal }
	 
		public  func copyFrom(_ ctx: Table_ref_aux_internalContext) {
			super.copyFrom(ctx)
		}
	}
	public  final class Table_ref_aux_internal_threeContext: Table_ref_aux_internalContext {
		open func ONLY() -> TerminalNode? { return getToken(plsqlParser.Tokens.ONLY.rawValue, 0) }
		open func dml_table_expression_clause() -> Dml_table_expression_clauseContext? {
			return getRuleContext(Dml_table_expression_clauseContext.self,0)
		}
		public init(_ ctx: Table_ref_aux_internalContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_ref_aux_internal_three(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_ref_aux_internal_three(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_ref_aux_internal_three(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_ref_aux_internal_three(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Table_ref_aux_internal_oneContext: Table_ref_aux_internalContext {
		open func dml_table_expression_clause() -> Dml_table_expression_clauseContext? {
			return getRuleContext(Dml_table_expression_clauseContext.self,0)
		}
		open func pivot_clause() -> Pivot_clauseContext? {
			return getRuleContext(Pivot_clauseContext.self,0)
		}
		open func unpivot_clause() -> Unpivot_clauseContext? {
			return getRuleContext(Unpivot_clauseContext.self,0)
		}
		public init(_ ctx: Table_ref_aux_internalContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_ref_aux_internal_one(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_ref_aux_internal_one(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_ref_aux_internal_one(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_ref_aux_internal_one(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Table_ref_aux_internal_twoContext: Table_ref_aux_internalContext {
		open func table_ref() -> Table_refContext? {
			return getRuleContext(Table_refContext.self,0)
		}
		open func subquery_operation_part() -> Array<Subquery_operation_partContext> {
			return getRuleContexts(Subquery_operation_partContext.self)
		}
		open func subquery_operation_part(_ i: Int) -> Subquery_operation_partContext? {
			return getRuleContext(Subquery_operation_partContext.self,i)
		}
		open func pivot_clause() -> Pivot_clauseContext? {
			return getRuleContext(Pivot_clauseContext.self,0)
		}
		open func unpivot_clause() -> Unpivot_clauseContext? {
			return getRuleContext(Unpivot_clauseContext.self,0)
		}
		public init(_ ctx: Table_ref_aux_internalContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_ref_aux_internal_two(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_ref_aux_internal_two(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_ref_aux_internal_two(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_ref_aux_internal_two(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_ref_aux_internal() throws -> Table_ref_aux_internalContext {
		var _localctx: Table_ref_aux_internalContext = Table_ref_aux_internalContext(_ctx, getState())
		try enterRule(_localctx, 334, plsqlParser.RULE_table_ref_aux_internal)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2917)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,320, _ctx)) {
		 	case 1:
		 		_localctx =  Table_ref_aux_internal_oneContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2894)
		 		try dml_table_expression_clause()
		 		setState(2897)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,317,_ctx)) {
		 		case 1:
		 			setState(2895)
		 			try pivot_clause()

		 			break
		 		case 2:
		 			setState(2896)
		 			try unpivot_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		_localctx =  Table_ref_aux_internal_twoContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2899)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(2900)
		 		try table_ref()
		 		setState(2904)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.INTERSECT.rawValue || _la == plsqlParser.Tokens.MINUS.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.UNION.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2901)
		 			try subquery_operation_part()


		 			setState(2906)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2907)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(2910)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,319,_ctx)) {
		 		case 1:
		 			setState(2908)
		 			try pivot_clause()

		 			break
		 		case 2:
		 			setState(2909)
		 			try unpivot_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		_localctx =  Table_ref_aux_internal_threeContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2912)
		 		try match(plsqlParser.Tokens.ONLY.rawValue)
		 		setState(2913)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(2914)
		 		try dml_table_expression_clause()
		 		setState(2915)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Join_clauseContext:ParserRuleContext {
		open func JOIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.JOIN.rawValue, 0) }
		open func table_ref_aux() -> Table_ref_auxContext? {
			return getRuleContext(Table_ref_auxContext.self,0)
		}
		open func query_partition_clause() -> Array<Query_partition_clauseContext> {
			return getRuleContexts(Query_partition_clauseContext.self)
		}
		open func query_partition_clause(_ i: Int) -> Query_partition_clauseContext? {
			return getRuleContext(Query_partition_clauseContext.self,i)
		}
		open func INNER() -> TerminalNode? { return getToken(plsqlParser.Tokens.INNER.rawValue, 0) }
		open func outer_join_type() -> Outer_join_typeContext? {
			return getRuleContext(Outer_join_typeContext.self,0)
		}
		open func join_on_part() -> Array<Join_on_partContext> {
			return getRuleContexts(Join_on_partContext.self)
		}
		open func join_on_part(_ i: Int) -> Join_on_partContext? {
			return getRuleContext(Join_on_partContext.self,i)
		}
		open func join_using_part() -> Array<Join_using_partContext> {
			return getRuleContexts(Join_using_partContext.self)
		}
		open func join_using_part(_ i: Int) -> Join_using_partContext? {
			return getRuleContext(Join_using_partContext.self,i)
		}
		open func CROSS() -> TerminalNode? { return getToken(plsqlParser.Tokens.CROSS.rawValue, 0) }
		open func NATURAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NATURAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_join_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterJoin_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitJoin_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitJoin_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitJoin_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func join_clause() throws -> Join_clauseContext {
		var _localctx: Join_clauseContext = Join_clauseContext(_ctx, getState())
		try enterRule(_localctx, 336, plsqlParser.RULE_join_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2920)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PARTITION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2919)
		 		try query_partition_clause()

		 	}

		 	setState(2923)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.CROSS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.NATURAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2922)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.CROSS.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.NATURAL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(2927)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .INNER:
		 	 	setState(2925)
		 	 	try match(plsqlParser.Tokens.INNER.rawValue)

		 		break
		 	case .FULL:fallthrough
		 	case .LEFT:fallthrough
		 	case .RIGHT:
		 	 	setState(2926)
		 	 	try outer_join_type()

		 		break

		 	case .JOIN:
		 		break
		 	default:
		 		break
		 	}
		 	setState(2929)
		 	try match(plsqlParser.Tokens.JOIN.rawValue)
		 	setState(2930)
		 	try table_ref_aux()
		 	setState(2932)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,324,_ctx)) {
		 	case 1:
		 		setState(2931)
		 		try query_partition_clause()

		 		break
		 	default: break
		 	}
		 	setState(2938)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,326,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2936)
		 			try _errHandler.sync(self)
		 			switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .ON:
		 				setState(2934)
		 				try join_on_part()

		 				break

		 			case .USING:
		 				setState(2935)
		 				try join_using_part()

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 	 
		 		}
		 		setState(2940)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,326,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Join_on_partContext:ParserRuleContext {
		open func ON() -> TerminalNode? { return getToken(plsqlParser.Tokens.ON.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_join_on_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterJoin_on_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitJoin_on_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitJoin_on_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitJoin_on_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func join_on_part() throws -> Join_on_partContext {
		var _localctx: Join_on_partContext = Join_on_partContext(_ctx, getState())
		try enterRule(_localctx, 338, plsqlParser.RULE_join_on_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2941)
		 	try match(plsqlParser.Tokens.ON.rawValue)
		 	setState(2942)
		 	try condition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Join_using_partContext:ParserRuleContext {
		open func USING() -> TerminalNode? { return getToken(plsqlParser.Tokens.USING.rawValue, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_join_using_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterJoin_using_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitJoin_using_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitJoin_using_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitJoin_using_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func join_using_part() throws -> Join_using_partContext {
		var _localctx: Join_using_partContext = Join_using_partContext(_ctx, getState())
		try enterRule(_localctx, 340, plsqlParser.RULE_join_using_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2944)
		 	try match(plsqlParser.Tokens.USING.rawValue)
		 	setState(2945)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(2946)
		 	try column_name()
		 	setState(2951)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2947)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(2948)
		 		try column_name()


		 		setState(2953)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2954)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Outer_join_typeContext:ParserRuleContext {
		open func FULL() -> TerminalNode? { return getToken(plsqlParser.Tokens.FULL.rawValue, 0) }
		open func LEFT() -> TerminalNode? { return getToken(plsqlParser.Tokens.LEFT.rawValue, 0) }
		open func RIGHT() -> TerminalNode? { return getToken(plsqlParser.Tokens.RIGHT.rawValue, 0) }
		open func OUTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.OUTER.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_outer_join_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOuter_join_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOuter_join_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOuter_join_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOuter_join_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func outer_join_type() throws -> Outer_join_typeContext {
		var _localctx: Outer_join_typeContext = Outer_join_typeContext(_ctx, getState())
		try enterRule(_localctx, 342, plsqlParser.RULE_outer_join_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2956)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.FULL.rawValue || _la == plsqlParser.Tokens.LEFT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.RIGHT.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2958)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OUTER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2957)
		 		try match(plsqlParser.Tokens.OUTER.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Query_partition_clauseContext:ParserRuleContext {
		open func PARTITION() -> TerminalNode? { return getToken(plsqlParser.Tokens.PARTITION.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_query_partition_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterQuery_partition_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitQuery_partition_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitQuery_partition_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitQuery_partition_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func query_partition_clause() throws -> Query_partition_clauseContext {
		var _localctx: Query_partition_clauseContext = Query_partition_clauseContext(_ctx, getState())
		try enterRule(_localctx, 344, plsqlParser.RULE_query_partition_clause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2960)
		 	try match(plsqlParser.Tokens.PARTITION.rawValue)
		 	setState(2961)
		 	try match(plsqlParser.Tokens.BY.rawValue)
		 	setState(2975)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,330, _ctx)) {
		 	case 1:
		 		setState(2962)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(2963)
		 		try subquery()
		 		setState(2964)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 2:
		 		setState(2966)
		 		try expression_list()

		 		break
		 	case 3:
		 		setState(2967)
		 		try expression()
		 		setState(2972)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,329,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(2968)
		 				try match(plsqlParser.Tokens.COMMA.rawValue)
		 				setState(2969)
		 				try expression()

		 		 
		 			}
		 			setState(2974)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,329,_ctx)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Flashback_query_clauseContext:ParserRuleContext {
		open func VERSIONS() -> TerminalNode? { return getToken(plsqlParser.Tokens.VERSIONS.rawValue, 0) }
		open func BETWEEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.BETWEEN.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func SCN() -> TerminalNode? { return getToken(plsqlParser.Tokens.SCN.rawValue, 0) }
		open func TIMESTAMP() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMESTAMP.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OF.rawValue, 0) }
		open func SNAPSHOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.SNAPSHOT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_flashback_query_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFlashback_query_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFlashback_query_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFlashback_query_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFlashback_query_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func flashback_query_clause() throws -> Flashback_query_clauseContext {
		var _localctx: Flashback_query_clauseContext = Flashback_query_clauseContext(_ctx, getState())
		try enterRule(_localctx, 346, plsqlParser.RULE_flashback_query_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2985)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .VERSIONS:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2977)
		 		try match(plsqlParser.Tokens.VERSIONS.rawValue)
		 		setState(2978)
		 		try match(plsqlParser.Tokens.BETWEEN.rawValue)
		 		setState(2979)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.SCN.rawValue || _la == plsqlParser.Tokens.TIMESTAMP.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2980)
		 		try expression()

		 		break

		 	case .AS:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2981)
		 		try match(plsqlParser.Tokens.AS.rawValue)
		 		setState(2982)
		 		try match(plsqlParser.Tokens.OF.rawValue)
		 		setState(2983)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 334)
		 		}()
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2984)
		 		try expression()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_clauseContext:ParserRuleContext {
		open func PIVOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.PIVOT.rawValue, 0) }
		open func pivot_element() -> Array<Pivot_elementContext> {
			return getRuleContexts(Pivot_elementContext.self)
		}
		open func pivot_element(_ i: Int) -> Pivot_elementContext? {
			return getRuleContext(Pivot_elementContext.self,i)
		}
		open func pivot_for_clause() -> Pivot_for_clauseContext? {
			return getRuleContext(Pivot_for_clauseContext.self,0)
		}
		open func pivot_in_clause() -> Pivot_in_clauseContext? {
			return getRuleContext(Pivot_in_clauseContext.self,0)
		}
		open func XML() -> TerminalNode? { return getToken(plsqlParser.Tokens.XML.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_clause() throws -> Pivot_clauseContext {
		var _localctx: Pivot_clauseContext = Pivot_clauseContext(_ctx, getState())
		try enterRule(_localctx, 348, plsqlParser.RULE_pivot_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2987)
		 	try match(plsqlParser.Tokens.PIVOT.rawValue)
		 	setState(2989)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.XML.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2988)
		 		try match(plsqlParser.Tokens.XML.rawValue)

		 	}

		 	setState(2991)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(2992)
		 	try pivot_element()
		 	setState(2997)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2993)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(2994)
		 		try pivot_element()


		 		setState(2999)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3000)
		 	try pivot_for_clause()
		 	setState(3001)
		 	try pivot_in_clause()
		 	setState(3002)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_elementContext:ParserRuleContext {
		open func aggregate_function_name() -> Aggregate_function_nameContext? {
			return getRuleContext(Aggregate_function_nameContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_element() throws -> Pivot_elementContext {
		var _localctx: Pivot_elementContext = Pivot_elementContext(_ctx, getState())
		try enterRule(_localctx, 350, plsqlParser.RULE_pivot_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3004)
		 	try aggregate_function_name()
		 	setState(3005)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3006)
		 	try expression()
		 	setState(3007)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(3009)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.AS.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3008)
		 		try column_alias()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_for_clauseContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOR.rawValue, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_for_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_for_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_for_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_for_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_for_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_for_clause() throws -> Pivot_for_clauseContext {
		var _localctx: Pivot_for_clauseContext = Pivot_for_clauseContext(_ctx, getState())
		try enterRule(_localctx, 352, plsqlParser.RULE_pivot_for_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3011)
		 	try match(plsqlParser.Tokens.FOR.rawValue)
		 	setState(3024)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(3012)
		 		try column_name()

		 		break

		 	case .LEFT_PAREN:
		 		setState(3013)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3014)
		 		try column_name()
		 		setState(3019)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3015)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(3016)
		 			try column_name()


		 			setState(3021)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3022)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_in_clauseContext:ParserRuleContext {
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func ANY() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.ANY.rawValue) }
		open func ANY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.ANY.rawValue, i)
		}
		open func pivot_in_clause_element() -> Array<Pivot_in_clause_elementContext> {
			return getRuleContexts(Pivot_in_clause_elementContext.self)
		}
		open func pivot_in_clause_element(_ i: Int) -> Pivot_in_clause_elementContext? {
			return getRuleContext(Pivot_in_clause_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_in_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_in_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_in_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_in_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_in_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_in_clause() throws -> Pivot_in_clauseContext {
		var _localctx: Pivot_in_clauseContext = Pivot_in_clauseContext(_ctx, getState())
		try enterRule(_localctx, 354, plsqlParser.RULE_pivot_in_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3026)
		 	try match(plsqlParser.Tokens.IN.rawValue)
		 	setState(3027)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3045)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,339, _ctx)) {
		 	case 1:
		 		setState(3028)
		 		try subquery()

		 		break
		 	case 2:
		 		setState(3029)
		 		try match(plsqlParser.Tokens.ANY.rawValue)
		 		setState(3034)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3030)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(3031)
		 			try match(plsqlParser.Tokens.ANY.rawValue)


		 			setState(3036)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 3:
		 		setState(3037)
		 		try pivot_in_clause_element()
		 		setState(3042)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3038)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(3039)
		 			try pivot_in_clause_element()


		 			setState(3044)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}
		 	setState(3047)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_in_clause_elementContext:ParserRuleContext {
		open func pivot_in_clause_elements() -> Pivot_in_clause_elementsContext? {
			return getRuleContext(Pivot_in_clause_elementsContext.self,0)
		}
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_in_clause_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_in_clause_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_in_clause_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_in_clause_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_in_clause_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_in_clause_element() throws -> Pivot_in_clause_elementContext {
		var _localctx: Pivot_in_clause_elementContext = Pivot_in_clause_elementContext(_ctx, getState())
		try enterRule(_localctx, 356, plsqlParser.RULE_pivot_in_clause_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3049)
		 	try pivot_in_clause_elements()
		 	setState(3051)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.AS.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3050)
		 		try column_alias()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_in_clause_elementsContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_pivot_in_clause_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPivot_in_clause_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPivot_in_clause_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPivot_in_clause_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPivot_in_clause_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_in_clause_elements() throws -> Pivot_in_clause_elementsContext {
		var _localctx: Pivot_in_clause_elementsContext = Pivot_in_clause_elementsContext(_ctx, getState())
		try enterRule(_localctx, 358, plsqlParser.RULE_pivot_in_clause_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3055)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,341, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3053)
		 		try expression()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3054)
		 		try expression_list()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Unpivot_clauseContext:ParserRuleContext {
		open func UNPIVOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNPIVOT.rawValue, 0) }
		open func pivot_for_clause() -> Pivot_for_clauseContext? {
			return getRuleContext(Pivot_for_clauseContext.self,0)
		}
		open func unpivot_in_clause() -> Unpivot_in_clauseContext? {
			return getRuleContext(Unpivot_in_clauseContext.self,0)
		}
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func NULLS() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULLS.rawValue, 0) }
		open func INCLUDE() -> TerminalNode? { return getToken(plsqlParser.Tokens.INCLUDE.rawValue, 0) }
		open func EXCLUDE() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXCLUDE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_unpivot_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUnpivot_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUnpivot_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUnpivot_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUnpivot_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unpivot_clause() throws -> Unpivot_clauseContext {
		var _localctx: Unpivot_clauseContext = Unpivot_clauseContext(_ctx, getState())
		try enterRule(_localctx, 360, plsqlParser.RULE_unpivot_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3057)
		 	try match(plsqlParser.Tokens.UNPIVOT.rawValue)
		 	setState(3060)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.EXCLUDE.rawValue || _la == plsqlParser.Tokens.INCLUDE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3058)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.EXCLUDE.rawValue || _la == plsqlParser.Tokens.INCLUDE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3059)
		 		try match(plsqlParser.Tokens.NULLS.rawValue)

		 	}

		 	setState(3062)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3075)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(3063)
		 		try column_name()

		 		break

		 	case .LEFT_PAREN:
		 		setState(3064)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3065)
		 		try column_name()
		 		setState(3070)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3066)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(3067)
		 			try column_name()


		 			setState(3072)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3073)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3077)
		 	try pivot_for_clause()
		 	setState(3078)
		 	try unpivot_in_clause()
		 	setState(3079)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Unpivot_in_clauseContext:ParserRuleContext {
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func unpivot_in_elements() -> Array<Unpivot_in_elementsContext> {
			return getRuleContexts(Unpivot_in_elementsContext.self)
		}
		open func unpivot_in_elements(_ i: Int) -> Unpivot_in_elementsContext? {
			return getRuleContext(Unpivot_in_elementsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_unpivot_in_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUnpivot_in_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUnpivot_in_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUnpivot_in_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUnpivot_in_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unpivot_in_clause() throws -> Unpivot_in_clauseContext {
		var _localctx: Unpivot_in_clauseContext = Unpivot_in_clauseContext(_ctx, getState())
		try enterRule(_localctx, 362, plsqlParser.RULE_unpivot_in_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3081)
		 	try match(plsqlParser.Tokens.IN.rawValue)
		 	setState(3082)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3083)
		 	try unpivot_in_elements()
		 	setState(3088)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3084)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(3085)
		 		try unpivot_in_elements()


		 		setState(3090)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3091)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Unpivot_in_elementsContext:ParserRuleContext {
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func constant() -> Array<ConstantContext> {
			return getRuleContexts(ConstantContext.self)
		}
		open func constant(_ i: Int) -> ConstantContext? {
			return getRuleContext(ConstantContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_unpivot_in_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUnpivot_in_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUnpivot_in_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUnpivot_in_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUnpivot_in_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unpivot_in_elements() throws -> Unpivot_in_elementsContext {
		var _localctx: Unpivot_in_elementsContext = Unpivot_in_elementsContext(_ctx, getState())
		try enterRule(_localctx, 364, plsqlParser.RULE_unpivot_in_elements)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3105)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(3093)
		 		try column_name()

		 		break

		 	case .LEFT_PAREN:
		 		setState(3094)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3095)
		 		try column_name()
		 		setState(3100)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3096)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(3097)
		 			try column_name()


		 			setState(3102)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3103)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3122)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3107)
		 		try match(plsqlParser.Tokens.AS.rawValue)
		 		setState(3120)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .DATE:fallthrough
		 		case .DBTIMEZONE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .FALSE:fallthrough
		 		case .INTERVAL:fallthrough
		 		case .MAXVALUE:fallthrough
		 		case .MINVALUE:fallthrough
		 		case .NULL:fallthrough
		 		case .SESSIONTIMEZONE:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .TRUE:fallthrough
		 		case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 		case .UNSIGNED_INTEGER:fallthrough
		 		case .APPROXIMATE_NUM_LIT:fallthrough
		 		case .CHAR_STRING:
		 			setState(3108)
		 			try constant()

		 			break

		 		case .LEFT_PAREN:
		 			setState(3109)
		 			try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 			setState(3110)
		 			try constant()
		 			setState(3115)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(3111)
		 				try match(plsqlParser.Tokens.COMMA.rawValue)
		 				setState(3112)
		 				try constant()


		 				setState(3117)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(3118)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Hierarchical_query_clauseContext:ParserRuleContext {
		open func CONNECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONNECT.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func NOCYCLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOCYCLE.rawValue, 0) }
		open func start_part() -> Start_partContext? {
			return getRuleContext(Start_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_hierarchical_query_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterHierarchical_query_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitHierarchical_query_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitHierarchical_query_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitHierarchical_query_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func hierarchical_query_clause() throws -> Hierarchical_query_clauseContext {
		var _localctx: Hierarchical_query_clauseContext = Hierarchical_query_clauseContext(_ctx, getState())
		try enterRule(_localctx, 366, plsqlParser.RULE_hierarchical_query_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3141)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CONNECT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3124)
		 		try match(plsqlParser.Tokens.CONNECT.rawValue)
		 		setState(3125)
		 		try match(plsqlParser.Tokens.BY.rawValue)
		 		setState(3127)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,351,_ctx)) {
		 		case 1:
		 			setState(3126)
		 			try match(plsqlParser.Tokens.NOCYCLE.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(3129)
		 		try condition()
		 		setState(3131)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,352,_ctx)) {
		 		case 1:
		 			setState(3130)
		 			try start_part()

		 			break
		 		default: break
		 		}

		 		break

		 	case .START:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3133)
		 		try start_part()
		 		setState(3134)
		 		try match(plsqlParser.Tokens.CONNECT.rawValue)
		 		setState(3135)
		 		try match(plsqlParser.Tokens.BY.rawValue)
		 		setState(3137)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,353,_ctx)) {
		 		case 1:
		 			setState(3136)
		 			try match(plsqlParser.Tokens.NOCYCLE.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(3139)
		 		try condition()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Start_partContext:ParserRuleContext {
		open func START() -> TerminalNode? { return getToken(plsqlParser.Tokens.START.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.Tokens.WITH.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_start_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStart_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStart_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStart_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStart_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func start_part() throws -> Start_partContext {
		var _localctx: Start_partContext = Start_partContext(_ctx, getState())
		try enterRule(_localctx, 368, plsqlParser.RULE_start_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3143)
		 	try match(plsqlParser.Tokens.START.rawValue)
		 	setState(3144)
		 	try match(plsqlParser.Tokens.WITH.rawValue)
		 	setState(3145)
		 	try condition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Group_by_clauseContext:ParserRuleContext {
		open func GROUP() -> TerminalNode? { return getToken(plsqlParser.Tokens.GROUP.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func group_by_elements() -> Array<Group_by_elementsContext> {
			return getRuleContexts(Group_by_elementsContext.self)
		}
		open func group_by_elements(_ i: Int) -> Group_by_elementsContext? {
			return getRuleContext(Group_by_elementsContext.self,i)
		}
		open func having_clause() -> Having_clauseContext? {
			return getRuleContext(Having_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_group_by_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGroup_by_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGroup_by_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGroup_by_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGroup_by_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func group_by_clause() throws -> Group_by_clauseContext {
		var _localctx: Group_by_clauseContext = Group_by_clauseContext(_ctx, getState())
		try enterRule(_localctx, 370, plsqlParser.RULE_group_by_clause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(3173)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .GROUP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3147)
		 		try match(plsqlParser.Tokens.GROUP.rawValue)
		 		setState(3148)
		 		try match(plsqlParser.Tokens.BY.rawValue)
		 		setState(3149)
		 		try group_by_elements()
		 		setState(3154)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,355,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(3150)
		 				try match(plsqlParser.Tokens.COMMA.rawValue)
		 				setState(3151)
		 				try group_by_elements()

		 		 
		 			}
		 			setState(3156)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,355,_ctx)
		 		}
		 		setState(3158)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,356,_ctx)) {
		 		case 1:
		 			setState(3157)
		 			try having_clause()

		 			break
		 		default: break
		 		}

		 		break

		 	case .HAVING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3160)
		 		try having_clause()
		 		setState(3171)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,358,_ctx)) {
		 		case 1:
		 			setState(3161)
		 			try match(plsqlParser.Tokens.GROUP.rawValue)
		 			setState(3162)
		 			try match(plsqlParser.Tokens.BY.rawValue)
		 			setState(3163)
		 			try group_by_elements()
		 			setState(3168)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,357,_ctx)
		 			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 				if ( _alt==1 ) {
		 					setState(3164)
		 					try match(plsqlParser.Tokens.COMMA.rawValue)
		 					setState(3165)
		 					try group_by_elements()

		 			 
		 				}
		 				setState(3170)
		 				try _errHandler.sync(self)
		 				_alt = try getInterpreter().adaptivePredict(_input,357,_ctx)
		 			}

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Group_by_elementsContext:ParserRuleContext {
		open func grouping_sets_clause() -> Grouping_sets_clauseContext? {
			return getRuleContext(Grouping_sets_clauseContext.self,0)
		}
		open func rollup_cube_clause() -> Rollup_cube_clauseContext? {
			return getRuleContext(Rollup_cube_clauseContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_group_by_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGroup_by_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGroup_by_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGroup_by_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGroup_by_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func group_by_elements() throws -> Group_by_elementsContext {
		var _localctx: Group_by_elementsContext = Group_by_elementsContext(_ctx, getState())
		try enterRule(_localctx, 372, plsqlParser.RULE_group_by_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3178)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,360, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3175)
		 		try grouping_sets_clause()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3176)
		 		try rollup_cube_clause()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3177)
		 		try expression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Rollup_cube_clauseContext:ParserRuleContext {
		open func grouping_sets_elements() -> Array<Grouping_sets_elementsContext> {
			return getRuleContexts(Grouping_sets_elementsContext.self)
		}
		open func grouping_sets_elements(_ i: Int) -> Grouping_sets_elementsContext? {
			return getRuleContext(Grouping_sets_elementsContext.self,i)
		}
		open func ROLLUP() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROLLUP.rawValue, 0) }
		open func CUBE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CUBE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_rollup_cube_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRollup_cube_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRollup_cube_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRollup_cube_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRollup_cube_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rollup_cube_clause() throws -> Rollup_cube_clauseContext {
		var _localctx: Rollup_cube_clauseContext = Rollup_cube_clauseContext(_ctx, getState())
		try enterRule(_localctx, 374, plsqlParser.RULE_rollup_cube_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3180)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.CUBE.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.ROLLUP.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3181)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3182)
		 	try grouping_sets_elements()
		 	setState(3187)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3183)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(3184)
		 		try grouping_sets_elements()


		 		setState(3189)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3190)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Grouping_sets_clauseContext:ParserRuleContext {
		open func GROUPING() -> TerminalNode? { return getToken(plsqlParser.Tokens.GROUPING.rawValue, 0) }
		open func SETS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SETS.rawValue, 0) }
		open func grouping_sets_elements() -> Array<Grouping_sets_elementsContext> {
			return getRuleContexts(Grouping_sets_elementsContext.self)
		}
		open func grouping_sets_elements(_ i: Int) -> Grouping_sets_elementsContext? {
			return getRuleContext(Grouping_sets_elementsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_grouping_sets_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGrouping_sets_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGrouping_sets_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGrouping_sets_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGrouping_sets_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func grouping_sets_clause() throws -> Grouping_sets_clauseContext {
		var _localctx: Grouping_sets_clauseContext = Grouping_sets_clauseContext(_ctx, getState())
		try enterRule(_localctx, 376, plsqlParser.RULE_grouping_sets_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3192)
		 	try match(plsqlParser.Tokens.GROUPING.rawValue)
		 	setState(3193)
		 	try match(plsqlParser.Tokens.SETS.rawValue)
		 	setState(3194)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3195)
		 	try grouping_sets_elements()
		 	setState(3200)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3196)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(3197)
		 		try grouping_sets_elements()


		 		setState(3202)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3203)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Grouping_sets_elementsContext:ParserRuleContext {
		open func rollup_cube_clause() -> Rollup_cube_clauseContext? {
			return getRuleContext(Rollup_cube_clauseContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_grouping_sets_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGrouping_sets_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGrouping_sets_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGrouping_sets_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGrouping_sets_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func grouping_sets_elements() throws -> Grouping_sets_elementsContext {
		var _localctx: Grouping_sets_elementsContext = Grouping_sets_elementsContext(_ctx, getState())
		try enterRule(_localctx, 378, plsqlParser.RULE_grouping_sets_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3208)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,363, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3205)
		 		try rollup_cube_clause()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3206)
		 		try expression_list()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3207)
		 		try expression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Having_clauseContext:ParserRuleContext {
		open func HAVING() -> TerminalNode? { return getToken(plsqlParser.Tokens.HAVING.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_having_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterHaving_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitHaving_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitHaving_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitHaving_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func having_clause() throws -> Having_clauseContext {
		var _localctx: Having_clauseContext = Having_clauseContext(_ctx, getState())
		try enterRule(_localctx, 380, plsqlParser.RULE_having_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3210)
		 	try match(plsqlParser.Tokens.HAVING.rawValue)
		 	setState(3211)
		 	try condition()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_clauseContext:ParserRuleContext {
		open func MODEL() -> TerminalNode? { return getToken(plsqlParser.Tokens.MODEL.rawValue, 0) }
		open func main_model() -> Main_modelContext? {
			return getRuleContext(Main_modelContext.self,0)
		}
		open func cell_reference_options() -> Array<Cell_reference_optionsContext> {
			return getRuleContexts(Cell_reference_optionsContext.self)
		}
		open func cell_reference_options(_ i: Int) -> Cell_reference_optionsContext? {
			return getRuleContext(Cell_reference_optionsContext.self,i)
		}
		open func return_rows_clause() -> Return_rows_clauseContext? {
			return getRuleContext(Return_rows_clauseContext.self,0)
		}
		open func reference_model() -> Array<Reference_modelContext> {
			return getRuleContexts(Reference_modelContext.self)
		}
		open func reference_model(_ i: Int) -> Reference_modelContext? {
			return getRuleContext(Reference_modelContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_clause() throws -> Model_clauseContext {
		var _localctx: Model_clauseContext = Model_clauseContext(_ctx, getState())
		try enterRule(_localctx, 382, plsqlParser.RULE_model_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3213)
		 	try match(plsqlParser.Tokens.MODEL.rawValue)
		 	setState(3217)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.IGNORE.rawValue || _la == plsqlParser.Tokens.KEEP.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.UNIQUE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3214)
		 		try cell_reference_options()


		 		setState(3219)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3221)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RETURN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3220)
		 		try return_rows_clause()

		 	}

		 	setState(3226)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.REFERENCE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3223)
		 		try reference_model()


		 		setState(3228)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3229)
		 	try main_model()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cell_reference_optionsContext:ParserRuleContext {
		open func NAV() -> TerminalNode? { return getToken(plsqlParser.Tokens.NAV.rawValue, 0) }
		open func IGNORE() -> TerminalNode? { return getToken(plsqlParser.Tokens.IGNORE.rawValue, 0) }
		open func KEEP() -> TerminalNode? { return getToken(plsqlParser.Tokens.KEEP.rawValue, 0) }
		open func UNIQUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNIQUE.rawValue, 0) }
		open func DIMENSION() -> TerminalNode? { return getToken(plsqlParser.Tokens.DIMENSION.rawValue, 0) }
		open func SINGLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SINGLE.rawValue, 0) }
		open func REFERENCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REFERENCE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cell_reference_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCell_reference_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCell_reference_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCell_reference_options(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCell_reference_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cell_reference_options() throws -> Cell_reference_optionsContext {
		var _localctx: Cell_reference_optionsContext = Cell_reference_optionsContext(_ctx, getState())
		try enterRule(_localctx, 384, plsqlParser.RULE_cell_reference_options)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3239)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IGNORE:fallthrough
		 	case .KEEP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3231)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.IGNORE.rawValue || _la == plsqlParser.Tokens.KEEP.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3232)
		 		try match(plsqlParser.Tokens.NAV.rawValue)

		 		break

		 	case .UNIQUE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3233)
		 		try match(plsqlParser.Tokens.UNIQUE.rawValue)
		 		setState(3237)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .DIMENSION:
		 			setState(3234)
		 			try match(plsqlParser.Tokens.DIMENSION.rawValue)

		 			break

		 		case .SINGLE:
		 			setState(3235)
		 			try match(plsqlParser.Tokens.SINGLE.rawValue)
		 			setState(3236)
		 			try match(plsqlParser.Tokens.REFERENCE.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Return_rows_clauseContext:ParserRuleContext {
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func ROWS() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROWS.rawValue, 0) }
		open func UPDATED() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPDATED.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_return_rows_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReturn_rows_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReturn_rows_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReturn_rows_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReturn_rows_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func return_rows_clause() throws -> Return_rows_clauseContext {
		var _localctx: Return_rows_clauseContext = Return_rows_clauseContext(_ctx, getState())
		try enterRule(_localctx, 386, plsqlParser.RULE_return_rows_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3241)
		 	try match(plsqlParser.Tokens.RETURN.rawValue)
		 	setState(3242)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.UPDATED.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3243)
		 	try match(plsqlParser.Tokens.ROWS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Reference_modelContext:ParserRuleContext {
		open func REFERENCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REFERENCE.rawValue, 0) }
		open func reference_model_name() -> Reference_model_nameContext? {
			return getRuleContext(Reference_model_nameContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(plsqlParser.Tokens.ON.rawValue, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func model_column_clauses() -> Model_column_clausesContext? {
			return getRuleContext(Model_column_clausesContext.self,0)
		}
		open func cell_reference_options() -> Array<Cell_reference_optionsContext> {
			return getRuleContexts(Cell_reference_optionsContext.self)
		}
		open func cell_reference_options(_ i: Int) -> Cell_reference_optionsContext? {
			return getRuleContext(Cell_reference_optionsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_reference_model }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReference_model(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReference_model(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReference_model(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReference_model(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reference_model() throws -> Reference_modelContext {
		var _localctx: Reference_modelContext = Reference_modelContext(_ctx, getState())
		try enterRule(_localctx, 388, plsqlParser.RULE_reference_model)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3245)
		 	try match(plsqlParser.Tokens.REFERENCE.rawValue)
		 	setState(3246)
		 	try reference_model_name()
		 	setState(3247)
		 	try match(plsqlParser.Tokens.ON.rawValue)
		 	setState(3248)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3249)
		 	try subquery()
		 	setState(3250)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(3251)
		 	try model_column_clauses()
		 	setState(3255)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.IGNORE.rawValue || _la == plsqlParser.Tokens.KEEP.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.UNIQUE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3252)
		 		try cell_reference_options()


		 		setState(3257)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Main_modelContext:ParserRuleContext {
		open func model_column_clauses() -> Model_column_clausesContext? {
			return getRuleContext(Model_column_clausesContext.self,0)
		}
		open func model_rules_clause() -> Model_rules_clauseContext? {
			return getRuleContext(Model_rules_clauseContext.self,0)
		}
		open func MAIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.MAIN.rawValue, 0) }
		open func main_model_name() -> Main_model_nameContext? {
			return getRuleContext(Main_model_nameContext.self,0)
		}
		open func cell_reference_options() -> Array<Cell_reference_optionsContext> {
			return getRuleContexts(Cell_reference_optionsContext.self)
		}
		open func cell_reference_options(_ i: Int) -> Cell_reference_optionsContext? {
			return getRuleContext(Cell_reference_optionsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_main_model }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMain_model(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMain_model(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMain_model(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMain_model(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func main_model() throws -> Main_modelContext {
		var _localctx: Main_modelContext = Main_modelContext(_ctx, getState())
		try enterRule(_localctx, 390, plsqlParser.RULE_main_model)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3260)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.MAIN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3258)
		 		try match(plsqlParser.Tokens.MAIN.rawValue)
		 		setState(3259)
		 		try main_model_name()

		 	}

		 	setState(3262)
		 	try model_column_clauses()
		 	setState(3266)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.IGNORE.rawValue || _la == plsqlParser.Tokens.KEEP.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.UNIQUE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3263)
		 		try cell_reference_options()


		 		setState(3268)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3269)
		 	try model_rules_clause()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_column_clausesContext:ParserRuleContext {
		open func DIMENSION() -> TerminalNode? { return getToken(plsqlParser.Tokens.DIMENSION.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func model_column_list() -> Array<Model_column_listContext> {
			return getRuleContexts(Model_column_listContext.self)
		}
		open func model_column_list(_ i: Int) -> Model_column_listContext? {
			return getRuleContext(Model_column_listContext.self,i)
		}
		open func MEASURES() -> TerminalNode? { return getToken(plsqlParser.Tokens.MEASURES.rawValue, 0) }
		open func model_column_partition_part() -> Model_column_partition_partContext? {
			return getRuleContext(Model_column_partition_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_column_clauses }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_column_clauses(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_column_clauses(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_column_clauses(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_column_clauses(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_column_clauses() throws -> Model_column_clausesContext {
		var _localctx: Model_column_clausesContext = Model_column_clausesContext(_ctx, getState())
		try enterRule(_localctx, 392, plsqlParser.RULE_model_column_clauses)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3272)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PARTITION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3271)
		 		try model_column_partition_part()

		 	}

		 	setState(3274)
		 	try match(plsqlParser.Tokens.DIMENSION.rawValue)
		 	setState(3275)
		 	try match(plsqlParser.Tokens.BY.rawValue)
		 	setState(3276)
		 	try model_column_list()
		 	setState(3277)
		 	try match(plsqlParser.Tokens.MEASURES.rawValue)
		 	setState(3278)
		 	try model_column_list()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_column_partition_partContext:ParserRuleContext {
		open func PARTITION() -> TerminalNode? { return getToken(plsqlParser.Tokens.PARTITION.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func model_column_list() -> Model_column_listContext? {
			return getRuleContext(Model_column_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_column_partition_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_column_partition_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_column_partition_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_column_partition_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_column_partition_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_column_partition_part() throws -> Model_column_partition_partContext {
		var _localctx: Model_column_partition_partContext = Model_column_partition_partContext(_ctx, getState())
		try enterRule(_localctx, 394, plsqlParser.RULE_model_column_partition_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3280)
		 	try match(plsqlParser.Tokens.PARTITION.rawValue)
		 	setState(3281)
		 	try match(plsqlParser.Tokens.BY.rawValue)
		 	setState(3282)
		 	try model_column_list()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_column_listContext:ParserRuleContext {
		open func model_column() -> Array<Model_columnContext> {
			return getRuleContexts(Model_columnContext.self)
		}
		open func model_column(_ i: Int) -> Model_columnContext? {
			return getRuleContext(Model_columnContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_column_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_column_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_column_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_column_list(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_column_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_column_list() throws -> Model_column_listContext {
		var _localctx: Model_column_listContext = Model_column_listContext(_ctx, getState())
		try enterRule(_localctx, 396, plsqlParser.RULE_model_column_list)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3284)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3285)
		 	try model_column()
		 	setState(3290)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3286)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(3287)
		 		try model_column()


		 		setState(3292)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3293)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_columnContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func query_block() -> Query_blockContext? {
			return getRuleContext(Query_blockContext.self,0)
		}
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_column }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_column(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_column(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_column(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_column(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_column() throws -> Model_columnContext {
		var _localctx: Model_columnContext = Model_columnContext(_ctx, getState())
		try enterRule(_localctx, 398, plsqlParser.RULE_model_column)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3297)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALL:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ANY:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CASE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COALESCE:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONNECT_BY_ROOT:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DISTINCT:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXISTS:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FALSE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NOT:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .PRIOR:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .DECODE:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NVL:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .TO_CHAR:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case .UNSIGNED_INTEGER:fallthrough
		 	case .APPROXIMATE_NUM_LIT:fallthrough
		 	case .CHAR_STRING:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .LEFT_PAREN:fallthrough
		 	case .PLUS_SIGN:fallthrough
		 	case .MINUS_SIGN:fallthrough
		 	case .BINDVAR:fallthrough
		 	case .COLON:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(3295)
		 		try expression()

		 		break

		 	case .SELECT:
		 		setState(3296)
		 		try query_block()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3300)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.AS.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3299)
		 		try column_alias()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_rules_clauseContext:ParserRuleContext {
		open func model_rules_part() -> Model_rules_partContext? {
			return getRuleContext(Model_rules_partContext.self,0)
		}
		open func model_rules_element() -> Array<Model_rules_elementContext> {
			return getRuleContexts(Model_rules_elementContext.self)
		}
		open func model_rules_element(_ i: Int) -> Model_rules_elementContext? {
			return getRuleContext(Model_rules_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_rules_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_rules_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_rules_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_rules_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_rules_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_rules_clause() throws -> Model_rules_clauseContext {
		var _localctx: Model_rules_clauseContext = Model_rules_clauseContext(_ctx, getState())
		try enterRule(_localctx, 400, plsqlParser.RULE_model_rules_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3303)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RULES.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3302)
		 		try model_rules_part()

		 	}

		 	setState(3305)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3314)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ALL.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ANY.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CASE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COALESCE.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONNECT_BY_ROOT.rawValue,plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DATE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DISTINCT.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTION_INIT.rawValue,plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXISTS.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FALSE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LANGUAGE.rawValue,plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULL.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OBJECT.rawValue,plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PRIOR.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 257)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.RIGHT.rawValue,plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUE.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATE.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YES.rawValue,plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.DECODE.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.NVL.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROUND.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.SUBSTR.rawValue,plsqlParser.Tokens.TO_CHAR.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue,plsqlParser.Tokens.APPROXIMATE_NUM_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue,plsqlParser.Tokens.LEFT_PAREN.rawValue,plsqlParser.Tokens.PLUS_SIGN.rawValue,plsqlParser.Tokens.MINUS_SIGN.rawValue,plsqlParser.Tokens.BINDVAR.rawValue,plsqlParser.Tokens.COLON.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3306)
		 		try model_rules_element()
		 		setState(3311)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3307)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(3308)
		 			try model_rules_element()


		 			setState(3313)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(3316)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_rules_partContext:ParserRuleContext {
		open func RULES() -> TerminalNode? { return getToken(plsqlParser.Tokens.RULES.rawValue, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func UPSERT() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPSERT.rawValue, 0) }
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ORDER.rawValue, 0) }
		open func model_iterate_clause() -> Model_iterate_clauseContext? {
			return getRuleContext(Model_iterate_clauseContext.self,0)
		}
		open func AUTOMATIC() -> TerminalNode? { return getToken(plsqlParser.Tokens.AUTOMATIC.rawValue, 0) }
		open func SEQUENTIAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.SEQUENTIAL.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_rules_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_rules_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_rules_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_rules_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_rules_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_rules_part() throws -> Model_rules_partContext {
		var _localctx: Model_rules_partContext = Model_rules_partContext(_ctx, getState())
		try enterRule(_localctx, 402, plsqlParser.RULE_model_rules_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3318)
		 	try match(plsqlParser.Tokens.RULES.rawValue)
		 	setState(3324)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .UPDATE:
		 	 	setState(3319)
		 	 	try match(plsqlParser.Tokens.UPDATE.rawValue)

		 		break

		 	case .UPSERT:
		 	 	setState(3320)
		 	 	try match(plsqlParser.Tokens.UPSERT.rawValue)
		 	 	setState(3322)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (//closure
		 	 	 { () -> Bool in
		 	 	      let testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue
		 	 	      return testSet
		 	 	 }()) {
		 	 		setState(3321)
		 	 		try match(plsqlParser.Tokens.ALL.rawValue)

		 	 	}


		 		break
		 	case .AUTOMATIC:fallthrough
		 	case .ITERATE:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .LEFT_PAREN:
		 		break
		 	default:
		 		break
		 	}
		 	setState(3328)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.AUTOMATIC.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.SEQUENTIAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3326)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.AUTOMATIC.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.SEQUENTIAL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3327)
		 		try match(plsqlParser.Tokens.ORDER.rawValue)

		 	}

		 	setState(3331)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.ITERATE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3330)
		 		try model_iterate_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_rules_elementContext:ParserRuleContext {
		open func cell_assignment() -> Cell_assignmentContext? {
			return getRuleContext(Cell_assignmentContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func UPSERT() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPSERT.rawValue, 0) }
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_rules_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_rules_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_rules_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_rules_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_rules_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_rules_element() throws -> Model_rules_elementContext {
		var _localctx: Model_rules_elementContext = Model_rules_elementContext(_ctx, getState())
		try enterRule(_localctx, 404, plsqlParser.RULE_model_rules_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3338)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,384,_ctx)) {
		 	case 1:
		 		setState(3333)
		 		try match(plsqlParser.Tokens.UPDATE.rawValue)

		 		break
		 	case 2:
		 		setState(3334)
		 		try match(plsqlParser.Tokens.UPSERT.rawValue)
		 		setState(3336)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,383,_ctx)) {
		 		case 1:
		 			setState(3335)
		 			try match(plsqlParser.Tokens.ALL.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		 	setState(3340)
		 	try cell_assignment()
		 	setState(3342)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.ORDER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3341)
		 		try order_by_clause()

		 	}

		 	setState(3344)
		 	try match(plsqlParser.Tokens.EQUALS_OP.rawValue)
		 	setState(3345)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cell_assignmentContext:ParserRuleContext {
		open func model_expression() -> Model_expressionContext? {
			return getRuleContext(Model_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cell_assignment }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCell_assignment(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCell_assignment(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCell_assignment(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCell_assignment(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cell_assignment() throws -> Cell_assignmentContext {
		var _localctx: Cell_assignmentContext = Cell_assignmentContext(_ctx, getState())
		try enterRule(_localctx, 406, plsqlParser.RULE_cell_assignment)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3347)
		 	try model_expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_iterate_clauseContext:ParserRuleContext {
		open func ITERATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ITERATE.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func until_part() -> Until_partContext? {
			return getRuleContext(Until_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_iterate_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_iterate_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_iterate_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_iterate_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_iterate_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_iterate_clause() throws -> Model_iterate_clauseContext {
		var _localctx: Model_iterate_clauseContext = Model_iterate_clauseContext(_ctx, getState())
		try enterRule(_localctx, 408, plsqlParser.RULE_model_iterate_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3349)
		 	try match(plsqlParser.Tokens.ITERATE.rawValue)
		 	setState(3350)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3351)
		 	try expression()
		 	setState(3352)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(3354)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.UNTIL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3353)
		 		try until_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Until_partContext:ParserRuleContext {
		open func UNTIL() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNTIL.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_until_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUntil_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUntil_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUntil_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUntil_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func until_part() throws -> Until_partContext {
		var _localctx: Until_partContext = Until_partContext(_ctx, getState())
		try enterRule(_localctx, 410, plsqlParser.RULE_until_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3356)
		 	try match(plsqlParser.Tokens.UNTIL.rawValue)
		 	setState(3357)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3358)
		 	try condition()
		 	setState(3359)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Order_by_clauseContext:ParserRuleContext {
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ORDER.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func order_by_elements() -> Array<Order_by_elementsContext> {
			return getRuleContexts(Order_by_elementsContext.self)
		}
		open func order_by_elements(_ i: Int) -> Order_by_elementsContext? {
			return getRuleContext(Order_by_elementsContext.self,i)
		}
		open func SIBLINGS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SIBLINGS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_order_by_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOrder_by_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOrder_by_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOrder_by_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOrder_by_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func order_by_clause() throws -> Order_by_clauseContext {
		var _localctx: Order_by_clauseContext = Order_by_clauseContext(_ctx, getState())
		try enterRule(_localctx, 412, plsqlParser.RULE_order_by_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3361)
		 	try match(plsqlParser.Tokens.ORDER.rawValue)
		 	setState(3363)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.SIBLINGS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3362)
		 		try match(plsqlParser.Tokens.SIBLINGS.rawValue)

		 	}

		 	setState(3365)
		 	try match(plsqlParser.Tokens.BY.rawValue)
		 	setState(3366)
		 	try order_by_elements()
		 	setState(3371)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3367)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(3368)
		 		try order_by_elements()


		 		setState(3373)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Order_by_elementsContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func NULLS() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULLS.rawValue, 0) }
		open func ASC() -> TerminalNode? { return getToken(plsqlParser.Tokens.ASC.rawValue, 0) }
		open func DESC() -> TerminalNode? { return getToken(plsqlParser.Tokens.DESC.rawValue, 0) }
		open func FIRST() -> TerminalNode? { return getToken(plsqlParser.Tokens.FIRST.rawValue, 0) }
		open func LAST() -> TerminalNode? { return getToken(plsqlParser.Tokens.LAST.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_order_by_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOrder_by_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOrder_by_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOrder_by_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOrder_by_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func order_by_elements() throws -> Order_by_elementsContext {
		var _localctx: Order_by_elementsContext = Order_by_elementsContext(_ctx, getState())
		try enterRule(_localctx, 414, plsqlParser.RULE_order_by_elements)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3374)
		 	try expression()
		 	setState(3376)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.ASC.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.DESC.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3375)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.ASC.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.DESC.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3380)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.NULLS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3378)
		 		try match(plsqlParser.Tokens.NULLS.rawValue)
		 		setState(3379)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.FIRST.rawValue || _la == plsqlParser.Tokens.LAST.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_update_clauseContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOR.rawValue, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func for_update_of_part() -> For_update_of_partContext? {
			return getRuleContext(For_update_of_partContext.self,0)
		}
		open func for_update_options() -> For_update_optionsContext? {
			return getRuleContext(For_update_optionsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_update_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_update_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_update_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_update_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_update_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_update_clause() throws -> For_update_clauseContext {
		var _localctx: For_update_clauseContext = For_update_clauseContext(_ctx, getState())
		try enterRule(_localctx, 416, plsqlParser.RULE_for_update_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3382)
		 	try match(plsqlParser.Tokens.FOR.rawValue)
		 	setState(3383)
		 	try match(plsqlParser.Tokens.UPDATE.rawValue)
		 	setState(3385)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.OF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3384)
		 		try for_update_of_part()

		 	}

		 	setState(3388)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.NOWAIT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.SKIP_.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.WAIT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3387)
		 		try for_update_options()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_update_of_partContext:ParserRuleContext {
		open func OF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OF.rawValue, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_update_of_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_update_of_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_update_of_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_update_of_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_update_of_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_update_of_part() throws -> For_update_of_partContext {
		var _localctx: For_update_of_partContext = For_update_of_partContext(_ctx, getState())
		try enterRule(_localctx, 418, plsqlParser.RULE_for_update_of_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3390)
		 	try match(plsqlParser.Tokens.OF.rawValue)
		 	setState(3391)
		 	try column_name()
		 	setState(3396)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3392)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(3393)
		 		try column_name()


		 		setState(3398)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_update_optionsContext:ParserRuleContext {
		open func SKIP_() -> TerminalNode? { return getToken(plsqlParser.Tokens.SKIP_.rawValue, 0) }
		open func LOCKED() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOCKED.rawValue, 0) }
		open func NOWAIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOWAIT.rawValue, 0) }
		open func WAIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.WAIT.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_update_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_update_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_update_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_update_options(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_update_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_update_options() throws -> For_update_optionsContext {
		var _localctx: For_update_optionsContext = For_update_optionsContext(_ctx, getState())
		try enterRule(_localctx, 420, plsqlParser.RULE_for_update_options)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3404)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SKIP_:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3399)
		 		try match(plsqlParser.Tokens.SKIP_.rawValue)
		 		setState(3400)
		 		try match(plsqlParser.Tokens.LOCKED.rawValue)

		 		break

		 	case .NOWAIT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3401)
		 		try match(plsqlParser.Tokens.NOWAIT.rawValue)

		 		break

		 	case .WAIT:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3402)
		 		try match(plsqlParser.Tokens.WAIT.rawValue)
		 		setState(3403)
		 		try expression()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Update_statementContext:ParserRuleContext {
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func general_table_ref() -> General_table_refContext? {
			return getRuleContext(General_table_refContext.self,0)
		}
		open func update_set_clause() -> Update_set_clauseContext? {
			return getRuleContext(Update_set_clauseContext.self,0)
		}
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open func static_returning_clause() -> Static_returning_clauseContext? {
			return getRuleContext(Static_returning_clauseContext.self,0)
		}
		open func error_logging_clause() -> Error_logging_clauseContext? {
			return getRuleContext(Error_logging_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_update_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUpdate_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUpdate_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUpdate_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUpdate_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func update_statement() throws -> Update_statementContext {
		var _localctx: Update_statementContext = Update_statementContext(_ctx, getState())
		try enterRule(_localctx, 422, plsqlParser.RULE_update_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3406)
		 	try match(plsqlParser.Tokens.UPDATE.rawValue)
		 	setState(3407)
		 	try general_table_ref()
		 	setState(3408)
		 	try update_set_clause()
		 	setState(3410)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WHERE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3409)
		 		try where_clause()

		 	}

		 	setState(3413)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RETURN.rawValue || _la == plsqlParser.Tokens.RETURNING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3412)
		 		try static_returning_clause()

		 	}

		 	setState(3416)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LOG.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3415)
		 		try error_logging_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Update_set_clauseContext:ParserRuleContext {
		open func SET() -> TerminalNode? { return getToken(plsqlParser.Tokens.SET.rawValue, 0) }
		open func column_based_update_set_clause() -> Array<Column_based_update_set_clauseContext> {
			return getRuleContexts(Column_based_update_set_clauseContext.self)
		}
		open func column_based_update_set_clause(_ i: Int) -> Column_based_update_set_clauseContext? {
			return getRuleContext(Column_based_update_set_clauseContext.self,i)
		}
		open func VALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.VALUE.rawValue, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_update_set_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUpdate_set_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUpdate_set_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUpdate_set_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUpdate_set_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func update_set_clause() throws -> Update_set_clauseContext {
		var _localctx: Update_set_clauseContext = Update_set_clauseContext(_ctx, getState())
		try enterRule(_localctx, 424, plsqlParser.RULE_update_set_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3418)
		 	try match(plsqlParser.Tokens.SET.rawValue)
		 	setState(3434)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,399, _ctx)) {
		 	case 1:
		 		setState(3419)
		 		try column_based_update_set_clause()
		 		setState(3424)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3420)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(3421)
		 			try column_based_update_set_clause()


		 			setState(3426)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		setState(3427)
		 		try match(plsqlParser.Tokens.VALUE.rawValue)
		 		setState(3428)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3429)
		 		try identifier()
		 		setState(3430)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(3431)
		 		try match(plsqlParser.Tokens.EQUALS_OP.rawValue)
		 		setState(3432)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_based_update_set_clauseContext:ParserRuleContext {
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_column_based_update_set_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterColumn_based_update_set_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitColumn_based_update_set_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitColumn_based_update_set_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitColumn_based_update_set_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_based_update_set_clause() throws -> Column_based_update_set_clauseContext {
		var _localctx: Column_based_update_set_clauseContext = Column_based_update_set_clauseContext(_ctx, getState())
		try enterRule(_localctx, 426, plsqlParser.RULE_column_based_update_set_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3453)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3436)
		 		try column_name()
		 		setState(3437)
		 		try match(plsqlParser.Tokens.EQUALS_OP.rawValue)
		 		setState(3438)
		 		try expression()

		 		break

		 	case .LEFT_PAREN:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3440)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3441)
		 		try column_name()
		 		setState(3446)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3442)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(3443)
		 			try column_name()


		 			setState(3448)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3449)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(3450)
		 		try match(plsqlParser.Tokens.EQUALS_OP.rawValue)
		 		setState(3451)
		 		try subquery()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Delete_statementContext:ParserRuleContext {
		open func DELETE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DELETE.rawValue, 0) }
		open func general_table_ref() -> General_table_refContext? {
			return getRuleContext(General_table_refContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(plsqlParser.Tokens.FROM.rawValue, 0) }
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open func static_returning_clause() -> Static_returning_clauseContext? {
			return getRuleContext(Static_returning_clauseContext.self,0)
		}
		open func error_logging_clause() -> Error_logging_clauseContext? {
			return getRuleContext(Error_logging_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_delete_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDelete_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDelete_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDelete_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDelete_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func delete_statement() throws -> Delete_statementContext {
		var _localctx: Delete_statementContext = Delete_statementContext(_ctx, getState())
		try enterRule(_localctx, 428, plsqlParser.RULE_delete_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3455)
		 	try match(plsqlParser.Tokens.DELETE.rawValue)
		 	setState(3457)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.FROM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3456)
		 		try match(plsqlParser.Tokens.FROM.rawValue)

		 	}

		 	setState(3459)
		 	try general_table_ref()
		 	setState(3461)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WHERE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3460)
		 		try where_clause()

		 	}

		 	setState(3464)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RETURN.rawValue || _la == plsqlParser.Tokens.RETURNING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3463)
		 		try static_returning_clause()

		 	}

		 	setState(3467)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LOG.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3466)
		 		try error_logging_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Insert_statementContext:ParserRuleContext {
		open func INSERT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INSERT.rawValue, 0) }
		open func single_table_insert() -> Single_table_insertContext? {
			return getRuleContext(Single_table_insertContext.self,0)
		}
		open func multi_table_insert() -> Multi_table_insertContext? {
			return getRuleContext(Multi_table_insertContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_insert_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterInsert_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitInsert_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitInsert_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitInsert_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func insert_statement() throws -> Insert_statementContext {
		var _localctx: Insert_statementContext = Insert_statementContext(_ctx, getState())
		try enterRule(_localctx, 430, plsqlParser.RULE_insert_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3469)
		 	try match(plsqlParser.Tokens.INSERT.rawValue)
		 	setState(3472)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .INTO:
		 		setState(3470)
		 		try single_table_insert()

		 		break
		 	case .ALL:fallthrough
		 	case .FIRST:fallthrough
		 	case .WHEN:
		 		setState(3471)
		 		try multi_table_insert()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Single_table_insertContext:ParserRuleContext {
		open func insert_into_clause() -> Insert_into_clauseContext? {
			return getRuleContext(Insert_into_clauseContext.self,0)
		}
		open func values_clause() -> Values_clauseContext? {
			return getRuleContext(Values_clauseContext.self,0)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func error_logging_clause() -> Error_logging_clauseContext? {
			return getRuleContext(Error_logging_clauseContext.self,0)
		}
		open func static_returning_clause() -> Static_returning_clauseContext? {
			return getRuleContext(Static_returning_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_single_table_insert }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSingle_table_insert(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSingle_table_insert(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSingle_table_insert(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSingle_table_insert(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func single_table_insert() throws -> Single_table_insertContext {
		var _localctx: Single_table_insertContext = Single_table_insertContext(_ctx, getState())
		try enterRule(_localctx, 432, plsqlParser.RULE_single_table_insert)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3474)
		 	try insert_into_clause()
		 	setState(3480)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .VALUES:
		 		setState(3475)
		 		try values_clause()
		 		setState(3477)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.RETURN.rawValue || _la == plsqlParser.Tokens.RETURNING.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3476)
		 			try static_returning_clause()

		 		}


		 		break
		 	case .SELECT:fallthrough
		 	case .WITH:fallthrough
		 	case .LEFT_PAREN:
		 		setState(3479)
		 		try select_statement()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3483)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LOG.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3482)
		 		try error_logging_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multi_table_insertContext:ParserRuleContext {
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open func conditional_insert_clause() -> Conditional_insert_clauseContext? {
			return getRuleContext(Conditional_insert_clauseContext.self,0)
		}
		open func multi_table_element() -> Array<Multi_table_elementContext> {
			return getRuleContexts(Multi_table_elementContext.self)
		}
		open func multi_table_element(_ i: Int) -> Multi_table_elementContext? {
			return getRuleContext(Multi_table_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multi_table_insert }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMulti_table_insert(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMulti_table_insert(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMulti_table_insert(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMulti_table_insert(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multi_table_insert() throws -> Multi_table_insertContext {
		var _localctx: Multi_table_insertContext = Multi_table_insertContext(_ctx, getState())
		try enterRule(_localctx, 434, plsqlParser.RULE_multi_table_insert)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3492)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,411, _ctx)) {
		 	case 1:
		 		setState(3485)
		 		try match(plsqlParser.Tokens.ALL.rawValue)
		 		setState(3487) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(3486)
		 			try multi_table_element()


		 			setState(3489); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.INTO.rawValue
		 		      return testSet
		 		 }())

		 		break
		 	case 2:
		 		setState(3491)
		 		try conditional_insert_clause()

		 		break
		 	default: break
		 	}
		 	setState(3494)
		 	try select_statement()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multi_table_elementContext:ParserRuleContext {
		open func insert_into_clause() -> Insert_into_clauseContext? {
			return getRuleContext(Insert_into_clauseContext.self,0)
		}
		open func values_clause() -> Values_clauseContext? {
			return getRuleContext(Values_clauseContext.self,0)
		}
		open func error_logging_clause() -> Error_logging_clauseContext? {
			return getRuleContext(Error_logging_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multi_table_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMulti_table_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMulti_table_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMulti_table_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMulti_table_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multi_table_element() throws -> Multi_table_elementContext {
		var _localctx: Multi_table_elementContext = Multi_table_elementContext(_ctx, getState())
		try enterRule(_localctx, 436, plsqlParser.RULE_multi_table_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3496)
		 	try insert_into_clause()
		 	setState(3498)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.VALUES.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3497)
		 		try values_clause()

		 	}

		 	setState(3501)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LOG.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3500)
		 		try error_logging_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Conditional_insert_clauseContext:ParserRuleContext {
		open func conditional_insert_when_part() -> Array<Conditional_insert_when_partContext> {
			return getRuleContexts(Conditional_insert_when_partContext.self)
		}
		open func conditional_insert_when_part(_ i: Int) -> Conditional_insert_when_partContext? {
			return getRuleContext(Conditional_insert_when_partContext.self,i)
		}
		open func conditional_insert_else_part() -> Conditional_insert_else_partContext? {
			return getRuleContext(Conditional_insert_else_partContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open func FIRST() -> TerminalNode? { return getToken(plsqlParser.Tokens.FIRST.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_conditional_insert_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConditional_insert_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConditional_insert_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConditional_insert_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConditional_insert_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func conditional_insert_clause() throws -> Conditional_insert_clauseContext {
		var _localctx: Conditional_insert_clauseContext = Conditional_insert_clauseContext(_ctx, getState())
		try enterRule(_localctx, 438, plsqlParser.RULE_conditional_insert_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3504)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.FIRST.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3503)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.FIRST.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3507) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3506)
		 		try conditional_insert_when_part()


		 		setState(3509); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WHEN.rawValue
		 	      return testSet
		 	 }())
		 	setState(3512)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.ELSE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3511)
		 		try conditional_insert_else_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Conditional_insert_when_partContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHEN.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.THEN.rawValue, 0) }
		open func multi_table_element() -> Array<Multi_table_elementContext> {
			return getRuleContexts(Multi_table_elementContext.self)
		}
		open func multi_table_element(_ i: Int) -> Multi_table_elementContext? {
			return getRuleContext(Multi_table_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_conditional_insert_when_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConditional_insert_when_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConditional_insert_when_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConditional_insert_when_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConditional_insert_when_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func conditional_insert_when_part() throws -> Conditional_insert_when_partContext {
		var _localctx: Conditional_insert_when_partContext = Conditional_insert_when_partContext(_ctx, getState())
		try enterRule(_localctx, 440, plsqlParser.RULE_conditional_insert_when_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3514)
		 	try match(plsqlParser.Tokens.WHEN.rawValue)
		 	setState(3515)
		 	try condition()
		 	setState(3516)
		 	try match(plsqlParser.Tokens.THEN.rawValue)
		 	setState(3518) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3517)
		 		try multi_table_element()


		 		setState(3520); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Conditional_insert_else_partContext:ParserRuleContext {
		open func ELSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ELSE.rawValue, 0) }
		open func multi_table_element() -> Array<Multi_table_elementContext> {
			return getRuleContexts(Multi_table_elementContext.self)
		}
		open func multi_table_element(_ i: Int) -> Multi_table_elementContext? {
			return getRuleContext(Multi_table_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_conditional_insert_else_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConditional_insert_else_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConditional_insert_else_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConditional_insert_else_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConditional_insert_else_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func conditional_insert_else_part() throws -> Conditional_insert_else_partContext {
		var _localctx: Conditional_insert_else_partContext = Conditional_insert_else_partContext(_ctx, getState())
		try enterRule(_localctx, 442, plsqlParser.RULE_conditional_insert_else_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3522)
		 	try match(plsqlParser.Tokens.ELSE.rawValue)
		 	setState(3524) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(3523)
		 		try multi_table_element()


		 		setState(3526); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }())

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Insert_into_clauseContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTO.rawValue, 0) }
		open func general_table_ref() -> General_table_refContext? {
			return getRuleContext(General_table_refContext.self,0)
		}
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_insert_into_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterInsert_into_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitInsert_into_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitInsert_into_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitInsert_into_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func insert_into_clause() throws -> Insert_into_clauseContext {
		var _localctx: Insert_into_clauseContext = Insert_into_clauseContext(_ctx, getState())
		try enterRule(_localctx, 444, plsqlParser.RULE_insert_into_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3528)
		 	try match(plsqlParser.Tokens.INTO.rawValue)
		 	setState(3529)
		 	try general_table_ref()
		 	setState(3541)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,420,_ctx)) {
		 	case 1:
		 		setState(3530)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3531)
		 		try column_name()
		 		setState(3536)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3532)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(3533)
		 			try column_name()


		 			setState(3538)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3539)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Values_clauseContext:ParserRuleContext {
		open func VALUES() -> TerminalNode? { return getToken(plsqlParser.Tokens.VALUES.rawValue, 0) }
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_values_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterValues_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitValues_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitValues_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitValues_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func values_clause() throws -> Values_clauseContext {
		var _localctx: Values_clauseContext = Values_clauseContext(_ctx, getState())
		try enterRule(_localctx, 446, plsqlParser.RULE_values_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3543)
		 	try match(plsqlParser.Tokens.VALUES.rawValue)
		 	setState(3544)
		 	try expression_list()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_statementContext:ParserRuleContext {
		open func MERGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.MERGE.rawValue, 0) }
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTO.rawValue, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func USING() -> TerminalNode? { return getToken(plsqlParser.Tokens.USING.rawValue, 0) }
		open func selected_tableview() -> Selected_tableviewContext? {
			return getRuleContext(Selected_tableviewContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(plsqlParser.Tokens.ON.rawValue, 0) }
		open func condition() -> ConditionContext? {
			return getRuleContext(ConditionContext.self,0)
		}
		open func table_alias() -> Table_aliasContext? {
			return getRuleContext(Table_aliasContext.self,0)
		}
		open func merge_update_clause() -> Merge_update_clauseContext? {
			return getRuleContext(Merge_update_clauseContext.self,0)
		}
		open func merge_insert_clause() -> Merge_insert_clauseContext? {
			return getRuleContext(Merge_insert_clauseContext.self,0)
		}
		open func error_logging_clause() -> Error_logging_clauseContext? {
			return getRuleContext(Error_logging_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_merge_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMerge_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMerge_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMerge_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMerge_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_statement() throws -> Merge_statementContext {
		var _localctx: Merge_statementContext = Merge_statementContext(_ctx, getState())
		try enterRule(_localctx, 448, plsqlParser.RULE_merge_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3546)
		 	try match(plsqlParser.Tokens.MERGE.rawValue)
		 	setState(3547)
		 	try match(plsqlParser.Tokens.INTO.rawValue)
		 	setState(3548)
		 	try tableview_name()
		 	setState(3550)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3549)
		 		try table_alias()

		 	}

		 	setState(3552)
		 	try match(plsqlParser.Tokens.USING.rawValue)
		 	setState(3553)
		 	try selected_tableview()
		 	setState(3554)
		 	try match(plsqlParser.Tokens.ON.rawValue)
		 	setState(3555)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3556)
		 	try condition()
		 	setState(3557)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(3566)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,424,_ctx)) {
		 	case 1:
		 		setState(3558)
		 		try merge_update_clause()
		 		setState(3560)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.WHEN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3559)
		 			try merge_insert_clause()

		 		}


		 		break
		 	case 2:
		 		setState(3562)
		 		try merge_insert_clause()
		 		setState(3564)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.WHEN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3563)
		 			try merge_update_clause()

		 		}


		 		break
		 	default: break
		 	}
		 	setState(3569)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LOG.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3568)
		 		try error_logging_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_update_clauseContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHEN.rawValue, 0) }
		open func MATCHED() -> TerminalNode? { return getToken(plsqlParser.Tokens.MATCHED.rawValue, 0) }
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.THEN.rawValue, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func SET() -> TerminalNode? { return getToken(plsqlParser.Tokens.SET.rawValue, 0) }
		open func merge_element() -> Array<Merge_elementContext> {
			return getRuleContexts(Merge_elementContext.self)
		}
		open func merge_element(_ i: Int) -> Merge_elementContext? {
			return getRuleContext(Merge_elementContext.self,i)
		}
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open func merge_update_delete_part() -> Merge_update_delete_partContext? {
			return getRuleContext(Merge_update_delete_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_merge_update_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMerge_update_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMerge_update_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMerge_update_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMerge_update_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_update_clause() throws -> Merge_update_clauseContext {
		var _localctx: Merge_update_clauseContext = Merge_update_clauseContext(_ctx, getState())
		try enterRule(_localctx, 450, plsqlParser.RULE_merge_update_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3571)
		 	try match(plsqlParser.Tokens.WHEN.rawValue)
		 	setState(3572)
		 	try match(plsqlParser.Tokens.MATCHED.rawValue)
		 	setState(3573)
		 	try match(plsqlParser.Tokens.THEN.rawValue)
		 	setState(3574)
		 	try match(plsqlParser.Tokens.UPDATE.rawValue)
		 	setState(3575)
		 	try match(plsqlParser.Tokens.SET.rawValue)
		 	setState(3576)
		 	try merge_element()
		 	setState(3581)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3577)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(3578)
		 		try merge_element()


		 		setState(3583)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3585)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WHERE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3584)
		 		try where_clause()

		 	}

		 	setState(3588)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,428,_ctx)) {
		 	case 1:
		 		setState(3587)
		 		try merge_update_delete_part()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_elementContext:ParserRuleContext {
		open func column_name() -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_merge_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMerge_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMerge_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMerge_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMerge_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_element() throws -> Merge_elementContext {
		var _localctx: Merge_elementContext = Merge_elementContext(_ctx, getState())
		try enterRule(_localctx, 452, plsqlParser.RULE_merge_element)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3590)
		 	try column_name()
		 	setState(3591)
		 	try match(plsqlParser.Tokens.EQUALS_OP.rawValue)
		 	setState(3592)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_update_delete_partContext:ParserRuleContext {
		open func DELETE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DELETE.rawValue, 0) }
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_merge_update_delete_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMerge_update_delete_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMerge_update_delete_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMerge_update_delete_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMerge_update_delete_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_update_delete_part() throws -> Merge_update_delete_partContext {
		var _localctx: Merge_update_delete_partContext = Merge_update_delete_partContext(_ctx, getState())
		try enterRule(_localctx, 454, plsqlParser.RULE_merge_update_delete_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3594)
		 	try match(plsqlParser.Tokens.DELETE.rawValue)
		 	setState(3595)
		 	try where_clause()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_insert_clauseContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHEN.rawValue, 0) }
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT.rawValue, 0) }
		open func MATCHED() -> TerminalNode? { return getToken(plsqlParser.Tokens.MATCHED.rawValue, 0) }
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.THEN.rawValue, 0) }
		open func INSERT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INSERT.rawValue, 0) }
		open func VALUES() -> TerminalNode? { return getToken(plsqlParser.Tokens.VALUES.rawValue, 0) }
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func where_clause() -> Where_clauseContext? {
			return getRuleContext(Where_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_merge_insert_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMerge_insert_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMerge_insert_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMerge_insert_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMerge_insert_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_insert_clause() throws -> Merge_insert_clauseContext {
		var _localctx: Merge_insert_clauseContext = Merge_insert_clauseContext(_ctx, getState())
		try enterRule(_localctx, 456, plsqlParser.RULE_merge_insert_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3597)
		 	try match(plsqlParser.Tokens.WHEN.rawValue)
		 	setState(3598)
		 	try match(plsqlParser.Tokens.NOT.rawValue)
		 	setState(3599)
		 	try match(plsqlParser.Tokens.MATCHED.rawValue)
		 	setState(3600)
		 	try match(plsqlParser.Tokens.THEN.rawValue)
		 	setState(3601)
		 	try match(plsqlParser.Tokens.INSERT.rawValue)
		 	setState(3613)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3602)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3603)
		 		try column_name()
		 		setState(3608)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3604)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(3605)
		 			try column_name()


		 			setState(3610)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3611)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 	}

		 	setState(3615)
		 	try match(plsqlParser.Tokens.VALUES.rawValue)
		 	setState(3616)
		 	try expression_list()
		 	setState(3618)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WHERE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3617)
		 		try where_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Selected_tableviewContext:ParserRuleContext {
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func table_alias() -> Table_aliasContext? {
			return getRuleContext(Table_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_selected_tableview }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSelected_tableview(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSelected_tableview(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSelected_tableview(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSelected_tableview(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func selected_tableview() throws -> Selected_tableviewContext {
		var _localctx: Selected_tableviewContext = Selected_tableviewContext(_ctx, getState())
		try enterRule(_localctx, 458, plsqlParser.RULE_selected_tableview)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3625)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(3620)
		 		try tableview_name()

		 		break

		 	case .LEFT_PAREN:
		 		setState(3621)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3622)
		 		try select_statement()
		 		setState(3623)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3628)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3627)
		 		try table_alias()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Lock_table_statementContext:ParserRuleContext {
		open func LOCK() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOCK.rawValue, 0) }
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TABLE.rawValue, 0) }
		open func lock_table_element() -> Array<Lock_table_elementContext> {
			return getRuleContexts(Lock_table_elementContext.self)
		}
		open func lock_table_element(_ i: Int) -> Lock_table_elementContext? {
			return getRuleContext(Lock_table_elementContext.self,i)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func lock_mode() -> Lock_modeContext? {
			return getRuleContext(Lock_modeContext.self,0)
		}
		open func MODE() -> TerminalNode? { return getToken(plsqlParser.Tokens.MODE.rawValue, 0) }
		open func wait_nowait_part() -> Wait_nowait_partContext? {
			return getRuleContext(Wait_nowait_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_lock_table_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLock_table_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLock_table_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLock_table_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLock_table_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func lock_table_statement() throws -> Lock_table_statementContext {
		var _localctx: Lock_table_statementContext = Lock_table_statementContext(_ctx, getState())
		try enterRule(_localctx, 460, plsqlParser.RULE_lock_table_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3630)
		 	try match(plsqlParser.Tokens.LOCK.rawValue)
		 	setState(3631)
		 	try match(plsqlParser.Tokens.TABLE.rawValue)
		 	setState(3632)
		 	try lock_table_element()
		 	setState(3637)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3633)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(3634)
		 		try lock_table_element()


		 		setState(3639)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3640)
		 	try match(plsqlParser.Tokens.IN.rawValue)
		 	setState(3641)
		 	try lock_mode()
		 	setState(3642)
		 	try match(plsqlParser.Tokens.MODE.rawValue)
		 	setState(3644)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.NOWAIT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.WAIT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3643)
		 		try wait_nowait_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Wait_nowait_partContext:ParserRuleContext {
		open func WAIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.WAIT.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func NOWAIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOWAIT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_wait_nowait_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWait_nowait_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWait_nowait_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWait_nowait_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWait_nowait_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func wait_nowait_part() throws -> Wait_nowait_partContext {
		var _localctx: Wait_nowait_partContext = Wait_nowait_partContext(_ctx, getState())
		try enterRule(_localctx, 462, plsqlParser.RULE_wait_nowait_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3649)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .WAIT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3646)
		 		try match(plsqlParser.Tokens.WAIT.rawValue)
		 		setState(3647)
		 		try expression()

		 		break

		 	case .NOWAIT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3648)
		 		try match(plsqlParser.Tokens.NOWAIT.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Lock_table_elementContext:ParserRuleContext {
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func partition_extension_clause() -> Partition_extension_clauseContext? {
			return getRuleContext(Partition_extension_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_lock_table_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLock_table_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLock_table_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLock_table_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLock_table_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func lock_table_element() throws -> Lock_table_elementContext {
		var _localctx: Lock_table_elementContext = Lock_table_elementContext(_ctx, getState())
		try enterRule(_localctx, 464, plsqlParser.RULE_lock_table_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3651)
		 	try tableview_name()
		 	setState(3653)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.PARTITION.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.SUBPARTITION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3652)
		 		try partition_extension_clause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Lock_modeContext:ParserRuleContext {
		open func ROW() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROW.rawValue, 0) }
		open func SHARE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SHARE.rawValue, 0) }
		open func EXCLUSIVE() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXCLUSIVE.rawValue, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPDATE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_lock_mode }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLock_mode(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLock_mode(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLock_mode(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLock_mode(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func lock_mode() throws -> Lock_modeContext {
		var _localctx: Lock_modeContext = Lock_modeContext(_ctx, getState())
		try enterRule(_localctx, 466, plsqlParser.RULE_lock_mode)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3667)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,439, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3655)
		 		try match(plsqlParser.Tokens.ROW.rawValue)
		 		setState(3656)
		 		try match(plsqlParser.Tokens.SHARE.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3657)
		 		try match(plsqlParser.Tokens.ROW.rawValue)
		 		setState(3658)
		 		try match(plsqlParser.Tokens.EXCLUSIVE.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3659)
		 		try match(plsqlParser.Tokens.SHARE.rawValue)
		 		setState(3661)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.UPDATE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3660)
		 			try match(plsqlParser.Tokens.UPDATE.rawValue)

		 		}


		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3663)
		 		try match(plsqlParser.Tokens.SHARE.rawValue)
		 		setState(3664)
		 		try match(plsqlParser.Tokens.ROW.rawValue)
		 		setState(3665)
		 		try match(plsqlParser.Tokens.EXCLUSIVE.rawValue)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3666)
		 		try match(plsqlParser.Tokens.EXCLUSIVE.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class General_table_refContext:ParserRuleContext {
		open func dml_table_expression_clause() -> Dml_table_expression_clauseContext? {
			return getRuleContext(Dml_table_expression_clauseContext.self,0)
		}
		open func ONLY() -> TerminalNode? { return getToken(plsqlParser.Tokens.ONLY.rawValue, 0) }
		open func table_alias() -> Table_aliasContext? {
			return getRuleContext(Table_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_general_table_ref }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGeneral_table_ref(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGeneral_table_ref(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGeneral_table_ref(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGeneral_table_ref(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func general_table_ref() throws -> General_table_refContext {
		var _localctx: General_table_refContext = General_table_refContext(_ctx, getState())
		try enterRule(_localctx, 468, plsqlParser.RULE_general_table_ref)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3675)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,440, _ctx)) {
		 	case 1:
		 		setState(3669)
		 		try dml_table_expression_clause()

		 		break
		 	case 2:
		 		setState(3670)
		 		try match(plsqlParser.Tokens.ONLY.rawValue)
		 		setState(3671)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3672)
		 		try dml_table_expression_clause()
		 		setState(3673)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(3678)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,441,_ctx)) {
		 	case 1:
		 		setState(3677)
		 		try table_alias()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Static_returning_clauseContext:ParserRuleContext {
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func into_clause() -> Into_clauseContext? {
			return getRuleContext(Into_clauseContext.self,0)
		}
		open func RETURNING() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURNING.rawValue, 0) }
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_static_returning_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStatic_returning_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStatic_returning_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStatic_returning_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStatic_returning_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func static_returning_clause() throws -> Static_returning_clauseContext {
		var _localctx: Static_returning_clauseContext = Static_returning_clauseContext(_ctx, getState())
		try enterRule(_localctx, 470, plsqlParser.RULE_static_returning_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3680)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RETURN.rawValue || _la == plsqlParser.Tokens.RETURNING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3681)
		 	try expression()
		 	setState(3686)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3682)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(3683)
		 		try expression()


		 		setState(3688)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3689)
		 	try into_clause()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Error_logging_clauseContext:ParserRuleContext {
		open func LOG() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOG.rawValue, 0) }
		open func ERRORS() -> TerminalNode? { return getToken(plsqlParser.Tokens.ERRORS.rawValue, 0) }
		open func error_logging_into_part() -> Error_logging_into_partContext? {
			return getRuleContext(Error_logging_into_partContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func error_logging_reject_part() -> Error_logging_reject_partContext? {
			return getRuleContext(Error_logging_reject_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_error_logging_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterError_logging_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitError_logging_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitError_logging_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitError_logging_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func error_logging_clause() throws -> Error_logging_clauseContext {
		var _localctx: Error_logging_clauseContext = Error_logging_clauseContext(_ctx, getState())
		try enterRule(_localctx, 472, plsqlParser.RULE_error_logging_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3691)
		 	try match(plsqlParser.Tokens.LOG.rawValue)
		 	setState(3692)
		 	try match(plsqlParser.Tokens.ERRORS.rawValue)
		 	setState(3694)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,443,_ctx)) {
		 	case 1:
		 		setState(3693)
		 		try error_logging_into_part()

		 		break
		 	default: break
		 	}
		 	setState(3697)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,444,_ctx)) {
		 	case 1:
		 		setState(3696)
		 		try expression()

		 		break
		 	default: break
		 	}
		 	setState(3700)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.REJECT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3699)
		 		try error_logging_reject_part()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Error_logging_into_partContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTO.rawValue, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_error_logging_into_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterError_logging_into_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitError_logging_into_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitError_logging_into_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitError_logging_into_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func error_logging_into_part() throws -> Error_logging_into_partContext {
		var _localctx: Error_logging_into_partContext = Error_logging_into_partContext(_ctx, getState())
		try enterRule(_localctx, 474, plsqlParser.RULE_error_logging_into_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3702)
		 	try match(plsqlParser.Tokens.INTO.rawValue)
		 	setState(3703)
		 	try tableview_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Error_logging_reject_partContext:ParserRuleContext {
		open func REJECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.REJECT.rawValue, 0) }
		open func LIMIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIMIT.rawValue, 0) }
		open func UNLIMITED() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNLIMITED.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_error_logging_reject_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterError_logging_reject_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitError_logging_reject_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitError_logging_reject_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitError_logging_reject_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func error_logging_reject_part() throws -> Error_logging_reject_partContext {
		var _localctx: Error_logging_reject_partContext = Error_logging_reject_partContext(_ctx, getState())
		try enterRule(_localctx, 476, plsqlParser.RULE_error_logging_reject_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3705)
		 	try match(plsqlParser.Tokens.REJECT.rawValue)
		 	setState(3706)
		 	try match(plsqlParser.Tokens.LIMIT.rawValue)
		 	setState(3709)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,446, _ctx)) {
		 	case 1:
		 		setState(3707)
		 		try match(plsqlParser.Tokens.UNLIMITED.rawValue)

		 		break
		 	case 2:
		 		setState(3708)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_table_expression_clauseContext:ParserRuleContext {
		open func table_collection_expression() -> Table_collection_expressionContext? {
			return getRuleContext(Table_collection_expressionContext.self,0)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func subquery_restriction_clause() -> Subquery_restriction_clauseContext? {
			return getRuleContext(Subquery_restriction_clauseContext.self,0)
		}
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func sample_clause() -> Sample_clauseContext? {
			return getRuleContext(Sample_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_dml_table_expression_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDml_table_expression_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDml_table_expression_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDml_table_expression_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDml_table_expression_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_table_expression_clause() throws -> Dml_table_expression_clauseContext {
		var _localctx: Dml_table_expression_clauseContext = Dml_table_expression_clauseContext(_ctx, getState())
		try enterRule(_localctx, 478, plsqlParser.RULE_dml_table_expression_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3723)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .TABLE:fallthrough
		 	case .THE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3711)
		 		try table_collection_expression()

		 		break

		 	case .LEFT_PAREN:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3712)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3713)
		 		try select_statement()
		 		setState(3715)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.WITH.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3714)
		 			try subquery_restriction_clause()

		 		}

		 		setState(3717)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3719)
		 		try tableview_name()
		 		setState(3721)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,448,_ctx)) {
		 		case 1:
		 			setState(3720)
		 			try sample_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_collection_expressionContext:ParserRuleContext {
		open func TABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TABLE.rawValue, 0) }
		open func THE() -> TerminalNode? { return getToken(plsqlParser.Tokens.THE.rawValue, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_collection_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_collection_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_collection_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_collection_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_collection_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_collection_expression() throws -> Table_collection_expressionContext {
		var _localctx: Table_collection_expressionContext = Table_collection_expressionContext(_ctx, getState())
		try enterRule(_localctx, 480, plsqlParser.RULE_table_collection_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3725)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.TABLE.rawValue || _la == plsqlParser.Tokens.THE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3738)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,451, _ctx)) {
		 	case 1:
		 		setState(3726)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3727)
		 		try subquery()
		 		setState(3728)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 2:
		 		setState(3730)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3731)
		 		try expression()
		 		setState(3732)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(3736)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,450,_ctx)) {
		 		case 1:
		 			setState(3733)
		 			try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 			setState(3734)
		 			try match(plsqlParser.Tokens.PLUS_SIGN.rawValue)
		 			setState(3735)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Subquery_restriction_clauseContext:ParserRuleContext {
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.Tokens.WITH.rawValue, 0) }
		open func READ() -> TerminalNode? { return getToken(plsqlParser.Tokens.READ.rawValue, 0) }
		open func ONLY() -> TerminalNode? { return getToken(plsqlParser.Tokens.ONLY.rawValue, 0) }
		open func CHECK() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHECK.rawValue, 0) }
		open func OPTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.OPTION.rawValue, 0) }
		open func CONSTRAINT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONSTRAINT.rawValue, 0) }
		open func constraint_name() -> Constraint_nameContext? {
			return getRuleContext(Constraint_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_subquery_restriction_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSubquery_restriction_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSubquery_restriction_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSubquery_restriction_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSubquery_restriction_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subquery_restriction_clause() throws -> Subquery_restriction_clauseContext {
		var _localctx: Subquery_restriction_clauseContext = Subquery_restriction_clauseContext(_ctx, getState())
		try enterRule(_localctx, 482, plsqlParser.RULE_subquery_restriction_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3740)
		 	try match(plsqlParser.Tokens.WITH.rawValue)
		 	setState(3749)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .READ:
		 		setState(3741)
		 		try match(plsqlParser.Tokens.READ.rawValue)
		 		setState(3742)
		 		try match(plsqlParser.Tokens.ONLY.rawValue)

		 		break

		 	case .CHECK:
		 		setState(3743)
		 		try match(plsqlParser.Tokens.CHECK.rawValue)
		 		setState(3744)
		 		try match(plsqlParser.Tokens.OPTION.rawValue)
		 		setState(3747)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.CONSTRAINT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3745)
		 			try match(plsqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(3746)
		 			try constraint_name()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sample_clauseContext:ParserRuleContext {
		open func SAMPLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SAMPLE.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func BLOCK() -> TerminalNode? { return getToken(plsqlParser.Tokens.BLOCK.rawValue, 0) }
		open func seed_part() -> Seed_partContext? {
			return getRuleContext(Seed_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sample_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSample_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSample_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSample_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSample_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sample_clause() throws -> Sample_clauseContext {
		var _localctx: Sample_clauseContext = Sample_clauseContext(_ctx, getState())
		try enterRule(_localctx, 484, plsqlParser.RULE_sample_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3751)
		 	try match(plsqlParser.Tokens.SAMPLE.rawValue)
		 	setState(3753)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.BLOCK.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3752)
		 		try match(plsqlParser.Tokens.BLOCK.rawValue)

		 	}

		 	setState(3755)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3756)
		 	try expression()
		 	setState(3759)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3757)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(3758)
		 		try expression()

		 	}

		 	setState(3761)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(3763)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,456,_ctx)) {
		 	case 1:
		 		setState(3762)
		 		try seed_part()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Seed_partContext:ParserRuleContext {
		open func SEED() -> TerminalNode? { return getToken(plsqlParser.Tokens.SEED.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_seed_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSeed_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSeed_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSeed_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSeed_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func seed_part() throws -> Seed_partContext {
		var _localctx: Seed_partContext = Seed_partContext(_ctx, getState())
		try enterRule(_localctx, 486, plsqlParser.RULE_seed_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3765)
		 	try match(plsqlParser.Tokens.SEED.rawValue)
		 	setState(3766)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3767)
		 	try expression()
		 	setState(3768)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_expressionContext:ParserRuleContext {
		open func CURSOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CURSOR.rawValue, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cursor_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCursor_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCursor_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCursor_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCursor_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_expression() throws -> Cursor_expressionContext {
		var _localctx: Cursor_expressionContext = Cursor_expressionContext(_ctx, getState())
		try enterRule(_localctx, 488, plsqlParser.RULE_cursor_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3770)
		 	try match(plsqlParser.Tokens.CURSOR.rawValue)
		 	setState(3771)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3772)
		 	try subquery()
		 	setState(3773)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Expression_listContext:ParserRuleContext {
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_expression_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExpression_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExpression_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExpression_list(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExpression_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func expression_list() throws -> Expression_listContext {
		var _localctx: Expression_listContext = Expression_listContext(_ctx, getState())
		try enterRule(_localctx, 490, plsqlParser.RULE_expression_list)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3775)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(3777)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ALL.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ANY.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CASE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COALESCE.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONNECT_BY_ROOT.rawValue,plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DATE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DISTINCT.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTION_INIT.rawValue,plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXISTS.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FALSE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LANGUAGE.rawValue,plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NOT.rawValue,plsqlParser.Tokens.NULL.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OBJECT.rawValue,plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PRIOR.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 257)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.RIGHT.rawValue,plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUE.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YES.rawValue,plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.DECODE.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.NVL.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROUND.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.SUBSTR.rawValue,plsqlParser.Tokens.TO_CHAR.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue,plsqlParser.Tokens.APPROXIMATE_NUM_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue,plsqlParser.Tokens.LEFT_PAREN.rawValue,plsqlParser.Tokens.PLUS_SIGN.rawValue,plsqlParser.Tokens.MINUS_SIGN.rawValue,plsqlParser.Tokens.BINDVAR.rawValue,plsqlParser.Tokens.COLON.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3776)
		 		try expression()

		 	}

		 	setState(3783)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3779)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(3780)
		 		try expression()


		 		setState(3785)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3786)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConditionContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_condition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCondition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCondition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCondition(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCondition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func condition() throws -> ConditionContext {
		var _localctx: ConditionContext = ConditionContext(_ctx, getState())
		try enterRule(_localctx, 492, plsqlParser.RULE_condition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3788)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ExpressionContext:ParserRuleContext {
		open func cursor_expression() -> Cursor_expressionContext? {
			return getRuleContext(Cursor_expressionContext.self,0)
		}
		open func logical_or_expression() -> Logical_or_expressionContext? {
			return getRuleContext(Logical_or_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExpression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExpression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExpression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExpression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func expression() throws -> ExpressionContext {
		var _localctx: ExpressionContext = ExpressionContext(_ctx, getState())
		try enterRule(_localctx, 494, plsqlParser.RULE_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3792)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,459, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3790)
		 		try cursor_expression()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3791)
		 		try logical_or_expression(0)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	open class Logical_or_expressionContext:ParserRuleContext {
		open func logical_and_expression() -> Logical_and_expressionContext? {
			return getRuleContext(Logical_and_expressionContext.self,0)
		}
		open func logical_or_expression() -> Logical_or_expressionContext? {
			return getRuleContext(Logical_or_expressionContext.self,0)
		}
		open func OR() -> TerminalNode? { return getToken(plsqlParser.Tokens.OR.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_logical_or_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLogical_or_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLogical_or_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLogical_or_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLogical_or_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}

	public final  func logical_or_expression( ) throws -> Logical_or_expressionContext   {
		return try logical_or_expression(0)
	}
	@discardableResult
	private func logical_or_expression(_ _p: Int) throws -> Logical_or_expressionContext   {
		let _parentctx: ParserRuleContext? = _ctx
		var _parentState: Int = getState()
		var _localctx: Logical_or_expressionContext = Logical_or_expressionContext(_ctx, _parentState)
		var  _prevctx: Logical_or_expressionContext = _localctx
		var _startState: Int = 496
		try enterRecursionRule(_localctx, 496, plsqlParser.RULE_logical_or_expression, _p)
		defer {
	    		try! unrollRecursionContexts(_parentctx)
	    }
		do {
			var _alt: Int
			try enterOuterAlt(_localctx, 1)
			setState(3795)
			try logical_and_expression(0)

			_ctx!.stop = try _input.LT(-1)
			setState(3802)
			try _errHandler.sync(self)
			_alt = try getInterpreter().adaptivePredict(_input,460,_ctx)
			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
				if ( _alt==1 ) {
					if _parseListeners != nil {
					   try triggerExitRuleEvent()
					}
					_prevctx = _localctx
					_localctx = Logical_or_expressionContext(_parentctx, _parentState);
					try pushNewRecursionContext(_localctx, _startState, plsqlParser.RULE_logical_or_expression)
					setState(3797)
					if (!(precpred(_ctx, 1))) {
					    throw try ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 1)"))
					}
					setState(3798)
					try match(plsqlParser.Tokens.OR.rawValue)
					setState(3799)
					try logical_and_expression(0)

			 
				}
				setState(3804)
				try _errHandler.sync(self)
				_alt = try getInterpreter().adaptivePredict(_input,460,_ctx)
			}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx;
	}

	open class Logical_and_expressionContext:ParserRuleContext {
		open func negated_expression() -> Negated_expressionContext? {
			return getRuleContext(Negated_expressionContext.self,0)
		}
		open func logical_and_expression() -> Logical_and_expressionContext? {
			return getRuleContext(Logical_and_expressionContext.self,0)
		}
		open func AND() -> TerminalNode? { return getToken(plsqlParser.Tokens.AND.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_logical_and_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLogical_and_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLogical_and_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLogical_and_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLogical_and_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}

	public final  func logical_and_expression( ) throws -> Logical_and_expressionContext   {
		return try logical_and_expression(0)
	}
	@discardableResult
	private func logical_and_expression(_ _p: Int) throws -> Logical_and_expressionContext   {
		let _parentctx: ParserRuleContext? = _ctx
		var _parentState: Int = getState()
		var _localctx: Logical_and_expressionContext = Logical_and_expressionContext(_ctx, _parentState)
		var  _prevctx: Logical_and_expressionContext = _localctx
		var _startState: Int = 498
		try enterRecursionRule(_localctx, 498, plsqlParser.RULE_logical_and_expression, _p)
		defer {
	    		try! unrollRecursionContexts(_parentctx)
	    }
		do {
			var _alt: Int
			try enterOuterAlt(_localctx, 1)
			setState(3806)
			try negated_expression()

			_ctx!.stop = try _input.LT(-1)
			setState(3813)
			try _errHandler.sync(self)
			_alt = try getInterpreter().adaptivePredict(_input,461,_ctx)
			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
				if ( _alt==1 ) {
					if _parseListeners != nil {
					   try triggerExitRuleEvent()
					}
					_prevctx = _localctx
					_localctx = Logical_and_expressionContext(_parentctx, _parentState);
					try pushNewRecursionContext(_localctx, _startState, plsqlParser.RULE_logical_and_expression)
					setState(3808)
					if (!(precpred(_ctx, 1))) {
					    throw try ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 1)"))
					}
					setState(3809)
					try match(plsqlParser.Tokens.AND.rawValue)
					setState(3810)
					try negated_expression()

			 
				}
				setState(3815)
				try _errHandler.sync(self)
				_alt = try getInterpreter().adaptivePredict(_input,461,_ctx)
			}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx;
	}
	open class Negated_expressionContext:ParserRuleContext {
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT.rawValue, 0) }
		open func negated_expression() -> Negated_expressionContext? {
			return getRuleContext(Negated_expressionContext.self,0)
		}
		open func equality_expression() -> Equality_expressionContext? {
			return getRuleContext(Equality_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_negated_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNegated_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNegated_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNegated_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNegated_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func negated_expression() throws -> Negated_expressionContext {
		var _localctx: Negated_expressionContext = Negated_expressionContext(_ctx, getState())
		try enterRule(_localctx, 500, plsqlParser.RULE_negated_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3819)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NOT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3816)
		 		try match(plsqlParser.Tokens.NOT.rawValue)
		 		setState(3817)
		 		try negated_expression()

		 		break
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALL:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ANY:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CASE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COALESCE:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONNECT_BY_ROOT:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DISTINCT:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXISTS:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FALSE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .PRIOR:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .DECODE:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NVL:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .TO_CHAR:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case .UNSIGNED_INTEGER:fallthrough
		 	case .APPROXIMATE_NUM_LIT:fallthrough
		 	case .CHAR_STRING:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .LEFT_PAREN:fallthrough
		 	case .PLUS_SIGN:fallthrough
		 	case .MINUS_SIGN:fallthrough
		 	case .BINDVAR:fallthrough
		 	case .COLON:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3818)
		 		try equality_expression()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Equality_expressionContext:ParserRuleContext {
		open func multiset_expression() -> Multiset_expressionContext? {
			return getRuleContext(Multiset_expressionContext.self,0)
		}
		open func IS() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.IS.rawValue) }
		open func IS(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.IS.rawValue, i)
		}
		open func NULL() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.NULL.rawValue) }
		open func NULL(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.NULL.rawValue, i)
		}
		open func NAN() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.NAN.rawValue) }
		open func NAN(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.NAN.rawValue, i)
		}
		open func PRESENT() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.PRESENT.rawValue) }
		open func PRESENT(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.PRESENT.rawValue, i)
		}
		open func INFINITE() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.INFINITE.rawValue) }
		open func INFINITE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.INFINITE.rawValue, i)
		}
		open func A_LETTER() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.A_LETTER.rawValue) }
		open func A_LETTER(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.A_LETTER.rawValue, i)
		}
		open func SET() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.SET.rawValue) }
		open func SET(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.SET.rawValue, i)
		}
		open func EMPTY() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.EMPTY.rawValue) }
		open func EMPTY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.EMPTY.rawValue, i)
		}
		open func OF() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.OF.rawValue) }
		open func OF(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.OF.rawValue, i)
		}
		open func type_spec() -> Array<Type_specContext> {
			return getRuleContexts(Type_specContext.self)
		}
		open func type_spec(_ i: Int) -> Type_specContext? {
			return getRuleContext(Type_specContext.self,i)
		}
		open func NOT() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.NOT.rawValue) }
		open func NOT(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.NOT.rawValue, i)
		}
		open func TYPE() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.TYPE.rawValue) }
		open func TYPE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.TYPE.rawValue, i)
		}
		open func ONLY() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.ONLY.rawValue) }
		open func ONLY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.ONLY.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_equality_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterEquality_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitEquality_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitEquality_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitEquality_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func equality_expression() throws -> Equality_expressionContext {
		var _localctx: Equality_expressionContext = Equality_expressionContext(_ctx, getState())
		try enterRule(_localctx, 502, plsqlParser.RULE_equality_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3821)
		 	try multiset_expression()
		 	setState(3855)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,468,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3822)
		 			try match(plsqlParser.Tokens.IS.rawValue)
		 			setState(3824)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.NOT.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(3823)
		 				try match(plsqlParser.Tokens.NOT.rawValue)

		 			}

		 			setState(3851)
		 			try _errHandler.sync(self)
		 			switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .NULL:
		 				setState(3826)
		 				try match(plsqlParser.Tokens.NULL.rawValue)

		 				break

		 			case .NAN:
		 				setState(3827)
		 				try match(plsqlParser.Tokens.NAN.rawValue)

		 				break

		 			case .PRESENT:
		 				setState(3828)
		 				try match(plsqlParser.Tokens.PRESENT.rawValue)

		 				break

		 			case .INFINITE:
		 				setState(3829)
		 				try match(plsqlParser.Tokens.INFINITE.rawValue)

		 				break

		 			case .A_LETTER:
		 				setState(3830)
		 				try match(plsqlParser.Tokens.A_LETTER.rawValue)
		 				setState(3831)
		 				try match(plsqlParser.Tokens.SET.rawValue)

		 				break

		 			case .EMPTY:
		 				setState(3832)
		 				try match(plsqlParser.Tokens.EMPTY.rawValue)

		 				break

		 			case .OF:
		 				setState(3833)
		 				try match(plsqlParser.Tokens.OF.rawValue)
		 				setState(3835)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (//closure
		 				 { () -> Bool in
		 				      let testSet: Bool = _la == plsqlParser.Tokens.TYPE.rawValue
		 				      return testSet
		 				 }()) {
		 					setState(3834)
		 					try match(plsqlParser.Tokens.TYPE.rawValue)

		 				}

		 				setState(3837)
		 				try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 				setState(3839)
		 				try _errHandler.sync(self)
		 				switch (try getInterpreter().adaptivePredict(_input,465,_ctx)) {
		 				case 1:
		 					setState(3838)
		 					try match(plsqlParser.Tokens.ONLY.rawValue)

		 					break
		 				default: break
		 				}
		 				setState(3841)
		 				try type_spec()
		 				setState(3846)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				while (//closure
		 				 { () -> Bool in
		 				      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 				      return testSet
		 				 }()) {
		 					setState(3842)
		 					try match(plsqlParser.Tokens.COMMA.rawValue)
		 					setState(3843)
		 					try type_spec()


		 					setState(3848)
		 					try _errHandler.sync(self)
		 					_la = try _input.LA(1)
		 				}
		 				setState(3849)
		 				try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 	 
		 		}
		 		setState(3857)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,468,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multiset_expressionContext:ParserRuleContext {
		open func relational_expression() -> Relational_expressionContext? {
			return getRuleContext(Relational_expressionContext.self,0)
		}
		open func multiset_type() -> Multiset_typeContext? {
			return getRuleContext(Multiset_typeContext.self,0)
		}
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open func OF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OF.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multiset_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMultiset_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMultiset_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMultiset_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMultiset_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiset_expression() throws -> Multiset_expressionContext {
		var _localctx: Multiset_expressionContext = Multiset_expressionContext(_ctx, getState())
		try enterRule(_localctx, 504, plsqlParser.RULE_multiset_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3858)
		 	try relational_expression(0)
		 	setState(3865)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,470,_ctx)) {
		 	case 1:
		 		setState(3859)
		 		try multiset_type()
		 		setState(3861)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.OF.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3860)
		 			try match(plsqlParser.Tokens.OF.rawValue)

		 		}

		 		setState(3863)
		 		try concatenation()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multiset_typeContext:ParserRuleContext {
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.Tokens.MEMBER.rawValue, 0) }
		open func SUBMULTISET() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUBMULTISET.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multiset_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMultiset_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMultiset_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMultiset_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMultiset_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiset_type() throws -> Multiset_typeContext {
		var _localctx: Multiset_typeContext = Multiset_typeContext(_ctx, getState())
		try enterRule(_localctx, 506, plsqlParser.RULE_multiset_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3867)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.MEMBER.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.SUBMULTISET.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	open class Relational_expressionContext:ParserRuleContext {
		open func compound_expression() -> Compound_expressionContext? {
			return getRuleContext(Compound_expressionContext.self,0)
		}
		open func relational_expression() -> Array<Relational_expressionContext> {
			return getRuleContexts(Relational_expressionContext.self)
		}
		open func relational_expression(_ i: Int) -> Relational_expressionContext? {
			return getRuleContext(Relational_expressionContext.self,i)
		}
		open func relational_operator() -> Relational_operatorContext? {
			return getRuleContext(Relational_operatorContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_relational_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRelational_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRelational_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRelational_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRelational_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}

	public final  func relational_expression( ) throws -> Relational_expressionContext   {
		return try relational_expression(0)
	}
	@discardableResult
	private func relational_expression(_ _p: Int) throws -> Relational_expressionContext   {
		let _parentctx: ParserRuleContext? = _ctx
		var _parentState: Int = getState()
		var _localctx: Relational_expressionContext = Relational_expressionContext(_ctx, _parentState)
		var  _prevctx: Relational_expressionContext = _localctx
		var _startState: Int = 508
		try enterRecursionRule(_localctx, 508, plsqlParser.RULE_relational_expression, _p)
		defer {
	    		try! unrollRecursionContexts(_parentctx)
	    }
		do {
			var _alt: Int
			try enterOuterAlt(_localctx, 1)
			setState(3870)
			try compound_expression()

			_ctx!.stop = try _input.LT(-1)
			setState(3878)
			try _errHandler.sync(self)
			_alt = try getInterpreter().adaptivePredict(_input,471,_ctx)
			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
				if ( _alt==1 ) {
					if _parseListeners != nil {
					   try triggerExitRuleEvent()
					}
					_prevctx = _localctx
					_localctx = Relational_expressionContext(_parentctx, _parentState);
					try pushNewRecursionContext(_localctx, _startState, plsqlParser.RULE_relational_expression)
					setState(3872)
					if (!(precpred(_ctx, 2))) {
					    throw try ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 2)"))
					}
					setState(3873)
					try relational_operator()
					setState(3874)
					try relational_expression(3)

			 
				}
				setState(3880)
				try _errHandler.sync(self)
				_alt = try getInterpreter().adaptivePredict(_input,471,_ctx)
			}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx;
	}
	open class Compound_expressionContext:ParserRuleContext {
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func in_elements() -> In_elementsContext? {
			return getRuleContext(In_elementsContext.self,0)
		}
		open func BETWEEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.BETWEEN.rawValue, 0) }
		open func between_elements() -> Between_elementsContext? {
			return getRuleContext(Between_elementsContext.self,0)
		}
		open func like_type() -> Like_typeContext? {
			return getRuleContext(Like_typeContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT.rawValue, 0) }
		open func like_escape_part() -> Like_escape_partContext? {
			return getRuleContext(Like_escape_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_compound_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCompound_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCompound_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCompound_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCompound_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func compound_expression() throws -> Compound_expressionContext {
		var _localctx: Compound_expressionContext = Compound_expressionContext(_ctx, getState())
		try enterRule(_localctx, 510, plsqlParser.RULE_compound_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3881)
		 	try concatenation()
		 	setState(3896)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,475,_ctx)) {
		 	case 1:
		 		setState(3883)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.NOT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3882)
		 			try match(plsqlParser.Tokens.NOT.rawValue)

		 		}

		 		setState(3894)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .IN:
		 			setState(3885)
		 			try match(plsqlParser.Tokens.IN.rawValue)
		 			setState(3886)
		 			try in_elements()

		 			break

		 		case .BETWEEN:
		 			setState(3887)
		 			try match(plsqlParser.Tokens.BETWEEN.rawValue)
		 			setState(3888)
		 			try between_elements()

		 			break
		 		case .LIKE:fallthrough
		 		case .LIKE2:fallthrough
		 		case .LIKE4:fallthrough
		 		case .LIKEC:
		 			setState(3889)
		 			try like_type()
		 			setState(3890)
		 			try concatenation()
		 			setState(3892)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,473,_ctx)) {
		 			case 1:
		 				setState(3891)
		 				try like_escape_part()

		 				break
		 			default: break
		 			}

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Relational_operatorContext:ParserRuleContext {
		open func not_equal_op() -> Not_equal_opContext? {
			return getRuleContext(Not_equal_opContext.self,0)
		}
		open func less_than_or_equals_op() -> Less_than_or_equals_opContext? {
			return getRuleContext(Less_than_or_equals_opContext.self,0)
		}
		open func greater_than_or_equals_op() -> Greater_than_or_equals_opContext? {
			return getRuleContext(Greater_than_or_equals_opContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_relational_operator }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRelational_operator(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRelational_operator(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRelational_operator(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRelational_operator(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func relational_operator() throws -> Relational_operatorContext {
		var _localctx: Relational_operatorContext = Relational_operatorContext(_ctx, getState())
		try enterRule(_localctx, 512, plsqlParser.RULE_relational_operator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3904)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,476, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3898)
		 		try match(plsqlParser.Tokens.EQUALS_OP.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3899)
		 		try not_equal_op()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3900)
		 		try match(plsqlParser.Tokens.LESS_THAN_OP.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3901)
		 		try match(plsqlParser.Tokens.GREATER_THAN_OP.rawValue)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3902)
		 		try less_than_or_equals_op()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3903)
		 		try greater_than_or_equals_op()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Like_typeContext:ParserRuleContext {
		open func LIKE() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIKE.rawValue, 0) }
		open func LIKEC() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIKEC.rawValue, 0) }
		open func LIKE2() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIKE2.rawValue, 0) }
		open func LIKE4() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIKE4.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_like_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLike_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLike_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLike_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLike_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func like_type() throws -> Like_typeContext {
		var _localctx: Like_typeContext = Like_typeContext(_ctx, getState())
		try enterRule(_localctx, 514, plsqlParser.RULE_like_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3906)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.LIKE.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 200)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Like_escape_partContext:ParserRuleContext {
		open func ESCAPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ESCAPE.rawValue, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_like_escape_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLike_escape_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLike_escape_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLike_escape_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLike_escape_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func like_escape_part() throws -> Like_escape_partContext {
		var _localctx: Like_escape_partContext = Like_escape_partContext(_ctx, getState())
		try enterRule(_localctx, 516, plsqlParser.RULE_like_escape_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3908)
		 	try match(plsqlParser.Tokens.ESCAPE.rawValue)
		 	setState(3909)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class In_elementsContext:ParserRuleContext {
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func constant() -> ConstantContext? {
			return getRuleContext(ConstantContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open func general_element() -> General_elementContext? {
			return getRuleContext(General_elementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_in_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterIn_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitIn_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitIn_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitIn_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func in_elements() throws -> In_elementsContext {
		var _localctx: In_elementsContext = In_elementsContext(_ctx, getState())
		try enterRule(_localctx, 518, plsqlParser.RULE_in_elements)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3929)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,478, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3911)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3912)
		 		try subquery()
		 		setState(3913)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3915)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(3916)
		 		try concatenation()
		 		setState(3921)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3917)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(3918)
		 			try concatenation()


		 			setState(3923)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3924)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3926)
		 		try constant()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3927)
		 		try bind_variable()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3928)
		 		try general_element()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Between_elementsContext:ParserRuleContext {
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func AND() -> TerminalNode? { return getToken(plsqlParser.Tokens.AND.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_between_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBetween_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBetween_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBetween_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBetween_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func between_elements() throws -> Between_elementsContext {
		var _localctx: Between_elementsContext = Between_elementsContext(_ctx, getState())
		try enterRule(_localctx, 520, plsqlParser.RULE_between_elements)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3931)
		 	try concatenation()
		 	setState(3932)
		 	try match(plsqlParser.Tokens.AND.rawValue)
		 	setState(3933)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConcatenationContext:ParserRuleContext {
		open func additive_expression() -> Array<Additive_expressionContext> {
			return getRuleContexts(Additive_expressionContext.self)
		}
		open func additive_expression(_ i: Int) -> Additive_expressionContext? {
			return getRuleContext(Additive_expressionContext.self,i)
		}
		open func concatenation_op() -> Array<Concatenation_opContext> {
			return getRuleContexts(Concatenation_opContext.self)
		}
		open func concatenation_op(_ i: Int) -> Concatenation_opContext? {
			return getRuleContext(Concatenation_opContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_concatenation }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConcatenation(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConcatenation(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConcatenation(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConcatenation(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func concatenation() throws -> ConcatenationContext {
		var _localctx: ConcatenationContext = ConcatenationContext(_ctx, getState())
		try enterRule(_localctx, 522, plsqlParser.RULE_concatenation)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3935)
		 	try additive_expression()
		 	setState(3941)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,479,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3936)
		 			try concatenation_op()
		 			setState(3937)
		 			try additive_expression()

		 	 
		 		}
		 		setState(3943)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,479,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Additive_expressionContext:ParserRuleContext {
		public var s503: Token!
		public var op: Array<Token> = Array<Token>()
		public var s504: Token!
		public var _tset6956: Token!
		open func multiply_expression() -> Array<Multiply_expressionContext> {
			return getRuleContexts(Multiply_expressionContext.self)
		}
		open func multiply_expression(_ i: Int) -> Multiply_expressionContext? {
			return getRuleContext(Multiply_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_additive_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAdditive_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAdditive_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAdditive_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAdditive_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func additive_expression() throws -> Additive_expressionContext {
		var _localctx: Additive_expressionContext = Additive_expressionContext(_ctx, getState())
		try enterRule(_localctx, 524, plsqlParser.RULE_additive_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3944)
		 	try multiply_expression()
		 	setState(3949)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,480,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3945)
		 			_localctx.castdown(Additive_expressionContext.self)._tset6956 = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.PLUS_SIGN.rawValue || _la == plsqlParser.Tokens.MINUS_SIGN.rawValue
		 			      return testSet
		 			 }())) {
		 				_localctx.castdown(Additive_expressionContext.self)._tset6956 = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			_localctx.castdown(Additive_expressionContext.self).op.append(_localctx.castdown(Additive_expressionContext.self)._tset6956)
		 			setState(3946)
		 			try multiply_expression()

		 	 
		 		}
		 		setState(3951)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,480,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multiply_expressionContext:ParserRuleContext {
		public var s502: Token!
		public var op: Array<Token> = Array<Token>()
		public var s506: Token!
		public var _tset6979: Token!
		open func datetime_expression() -> Array<Datetime_expressionContext> {
			return getRuleContexts(Datetime_expressionContext.self)
		}
		open func datetime_expression(_ i: Int) -> Datetime_expressionContext? {
			return getRuleContext(Datetime_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multiply_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMultiply_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMultiply_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMultiply_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMultiply_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multiply_expression() throws -> Multiply_expressionContext {
		var _localctx: Multiply_expressionContext = Multiply_expressionContext(_ctx, getState())
		try enterRule(_localctx, 526, plsqlParser.RULE_multiply_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3952)
		 	try datetime_expression()
		 	setState(3957)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,481,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3953)
		 			_localctx.castdown(Multiply_expressionContext.self)._tset6979 = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.ASTERISK.rawValue || _la == plsqlParser.Tokens.SOLIDUS.rawValue
		 			      return testSet
		 			 }())) {
		 				_localctx.castdown(Multiply_expressionContext.self)._tset6979 = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			_localctx.castdown(Multiply_expressionContext.self).op.append(_localctx.castdown(Multiply_expressionContext.self)._tset6979)
		 			setState(3954)
		 			try datetime_expression()

		 	 
		 		}
		 		setState(3959)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,481,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Datetime_expressionContext:ParserRuleContext {
		open func model_expression() -> Model_expressionContext? {
			return getRuleContext(Model_expressionContext.self,0)
		}
		open func AT() -> TerminalNode? { return getToken(plsqlParser.Tokens.AT.rawValue, 0) }
		open func interval_expression() -> Interval_expressionContext? {
			return getRuleContext(Interval_expressionContext.self,0)
		}
		open func LOCAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOCAL.rawValue, 0) }
		open func TIME() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIME.rawValue, 0) }
		open func ZONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ZONE.rawValue, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_datetime_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDatetime_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDatetime_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDatetime_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDatetime_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func datetime_expression() throws -> Datetime_expressionContext {
		var _localctx: Datetime_expressionContext = Datetime_expressionContext(_ctx, getState())
		try enterRule(_localctx, 528, plsqlParser.RULE_datetime_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3960)
		 	try model_expression()
		 	setState(3969)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,483,_ctx)) {
		 	case 1:
		 		setState(3961)
		 		try match(plsqlParser.Tokens.AT.rawValue)
		 		setState(3966)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .LOCAL:
		 			setState(3962)
		 			try match(plsqlParser.Tokens.LOCAL.rawValue)

		 			break

		 		case .TIME:
		 			setState(3963)
		 			try match(plsqlParser.Tokens.TIME.rawValue)
		 			setState(3964)
		 			try match(plsqlParser.Tokens.ZONE.rawValue)
		 			setState(3965)
		 			try concatenation()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 2:
		 		setState(3968)
		 		try interval_expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Interval_expressionContext:ParserRuleContext {
		open func DAY() -> TerminalNode? { return getToken(plsqlParser.Tokens.DAY.rawValue, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.Tokens.TO.rawValue, 0) }
		open func SECOND() -> TerminalNode? { return getToken(plsqlParser.Tokens.SECOND.rawValue, 0) }
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func YEAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.YEAR.rawValue, 0) }
		open func MONTH() -> TerminalNode? { return getToken(plsqlParser.Tokens.MONTH.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_interval_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterInterval_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitInterval_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitInterval_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitInterval_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func interval_expression() throws -> Interval_expressionContext {
		var _localctx: Interval_expressionContext = Interval_expressionContext(_ctx, getState())
		try enterRule(_localctx, 530, plsqlParser.RULE_interval_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3995)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DAY:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3971)
		 		try match(plsqlParser.Tokens.DAY.rawValue)
		 		setState(3976)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3972)
		 			try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 			setState(3973)
		 			try concatenation()
		 			setState(3974)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		}

		 		setState(3978)
		 		try match(plsqlParser.Tokens.TO.rawValue)
		 		setState(3979)
		 		try match(plsqlParser.Tokens.SECOND.rawValue)
		 		setState(3984)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,485,_ctx)) {
		 		case 1:
		 			setState(3980)
		 			try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 			setState(3981)
		 			try concatenation()
		 			setState(3982)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 			break
		 		default: break
		 		}

		 		break

		 	case .YEAR:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3986)
		 		try match(plsqlParser.Tokens.YEAR.rawValue)
		 		setState(3991)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3987)
		 			try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 			setState(3988)
		 			try concatenation()
		 			setState(3989)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		}

		 		setState(3993)
		 		try match(plsqlParser.Tokens.TO.rawValue)
		 		setState(3994)
		 		try match(plsqlParser.Tokens.MONTH.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_expressionContext:ParserRuleContext {
		open func unary_expression() -> Unary_expressionContext? {
			return getRuleContext(Unary_expressionContext.self,0)
		}
		open func model_expression_element() -> Model_expression_elementContext? {
			return getRuleContext(Model_expression_elementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_expression() throws -> Model_expressionContext {
		var _localctx: Model_expressionContext = Model_expressionContext(_ctx, getState())
		try enterRule(_localctx, 532, plsqlParser.RULE_model_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3997)
		 	try unary_expression()
		 	setState(4002)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,488,_ctx)) {
		 	case 1:
		 		setState(3998)
		 		try match(plsqlParser.Tokens.LEFT_BRACKET.rawValue)
		 		setState(3999)
		 		try model_expression_element()
		 		setState(4000)
		 		try match(plsqlParser.Tokens.RIGHT_BRACKET.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Model_expression_elementContext:ParserRuleContext {
		open func ANY() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.ANY.rawValue) }
		open func ANY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.ANY.rawValue, i)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func single_column_for_loop() -> Array<Single_column_for_loopContext> {
			return getRuleContexts(Single_column_for_loopContext.self)
		}
		open func single_column_for_loop(_ i: Int) -> Single_column_for_loopContext? {
			return getRuleContext(Single_column_for_loopContext.self,i)
		}
		open func multi_column_for_loop() -> Multi_column_for_loopContext? {
			return getRuleContext(Multi_column_for_loopContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_model_expression_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterModel_expression_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitModel_expression_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitModel_expression_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitModel_expression_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func model_expression_element() throws -> Model_expression_elementContext {
		var _localctx: Model_expression_elementContext = Model_expression_elementContext(_ctx, getState())
		try enterRule(_localctx, 534, plsqlParser.RULE_model_expression_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4027)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,493, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4006)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,489, _ctx)) {
		 		case 1:
		 			setState(4004)
		 			try match(plsqlParser.Tokens.ANY.rawValue)

		 			break
		 		case 2:
		 			setState(4005)
		 			try expression()

		 			break
		 		default: break
		 		}
		 		setState(4015)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4008)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4011)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,490, _ctx)) {
		 			case 1:
		 				setState(4009)
		 				try match(plsqlParser.Tokens.ANY.rawValue)

		 				break
		 			case 2:
		 				setState(4010)
		 				try expression()

		 				break
		 			default: break
		 			}


		 			setState(4017)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4018)
		 		try single_column_for_loop()
		 		setState(4023)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4019)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4020)
		 			try single_column_for_loop()


		 			setState(4025)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4026)
		 		try multi_column_for_loop()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Single_column_for_loopContext:ParserRuleContext {
		public var ex1: ExpressionContext!
		public var ex2: ExpressionContext!
		public var ex3: ExpressionContext!
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOR.rawValue, 0) }
		open func column_name() -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(plsqlParser.Tokens.FROM.rawValue, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.Tokens.TO.rawValue, 0) }
		open func for_increment_decrement_type() -> For_increment_decrement_typeContext? {
			return getRuleContext(For_increment_decrement_typeContext.self,0)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func for_like_part() -> For_like_partContext? {
			return getRuleContext(For_like_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_single_column_for_loop }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSingle_column_for_loop(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSingle_column_for_loop(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSingle_column_for_loop(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSingle_column_for_loop(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func single_column_for_loop() throws -> Single_column_for_loopContext {
		var _localctx: Single_column_for_loopContext = Single_column_for_loopContext(_ctx, getState())
		try enterRule(_localctx, 536, plsqlParser.RULE_single_column_for_loop)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4029)
		 	try match(plsqlParser.Tokens.FOR.rawValue)
		 	setState(4030)
		 	try column_name()
		 	setState(4043)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IN:
		 		setState(4031)
		 		try match(plsqlParser.Tokens.IN.rawValue)
		 		setState(4032)
		 		try expression_list()

		 		break
		 	case .FROM:fallthrough
		 	case .LIKE:
		 		setState(4034)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.LIKE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4033)
		 			try for_like_part()

		 		}

		 		setState(4036)
		 		try match(plsqlParser.Tokens.FROM.rawValue)
		 		setState(4037)
		 		try {
		 				let assignmentValue = try expression()
		 				_localctx.castdown(Single_column_for_loopContext.self).ex1 = assignmentValue
		 		     }()

		 		setState(4038)
		 		try match(plsqlParser.Tokens.TO.rawValue)
		 		setState(4039)
		 		try {
		 				let assignmentValue = try expression()
		 				_localctx.castdown(Single_column_for_loopContext.self).ex2 = assignmentValue
		 		     }()

		 		setState(4040)
		 		try for_increment_decrement_type()
		 		setState(4041)
		 		try {
		 				let assignmentValue = try expression()
		 				_localctx.castdown(Single_column_for_loopContext.self).ex3 = assignmentValue
		 		     }()


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_like_partContext:ParserRuleContext {
		open func LIKE() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIKE.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_like_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_like_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_like_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_like_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_like_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_like_part() throws -> For_like_partContext {
		var _localctx: For_like_partContext = For_like_partContext(_ctx, getState())
		try enterRule(_localctx, 538, plsqlParser.RULE_for_like_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4045)
		 	try match(plsqlParser.Tokens.LIKE.rawValue)
		 	setState(4046)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_increment_decrement_typeContext:ParserRuleContext {
		open func INCREMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INCREMENT.rawValue, 0) }
		open func DECREMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECREMENT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_for_increment_decrement_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFor_increment_decrement_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFor_increment_decrement_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFor_increment_decrement_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFor_increment_decrement_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_increment_decrement_type() throws -> For_increment_decrement_typeContext {
		var _localctx: For_increment_decrement_typeContext = For_increment_decrement_typeContext(_ctx, getState())
		try enterRule(_localctx, 540, plsqlParser.RULE_for_increment_decrement_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4048)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.DECREMENT.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.INCREMENT.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Multi_column_for_loopContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOR.rawValue, 0) }
		open func column_name() -> Array<Column_nameContext> {
			return getRuleContexts(Column_nameContext.self)
		}
		open func column_name(_ i: Int) -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,i)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func expression_list() -> Array<Expression_listContext> {
			return getRuleContexts(Expression_listContext.self)
		}
		open func expression_list(_ i: Int) -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_multi_column_for_loop }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMulti_column_for_loop(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMulti_column_for_loop(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMulti_column_for_loop(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMulti_column_for_loop(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func multi_column_for_loop() throws -> Multi_column_for_loopContext {
		var _localctx: Multi_column_for_loopContext = Multi_column_for_loopContext(_ctx, getState())
		try enterRule(_localctx, 542, plsqlParser.RULE_multi_column_for_loop)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4050)
		 	try match(plsqlParser.Tokens.FOR.rawValue)
		 	setState(4051)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(4052)
		 	try column_name()
		 	setState(4057)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4053)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(4054)
		 		try column_name()


		 		setState(4059)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4060)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(4061)
		 	try match(plsqlParser.Tokens.IN.rawValue)
		 	setState(4062)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(4075)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,498, _ctx)) {
		 	case 1:
		 		setState(4063)
		 		try subquery()

		 		break
		 	case 2:
		 		setState(4064)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4065)
		 		try expression_list()
		 		setState(4070)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4066)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4067)
		 			try expression_list()


		 			setState(4072)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4073)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4077)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Unary_expressionContext:ParserRuleContext {
		open func unary_expression() -> Unary_expressionContext? {
			return getRuleContext(Unary_expressionContext.self,0)
		}
		open func PRIOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.PRIOR.rawValue, 0) }
		open func CONNECT_BY_ROOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONNECT_BY_ROOT.rawValue, 0) }
		open func NEW() -> TerminalNode? { return getToken(plsqlParser.Tokens.NEW.rawValue, 0) }
		open func DISTINCT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DISTINCT.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open func case_statement() -> Case_statementContext? {
			return getRuleContext(Case_statementContext.self,0)
		}
		open func quantified_expression() -> Quantified_expressionContext? {
			return getRuleContext(Quantified_expressionContext.self,0)
		}
		open func standard_function() -> Standard_functionContext? {
			return getRuleContext(Standard_functionContext.self,0)
		}
		open func atom() -> AtomContext? {
			return getRuleContext(AtomContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_unary_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUnary_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUnary_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUnary_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUnary_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unary_expression() throws -> Unary_expressionContext {
		var _localctx: Unary_expressionContext = Unary_expressionContext(_ctx, getState())
		try enterRule(_localctx, 544, plsqlParser.RULE_unary_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4095)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,499, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4079)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.PLUS_SIGN.rawValue || _la == plsqlParser.Tokens.MINUS_SIGN.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4080)
		 		try unary_expression()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4081)
		 		try match(plsqlParser.Tokens.PRIOR.rawValue)
		 		setState(4082)
		 		try unary_expression()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4083)
		 		try match(plsqlParser.Tokens.CONNECT_BY_ROOT.rawValue)
		 		setState(4084)
		 		try unary_expression()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4085)
		 		try match(plsqlParser.Tokens.NEW.rawValue)
		 		setState(4086)
		 		try unary_expression()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4087)
		 		try match(plsqlParser.Tokens.DISTINCT.rawValue)
		 		setState(4088)
		 		try unary_expression()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(4089)
		 		try match(plsqlParser.Tokens.ALL.rawValue)
		 		setState(4090)
		 		try unary_expression()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(4091)
		 		try case_statement()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(4092)
		 		try quantified_expression()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(4093)
		 		try standard_function()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(4094)
		 		try atom()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Case_statementContext:ParserRuleContext {
		open func searched_case_statement() -> Searched_case_statementContext? {
			return getRuleContext(Searched_case_statementContext.self,0)
		}
		open func simple_case_statement() -> Simple_case_statementContext? {
			return getRuleContext(Simple_case_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_case_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCase_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCase_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCase_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCase_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func case_statement() throws -> Case_statementContext {
		var _localctx: Case_statementContext = Case_statementContext(_ctx, getState())
		try enterRule(_localctx, 546, plsqlParser.RULE_case_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4099)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,500, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4097)
		 		try searched_case_statement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4098)
		 		try simple_case_statement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Simple_case_statementContext:ParserRuleContext {
		public var ck1: Token!
		open func atom() -> AtomContext? {
			return getRuleContext(AtomContext.self,0)
		}
		open func END() -> TerminalNode? { return getToken(plsqlParser.Tokens.END.rawValue, 0) }
		open func CASE() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.CASE.rawValue) }
		open func CASE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.CASE.rawValue, i)
		}
		open func label_name() -> Array<Label_nameContext> {
			return getRuleContexts(Label_nameContext.self)
		}
		open func label_name(_ i: Int) -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,i)
		}
		open func simple_case_when_part() -> Array<Simple_case_when_partContext> {
			return getRuleContexts(Simple_case_when_partContext.self)
		}
		open func simple_case_when_part(_ i: Int) -> Simple_case_when_partContext? {
			return getRuleContext(Simple_case_when_partContext.self,i)
		}
		open func case_else_part() -> Case_else_partContext? {
			return getRuleContext(Case_else_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_simple_case_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSimple_case_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSimple_case_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSimple_case_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSimple_case_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func simple_case_statement() throws -> Simple_case_statementContext {
		var _localctx: Simple_case_statementContext = Simple_case_statementContext(_ctx, getState())
		try enterRule(_localctx, 548, plsqlParser.RULE_simple_case_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4102)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4101)
		 		try label_name()

		 	}

		 	setState(4104)
		 	try {
		 			let assignmentValue = try match(plsqlParser.Tokens.CASE.rawValue)
		 			_localctx.castdown(Simple_case_statementContext.self).ck1 = assignmentValue
		 	     }()

		 	setState(4105)
		 	try atom()
		 	setState(4107) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4106)
		 		try simple_case_when_part()


		 		setState(4109); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WHEN.rawValue
		 	      return testSet
		 	 }())
		 	setState(4112)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.ELSE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4111)
		 		try case_else_part()

		 	}

		 	setState(4114)
		 	try match(plsqlParser.Tokens.END.rawValue)
		 	setState(4116)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,504,_ctx)) {
		 	case 1:
		 		setState(4115)
		 		try match(plsqlParser.Tokens.CASE.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4119)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,505,_ctx)) {
		 	case 1:
		 		setState(4118)
		 		try label_name()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Simple_case_when_partContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHEN.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.THEN.rawValue, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_simple_case_when_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSimple_case_when_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSimple_case_when_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSimple_case_when_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSimple_case_when_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func simple_case_when_part() throws -> Simple_case_when_partContext {
		var _localctx: Simple_case_when_partContext = Simple_case_when_partContext(_ctx, getState())
		try enterRule(_localctx, 550, plsqlParser.RULE_simple_case_when_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4121)
		 	try match(plsqlParser.Tokens.WHEN.rawValue)
		 	setState(4122)
		 	try expression()
		 	setState(4123)
		 	try match(plsqlParser.Tokens.THEN.rawValue)
		 	setState(4126)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,506, _ctx)) {
		 	case 1:
		 		setState(4124)
		 		try seq_of_statements()

		 		break
		 	case 2:
		 		setState(4125)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Searched_case_statementContext:ParserRuleContext {
		public var ck1: Token!
		open func END() -> TerminalNode? { return getToken(plsqlParser.Tokens.END.rawValue, 0) }
		open func CASE() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.CASE.rawValue) }
		open func CASE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.CASE.rawValue, i)
		}
		open func label_name() -> Array<Label_nameContext> {
			return getRuleContexts(Label_nameContext.self)
		}
		open func label_name(_ i: Int) -> Label_nameContext? {
			return getRuleContext(Label_nameContext.self,i)
		}
		open func searched_case_when_part() -> Array<Searched_case_when_partContext> {
			return getRuleContexts(Searched_case_when_partContext.self)
		}
		open func searched_case_when_part(_ i: Int) -> Searched_case_when_partContext? {
			return getRuleContext(Searched_case_when_partContext.self,i)
		}
		open func case_else_part() -> Case_else_partContext? {
			return getRuleContext(Case_else_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_searched_case_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSearched_case_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSearched_case_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSearched_case_statement(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSearched_case_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func searched_case_statement() throws -> Searched_case_statementContext {
		var _localctx: Searched_case_statementContext = Searched_case_statementContext(_ctx, getState())
		try enterRule(_localctx, 552, plsqlParser.RULE_searched_case_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4129)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4128)
		 		try label_name()

		 	}

		 	setState(4131)
		 	try {
		 			let assignmentValue = try match(plsqlParser.Tokens.CASE.rawValue)
		 			_localctx.castdown(Searched_case_statementContext.self).ck1 = assignmentValue
		 	     }()

		 	setState(4133) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4132)
		 		try searched_case_when_part()


		 		setState(4135); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.WHEN.rawValue
		 	      return testSet
		 	 }())
		 	setState(4138)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.ELSE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4137)
		 		try case_else_part()

		 	}

		 	setState(4140)
		 	try match(plsqlParser.Tokens.END.rawValue)
		 	setState(4142)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,510,_ctx)) {
		 	case 1:
		 		setState(4141)
		 		try match(plsqlParser.Tokens.CASE.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4145)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,511,_ctx)) {
		 	case 1:
		 		setState(4144)
		 		try label_name()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Searched_case_when_partContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHEN.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func THEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.THEN.rawValue, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_searched_case_when_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSearched_case_when_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSearched_case_when_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSearched_case_when_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSearched_case_when_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func searched_case_when_part() throws -> Searched_case_when_partContext {
		var _localctx: Searched_case_when_partContext = Searched_case_when_partContext(_ctx, getState())
		try enterRule(_localctx, 554, plsqlParser.RULE_searched_case_when_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4147)
		 	try match(plsqlParser.Tokens.WHEN.rawValue)
		 	setState(4148)
		 	try expression()
		 	setState(4149)
		 	try match(plsqlParser.Tokens.THEN.rawValue)
		 	setState(4152)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,512, _ctx)) {
		 	case 1:
		 		setState(4150)
		 		try seq_of_statements()

		 		break
		 	case 2:
		 		setState(4151)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Case_else_partContext:ParserRuleContext {
		open func ELSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ELSE.rawValue, 0) }
		open func seq_of_statements() -> Seq_of_statementsContext? {
			return getRuleContext(Seq_of_statementsContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_case_else_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCase_else_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCase_else_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCase_else_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCase_else_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func case_else_part() throws -> Case_else_partContext {
		var _localctx: Case_else_partContext = Case_else_partContext(_ctx, getState())
		try enterRule(_localctx, 556, plsqlParser.RULE_case_else_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4154)
		 	try match(plsqlParser.Tokens.ELSE.rawValue)
		 	setState(4157)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,513, _ctx)) {
		 	case 1:
		 		setState(4155)
		 		try seq_of_statements()

		 		break
		 	case 2:
		 		setState(4156)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AtomContext:ParserRuleContext {
		open func table_element() -> Table_elementContext? {
			return getRuleContext(Table_elementContext.self,0)
		}
		open func outer_join_sign() -> Outer_join_signContext? {
			return getRuleContext(Outer_join_signContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open func constant() -> ConstantContext? {
			return getRuleContext(ConstantContext.self,0)
		}
		open func general_element() -> General_elementContext? {
			return getRuleContext(General_elementContext.self,0)
		}
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func expression_or_vector() -> Expression_or_vectorContext? {
			return getRuleContext(Expression_or_vectorContext.self,0)
		}
		open func subquery_operation_part() -> Array<Subquery_operation_partContext> {
			return getRuleContexts(Subquery_operation_partContext.self)
		}
		open func subquery_operation_part(_ i: Int) -> Subquery_operation_partContext? {
			return getRuleContext(Subquery_operation_partContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_atom }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAtom(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAtom(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAtom(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAtom(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func atom() throws -> AtomContext {
		var _localctx: AtomContext = AtomContext(_ctx, getState())
		try enterRule(_localctx, 558, plsqlParser.RULE_atom)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(4179)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,516, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4159)
		 		try table_element()
		 		setState(4160)
		 		try outer_join_sign()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4162)
		 		try bind_variable()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4163)
		 		try constant()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4164)
		 		try general_element()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4165)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4177)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,515, _ctx)) {
		 		case 1:
		 			setState(4166)
		 			try subquery()
		 			setState(4167)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 			setState(4171)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,514,_ctx)
		 			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 				if ( _alt==1 ) {
		 					setState(4168)
		 					try subquery_operation_part()

		 			 
		 				}
		 				setState(4173)
		 				try _errHandler.sync(self)
		 				_alt = try getInterpreter().adaptivePredict(_input,514,_ctx)
		 			}

		 			break
		 		case 2:
		 			setState(4174)
		 			try expression_or_vector()
		 			setState(4175)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Expression_or_vectorContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func vector_expr() -> Vector_exprContext? {
			return getRuleContext(Vector_exprContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_expression_or_vector }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExpression_or_vector(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExpression_or_vector(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExpression_or_vector(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExpression_or_vector(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func expression_or_vector() throws -> Expression_or_vectorContext {
		var _localctx: Expression_or_vectorContext = Expression_or_vectorContext(_ctx, getState())
		try enterRule(_localctx, 560, plsqlParser.RULE_expression_or_vector)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4181)
		 	try expression()
		 	setState(4183)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4182)
		 		try vector_expr()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Vector_exprContext:ParserRuleContext {
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_vector_expr }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterVector_expr(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitVector_expr(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitVector_expr(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitVector_expr(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func vector_expr() throws -> Vector_exprContext {
		var _localctx: Vector_exprContext = Vector_exprContext(_ctx, getState())
		try enterRule(_localctx, 562, plsqlParser.RULE_vector_expr)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4185)
		 	try match(plsqlParser.Tokens.COMMA.rawValue)
		 	setState(4186)
		 	try expression()
		 	setState(4191)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4187)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(4188)
		 		try expression()


		 		setState(4193)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Quantified_expressionContext:ParserRuleContext {
		open func SOME() -> TerminalNode? { return getToken(plsqlParser.Tokens.SOME.rawValue, 0) }
		open func EXISTS() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXISTS.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open func ANY() -> TerminalNode? { return getToken(plsqlParser.Tokens.ANY.rawValue, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_quantified_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterQuantified_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitQuantified_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitQuantified_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitQuantified_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func quantified_expression() throws -> Quantified_expressionContext {
		var _localctx: Quantified_expressionContext = Quantified_expressionContext(_ctx, getState())
		try enterRule(_localctx, 564, plsqlParser.RULE_quantified_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4194)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue || _la == plsqlParser.Tokens.ANY.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.EXISTS.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.SOME.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4203)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,519, _ctx)) {
		 	case 1:
		 		setState(4195)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4196)
		 		try subquery()
		 		setState(4197)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 2:
		 		setState(4199)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4200)
		 		try expression()
		 		setState(4201)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class String_functionContext:ParserRuleContext {
		open func SUBSTR() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUBSTR.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func COMMA() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.COMMA.rawValue) }
		open func COMMA(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.COMMA.rawValue, i)
		}
		open func TO_CHAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.TO_CHAR.rawValue, 0) }
		open func table_element() -> Table_elementContext? {
			return getRuleContext(Table_elementContext.self,0)
		}
		open func standard_function() -> Standard_functionContext? {
			return getRuleContext(Standard_functionContext.self,0)
		}
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open func DECODE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECODE.rawValue, 0) }
		open func CHR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHR.rawValue, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open func USING() -> TerminalNode? { return getToken(plsqlParser.Tokens.USING.rawValue, 0) }
		open func NCHAR_CS() -> TerminalNode? { return getToken(plsqlParser.Tokens.NCHAR_CS.rawValue, 0) }
		open func NVL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NVL.rawValue, 0) }
		open func TRIM() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRIM.rawValue, 0) }
		open func FROM() -> TerminalNode? { return getToken(plsqlParser.Tokens.FROM.rawValue, 0) }
		open func LEADING() -> TerminalNode? { return getToken(plsqlParser.Tokens.LEADING.rawValue, 0) }
		open func TRAILING() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRAILING.rawValue, 0) }
		open func BOTH() -> TerminalNode? { return getToken(plsqlParser.Tokens.BOTH.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_string_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterString_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitString_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitString_function(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitString_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func string_function() throws -> String_functionContext {
		var _localctx: String_functionContext = String_functionContext(_ctx, getState())
		try enterRule(_localctx, 566, plsqlParser.RULE_string_function)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4268)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SUBSTR:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4205)
		 		try match(plsqlParser.Tokens.SUBSTR.rawValue)
		 		setState(4206)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4207)
		 		try expression()
		 		setState(4208)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(4209)
		 		try expression()
		 		setState(4212)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4210)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4211)
		 			try expression()

		 		}

		 		setState(4214)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break

		 	case .TO_CHAR:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4216)
		 		try match(plsqlParser.Tokens.TO_CHAR.rawValue)
		 		setState(4217)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4220)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,521, _ctx)) {
		 		case 1:
		 			setState(4218)
		 			try table_element()

		 			break
		 		case 2:
		 			setState(4219)
		 			try standard_function()

		 			break
		 		default: break
		 		}
		 		setState(4224)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4222)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4223)
		 			try quoted_string()

		 		}

		 		setState(4226)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break

		 	case .DECODE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4228)
		 		try match(plsqlParser.Tokens.DECODE.rawValue)
		 		setState(4229)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4230)
		 		try expression()
		 		setState(4235)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4231)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4232)
		 			try expression()


		 			setState(4237)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4238)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break

		 	case .CHR:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4240)
		 		try match(plsqlParser.Tokens.CHR.rawValue)
		 		setState(4241)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4242)
		 		try concatenation()
		 		setState(4243)
		 		try match(plsqlParser.Tokens.USING.rawValue)
		 		setState(4244)
		 		try match(plsqlParser.Tokens.NCHAR_CS.rawValue)
		 		setState(4245)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break

		 	case .NVL:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4247)
		 		try match(plsqlParser.Tokens.NVL.rawValue)
		 		setState(4248)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4249)
		 		try expression()
		 		setState(4250)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(4251)
		 		try expression()
		 		setState(4252)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break

		 	case .TRIM:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(4254)
		 		try match(plsqlParser.Tokens.TRIM.rawValue)
		 		setState(4255)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4263)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,526,_ctx)) {
		 		case 1:
		 			setState(4257)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.Tokens.BOTH.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.LEADING.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.TRAILING.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(4256)
		 				_la = try _input.LA(1)
		 				if (!(//closure
		 				 { () -> Bool in
		 				      var testSet: Bool = _la == plsqlParser.Tokens.BOTH.rawValue
		 				          testSet = testSet || _la == plsqlParser.Tokens.LEADING.rawValue
		 				          testSet = testSet || _la == plsqlParser.Tokens.TRAILING.rawValue
		 				      return testSet
		 				 }())) {
		 				try _errHandler.recoverInline(self)
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 			}

		 			setState(4260)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue || _la == plsqlParser.Tokens.CHAR_STRING.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(4259)
		 				try quoted_string()

		 			}

		 			setState(4262)
		 			try match(plsqlParser.Tokens.FROM.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(4265)
		 		try concatenation()
		 		setState(4266)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Standard_functionContext:ParserRuleContext {
		open func string_function() -> String_functionContext? {
			return getRuleContext(String_functionContext.self,0)
		}
		open func numeric_function_wrapper() -> Numeric_function_wrapperContext? {
			return getRuleContext(Numeric_function_wrapperContext.self,0)
		}
		open func other_function() -> Other_functionContext? {
			return getRuleContext(Other_functionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_standard_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStandard_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStandard_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStandard_function(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStandard_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func standard_function() throws -> Standard_functionContext {
		var _localctx: Standard_functionContext = Standard_functionContext(_ctx, getState())
		try enterRule(_localctx, 568, plsqlParser.RULE_standard_function)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4273)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,528, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4270)
		 		try string_function()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4271)
		 		try numeric_function_wrapper()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4272)
		 		try other_function()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Numeric_function_wrapperContext:ParserRuleContext {
		open func numeric_function() -> Numeric_functionContext? {
			return getRuleContext(Numeric_functionContext.self,0)
		}
		open func single_column_for_loop() -> Single_column_for_loopContext? {
			return getRuleContext(Single_column_for_loopContext.self,0)
		}
		open func multi_column_for_loop() -> Multi_column_for_loopContext? {
			return getRuleContext(Multi_column_for_loopContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_numeric_function_wrapper }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNumeric_function_wrapper(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNumeric_function_wrapper(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNumeric_function_wrapper(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNumeric_function_wrapper(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func numeric_function_wrapper() throws -> Numeric_function_wrapperContext {
		var _localctx: Numeric_function_wrapperContext = Numeric_function_wrapperContext(_ctx, getState())
		try enterRule(_localctx, 570, plsqlParser.RULE_numeric_function_wrapper)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4275)
		 	try numeric_function()
		 	setState(4278)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,529,_ctx)) {
		 	case 1:
		 		setState(4276)
		 		try single_column_for_loop()

		 		break
		 	case 2:
		 		setState(4277)
		 		try multi_column_for_loop()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Numeric_functionContext:ParserRuleContext {
		open func SUM() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUM.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func DISTINCT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DISTINCT.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open func COUNT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COUNT.rawValue, 0) }
		open func over_clause() -> Over_clauseContext? {
			return getRuleContext(Over_clauseContext.self,0)
		}
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open func UNIQUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNIQUE.rawValue, 0) }
		open func ROUND() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROUND.rawValue, 0) }
		open func COMMA() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMMA.rawValue, 0) }
		open func UNSIGNED_INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue, 0) }
		open func AVG() -> TerminalNode? { return getToken(plsqlParser.Tokens.AVG.rawValue, 0) }
		open func MAX() -> TerminalNode? { return getToken(plsqlParser.Tokens.MAX.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_numeric_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNumeric_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNumeric_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNumeric_function(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNumeric_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func numeric_function() throws -> Numeric_functionContext {
		var _localctx: Numeric_functionContext = Numeric_functionContext(_ctx, getState())
		try enterRule(_localctx, 572, plsqlParser.RULE_numeric_function)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4328)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SUM:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4280)
		 		try match(plsqlParser.Tokens.SUM.rawValue)
		 		setState(4281)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4283)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,530,_ctx)) {
		 		case 1:
		 			setState(4282)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.DISTINCT.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(4285)
		 		try expression()
		 		setState(4286)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break

		 	case .COUNT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4288)
		 		try match(plsqlParser.Tokens.COUNT.rawValue)
		 		setState(4289)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4297)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ASTERISK:
		 			setState(4290)
		 			try match(plsqlParser.Tokens.ASTERISK.rawValue)

		 			break
		 		case .A_LETTER:fallthrough
		 		case .ADD:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGENT:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALL:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .ANY:fallthrough
		 		case .ARRAY:fallthrough
		 		case .ASSOCIATE:fallthrough
		 		case .AT:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .AUDIT:fallthrough
		 		case .AUTHID:fallthrough
		 		case .AUTO:fallthrough
		 		case .AUTOMATIC:fallthrough
		 		case .AUTONOMOUS_TRANSACTION:fallthrough
		 		case .BATCH:fallthrough
		 		case .BEFORE:fallthrough
		 		case .BFILE:fallthrough
		 		case .BINARY_DOUBLE:fallthrough
		 		case .BINARY_FLOAT:fallthrough
		 		case .BINARY_INTEGER:fallthrough
		 		case .BLOB:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BODY:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BOTH:fallthrough
		 		case .BULK:fallthrough
		 		case .BYTE:fallthrough
		 		case .C_LETTER:fallthrough
		 		case .CALL:fallthrough
		 		case .CANONICAL:fallthrough
		 		case .CASCADE:fallthrough
		 		case .CASE:fallthrough
		 		case .CAST:fallthrough
		 		case .CHAR:fallthrough
		 		case .CHAR_CS:fallthrough
		 		case .CHARACTER:fallthrough
		 		case .CHR:fallthrough
		 		case .CLOB:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTER:fallthrough
		 		case .COALESCE:fallthrough
		 		case .COLLECT:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .COMPATIBILITY:fallthrough
		 		case .COMPILE:fallthrough
		 		case .COMPOUND:fallthrough
		 		case .CONNECT_BY_ROOT:fallthrough
		 		case .CONSTANT:fallthrough
		 		case .CONSTRAINT:fallthrough
		 		case .CONSTRAINTS:fallthrough
		 		case .CONSTRUCTOR:fallthrough
		 		case .CONTENT:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTINUE:fallthrough
		 		case .CONVERT:fallthrough
		 		case .CORRUPT_XID:fallthrough
		 		case .CORRUPT_XID_ALL:fallthrough
		 		case .COST:fallthrough
		 		case .COUNT:fallthrough
		 		case .CROSS:fallthrough
		 		case .CUBE:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .CURSOR:fallthrough
		 		case .CUSTOMDATUM:fallthrough
		 		case .CYCLE:fallthrough
		 		case .DATA:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DATE:fallthrough
		 		case .DAY:fallthrough
		 		case .DB_ROLE_CHANGE:fallthrough
		 		case .DBTIMEZONE:fallthrough
		 		case .DDL:fallthrough
		 		case .DEBUG:fallthrough
		 		case .DEC:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .DECOMPOSE:fallthrough
		 		case .DECREMENT:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DEFAULTS:fallthrough
		 		case .DEFERRED:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DETERMINISTIC:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISASSOCIATE:fallthrough
		 		case .DISTINCT:fallthrough
		 		case .DOCUMENT:fallthrough
		 		case .DOUBLE:fallthrough
		 		case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 		case .EACH:fallthrough
		 		case .ELEMENT:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCODING:fallthrough
		 		case .ENTITYESCAPING:fallthrough
		 		case .ERR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVALNAME:fallthrough
		 		case .EXCEPTION:fallthrough
		 		case .EXCEPTION_INIT:fallthrough
		 		case .EXCEPTIONS:fallthrough
		 		case .EXCLUDE:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .EXISTS:fallthrough
		 		case .EXIT:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .EXTERNAL:fallthrough
		 		case .EXTRACT:fallthrough
		 		case .FAILURE:fallthrough
		 		case .FALSE:fallthrough
		 		case .FINAL:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .FLOAT:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FORALL:fallthrough
		 		case .FORCE:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GROUPING:fallthrough
		 		case .HASH:fallthrough
		 		case .HIDE:fallthrough
		 		case .HOUR:fallthrough
		 		case .IGNORE:fallthrough
		 		case .IMMEDIATE:fallthrough
		 		case .INCLUDE:fallthrough
		 		case .INCLUDING:fallthrough
		 		case .INCREMENT:fallthrough
		 		case .INDENT:fallthrough
		 		case .INDEXED:fallthrough
		 		case .INDICATOR:fallthrough
		 		case .INDICES:fallthrough
		 		case .INFINITE:fallthrough
		 		case .INLINE:fallthrough
		 		case .INNER:fallthrough
		 		case .INOUT:fallthrough
		 		case .INSTANTIABLE:fallthrough
		 		case .INSTEAD:fallthrough
		 		case .INT:fallthrough
		 		case .INTEGER:fallthrough
		 		case .INTERVAL:fallthrough
		 		case .INVALIDATE:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ITERATE:fallthrough
		 		case .JAVA:fallthrough
		 		case .JOIN:fallthrough
		 		case .KEEP:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEADING:fallthrough
		 		case .LEFT:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIBRARY:fallthrough
		 		case .LIKE2:fallthrough
		 		case .LIKE4:fallthrough
		 		case .LIKEC:fallthrough
		 		case .LIMIT:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCKED:fallthrough
		 		case .LOG:fallthrough
		 		case .LOGOFF:fallthrough
		 		case .LOGON:fallthrough
		 		case .LONG:fallthrough
		 		case .LOOP:fallthrough
		 		case .MAIN:fallthrough
		 		case .MAP:fallthrough
		 		case .MATCHED:fallthrough
		 		case .MAXVALUE:fallthrough
		 		case .MEASURES:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MINUTE:fallthrough
		 		case .MINVALUE:fallthrough
		 		case .MLSLABEL:fallthrough
		 		case .MODEL:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MONTH:fallthrough
		 		case .MULTISET:fallthrough
		 		case .NAME:fallthrough
		 		case .NAN:fallthrough
		 		case .NATURAL:fallthrough
		 		case .NATURALN:fallthrough
		 		case .NAV:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NCHAR_CS:fallthrough
		 		case .NCLOB:fallthrough
		 		case .NESTED:fallthrough
		 		case .NEW:fallthrough
		 		case .NO:fallthrough
		 		case .NOAUDIT:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOCYCLE:fallthrough
		 		case .NOENTITYESCAPING:fallthrough
		 		case .NONE:fallthrough
		 		case .NOSCHEMACHECK:fallthrough
		 		case .NULL:fallthrough
		 		case .NULLS:fallthrough
		 		case .NUMBER:fallthrough
		 		case .NUMERIC:fallthrough
		 		case .NVARCHAR2:fallthrough
		 		case .OBJECT:fallthrough
		 		case .OFF:fallthrough
		 		case .OID:fallthrough
		 		case .OLD:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .ORADATA:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .OSERROR:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTER:fallthrough
		 		case .OVER:fallthrough
		 		case .OVERRIDING:fallthrough
		 		case .PACKAGE:fallthrough
		 		case .PARALLEL_ENABLE:fallthrough
		 		case .PARAMETERS:fallthrough
		 		case .PARENT:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PASSING:fallthrough
		 		case .PATH:fallthrough
		 		case .PIPELINED:fallthrough
		 		case .PLAN:fallthrough
		 		case .PLS_INTEGER:fallthrough
		 		case .POSITIVE:fallthrough
		 		case .POSITIVEN:fallthrough
		 		case .PRAGMA:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRECISION:fallthrough
		 		case .PRESENT:fallthrough
		 		case .PRIOR:fallthrough
		 		case .RAISE:fallthrough
		 		case .RANGE:fallthrough
		 		case .RAW:fallthrough
		 		case .READ:fallthrough
		 		case .REAL:fallthrough
		 		case .RECORD:fallthrough
		 		case .REF:fallthrough
		 		case .REFERENCE:fallthrough
		 		case .REFERENCING:fallthrough
		 		case .REJECT:fallthrough
		 		case .RELIES_ON:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESPECT:fallthrough
		 		case .RESTRICT_REFERENCES:fallthrough
		 		case .RESULT:fallthrough
		 		case .RESULT_CACHE:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNING:fallthrough
		 		case .REUSE:fallthrough
		 		case .REVERSE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWID:fallthrough
		 		case .ROWS:fallthrough
		 		case .RULES:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SAVE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SCHEMACHECK:fallthrough
		 		case .SCN:fallthrough
		 		case .SECOND:fallthrough
		 		case .SEED:fallthrough
		 		case .SEGMENT:fallthrough
		 		case .SELF:fallthrough
		 		case .SEQUENTIAL:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SERIALLY_REUSABLE:fallthrough
		 		case .SERVERERROR:fallthrough
		 		case .SESSIONTIMEZONE:fallthrough
		 		case .SET:fallthrough
		 		case .SETS:fallthrough
		 		case .SETTINGS:fallthrough
		 		case .SHOW:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SIBLINGS:fallthrough
		 		case .SIGNTYPE:fallthrough
		 		case .SIMPLE_INTEGER:fallthrough
		 		case .SINGLE:fallthrough
		 		case .SKIP_:fallthrough
		 		case .SMALLINT:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOME:fallthrough
		 		case .SPECIFICATION:fallthrough
		 		case .SQLDATA:fallthrough
		 		case .SQLERROR:fallthrough
		 		case .STANDALONE:fallthrough
		 		case .STARTUP:fallthrough
		 		case .STATEMENT:fallthrough
		 		case .STATEMENT_ID:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATISTICS:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBMULTISET:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBSTITUTABLE:fallthrough
		 		case .SUBTYPE:fallthrough
		 		case .SUCCESS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 		case .TIMEZONE_ABBR:fallthrough
		 		case .TIMEZONE_HOUR:fallthrough
		 		case .TIMEZONE_MINUTE:fallthrough
		 		case .TIMEZONE_REGION:fallthrough
		 		case .TRAILING:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSLATE:fallthrough
		 		case .TREAT:fallthrough
		 		case .TRIGGER:fallthrough
		 		case .TRUE:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .TYPE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDER:fallthrough
		 		case .UNIQUE:fallthrough
		 		case .UNLIMITED:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPDATED:fallthrough
		 		case .UPSERT:fallthrough
		 		case .UROWID:fallthrough
		 		case .USE:fallthrough
		 		case .VALIDATE:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARCHAR:fallthrough
		 		case .VARCHAR2:fallthrough
		 		case .VARIABLE:fallthrough
		 		case .VARRAY:fallthrough
		 		case .VARYING:fallthrough
		 		case .VERSION:fallthrough
		 		case .VERSIONS:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNING:fallthrough
		 		case .WELLFORMED:fallthrough
		 		case .WHENEVER:fallthrough
		 		case .WHILE:fallthrough
		 		case .WITHIN:fallthrough
		 		case .WORK:fallthrough
		 		case .WRITE:fallthrough
		 		case .XML:fallthrough
		 		case .XMLAGG:fallthrough
		 		case .XMLATTRIBUTES:fallthrough
		 		case .XMLCAST:fallthrough
		 		case .XMLCOLATTVAL:fallthrough
		 		case .XMLELEMENT:fallthrough
		 		case .XMLEXISTS:fallthrough
		 		case .XMLFOREST:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .XMLPARSE:fallthrough
		 		case .XMLPI:fallthrough
		 		case .XMLQUERY:fallthrough
		 		case .XMLROOT:fallthrough
		 		case .XMLSERIALIZE:fallthrough
		 		case .XMLTABLE:fallthrough
		 		case .YEAR:fallthrough
		 		case .YES:fallthrough
		 		case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 		case .ZONE:fallthrough
		 		case .PREDICTION:fallthrough
		 		case .PREDICTION_BOUNDS:fallthrough
		 		case .PREDICTION_COST:fallthrough
		 		case .PREDICTION_DETAILS:fallthrough
		 		case .PREDICTION_PROBABILITY:fallthrough
		 		case .PREDICTION_SET:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .LISTAGG:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .PERCENTILE_CONT:fallthrough
		 		case .PERCENTILE_DISC:fallthrough
		 		case .RANK:fallthrough
		 		case .AVG:fallthrough
		 		case .CORR:fallthrough
		 		case .COVAR_:fallthrough
		 		case .DECODE:fallthrough
		 		case .LAG:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MEDIAN:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NVL:fallthrough
		 		case .RATIO_TO_REPORT:fallthrough
		 		case .REGR_:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .TO_CHAR:fallthrough
		 		case .TRIM:fallthrough
		 		case .SUM:fallthrough
		 		case .STDDEV:fallthrough
		 		case .VAR_:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 		case .UNSIGNED_INTEGER:fallthrough
		 		case .APPROXIMATE_NUM_LIT:fallthrough
		 		case .CHAR_STRING:fallthrough
		 		case .DELIMITED_ID:fallthrough
		 		case .LEFT_PAREN:fallthrough
		 		case .RIGHT_PAREN:fallthrough
		 		case .PLUS_SIGN:fallthrough
		 		case .MINUS_SIGN:fallthrough
		 		case .BINDVAR:fallthrough
		 		case .COLON:fallthrough
		 		case .INTRODUCER:fallthrough
		 		case .REGULAR_ID:
		 			setState(4295)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ALL.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ANY.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CASE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COALESCE.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.CONNECT_BY_ROOT.rawValue,plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DATE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DISTINCT.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 65)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTION_INIT.rawValue,plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXISTS.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FALSE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 129)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.LANGUAGE.rawValue,plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULL.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 193)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.OBJECT.rawValue,plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PRIOR.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 257)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.RIGHT.rawValue,plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 322)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUE.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNIQUE.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 386)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.YES.rawValue,plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.DECODE.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.NVL.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROUND.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.SUBSTR.rawValue,plsqlParser.Tokens.TO_CHAR.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue,plsqlParser.Tokens.APPROXIMATE_NUM_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue,plsqlParser.Tokens.LEFT_PAREN.rawValue,plsqlParser.Tokens.PLUS_SIGN.rawValue,plsqlParser.Tokens.MINUS_SIGN.rawValue,plsqlParser.Tokens.BINDVAR.rawValue,plsqlParser.Tokens.COLON.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 450)
		 			          }()
		 			          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(4292)
		 				try _errHandler.sync(self)
		 				switch (try getInterpreter().adaptivePredict(_input,531,_ctx)) {
		 				case 1:
		 					setState(4291)
		 					_la = try _input.LA(1)
		 					if (!(//closure
		 					 { () -> Bool in
		 					      var testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue
		 					          testSet = testSet || _la == plsqlParser.Tokens.DISTINCT.rawValue
		 					          testSet = testSet || _la == plsqlParser.Tokens.UNIQUE.rawValue
		 					      return testSet
		 					 }())) {
		 					try _errHandler.recoverInline(self)
		 					}
		 					else {
		 						_errHandler.reportMatch(self)
		 						try consume()
		 					}

		 					break
		 				default: break
		 				}
		 				setState(4294)
		 				try concatenation()

		 			}


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4299)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4301)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,534,_ctx)) {
		 		case 1:
		 			setState(4300)
		 			try over_clause()

		 			break
		 		default: break
		 		}

		 		break

		 	case .ROUND:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4303)
		 		try match(plsqlParser.Tokens.ROUND.rawValue)
		 		setState(4304)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4305)
		 		try expression()
		 		setState(4308)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4306)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4307)
		 			try match(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue)

		 		}

		 		setState(4310)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break

		 	case .AVG:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4312)
		 		try match(plsqlParser.Tokens.AVG.rawValue)
		 		setState(4313)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4315)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,536,_ctx)) {
		 		case 1:
		 			setState(4314)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.DISTINCT.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(4317)
		 		try expression()
		 		setState(4318)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break

		 	case .MAX:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4320)
		 		try match(plsqlParser.Tokens.MAX.rawValue)
		 		setState(4321)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4323)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,537,_ctx)) {
		 		case 1:
		 			setState(4322)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.DISTINCT.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(4325)
		 		try expression()
		 		setState(4326)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Other_functionContext:ParserRuleContext {
		open func over_clause_keyword() -> Over_clause_keywordContext? {
			return getRuleContext(Over_clause_keywordContext.self,0)
		}
		open func function_argument_analytic() -> Function_argument_analyticContext? {
			return getRuleContext(Function_argument_analyticContext.self,0)
		}
		open func over_clause() -> Over_clauseContext? {
			return getRuleContext(Over_clauseContext.self,0)
		}
		open func regular_id() -> Regular_idContext? {
			return getRuleContext(Regular_idContext.self,0)
		}
		open func function_argument_modeling() -> Function_argument_modelingContext? {
			return getRuleContext(Function_argument_modelingContext.self,0)
		}
		open func using_clause() -> Using_clauseContext? {
			return getRuleContext(Using_clauseContext.self,0)
		}
		open func COUNT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COUNT.rawValue, 0) }
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func DISTINCT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DISTINCT.rawValue, 0) }
		open func UNIQUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNIQUE.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.ALL.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func CAST() -> TerminalNode? { return getToken(plsqlParser.Tokens.CAST.rawValue, 0) }
		open func XMLCAST() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLCAST.rawValue, 0) }
		open func MULTISET() -> TerminalNode? { return getToken(plsqlParser.Tokens.MULTISET.rawValue, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func COALESCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.COALESCE.rawValue, 0) }
		open func table_element() -> Table_elementContext? {
			return getRuleContext(Table_elementContext.self,0)
		}
		open func COMMA() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMMA.rawValue, 0) }
		open func numeric() -> NumericContext? {
			return getRuleContext(NumericContext.self,0)
		}
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open func COLLECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COLLECT.rawValue, 0) }
		open func collect_order_by_part() -> Collect_order_by_partContext? {
			return getRuleContext(Collect_order_by_partContext.self,0)
		}
		open func within_or_over_clause_keyword() -> Within_or_over_clause_keywordContext? {
			return getRuleContext(Within_or_over_clause_keywordContext.self,0)
		}
		open func function_argument() -> Function_argumentContext? {
			return getRuleContext(Function_argumentContext.self,0)
		}
		open func within_or_over_part() -> Array<Within_or_over_partContext> {
			return getRuleContexts(Within_or_over_partContext.self)
		}
		open func within_or_over_part(_ i: Int) -> Within_or_over_partContext? {
			return getRuleContext(Within_or_over_partContext.self,i)
		}
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func PERCENT_ISOPEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENT_ISOPEN.rawValue, 0) }
		open func PERCENT_FOUND() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENT_FOUND.rawValue, 0) }
		open func PERCENT_NOTFOUND() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENT_NOTFOUND.rawValue, 0) }
		open func PERCENT_ROWCOUNT() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENT_ROWCOUNT.rawValue, 0) }
		open func DECOMPOSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECOMPOSE.rawValue, 0) }
		open func CANONICAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.CANONICAL.rawValue, 0) }
		open func COMPATIBILITY() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMPATIBILITY.rawValue, 0) }
		open func EXTRACT() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXTRACT.rawValue, 0) }
		open func FROM() -> TerminalNode? { return getToken(plsqlParser.Tokens.FROM.rawValue, 0) }
		open func FIRST_VALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.FIRST_VALUE.rawValue, 0) }
		open func LAST_VALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.LAST_VALUE.rawValue, 0) }
		open func respect_or_ignore_nulls() -> Respect_or_ignore_nullsContext? {
			return getRuleContext(Respect_or_ignore_nullsContext.self,0)
		}
		open func standard_prediction_function_keyword() -> Standard_prediction_function_keywordContext? {
			return getRuleContext(Standard_prediction_function_keywordContext.self,0)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func cost_matrix_clause() -> Cost_matrix_clauseContext? {
			return getRuleContext(Cost_matrix_clauseContext.self,0)
		}
		open func TRANSLATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRANSLATE.rawValue, 0) }
		open func USING() -> TerminalNode? { return getToken(plsqlParser.Tokens.USING.rawValue, 0) }
		open func CHAR_CS() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHAR_CS.rawValue, 0) }
		open func NCHAR_CS() -> TerminalNode? { return getToken(plsqlParser.Tokens.NCHAR_CS.rawValue, 0) }
		open func TREAT() -> TerminalNode? { return getToken(plsqlParser.Tokens.TREAT.rawValue, 0) }
		open func REF() -> TerminalNode? { return getToken(plsqlParser.Tokens.REF.rawValue, 0) }
		open func TRIM() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRIM.rawValue, 0) }
		open func LEADING() -> TerminalNode? { return getToken(plsqlParser.Tokens.LEADING.rawValue, 0) }
		open func TRAILING() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRAILING.rawValue, 0) }
		open func BOTH() -> TerminalNode? { return getToken(plsqlParser.Tokens.BOTH.rawValue, 0) }
		open func XMLAGG() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLAGG.rawValue, 0) }
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func general_element_part() -> General_element_partContext? {
			return getRuleContext(General_element_partContext.self,0)
		}
		open func xml_multiuse_expression_element() -> Array<Xml_multiuse_expression_elementContext> {
			return getRuleContexts(Xml_multiuse_expression_elementContext.self)
		}
		open func xml_multiuse_expression_element(_ i: Int) -> Xml_multiuse_expression_elementContext? {
			return getRuleContext(Xml_multiuse_expression_elementContext.self,i)
		}
		open func XMLCOLATTVAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLCOLATTVAL.rawValue, 0) }
		open func XMLFOREST() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLFOREST.rawValue, 0) }
		open func XMLELEMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLELEMENT.rawValue, 0) }
		open func xml_attributes_clause() -> Xml_attributes_clauseContext? {
			return getRuleContext(Xml_attributes_clauseContext.self,0)
		}
		open func ENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.Tokens.ENTITYESCAPING.rawValue, 0) }
		open func NOENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOENTITYESCAPING.rawValue, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.NAME.rawValue, 0) }
		open func EVALNAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.EVALNAME.rawValue, 0) }
		open func column_alias() -> Array<Column_aliasContext> {
			return getRuleContexts(Column_aliasContext.self)
		}
		open func column_alias(_ i: Int) -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,i)
		}
		open func XMLEXISTS() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLEXISTS.rawValue, 0) }
		open func xml_passing_clause() -> Xml_passing_clauseContext? {
			return getRuleContext(Xml_passing_clauseContext.self,0)
		}
		open func XMLPARSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLPARSE.rawValue, 0) }
		open func DOCUMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DOCUMENT.rawValue, 0) }
		open func CONTENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONTENT.rawValue, 0) }
		open func WELLFORMED() -> TerminalNode? { return getToken(plsqlParser.Tokens.WELLFORMED.rawValue, 0) }
		open func XMLPI() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLPI.rawValue, 0) }
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func XMLQUERY() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLQUERY.rawValue, 0) }
		open func RETURNING() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURNING.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULL.rawValue, 0) }
		open func ON() -> TerminalNode? { return getToken(plsqlParser.Tokens.ON.rawValue, 0) }
		open func EMPTY() -> TerminalNode? { return getToken(plsqlParser.Tokens.EMPTY.rawValue, 0) }
		open func XMLROOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLROOT.rawValue, 0) }
		open func xmlroot_param_version_part() -> Xmlroot_param_version_partContext? {
			return getRuleContext(Xmlroot_param_version_partContext.self,0)
		}
		open func xmlroot_param_standalone_part() -> Xmlroot_param_standalone_partContext? {
			return getRuleContext(Xmlroot_param_standalone_partContext.self,0)
		}
		open func XMLSERIALIZE() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLSERIALIZE.rawValue, 0) }
		open func xmlserialize_param_enconding_part() -> Xmlserialize_param_enconding_partContext? {
			return getRuleContext(Xmlserialize_param_enconding_partContext.self,0)
		}
		open func xmlserialize_param_version_part() -> Xmlserialize_param_version_partContext? {
			return getRuleContext(Xmlserialize_param_version_partContext.self,0)
		}
		open func xmlserialize_param_ident_part() -> Xmlserialize_param_ident_partContext? {
			return getRuleContext(Xmlserialize_param_ident_partContext.self,0)
		}
		open func DEFAULTS() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFAULTS.rawValue, 0) }
		open func HIDE() -> TerminalNode? { return getToken(plsqlParser.Tokens.HIDE.rawValue, 0) }
		open func SHOW() -> TerminalNode? { return getToken(plsqlParser.Tokens.SHOW.rawValue, 0) }
		open func XMLTABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLTABLE.rawValue, 0) }
		open func xml_namespaces_clause() -> Xml_namespaces_clauseContext? {
			return getRuleContext(Xml_namespaces_clauseContext.self,0)
		}
		open func COLUMNS() -> TerminalNode? { return getToken(plsqlParser.Tokens.COLUMNS.rawValue, 0) }
		open func xml_table_column() -> Array<Xml_table_columnContext> {
			return getRuleContexts(Xml_table_columnContext.self)
		}
		open func xml_table_column(_ i: Int) -> Xml_table_columnContext? {
			return getRuleContext(Xml_table_columnContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_other_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOther_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOther_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOther_function(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOther_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func other_function() throws -> Other_functionContext {
		var _localctx: Other_functionContext = Other_functionContext(_ctx, getState())
		try enterRule(_localctx, 574, plsqlParser.RULE_other_function)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(4652)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,593, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4330)
		 		try over_clause_keyword()
		 		setState(4331)
		 		try function_argument_analytic()
		 		setState(4333)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,539,_ctx)) {
		 		case 1:
		 			setState(4332)
		 			try over_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4335)
		 		try regular_id()
		 		setState(4336)
		 		try function_argument_modeling()
		 		setState(4338)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,540,_ctx)) {
		 		case 1:
		 			setState(4337)
		 			try using_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4340)
		 		try match(plsqlParser.Tokens.COUNT.rawValue)
		 		setState(4341)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4347)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ASTERISK:
		 			setState(4342)
		 			try match(plsqlParser.Tokens.ASTERISK.rawValue)

		 			break
		 		case .A_LETTER:fallthrough
		 		case .ADD:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGENT:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALL:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .ANY:fallthrough
		 		case .ARRAY:fallthrough
		 		case .ASSOCIATE:fallthrough
		 		case .AT:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .AUDIT:fallthrough
		 		case .AUTHID:fallthrough
		 		case .AUTO:fallthrough
		 		case .AUTOMATIC:fallthrough
		 		case .AUTONOMOUS_TRANSACTION:fallthrough
		 		case .BATCH:fallthrough
		 		case .BEFORE:fallthrough
		 		case .BFILE:fallthrough
		 		case .BINARY_DOUBLE:fallthrough
		 		case .BINARY_FLOAT:fallthrough
		 		case .BINARY_INTEGER:fallthrough
		 		case .BLOB:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BODY:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BOTH:fallthrough
		 		case .BULK:fallthrough
		 		case .BYTE:fallthrough
		 		case .C_LETTER:fallthrough
		 		case .CALL:fallthrough
		 		case .CANONICAL:fallthrough
		 		case .CASCADE:fallthrough
		 		case .CASE:fallthrough
		 		case .CAST:fallthrough
		 		case .CHAR:fallthrough
		 		case .CHAR_CS:fallthrough
		 		case .CHARACTER:fallthrough
		 		case .CHR:fallthrough
		 		case .CLOB:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTER:fallthrough
		 		case .COALESCE:fallthrough
		 		case .COLLECT:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .COMPATIBILITY:fallthrough
		 		case .COMPILE:fallthrough
		 		case .COMPOUND:fallthrough
		 		case .CONNECT_BY_ROOT:fallthrough
		 		case .CONSTANT:fallthrough
		 		case .CONSTRAINT:fallthrough
		 		case .CONSTRAINTS:fallthrough
		 		case .CONSTRUCTOR:fallthrough
		 		case .CONTENT:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTINUE:fallthrough
		 		case .CONVERT:fallthrough
		 		case .CORRUPT_XID:fallthrough
		 		case .CORRUPT_XID_ALL:fallthrough
		 		case .COST:fallthrough
		 		case .COUNT:fallthrough
		 		case .CROSS:fallthrough
		 		case .CUBE:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .CURSOR:fallthrough
		 		case .CUSTOMDATUM:fallthrough
		 		case .CYCLE:fallthrough
		 		case .DATA:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DATE:fallthrough
		 		case .DAY:fallthrough
		 		case .DB_ROLE_CHANGE:fallthrough
		 		case .DBTIMEZONE:fallthrough
		 		case .DDL:fallthrough
		 		case .DEBUG:fallthrough
		 		case .DEC:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .DECOMPOSE:fallthrough
		 		case .DECREMENT:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DEFAULTS:fallthrough
		 		case .DEFERRED:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DETERMINISTIC:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISASSOCIATE:fallthrough
		 		case .DISTINCT:fallthrough
		 		case .DOCUMENT:fallthrough
		 		case .DOUBLE:fallthrough
		 		case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 		case .EACH:fallthrough
		 		case .ELEMENT:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCODING:fallthrough
		 		case .ENTITYESCAPING:fallthrough
		 		case .ERR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVALNAME:fallthrough
		 		case .EXCEPTION:fallthrough
		 		case .EXCEPTION_INIT:fallthrough
		 		case .EXCEPTIONS:fallthrough
		 		case .EXCLUDE:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .EXISTS:fallthrough
		 		case .EXIT:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .EXTERNAL:fallthrough
		 		case .EXTRACT:fallthrough
		 		case .FAILURE:fallthrough
		 		case .FALSE:fallthrough
		 		case .FINAL:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .FLOAT:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FORALL:fallthrough
		 		case .FORCE:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GROUPING:fallthrough
		 		case .HASH:fallthrough
		 		case .HIDE:fallthrough
		 		case .HOUR:fallthrough
		 		case .IGNORE:fallthrough
		 		case .IMMEDIATE:fallthrough
		 		case .INCLUDE:fallthrough
		 		case .INCLUDING:fallthrough
		 		case .INCREMENT:fallthrough
		 		case .INDENT:fallthrough
		 		case .INDEXED:fallthrough
		 		case .INDICATOR:fallthrough
		 		case .INDICES:fallthrough
		 		case .INFINITE:fallthrough
		 		case .INLINE:fallthrough
		 		case .INNER:fallthrough
		 		case .INOUT:fallthrough
		 		case .INSTANTIABLE:fallthrough
		 		case .INSTEAD:fallthrough
		 		case .INT:fallthrough
		 		case .INTEGER:fallthrough
		 		case .INTERVAL:fallthrough
		 		case .INVALIDATE:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ITERATE:fallthrough
		 		case .JAVA:fallthrough
		 		case .JOIN:fallthrough
		 		case .KEEP:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEADING:fallthrough
		 		case .LEFT:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIBRARY:fallthrough
		 		case .LIKE2:fallthrough
		 		case .LIKE4:fallthrough
		 		case .LIKEC:fallthrough
		 		case .LIMIT:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCKED:fallthrough
		 		case .LOG:fallthrough
		 		case .LOGOFF:fallthrough
		 		case .LOGON:fallthrough
		 		case .LONG:fallthrough
		 		case .LOOP:fallthrough
		 		case .MAIN:fallthrough
		 		case .MAP:fallthrough
		 		case .MATCHED:fallthrough
		 		case .MAXVALUE:fallthrough
		 		case .MEASURES:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MINUTE:fallthrough
		 		case .MINVALUE:fallthrough
		 		case .MLSLABEL:fallthrough
		 		case .MODEL:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MONTH:fallthrough
		 		case .MULTISET:fallthrough
		 		case .NAME:fallthrough
		 		case .NAN:fallthrough
		 		case .NATURAL:fallthrough
		 		case .NATURALN:fallthrough
		 		case .NAV:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NCHAR_CS:fallthrough
		 		case .NCLOB:fallthrough
		 		case .NESTED:fallthrough
		 		case .NEW:fallthrough
		 		case .NO:fallthrough
		 		case .NOAUDIT:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOCYCLE:fallthrough
		 		case .NOENTITYESCAPING:fallthrough
		 		case .NONE:fallthrough
		 		case .NOSCHEMACHECK:fallthrough
		 		case .NULL:fallthrough
		 		case .NULLS:fallthrough
		 		case .NUMBER:fallthrough
		 		case .NUMERIC:fallthrough
		 		case .NVARCHAR2:fallthrough
		 		case .OBJECT:fallthrough
		 		case .OFF:fallthrough
		 		case .OID:fallthrough
		 		case .OLD:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .ORADATA:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .OSERROR:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTER:fallthrough
		 		case .OVER:fallthrough
		 		case .OVERRIDING:fallthrough
		 		case .PACKAGE:fallthrough
		 		case .PARALLEL_ENABLE:fallthrough
		 		case .PARAMETERS:fallthrough
		 		case .PARENT:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PASSING:fallthrough
		 		case .PATH:fallthrough
		 		case .PIPELINED:fallthrough
		 		case .PLAN:fallthrough
		 		case .PLS_INTEGER:fallthrough
		 		case .POSITIVE:fallthrough
		 		case .POSITIVEN:fallthrough
		 		case .PRAGMA:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRECISION:fallthrough
		 		case .PRESENT:fallthrough
		 		case .PRIOR:fallthrough
		 		case .RAISE:fallthrough
		 		case .RANGE:fallthrough
		 		case .RAW:fallthrough
		 		case .READ:fallthrough
		 		case .REAL:fallthrough
		 		case .RECORD:fallthrough
		 		case .REF:fallthrough
		 		case .REFERENCE:fallthrough
		 		case .REFERENCING:fallthrough
		 		case .REJECT:fallthrough
		 		case .RELIES_ON:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESPECT:fallthrough
		 		case .RESTRICT_REFERENCES:fallthrough
		 		case .RESULT:fallthrough
		 		case .RESULT_CACHE:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNING:fallthrough
		 		case .REUSE:fallthrough
		 		case .REVERSE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWID:fallthrough
		 		case .ROWS:fallthrough
		 		case .RULES:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SAVE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SCHEMACHECK:fallthrough
		 		case .SCN:fallthrough
		 		case .SECOND:fallthrough
		 		case .SEED:fallthrough
		 		case .SEGMENT:fallthrough
		 		case .SELF:fallthrough
		 		case .SEQUENTIAL:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SERIALLY_REUSABLE:fallthrough
		 		case .SERVERERROR:fallthrough
		 		case .SESSIONTIMEZONE:fallthrough
		 		case .SET:fallthrough
		 		case .SETS:fallthrough
		 		case .SETTINGS:fallthrough
		 		case .SHOW:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SIBLINGS:fallthrough
		 		case .SIGNTYPE:fallthrough
		 		case .SIMPLE_INTEGER:fallthrough
		 		case .SINGLE:fallthrough
		 		case .SKIP_:fallthrough
		 		case .SMALLINT:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOME:fallthrough
		 		case .SPECIFICATION:fallthrough
		 		case .SQLDATA:fallthrough
		 		case .SQLERROR:fallthrough
		 		case .STANDALONE:fallthrough
		 		case .STARTUP:fallthrough
		 		case .STATEMENT:fallthrough
		 		case .STATEMENT_ID:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATISTICS:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBMULTISET:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBSTITUTABLE:fallthrough
		 		case .SUBTYPE:fallthrough
		 		case .SUCCESS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 		case .TIMEZONE_ABBR:fallthrough
		 		case .TIMEZONE_HOUR:fallthrough
		 		case .TIMEZONE_MINUTE:fallthrough
		 		case .TIMEZONE_REGION:fallthrough
		 		case .TRAILING:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSLATE:fallthrough
		 		case .TREAT:fallthrough
		 		case .TRIGGER:fallthrough
		 		case .TRUE:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .TYPE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDER:fallthrough
		 		case .UNIQUE:fallthrough
		 		case .UNLIMITED:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPDATED:fallthrough
		 		case .UPSERT:fallthrough
		 		case .UROWID:fallthrough
		 		case .USE:fallthrough
		 		case .VALIDATE:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARCHAR:fallthrough
		 		case .VARCHAR2:fallthrough
		 		case .VARIABLE:fallthrough
		 		case .VARRAY:fallthrough
		 		case .VARYING:fallthrough
		 		case .VERSION:fallthrough
		 		case .VERSIONS:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNING:fallthrough
		 		case .WELLFORMED:fallthrough
		 		case .WHENEVER:fallthrough
		 		case .WHILE:fallthrough
		 		case .WITHIN:fallthrough
		 		case .WORK:fallthrough
		 		case .WRITE:fallthrough
		 		case .XML:fallthrough
		 		case .XMLAGG:fallthrough
		 		case .XMLATTRIBUTES:fallthrough
		 		case .XMLCAST:fallthrough
		 		case .XMLCOLATTVAL:fallthrough
		 		case .XMLELEMENT:fallthrough
		 		case .XMLEXISTS:fallthrough
		 		case .XMLFOREST:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .XMLPARSE:fallthrough
		 		case .XMLPI:fallthrough
		 		case .XMLQUERY:fallthrough
		 		case .XMLROOT:fallthrough
		 		case .XMLSERIALIZE:fallthrough
		 		case .XMLTABLE:fallthrough
		 		case .YEAR:fallthrough
		 		case .YES:fallthrough
		 		case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 		case .ZONE:fallthrough
		 		case .PREDICTION:fallthrough
		 		case .PREDICTION_BOUNDS:fallthrough
		 		case .PREDICTION_COST:fallthrough
		 		case .PREDICTION_DETAILS:fallthrough
		 		case .PREDICTION_PROBABILITY:fallthrough
		 		case .PREDICTION_SET:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .LISTAGG:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .PERCENTILE_CONT:fallthrough
		 		case .PERCENTILE_DISC:fallthrough
		 		case .RANK:fallthrough
		 		case .AVG:fallthrough
		 		case .CORR:fallthrough
		 		case .COVAR_:fallthrough
		 		case .DECODE:fallthrough
		 		case .LAG:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MEDIAN:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NVL:fallthrough
		 		case .RATIO_TO_REPORT:fallthrough
		 		case .REGR_:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .TO_CHAR:fallthrough
		 		case .TRIM:fallthrough
		 		case .SUM:fallthrough
		 		case .STDDEV:fallthrough
		 		case .VAR_:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 		case .UNSIGNED_INTEGER:fallthrough
		 		case .APPROXIMATE_NUM_LIT:fallthrough
		 		case .CHAR_STRING:fallthrough
		 		case .DELIMITED_ID:fallthrough
		 		case .LEFT_PAREN:fallthrough
		 		case .PLUS_SIGN:fallthrough
		 		case .MINUS_SIGN:fallthrough
		 		case .BINDVAR:fallthrough
		 		case .COLON:fallthrough
		 		case .INTRODUCER:fallthrough
		 		case .REGULAR_ID:
		 			setState(4344)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,541,_ctx)) {
		 			case 1:
		 				setState(4343)
		 				_la = try _input.LA(1)
		 				if (!(//closure
		 				 { () -> Bool in
		 				      var testSet: Bool = _la == plsqlParser.Tokens.ALL.rawValue
		 				          testSet = testSet || _la == plsqlParser.Tokens.DISTINCT.rawValue
		 				          testSet = testSet || _la == plsqlParser.Tokens.UNIQUE.rawValue
		 				      return testSet
		 				 }())) {
		 				try _errHandler.recoverInline(self)
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 				break
		 			default: break
		 			}
		 			setState(4346)
		 			try concatenation()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4349)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4351)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,543,_ctx)) {
		 		case 1:
		 			setState(4350)
		 			try over_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4353)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.CAST.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.XMLCAST.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4354)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4361)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,544, _ctx)) {
		 		case 1:
		 			setState(4355)
		 			try match(plsqlParser.Tokens.MULTISET.rawValue)
		 			setState(4356)
		 			try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 			setState(4357)
		 			try subquery()
		 			setState(4358)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 			break
		 		case 2:
		 			setState(4360)
		 			try concatenation()

		 			break
		 		default: break
		 		}
		 		setState(4363)
		 		try match(plsqlParser.Tokens.AS.rawValue)
		 		setState(4364)
		 		try type_spec()
		 		setState(4365)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4367)
		 		try match(plsqlParser.Tokens.COALESCE.rawValue)
		 		setState(4368)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4369)
		 		try table_element()
		 		setState(4375)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4370)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4373)
		 			try _errHandler.sync(self)
		 			switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .UNSIGNED_INTEGER:fallthrough
		 			case .APPROXIMATE_NUM_LIT:
		 				setState(4371)
		 				try numeric()

		 				break
		 			case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 			case .CHAR_STRING:
		 				setState(4372)
		 				try quoted_string()

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 		}

		 		setState(4377)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(4379)
		 		try match(plsqlParser.Tokens.COLLECT.rawValue)
		 		setState(4380)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4382)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,547,_ctx)) {
		 		case 1:
		 			setState(4381)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.Tokens.DISTINCT.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.UNIQUE.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(4384)
		 		try concatenation()
		 		setState(4386)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.ORDER.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4385)
		 			try collect_order_by_part()

		 		}

		 		setState(4388)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(4390)
		 		try within_or_over_clause_keyword()
		 		setState(4391)
		 		try function_argument()
		 		setState(4393); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(4392)
		 				try within_or_over_part()


		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(4395); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,549,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(4397)
		 		try cursor_name()
		 		setState(4398)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.Tokens.PERCENT_ISOPEN.rawValue,plsqlParser.Tokens.PERCENT_FOUND.rawValue,plsqlParser.Tokens.PERCENT_NOTFOUND.rawValue,plsqlParser.Tokens.PERCENT_ROWCOUNT.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 282)
		 		}()
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(4400)
		 		try match(plsqlParser.Tokens.DECOMPOSE.rawValue)
		 		setState(4401)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4402)
		 		try concatenation()
		 		setState(4404)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.CANONICAL.rawValue || _la == plsqlParser.Tokens.COMPATIBILITY.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4403)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.CANONICAL.rawValue || _la == plsqlParser.Tokens.COMPATIBILITY.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(4406)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(4408)
		 		try match(plsqlParser.Tokens.EXTRACT.rawValue)
		 		setState(4409)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4410)
		 		try regular_id()
		 		setState(4411)
		 		try match(plsqlParser.Tokens.FROM.rawValue)
		 		setState(4412)
		 		try concatenation()
		 		setState(4413)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(4415)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.FIRST_VALUE.rawValue || _la == plsqlParser.Tokens.LAST_VALUE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4416)
		 		try function_argument_analytic()
		 		setState(4418)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.IGNORE.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.RESPECT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4417)
		 			try respect_or_ignore_nulls()

		 		}

		 		setState(4420)
		 		try over_clause()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(4422)
		 		try standard_prediction_function_keyword()
		 		setState(4423)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4424)
		 		try expression()
		 		setState(4429)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4425)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4426)
		 			try expression()


		 			setState(4431)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4433)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COST.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4432)
		 			try cost_matrix_clause()

		 		}

		 		setState(4436)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.USING.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4435)
		 			try using_clause()

		 		}

		 		setState(4438)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(4440)
		 		try match(plsqlParser.Tokens.TRANSLATE.rawValue)
		 		setState(4441)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4442)
		 		try expression()
		 		setState(4445)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.USING.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4443)
		 			try match(plsqlParser.Tokens.USING.rawValue)
		 			setState(4444)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.Tokens.CHAR_CS.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.NCHAR_CS.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(4451)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4447)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4448)
		 			try expression()


		 			setState(4453)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4454)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(4456)
		 		try match(plsqlParser.Tokens.TREAT.rawValue)
		 		setState(4457)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4458)
		 		try expression()
		 		setState(4459)
		 		try match(plsqlParser.Tokens.AS.rawValue)
		 		setState(4461)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,557,_ctx)) {
		 		case 1:
		 			setState(4460)
		 			try match(plsqlParser.Tokens.REF.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(4463)
		 		try type_spec()
		 		setState(4464)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(4466)
		 		try match(plsqlParser.Tokens.TRIM.rawValue)
		 		setState(4467)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4475)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,560,_ctx)) {
		 		case 1:
		 			setState(4469)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.Tokens.BOTH.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.LEADING.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.TRAILING.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(4468)
		 				_la = try _input.LA(1)
		 				if (!(//closure
		 				 { () -> Bool in
		 				      var testSet: Bool = _la == plsqlParser.Tokens.BOTH.rawValue
		 				          testSet = testSet || _la == plsqlParser.Tokens.LEADING.rawValue
		 				          testSet = testSet || _la == plsqlParser.Tokens.TRAILING.rawValue
		 				      return testSet
		 				 }())) {
		 				try _errHandler.recoverInline(self)
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 			}

		 			setState(4472)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue || _la == plsqlParser.Tokens.CHAR_STRING.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(4471)
		 				try quoted_string()

		 			}

		 			setState(4474)
		 			try match(plsqlParser.Tokens.FROM.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(4477)
		 		try concatenation()
		 		setState(4478)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(4480)
		 		try match(plsqlParser.Tokens.XMLAGG.rawValue)
		 		setState(4481)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4482)
		 		try expression()
		 		setState(4484)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.ORDER.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4483)
		 			try order_by_clause()

		 		}

		 		setState(4486)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4489)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,562,_ctx)) {
		 		case 1:
		 			setState(4487)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(4488)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(4491)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.XMLCOLATTVAL.rawValue || _la == plsqlParser.Tokens.XMLFOREST.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4492)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4493)
		 		try xml_multiuse_expression_element()
		 		setState(4498)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4494)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4495)
		 			try xml_multiuse_expression_element()


		 			setState(4500)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4501)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4504)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,564,_ctx)) {
		 		case 1:
		 			setState(4502)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(4503)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(4506)
		 		try match(plsqlParser.Tokens.XMLELEMENT.rawValue)
		 		setState(4507)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4509)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,565,_ctx)) {
		 		case 1:
		 			setState(4508)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.Tokens.ENTITYESCAPING.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.NOENTITYESCAPING.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(4512)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,566,_ctx)) {
		 		case 1:
		 			setState(4511)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.Tokens.EVALNAME.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.NAME.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(4514)
		 		try expression()
		 		setState(4517)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,567,_ctx)) {
		 		case 1:
		 			setState(4515)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4516)
		 			try xml_attributes_clause()

		 			break
		 		default: break
		 		}
		 		setState(4526)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4519)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4520)
		 			try expression()
		 			setState(4522)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.AS.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 66)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 130)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 194)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 259)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 323)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 387)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 451)
		 			          }()
		 			          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(4521)
		 				try column_alias()

		 			}



		 			setState(4528)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4529)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4532)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,570,_ctx)) {
		 		case 1:
		 			setState(4530)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(4531)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(4534)
		 		try match(plsqlParser.Tokens.XMLEXISTS.rawValue)
		 		setState(4535)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4536)
		 		try expression()
		 		setState(4538)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.PASSING.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4537)
		 			try xml_passing_clause()

		 		}

		 		setState(4540)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break
		 	case 20:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(4542)
		 		try match(plsqlParser.Tokens.XMLPARSE.rawValue)
		 		setState(4543)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4544)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.CONTENT.rawValue || _la == plsqlParser.Tokens.DOCUMENT.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4545)
		 		try concatenation()
		 		setState(4547)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.WELLFORMED.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4546)
		 			try match(plsqlParser.Tokens.WELLFORMED.rawValue)

		 		}

		 		setState(4549)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4552)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,573,_ctx)) {
		 		case 1:
		 			setState(4550)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(4551)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 21:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(4554)
		 		try match(plsqlParser.Tokens.XMLPI.rawValue)
		 		setState(4555)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4560)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .NAME:
		 			setState(4556)
		 			try match(plsqlParser.Tokens.NAME.rawValue)
		 			setState(4557)
		 			try identifier()

		 			break

		 		case .EVALNAME:
		 			setState(4558)
		 			try match(plsqlParser.Tokens.EVALNAME.rawValue)
		 			setState(4559)
		 			try concatenation()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4564)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4562)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4563)
		 			try concatenation()

		 		}

		 		setState(4566)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4569)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,576,_ctx)) {
		 		case 1:
		 			setState(4567)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(4568)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 22:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(4571)
		 		try match(plsqlParser.Tokens.XMLQUERY.rawValue)
		 		setState(4572)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4573)
		 		try concatenation()
		 		setState(4575)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.PASSING.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4574)
		 			try xml_passing_clause()

		 		}

		 		setState(4577)
		 		try match(plsqlParser.Tokens.RETURNING.rawValue)
		 		setState(4578)
		 		try match(plsqlParser.Tokens.CONTENT.rawValue)
		 		setState(4582)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.NULL.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4579)
		 			try match(plsqlParser.Tokens.NULL.rawValue)
		 			setState(4580)
		 			try match(plsqlParser.Tokens.ON.rawValue)
		 			setState(4581)
		 			try match(plsqlParser.Tokens.EMPTY.rawValue)

		 		}

		 		setState(4584)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4587)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,579,_ctx)) {
		 		case 1:
		 			setState(4585)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(4586)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 23:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(4589)
		 		try match(plsqlParser.Tokens.XMLROOT.rawValue)
		 		setState(4590)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4591)
		 		try concatenation()
		 		setState(4594)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,580,_ctx)) {
		 		case 1:
		 			setState(4592)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4593)
		 			try xmlroot_param_version_part()

		 			break
		 		default: break
		 		}
		 		setState(4598)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4596)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4597)
		 			try xmlroot_param_standalone_part()

		 		}

		 		setState(4600)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4603)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,582,_ctx)) {
		 		case 1:
		 			setState(4601)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(4602)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 24:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(4605)
		 		try match(plsqlParser.Tokens.XMLSERIALIZE.rawValue)
		 		setState(4606)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4607)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.CONTENT.rawValue || _la == plsqlParser.Tokens.DOCUMENT.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4608)
		 		try concatenation()
		 		setState(4611)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4609)
		 			try match(plsqlParser.Tokens.AS.rawValue)
		 			setState(4610)
		 			try type_spec()

		 		}

		 		setState(4614)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.ENCODING.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4613)
		 			try xmlserialize_param_enconding_part()

		 		}

		 		setState(4617)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.VERSION.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4616)
		 			try xmlserialize_param_version_part()

		 		}

		 		setState(4620)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.INDENT.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.NO.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4619)
		 			try xmlserialize_param_ident_part()

		 		}

		 		setState(4624)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.HIDE.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.SHOW.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4622)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == plsqlParser.Tokens.HIDE.rawValue
		 			          testSet = testSet || _la == plsqlParser.Tokens.SHOW.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(4623)
		 			try match(plsqlParser.Tokens.DEFAULTS.rawValue)

		 		}

		 		setState(4626)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4629)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,588,_ctx)) {
		 		case 1:
		 			setState(4627)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(4628)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	case 25:
		 		try enterOuterAlt(_localctx, 25)
		 		setState(4631)
		 		try match(plsqlParser.Tokens.XMLTABLE.rawValue)
		 		setState(4632)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4634)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,589,_ctx)) {
		 		case 1:
		 			setState(4633)
		 			try xml_namespaces_clause()

		 			break
		 		default: break
		 		}
		 		setState(4636)
		 		try concatenation()
		 		setState(4638)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.PASSING.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4637)
		 			try xml_passing_clause()

		 		}

		 		setState(4645)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COLUMNS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4640)
		 			try match(plsqlParser.Tokens.COLUMNS.rawValue)
		 			setState(4641)
		 			try xml_table_column()

		 			setState(4642)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4643)
		 			try xml_table_column()


		 		}

		 		setState(4647)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4650)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,592,_ctx)) {
		 		case 1:
		 			setState(4648)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(4649)
		 			try general_element_part()

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Over_clause_keywordContext:ParserRuleContext {
		open func AVG() -> TerminalNode? { return getToken(plsqlParser.Tokens.AVG.rawValue, 0) }
		open func CORR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CORR.rawValue, 0) }
		open func LAG() -> TerminalNode? { return getToken(plsqlParser.Tokens.LAG.rawValue, 0) }
		open func LEAD() -> TerminalNode? { return getToken(plsqlParser.Tokens.LEAD.rawValue, 0) }
		open func MAX() -> TerminalNode? { return getToken(plsqlParser.Tokens.MAX.rawValue, 0) }
		open func MEDIAN() -> TerminalNode? { return getToken(plsqlParser.Tokens.MEDIAN.rawValue, 0) }
		open func MIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.MIN.rawValue, 0) }
		open func NTILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.NTILE.rawValue, 0) }
		open func RATIO_TO_REPORT() -> TerminalNode? { return getToken(plsqlParser.Tokens.RATIO_TO_REPORT.rawValue, 0) }
		open func ROW_NUMBER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROW_NUMBER.rawValue, 0) }
		open func SUM() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUM.rawValue, 0) }
		open func VARIANCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARIANCE.rawValue, 0) }
		open func REGR_() -> TerminalNode? { return getToken(plsqlParser.Tokens.REGR_.rawValue, 0) }
		open func STDDEV() -> TerminalNode? { return getToken(plsqlParser.Tokens.STDDEV.rawValue, 0) }
		open func VAR_() -> TerminalNode? { return getToken(plsqlParser.Tokens.VAR_.rawValue, 0) }
		open func COVAR_() -> TerminalNode? { return getToken(plsqlParser.Tokens.COVAR_.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_over_clause_keyword }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOver_clause_keyword(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOver_clause_keyword(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOver_clause_keyword(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOver_clause_keyword(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func over_clause_keyword() throws -> Over_clause_keywordContext {
		var _localctx: Over_clause_keywordContext = Over_clause_keywordContext(_ctx, getState())
		try enterRule(_localctx, 576, plsqlParser.RULE_over_clause_keyword)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4654)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 466)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Within_or_over_clause_keywordContext:ParserRuleContext {
		open func CUME_DIST() -> TerminalNode? { return getToken(plsqlParser.Tokens.CUME_DIST.rawValue, 0) }
		open func DENSE_RANK() -> TerminalNode? { return getToken(plsqlParser.Tokens.DENSE_RANK.rawValue, 0) }
		open func LISTAGG() -> TerminalNode? { return getToken(plsqlParser.Tokens.LISTAGG.rawValue, 0) }
		open func PERCENT_RANK() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENT_RANK.rawValue, 0) }
		open func PERCENTILE_CONT() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENTILE_CONT.rawValue, 0) }
		open func PERCENTILE_DISC() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENTILE_DISC.rawValue, 0) }
		open func RANK() -> TerminalNode? { return getToken(plsqlParser.Tokens.RANK.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_within_or_over_clause_keyword }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWithin_or_over_clause_keyword(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWithin_or_over_clause_keyword(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWithin_or_over_clause_keyword(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWithin_or_over_clause_keyword(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func within_or_over_clause_keyword() throws -> Within_or_over_clause_keywordContext {
		var _localctx: Within_or_over_clause_keywordContext = Within_or_over_clause_keywordContext(_ctx, getState())
		try enterRule(_localctx, 578, plsqlParser.RULE_within_or_over_clause_keyword)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4656)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 459)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Standard_prediction_function_keywordContext:ParserRuleContext {
		open func PREDICTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION.rawValue, 0) }
		open func PREDICTION_BOUNDS() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue, 0) }
		open func PREDICTION_COST() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION_COST.rawValue, 0) }
		open func PREDICTION_DETAILS() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION_DETAILS.rawValue, 0) }
		open func PREDICTION_PROBABILITY() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue, 0) }
		open func PREDICTION_SET() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION_SET.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_standard_prediction_function_keyword }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterStandard_prediction_function_keyword(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitStandard_prediction_function_keyword(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitStandard_prediction_function_keyword(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitStandard_prediction_function_keyword(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func standard_prediction_function_keyword() throws -> Standard_prediction_function_keywordContext {
		var _localctx: Standard_prediction_function_keywordContext = Standard_prediction_function_keywordContext(_ctx, getState())
		try enterRule(_localctx, 580, plsqlParser.RULE_standard_prediction_function_keyword)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4658)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 453)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Over_clauseContext:ParserRuleContext {
		open func OVER() -> TerminalNode? { return getToken(plsqlParser.Tokens.OVER.rawValue, 0) }
		open func query_partition_clause() -> Query_partition_clauseContext? {
			return getRuleContext(Query_partition_clauseContext.self,0)
		}
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func windowing_clause() -> Windowing_clauseContext? {
			return getRuleContext(Windowing_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_over_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOver_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOver_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOver_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOver_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func over_clause() throws -> Over_clauseContext {
		var _localctx: Over_clauseContext = Over_clauseContext(_ctx, getState())
		try enterRule(_localctx, 582, plsqlParser.RULE_over_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4660)
		 	try match(plsqlParser.Tokens.OVER.rawValue)
		 	setState(4661)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(4663)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PARTITION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4662)
		 		try query_partition_clause()

		 	}

		 	setState(4669)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.ORDER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4665)
		 		try order_by_clause()
		 		setState(4667)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.RANGE.rawValue || _la == plsqlParser.Tokens.ROWS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4666)
		 			try windowing_clause()

		 		}


		 	}

		 	setState(4671)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Windowing_clauseContext:ParserRuleContext {
		open func windowing_type() -> Windowing_typeContext? {
			return getRuleContext(Windowing_typeContext.self,0)
		}
		open func BETWEEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.BETWEEN.rawValue, 0) }
		open func windowing_elements() -> Array<Windowing_elementsContext> {
			return getRuleContexts(Windowing_elementsContext.self)
		}
		open func windowing_elements(_ i: Int) -> Windowing_elementsContext? {
			return getRuleContext(Windowing_elementsContext.self,i)
		}
		open func AND() -> TerminalNode? { return getToken(plsqlParser.Tokens.AND.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_windowing_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWindowing_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWindowing_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWindowing_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWindowing_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func windowing_clause() throws -> Windowing_clauseContext {
		var _localctx: Windowing_clauseContext = Windowing_clauseContext(_ctx, getState())
		try enterRule(_localctx, 584, plsqlParser.RULE_windowing_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4673)
		 	try windowing_type()
		 	setState(4680)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .BETWEEN:
		 		setState(4674)
		 		try match(plsqlParser.Tokens.BETWEEN.rawValue)
		 		setState(4675)
		 		try windowing_elements()
		 		setState(4676)
		 		try match(plsqlParser.Tokens.AND.rawValue)
		 		setState(4677)
		 		try windowing_elements()

		 		break
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALL:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ANY:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CASE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COALESCE:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONNECT_BY_ROOT:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DISTINCT:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXISTS:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FALSE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .PRIOR:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .DECODE:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NVL:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .TO_CHAR:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case .UNSIGNED_INTEGER:fallthrough
		 	case .APPROXIMATE_NUM_LIT:fallthrough
		 	case .CHAR_STRING:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .LEFT_PAREN:fallthrough
		 	case .PLUS_SIGN:fallthrough
		 	case .MINUS_SIGN:fallthrough
		 	case .BINDVAR:fallthrough
		 	case .COLON:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(4679)
		 		try windowing_elements()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Windowing_typeContext:ParserRuleContext {
		open func ROWS() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROWS.rawValue, 0) }
		open func RANGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.RANGE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_windowing_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWindowing_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWindowing_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWindowing_type(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWindowing_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func windowing_type() throws -> Windowing_typeContext {
		var _localctx: Windowing_typeContext = Windowing_typeContext(_ctx, getState())
		try enterRule(_localctx, 586, plsqlParser.RULE_windowing_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4682)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.RANGE.rawValue || _la == plsqlParser.Tokens.ROWS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Windowing_elementsContext:ParserRuleContext {
		open func UNBOUNDED() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNBOUNDED.rawValue, 0) }
		open func PRECEDING() -> TerminalNode? { return getToken(plsqlParser.Tokens.PRECEDING.rawValue, 0) }
		open func CURRENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CURRENT.rawValue, 0) }
		open func ROW() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROW.rawValue, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open func FOLLOWING() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOLLOWING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_windowing_elements }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWindowing_elements(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWindowing_elements(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWindowing_elements(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWindowing_elements(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func windowing_elements() throws -> Windowing_elementsContext {
		var _localctx: Windowing_elementsContext = Windowing_elementsContext(_ctx, getState())
		try enterRule(_localctx, 588, plsqlParser.RULE_windowing_elements)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4691)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,598, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4684)
		 		try match(plsqlParser.Tokens.UNBOUNDED.rawValue)
		 		setState(4685)
		 		try match(plsqlParser.Tokens.PRECEDING.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4686)
		 		try match(plsqlParser.Tokens.CURRENT.rawValue)
		 		setState(4687)
		 		try match(plsqlParser.Tokens.ROW.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4688)
		 		try concatenation()
		 		setState(4689)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.FOLLOWING.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.PRECEDING.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Using_clauseContext:ParserRuleContext {
		open func USING() -> TerminalNode? { return getToken(plsqlParser.Tokens.USING.rawValue, 0) }
		open func using_element() -> Array<Using_elementContext> {
			return getRuleContexts(Using_elementContext.self)
		}
		open func using_element(_ i: Int) -> Using_elementContext? {
			return getRuleContext(Using_elementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_using_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUsing_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUsing_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUsing_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUsing_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func using_clause() throws -> Using_clauseContext {
		var _localctx: Using_clauseContext = Using_clauseContext(_ctx, getState())
		try enterRule(_localctx, 590, plsqlParser.RULE_using_clause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4693)
		 	try match(plsqlParser.Tokens.USING.rawValue)
		 	setState(4703)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ASTERISK:
		 		setState(4694)
		 		try match(plsqlParser.Tokens.ASTERISK.rawValue)

		 		break
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALL:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ANY:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CASE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COALESCE:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONNECT_BY_ROOT:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DISTINCT:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXISTS:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FALSE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .IN:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NOT:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .PRIOR:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .DECODE:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NVL:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .TO_CHAR:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case .UNSIGNED_INTEGER:fallthrough
		 	case .APPROXIMATE_NUM_LIT:fallthrough
		 	case .CHAR_STRING:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .LEFT_PAREN:fallthrough
		 	case .PLUS_SIGN:fallthrough
		 	case .MINUS_SIGN:fallthrough
		 	case .BINDVAR:fallthrough
		 	case .COLON:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(4695)
		 		try using_element()
		 		setState(4700)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,599,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(4696)
		 				try match(plsqlParser.Tokens.COMMA.rawValue)
		 				setState(4697)
		 				try using_element()

		 		 
		 			}
		 			setState(4702)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,599,_ctx)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Using_elementContext:ParserRuleContext {
		open func select_list_elements() -> Select_list_elementsContext? {
			return getRuleContext(Select_list_elementsContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(plsqlParser.Tokens.IN.rawValue, 0) }
		open func OUT() -> TerminalNode? { return getToken(plsqlParser.Tokens.OUT.rawValue, 0) }
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_using_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterUsing_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitUsing_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitUsing_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitUsing_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func using_element() throws -> Using_elementContext {
		var _localctx: Using_elementContext = Using_elementContext(_ctx, getState())
		try enterRule(_localctx, 592, plsqlParser.RULE_using_element)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4710)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,602,_ctx)) {
		 	case 1:
		 		setState(4705)
		 		try match(plsqlParser.Tokens.IN.rawValue)
		 		setState(4707)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,601,_ctx)) {
		 		case 1:
		 			setState(4706)
		 			try match(plsqlParser.Tokens.OUT.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		setState(4709)
		 		try match(plsqlParser.Tokens.OUT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4712)
		 	try select_list_elements()
		 	setState(4714)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,603,_ctx)) {
		 	case 1:
		 		setState(4713)
		 		try column_alias()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Collect_order_by_partContext:ParserRuleContext {
		open func ORDER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ORDER.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_collect_order_by_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCollect_order_by_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCollect_order_by_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCollect_order_by_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCollect_order_by_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func collect_order_by_part() throws -> Collect_order_by_partContext {
		var _localctx: Collect_order_by_partContext = Collect_order_by_partContext(_ctx, getState())
		try enterRule(_localctx, 594, plsqlParser.RULE_collect_order_by_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4716)
		 	try match(plsqlParser.Tokens.ORDER.rawValue)
		 	setState(4717)
		 	try match(plsqlParser.Tokens.BY.rawValue)
		 	setState(4718)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Within_or_over_partContext:ParserRuleContext {
		open func WITHIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.WITHIN.rawValue, 0) }
		open func GROUP() -> TerminalNode? { return getToken(plsqlParser.Tokens.GROUP.rawValue, 0) }
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func over_clause() -> Over_clauseContext? {
			return getRuleContext(Over_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_within_or_over_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWithin_or_over_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWithin_or_over_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWithin_or_over_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWithin_or_over_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func within_or_over_part() throws -> Within_or_over_partContext {
		var _localctx: Within_or_over_partContext = Within_or_over_partContext(_ctx, getState())
		try enterRule(_localctx, 596, plsqlParser.RULE_within_or_over_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4727)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .WITHIN:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4720)
		 		try match(plsqlParser.Tokens.WITHIN.rawValue)
		 		setState(4721)
		 		try match(plsqlParser.Tokens.GROUP.rawValue)
		 		setState(4722)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4723)
		 		try order_by_clause()
		 		setState(4724)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		break

		 	case .OVER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4726)
		 		try over_clause()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cost_matrix_clauseContext:ParserRuleContext {
		open func COST() -> TerminalNode? { return getToken(plsqlParser.Tokens.COST.rawValue, 0) }
		open func MODEL() -> TerminalNode? { return getToken(plsqlParser.Tokens.MODEL.rawValue, 0) }
		open func cost_class_name() -> Array<Cost_class_nameContext> {
			return getRuleContexts(Cost_class_nameContext.self)
		}
		open func cost_class_name(_ i: Int) -> Cost_class_nameContext? {
			return getRuleContext(Cost_class_nameContext.self,i)
		}
		open func VALUES() -> TerminalNode? { return getToken(plsqlParser.Tokens.VALUES.rawValue, 0) }
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func AUTO() -> TerminalNode? { return getToken(plsqlParser.Tokens.AUTO.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cost_matrix_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCost_matrix_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCost_matrix_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCost_matrix_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCost_matrix_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cost_matrix_clause() throws -> Cost_matrix_clauseContext {
		var _localctx: Cost_matrix_clauseContext = Cost_matrix_clauseContext(_ctx, getState())
		try enterRule(_localctx, 598, plsqlParser.RULE_cost_matrix_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4729)
		 	try match(plsqlParser.Tokens.COST.rawValue)
		 	setState(4747)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .MODEL:
		 		setState(4730)
		 		try match(plsqlParser.Tokens.MODEL.rawValue)
		 		setState(4732)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.AUTO.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4731)
		 			try match(plsqlParser.Tokens.AUTO.rawValue)

		 		}


		 		break

		 	case .LEFT_PAREN:
		 		setState(4734)
		 		try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 		setState(4735)
		 		try cost_class_name()
		 		setState(4740)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4736)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4737)
		 			try cost_class_name()


		 			setState(4742)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4743)
		 		try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 		setState(4744)
		 		try match(plsqlParser.Tokens.VALUES.rawValue)
		 		setState(4745)
		 		try expression_list()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_passing_clauseContext:ParserRuleContext {
		open func PASSING() -> TerminalNode? { return getToken(plsqlParser.Tokens.PASSING.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func BY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BY.rawValue, 0) }
		open func VALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.VALUE.rawValue, 0) }
		open func column_alias() -> Array<Column_aliasContext> {
			return getRuleContexts(Column_aliasContext.self)
		}
		open func column_alias(_ i: Int) -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_passing_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_passing_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_passing_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_passing_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_passing_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_passing_clause() throws -> Xml_passing_clauseContext {
		var _localctx: Xml_passing_clauseContext = Xml_passing_clauseContext(_ctx, getState())
		try enterRule(_localctx, 600, plsqlParser.RULE_xml_passing_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4749)
		 	try match(plsqlParser.Tokens.PASSING.rawValue)
		 	setState(4752)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.BY.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4750)
		 		try match(plsqlParser.Tokens.BY.rawValue)
		 		setState(4751)
		 		try match(plsqlParser.Tokens.VALUE.rawValue)

		 	}

		 	setState(4754)
		 	try expression()
		 	setState(4756)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.AS.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4755)
		 		try column_alias()

		 	}

		 	setState(4758)
		 	try match(plsqlParser.Tokens.COMMA.rawValue)
		 	setState(4759)
		 	try expression()
		 	setState(4761)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,610,_ctx)) {
		 	case 1:
		 		setState(4760)
		 		try column_alias()

		 		break
		 	default: break
		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_attributes_clauseContext:ParserRuleContext {
		open func XMLATTRIBUTES() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLATTRIBUTES.rawValue, 0) }
		open func xml_multiuse_expression_element() -> Array<Xml_multiuse_expression_elementContext> {
			return getRuleContexts(Xml_multiuse_expression_elementContext.self)
		}
		open func xml_multiuse_expression_element(_ i: Int) -> Xml_multiuse_expression_elementContext? {
			return getRuleContext(Xml_multiuse_expression_elementContext.self,i)
		}
		open func ENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.Tokens.ENTITYESCAPING.rawValue, 0) }
		open func NOENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOENTITYESCAPING.rawValue, 0) }
		open func SCHEMACHECK() -> TerminalNode? { return getToken(plsqlParser.Tokens.SCHEMACHECK.rawValue, 0) }
		open func NOSCHEMACHECK() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOSCHEMACHECK.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_attributes_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_attributes_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_attributes_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_attributes_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_attributes_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_attributes_clause() throws -> Xml_attributes_clauseContext {
		var _localctx: Xml_attributes_clauseContext = Xml_attributes_clauseContext(_ctx, getState())
		try enterRule(_localctx, 602, plsqlParser.RULE_xml_attributes_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4763)
		 	try match(plsqlParser.Tokens.XMLATTRIBUTES.rawValue)
		 	setState(4764)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(4766)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,611,_ctx)) {
		 	case 1:
		 		setState(4765)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.ENTITYESCAPING.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.NOENTITYESCAPING.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(4769)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,612,_ctx)) {
		 	case 1:
		 		setState(4768)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.NOSCHEMACHECK.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.SCHEMACHECK.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(4771)
		 	try xml_multiuse_expression_element()
		 	setState(4776)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4772)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(4773)
		 		try xml_multiuse_expression_element()


		 		setState(4778)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4779)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_namespaces_clauseContext:ParserRuleContext {
		open func XMLNAMESPACES() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLNAMESPACES.rawValue, 0) }
		open func concatenation() -> Array<ConcatenationContext> {
			return getRuleContexts(ConcatenationContext.self)
		}
		open func concatenation(_ i: Int) -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,i)
		}
		open func column_alias() -> Array<Column_aliasContext> {
			return getRuleContexts(Column_aliasContext.self)
		}
		open func column_alias(_ i: Int) -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,i)
		}
		open func xml_general_default_part() -> Xml_general_default_partContext? {
			return getRuleContext(Xml_general_default_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_namespaces_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_namespaces_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_namespaces_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_namespaces_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_namespaces_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_namespaces_clause() throws -> Xml_namespaces_clauseContext {
		var _localctx: Xml_namespaces_clauseContext = Xml_namespaces_clauseContext(_ctx, getState())
		try enterRule(_localctx, 604, plsqlParser.RULE_xml_namespaces_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4781)
		 	try match(plsqlParser.Tokens.XMLNAMESPACES.rawValue)
		 	setState(4782)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(4786)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,614,_ctx)) {
		 	case 1:
		 		setState(4783)
		 		try concatenation()
		 		setState(4784)
		 		try column_alias()

		 		break
		 	default: break
		 	}
		 	setState(4794)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4788)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(4789)
		 		try concatenation()
		 		setState(4790)
		 		try column_alias()


		 		setState(4796)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4798)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.DEFAULT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4797)
		 		try xml_general_default_part()

		 	}

		 	setState(4800)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_table_columnContext:ParserRuleContext {
		open func xml_column_name() -> Xml_column_nameContext? {
			return getRuleContext(Xml_column_nameContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOR.rawValue, 0) }
		open func ORDINALITY() -> TerminalNode? { return getToken(plsqlParser.Tokens.ORDINALITY.rawValue, 0) }
		open func type_spec() -> Type_specContext? {
			return getRuleContext(Type_specContext.self,0)
		}
		open func PATH() -> TerminalNode? { return getToken(plsqlParser.Tokens.PATH.rawValue, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open func xml_general_default_part() -> Xml_general_default_partContext? {
			return getRuleContext(Xml_general_default_partContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_table_column }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_table_column(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_table_column(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_table_column(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_table_column(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_table_column() throws -> Xml_table_columnContext {
		var _localctx: Xml_table_columnContext = Xml_table_columnContext(_ctx, getState())
		try enterRule(_localctx, 606, plsqlParser.RULE_xml_table_column)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4802)
		 	try xml_column_name()
		 	setState(4813)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FOR:
		 		setState(4803)
		 		try match(plsqlParser.Tokens.FOR.rawValue)
		 		setState(4804)
		 		try match(plsqlParser.Tokens.ORDINALITY.rawValue)

		 		break
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .REGULAR_ID:
		 		setState(4805)
		 		try type_spec()
		 		setState(4808)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.PATH.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4806)
		 			try match(plsqlParser.Tokens.PATH.rawValue)
		 			setState(4807)
		 			try concatenation()

		 		}

		 		setState(4811)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.DEFAULT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4810)
		 			try xml_general_default_part()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_general_default_partContext:ParserRuleContext {
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_general_default_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_general_default_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_general_default_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_general_default_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_general_default_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_general_default_part() throws -> Xml_general_default_partContext {
		var _localctx: Xml_general_default_partContext = Xml_general_default_partContext(_ctx, getState())
		try enterRule(_localctx, 608, plsqlParser.RULE_xml_general_default_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4815)
		 	try match(plsqlParser.Tokens.DEFAULT.rawValue)
		 	setState(4816)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_multiuse_expression_elementContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open func EVALNAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.EVALNAME.rawValue, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_multiuse_expression_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_multiuse_expression_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_multiuse_expression_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_multiuse_expression_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_multiuse_expression_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_multiuse_expression_element() throws -> Xml_multiuse_expression_elementContext {
		var _localctx: Xml_multiuse_expression_elementContext = Xml_multiuse_expression_elementContext(_ctx, getState())
		try enterRule(_localctx, 610, plsqlParser.RULE_xml_multiuse_expression_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4818)
		 	try expression()
		 	setState(4825)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4819)
		 		try match(plsqlParser.Tokens.AS.rawValue)
		 		setState(4823)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,620, _ctx)) {
		 		case 1:
		 			setState(4820)
		 			try id_expression()

		 			break
		 		case 2:
		 			setState(4821)
		 			try match(plsqlParser.Tokens.EVALNAME.rawValue)
		 			setState(4822)
		 			try concatenation()

		 			break
		 		default: break
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xmlroot_param_version_partContext:ParserRuleContext {
		open func VERSION() -> TerminalNode? { return getToken(plsqlParser.Tokens.VERSION.rawValue, 0) }
		open func NO() -> TerminalNode? { return getToken(plsqlParser.Tokens.NO.rawValue, 0) }
		open func VALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.VALUE.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xmlroot_param_version_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXmlroot_param_version_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXmlroot_param_version_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXmlroot_param_version_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXmlroot_param_version_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xmlroot_param_version_part() throws -> Xmlroot_param_version_partContext {
		var _localctx: Xmlroot_param_version_partContext = Xmlroot_param_version_partContext(_ctx, getState())
		try enterRule(_localctx, 612, plsqlParser.RULE_xmlroot_param_version_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4827)
		 	try match(plsqlParser.Tokens.VERSION.rawValue)
		 	setState(4831)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,622, _ctx)) {
		 	case 1:
		 		setState(4828)
		 		try match(plsqlParser.Tokens.NO.rawValue)
		 		setState(4829)
		 		try match(plsqlParser.Tokens.VALUE.rawValue)

		 		break
		 	case 2:
		 		setState(4830)
		 		try expression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xmlroot_param_standalone_partContext:ParserRuleContext {
		open func STANDALONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.STANDALONE.rawValue, 0) }
		open func YES() -> TerminalNode? { return getToken(plsqlParser.Tokens.YES.rawValue, 0) }
		open func NO() -> TerminalNode? { return getToken(plsqlParser.Tokens.NO.rawValue, 0) }
		open func VALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.VALUE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xmlroot_param_standalone_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXmlroot_param_standalone_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXmlroot_param_standalone_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXmlroot_param_standalone_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXmlroot_param_standalone_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xmlroot_param_standalone_part() throws -> Xmlroot_param_standalone_partContext {
		var _localctx: Xmlroot_param_standalone_partContext = Xmlroot_param_standalone_partContext(_ctx, getState())
		try enterRule(_localctx, 614, plsqlParser.RULE_xmlroot_param_standalone_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4833)
		 	try match(plsqlParser.Tokens.STANDALONE.rawValue)
		 	setState(4839)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .YES:
		 		setState(4834)
		 		try match(plsqlParser.Tokens.YES.rawValue)

		 		break

		 	case .NO:
		 		setState(4835)
		 		try match(plsqlParser.Tokens.NO.rawValue)
		 		setState(4837)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.VALUE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4836)
		 			try match(plsqlParser.Tokens.VALUE.rawValue)

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xmlserialize_param_enconding_partContext:ParserRuleContext {
		open func ENCODING() -> TerminalNode? { return getToken(plsqlParser.Tokens.ENCODING.rawValue, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xmlserialize_param_enconding_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXmlserialize_param_enconding_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXmlserialize_param_enconding_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXmlserialize_param_enconding_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXmlserialize_param_enconding_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xmlserialize_param_enconding_part() throws -> Xmlserialize_param_enconding_partContext {
		var _localctx: Xmlserialize_param_enconding_partContext = Xmlserialize_param_enconding_partContext(_ctx, getState())
		try enterRule(_localctx, 616, plsqlParser.RULE_xmlserialize_param_enconding_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4841)
		 	try match(plsqlParser.Tokens.ENCODING.rawValue)
		 	setState(4842)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xmlserialize_param_version_partContext:ParserRuleContext {
		open func VERSION() -> TerminalNode? { return getToken(plsqlParser.Tokens.VERSION.rawValue, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xmlserialize_param_version_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXmlserialize_param_version_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXmlserialize_param_version_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXmlserialize_param_version_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXmlserialize_param_version_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xmlserialize_param_version_part() throws -> Xmlserialize_param_version_partContext {
		var _localctx: Xmlserialize_param_version_partContext = Xmlserialize_param_version_partContext(_ctx, getState())
		try enterRule(_localctx, 618, plsqlParser.RULE_xmlserialize_param_version_part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4844)
		 	try match(plsqlParser.Tokens.VERSION.rawValue)
		 	setState(4845)
		 	try concatenation()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xmlserialize_param_ident_partContext:ParserRuleContext {
		open func NO() -> TerminalNode? { return getToken(plsqlParser.Tokens.NO.rawValue, 0) }
		open func INDENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INDENT.rawValue, 0) }
		open func SIZE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SIZE.rawValue, 0) }
		open func concatenation() -> ConcatenationContext? {
			return getRuleContext(ConcatenationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xmlserialize_param_ident_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXmlserialize_param_ident_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXmlserialize_param_ident_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXmlserialize_param_ident_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXmlserialize_param_ident_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xmlserialize_param_ident_part() throws -> Xmlserialize_param_ident_partContext {
		var _localctx: Xmlserialize_param_ident_partContext = Xmlserialize_param_ident_partContext(_ctx, getState())
		try enterRule(_localctx, 620, plsqlParser.RULE_xmlserialize_param_ident_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4855)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NO:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4847)
		 		try match(plsqlParser.Tokens.NO.rawValue)
		 		setState(4848)
		 		try match(plsqlParser.Tokens.INDENT.rawValue)

		 		break

		 	case .INDENT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4849)
		 		try match(plsqlParser.Tokens.INDENT.rawValue)
		 		setState(4853)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.SIZE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4850)
		 			try match(plsqlParser.Tokens.SIZE.rawValue)
		 			setState(4851)
		 			try match(plsqlParser.Tokens.EQUALS_OP.rawValue)
		 			setState(4852)
		 			try concatenation()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sql_plus_commandContext:ParserRuleContext {
		open func whenever_command() -> Whenever_commandContext? {
			return getRuleContext(Whenever_commandContext.self,0)
		}
		open func exit_command() -> Exit_commandContext? {
			return getRuleContext(Exit_commandContext.self,0)
		}
		open func prompt_command() -> Prompt_commandContext? {
			return getRuleContext(Prompt_commandContext.self,0)
		}
		open func set_command() -> Set_commandContext? {
			return getRuleContext(Set_commandContext.self,0)
		}
		open func show_errors_command() -> Show_errors_commandContext? {
			return getRuleContext(Show_errors_commandContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sql_plus_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSql_plus_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSql_plus_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSql_plus_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSql_plus_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sql_plus_command() throws -> Sql_plus_commandContext {
		var _localctx: Sql_plus_commandContext = Sql_plus_commandContext(_ctx, getState())
		try enterRule(_localctx, 622, plsqlParser.RULE_sql_plus_command)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4863)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SOLIDUS:
		 		setState(4857)
		 		try match(plsqlParser.Tokens.SOLIDUS.rawValue)

		 		break

		 	case .WHENEVER:
		 		setState(4858)
		 		try whenever_command()

		 		break

		 	case .EXIT:
		 		setState(4859)
		 		try exit_command()

		 		break

		 	case .PROMPT:
		 		setState(4860)
		 		try prompt_command()

		 		break

		 	case .SET:
		 		setState(4861)
		 		try set_command()

		 		break

		 	case .SHOW:
		 		setState(4862)
		 		try show_errors_command()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4866)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.SEMICOLON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4865)
		 		try match(plsqlParser.Tokens.SEMICOLON.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Whenever_commandContext:ParserRuleContext {
		open func WHENEVER() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHENEVER.rawValue, 0) }
		open func SQLERROR() -> TerminalNode? { return getToken(plsqlParser.Tokens.SQLERROR.rawValue, 0) }
		open func OSERROR() -> TerminalNode? { return getToken(plsqlParser.Tokens.OSERROR.rawValue, 0) }
		open func EXIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXIT.rawValue, 0) }
		open func CONTINUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONTINUE.rawValue, 0) }
		open func SUCCESS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUCCESS.rawValue, 0) }
		open func FAILURE() -> TerminalNode? { return getToken(plsqlParser.Tokens.FAILURE.rawValue, 0) }
		open func WARNING() -> TerminalNode? { return getToken(plsqlParser.Tokens.WARNING.rawValue, 0) }
		open func COMMIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMMIT.rawValue, 0) }
		open func ROLLBACK() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROLLBACK.rawValue, 0) }
		open func NONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.NONE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_whenever_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWhenever_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWhenever_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWhenever_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWhenever_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func whenever_command() throws -> Whenever_commandContext {
		var _localctx: Whenever_commandContext = Whenever_commandContext(_ctx, getState())
		try enterRule(_localctx, 624, plsqlParser.RULE_whenever_command)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4868)
		 	try match(plsqlParser.Tokens.WHENEVER.rawValue)
		 	setState(4869)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.OSERROR.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.SQLERROR.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4875)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .EXIT:
		 		setState(4870)
		 		try match(plsqlParser.Tokens.EXIT.rawValue)
		 		setState(4871)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.FAILURE.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.SUCCESS.rawValue || _la == plsqlParser.Tokens.WARNING.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4872)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.COMMIT.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.ROLLBACK.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .CONTINUE:
		 		setState(4873)
		 		try match(plsqlParser.Tokens.CONTINUE.rawValue)
		 		setState(4874)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.COMMIT.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.NONE.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.ROLLBACK.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Set_commandContext:ParserRuleContext {
		open func SET() -> TerminalNode? { return getToken(plsqlParser.Tokens.SET.rawValue, 0) }
		open func regular_id() -> Array<Regular_idContext> {
			return getRuleContexts(Regular_idContext.self)
		}
		open func regular_id(_ i: Int) -> Regular_idContext? {
			return getRuleContext(Regular_idContext.self,i)
		}
		open func CHAR_STRING() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHAR_STRING.rawValue, 0) }
		open func ON() -> TerminalNode? { return getToken(plsqlParser.Tokens.ON.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OFF.rawValue, 0) }
		open func numeric() -> NumericContext? {
			return getRuleContext(NumericContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_set_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSet_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSet_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSet_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSet_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func set_command() throws -> Set_commandContext {
		var _localctx: Set_commandContext = Set_commandContext(_ctx, getState())
		try enterRule(_localctx, 626, plsqlParser.RULE_set_command)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4877)
		 	try match(plsqlParser.Tokens.SET.rawValue)
		 	setState(4878)
		 	try regular_id()
		 	setState(4884)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,630, _ctx)) {
		 	case 1:
		 		setState(4879)
		 		try match(plsqlParser.Tokens.CHAR_STRING.rawValue)

		 		break
		 	case 2:
		 		setState(4880)
		 		try match(plsqlParser.Tokens.ON.rawValue)

		 		break
		 	case 3:
		 		setState(4881)
		 		try match(plsqlParser.Tokens.OFF.rawValue)

		 		break
		 	case 4:
		 		setState(4882)
		 		try numeric()

		 		break
		 	case 5:
		 		setState(4883)
		 		try regular_id()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Exit_commandContext:ParserRuleContext {
		open func EXIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXIT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_exit_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterExit_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitExit_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitExit_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitExit_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exit_command() throws -> Exit_commandContext {
		var _localctx: Exit_commandContext = Exit_commandContext(_ctx, getState())
		try enterRule(_localctx, 628, plsqlParser.RULE_exit_command)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4886)
		 	try match(plsqlParser.Tokens.EXIT.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Prompt_commandContext:ParserRuleContext {
		open func PROMPT() -> TerminalNode? { return getToken(plsqlParser.Tokens.PROMPT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_prompt_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPrompt_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPrompt_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPrompt_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPrompt_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func prompt_command() throws -> Prompt_commandContext {
		var _localctx: Prompt_commandContext = Prompt_commandContext(_ctx, getState())
		try enterRule(_localctx, 630, plsqlParser.RULE_prompt_command)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4888)
		 	try match(plsqlParser.Tokens.PROMPT.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Show_errors_commandContext:ParserRuleContext {
		open func SHOW() -> TerminalNode? { return getToken(plsqlParser.Tokens.SHOW.rawValue, 0) }
		open func ERR() -> TerminalNode? { return getToken(plsqlParser.Tokens.ERR.rawValue, 0) }
		open func ERRORS() -> TerminalNode? { return getToken(plsqlParser.Tokens.ERRORS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_show_errors_command }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterShow_errors_command(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitShow_errors_command(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitShow_errors_command(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitShow_errors_command(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func show_errors_command() throws -> Show_errors_commandContext {
		var _localctx: Show_errors_commandContext = Show_errors_commandContext(_ctx, getState())
		try enterRule(_localctx, 632, plsqlParser.RULE_show_errors_command)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4894)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,631, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4890)
		 		try match(plsqlParser.Tokens.SHOW.rawValue)
		 		setState(4891)
		 		try match(plsqlParser.Tokens.ERR.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4892)
		 		try match(plsqlParser.Tokens.SHOW.rawValue)
		 		setState(4893)
		 		try match(plsqlParser.Tokens.ERRORS.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Partition_extension_clauseContext:ParserRuleContext {
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func SUBPARTITION() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUBPARTITION.rawValue, 0) }
		open func PARTITION() -> TerminalNode? { return getToken(plsqlParser.Tokens.PARTITION.rawValue, 0) }
		open func FOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOR.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_partition_extension_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPartition_extension_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPartition_extension_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPartition_extension_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPartition_extension_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func partition_extension_clause() throws -> Partition_extension_clauseContext {
		var _localctx: Partition_extension_clauseContext = Partition_extension_clauseContext(_ctx, getState())
		try enterRule(_localctx, 634, plsqlParser.RULE_partition_extension_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4896)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.PARTITION.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.SUBPARTITION.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4898)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4897)
		 		try match(plsqlParser.Tokens.FOR.rawValue)

		 	}

		 	setState(4900)
		 	try expression_list()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_aliasContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func alias_quoted_string() -> Alias_quoted_stringContext? {
			return getRuleContext(Alias_quoted_stringContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(plsqlParser.Tokens.AS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_column_alias }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterColumn_alias(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitColumn_alias(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitColumn_alias(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitColumn_alias(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_alias() throws -> Column_aliasContext {
		var _localctx: Column_aliasContext = Column_aliasContext(_ctx, getState())
		try enterRule(_localctx, 636, plsqlParser.RULE_column_alias)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4910)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,635, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4903)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.AS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4902)
		 			try match(plsqlParser.Tokens.AS.rawValue)

		 		}

		 		setState(4907)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .A_LETTER:fallthrough
		 		case .ADD:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGENT:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .ARRAY:fallthrough
		 		case .ASSOCIATE:fallthrough
		 		case .AT:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .AUDIT:fallthrough
		 		case .AUTHID:fallthrough
		 		case .AUTO:fallthrough
		 		case .AUTOMATIC:fallthrough
		 		case .AUTONOMOUS_TRANSACTION:fallthrough
		 		case .BATCH:fallthrough
		 		case .BEFORE:fallthrough
		 		case .BFILE:fallthrough
		 		case .BINARY_DOUBLE:fallthrough
		 		case .BINARY_FLOAT:fallthrough
		 		case .BINARY_INTEGER:fallthrough
		 		case .BLOB:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BODY:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BOTH:fallthrough
		 		case .BULK:fallthrough
		 		case .BYTE:fallthrough
		 		case .C_LETTER:fallthrough
		 		case .CALL:fallthrough
		 		case .CANONICAL:fallthrough
		 		case .CASCADE:fallthrough
		 		case .CAST:fallthrough
		 		case .CHAR:fallthrough
		 		case .CHAR_CS:fallthrough
		 		case .CHARACTER:fallthrough
		 		case .CHR:fallthrough
		 		case .CLOB:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTER:fallthrough
		 		case .COLLECT:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .COMPATIBILITY:fallthrough
		 		case .COMPILE:fallthrough
		 		case .COMPOUND:fallthrough
		 		case .CONSTANT:fallthrough
		 		case .CONSTRAINT:fallthrough
		 		case .CONSTRAINTS:fallthrough
		 		case .CONSTRUCTOR:fallthrough
		 		case .CONTENT:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTINUE:fallthrough
		 		case .CONVERT:fallthrough
		 		case .CORRUPT_XID:fallthrough
		 		case .CORRUPT_XID_ALL:fallthrough
		 		case .COST:fallthrough
		 		case .COUNT:fallthrough
		 		case .CROSS:fallthrough
		 		case .CUBE:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .CURSOR:fallthrough
		 		case .CUSTOMDATUM:fallthrough
		 		case .CYCLE:fallthrough
		 		case .DATA:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DAY:fallthrough
		 		case .DB_ROLE_CHANGE:fallthrough
		 		case .DBTIMEZONE:fallthrough
		 		case .DDL:fallthrough
		 		case .DEBUG:fallthrough
		 		case .DEC:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .DECOMPOSE:fallthrough
		 		case .DECREMENT:fallthrough
		 		case .DEFAULTS:fallthrough
		 		case .DEFERRED:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DETERMINISTIC:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISASSOCIATE:fallthrough
		 		case .DOCUMENT:fallthrough
		 		case .DOUBLE:fallthrough
		 		case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 		case .EACH:fallthrough
		 		case .ELEMENT:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCODING:fallthrough
		 		case .ENTITYESCAPING:fallthrough
		 		case .ERR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVALNAME:fallthrough
		 		case .EXCEPTION:fallthrough
		 		case .EXCEPTION_INIT:fallthrough
		 		case .EXCEPTIONS:fallthrough
		 		case .EXCLUDE:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .EXIT:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .EXTERNAL:fallthrough
		 		case .EXTRACT:fallthrough
		 		case .FAILURE:fallthrough
		 		case .FINAL:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .FLOAT:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FORALL:fallthrough
		 		case .FORCE:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GROUPING:fallthrough
		 		case .HASH:fallthrough
		 		case .HIDE:fallthrough
		 		case .HOUR:fallthrough
		 		case .IGNORE:fallthrough
		 		case .IMMEDIATE:fallthrough
		 		case .INCLUDE:fallthrough
		 		case .INCLUDING:fallthrough
		 		case .INCREMENT:fallthrough
		 		case .INDENT:fallthrough
		 		case .INDEXED:fallthrough
		 		case .INDICATOR:fallthrough
		 		case .INDICES:fallthrough
		 		case .INFINITE:fallthrough
		 		case .INLINE:fallthrough
		 		case .INNER:fallthrough
		 		case .INOUT:fallthrough
		 		case .INSTANTIABLE:fallthrough
		 		case .INSTEAD:fallthrough
		 		case .INT:fallthrough
		 		case .INTEGER:fallthrough
		 		case .INTERVAL:fallthrough
		 		case .INVALIDATE:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ITERATE:fallthrough
		 		case .JAVA:fallthrough
		 		case .JOIN:fallthrough
		 		case .KEEP:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEADING:fallthrough
		 		case .LEFT:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIBRARY:fallthrough
		 		case .LIKE2:fallthrough
		 		case .LIKE4:fallthrough
		 		case .LIKEC:fallthrough
		 		case .LIMIT:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCKED:fallthrough
		 		case .LOG:fallthrough
		 		case .LOGOFF:fallthrough
		 		case .LOGON:fallthrough
		 		case .LONG:fallthrough
		 		case .LOOP:fallthrough
		 		case .MAIN:fallthrough
		 		case .MAP:fallthrough
		 		case .MATCHED:fallthrough
		 		case .MAXVALUE:fallthrough
		 		case .MEASURES:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MINUTE:fallthrough
		 		case .MINVALUE:fallthrough
		 		case .MLSLABEL:fallthrough
		 		case .MODEL:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MONTH:fallthrough
		 		case .MULTISET:fallthrough
		 		case .NAME:fallthrough
		 		case .NAN:fallthrough
		 		case .NATURAL:fallthrough
		 		case .NATURALN:fallthrough
		 		case .NAV:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NCHAR_CS:fallthrough
		 		case .NCLOB:fallthrough
		 		case .NESTED:fallthrough
		 		case .NEW:fallthrough
		 		case .NO:fallthrough
		 		case .NOAUDIT:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOCYCLE:fallthrough
		 		case .NOENTITYESCAPING:fallthrough
		 		case .NONE:fallthrough
		 		case .NOSCHEMACHECK:fallthrough
		 		case .NULLS:fallthrough
		 		case .NUMBER:fallthrough
		 		case .NUMERIC:fallthrough
		 		case .NVARCHAR2:fallthrough
		 		case .OBJECT:fallthrough
		 		case .OFF:fallthrough
		 		case .OID:fallthrough
		 		case .OLD:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .ORADATA:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .OSERROR:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTER:fallthrough
		 		case .OVER:fallthrough
		 		case .OVERRIDING:fallthrough
		 		case .PACKAGE:fallthrough
		 		case .PARALLEL_ENABLE:fallthrough
		 		case .PARAMETERS:fallthrough
		 		case .PARENT:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PASSING:fallthrough
		 		case .PATH:fallthrough
		 		case .PIPELINED:fallthrough
		 		case .PLAN:fallthrough
		 		case .PLS_INTEGER:fallthrough
		 		case .POSITIVE:fallthrough
		 		case .POSITIVEN:fallthrough
		 		case .PRAGMA:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRECISION:fallthrough
		 		case .PRESENT:fallthrough
		 		case .RAISE:fallthrough
		 		case .RANGE:fallthrough
		 		case .RAW:fallthrough
		 		case .READ:fallthrough
		 		case .REAL:fallthrough
		 		case .RECORD:fallthrough
		 		case .REF:fallthrough
		 		case .REFERENCE:fallthrough
		 		case .REFERENCING:fallthrough
		 		case .REJECT:fallthrough
		 		case .RELIES_ON:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESPECT:fallthrough
		 		case .RESTRICT_REFERENCES:fallthrough
		 		case .RESULT:fallthrough
		 		case .RESULT_CACHE:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNING:fallthrough
		 		case .REUSE:fallthrough
		 		case .REVERSE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWID:fallthrough
		 		case .ROWS:fallthrough
		 		case .RULES:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SAVE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SCHEMACHECK:fallthrough
		 		case .SCN:fallthrough
		 		case .SECOND:fallthrough
		 		case .SEED:fallthrough
		 		case .SEGMENT:fallthrough
		 		case .SELF:fallthrough
		 		case .SEQUENTIAL:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SERIALLY_REUSABLE:fallthrough
		 		case .SERVERERROR:fallthrough
		 		case .SESSIONTIMEZONE:fallthrough
		 		case .SET:fallthrough
		 		case .SETS:fallthrough
		 		case .SETTINGS:fallthrough
		 		case .SHOW:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SIBLINGS:fallthrough
		 		case .SIGNTYPE:fallthrough
		 		case .SIMPLE_INTEGER:fallthrough
		 		case .SINGLE:fallthrough
		 		case .SKIP_:fallthrough
		 		case .SMALLINT:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOME:fallthrough
		 		case .SPECIFICATION:fallthrough
		 		case .SQLDATA:fallthrough
		 		case .SQLERROR:fallthrough
		 		case .STANDALONE:fallthrough
		 		case .STARTUP:fallthrough
		 		case .STATEMENT:fallthrough
		 		case .STATEMENT_ID:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATISTICS:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBMULTISET:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBSTITUTABLE:fallthrough
		 		case .SUBTYPE:fallthrough
		 		case .SUCCESS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 		case .TIMEZONE_ABBR:fallthrough
		 		case .TIMEZONE_HOUR:fallthrough
		 		case .TIMEZONE_MINUTE:fallthrough
		 		case .TIMEZONE_REGION:fallthrough
		 		case .TRAILING:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSLATE:fallthrough
		 		case .TREAT:fallthrough
		 		case .TRIGGER:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .TYPE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDER:fallthrough
		 		case .UNLIMITED:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPDATED:fallthrough
		 		case .UPSERT:fallthrough
		 		case .UROWID:fallthrough
		 		case .USE:fallthrough
		 		case .VALIDATE:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARCHAR:fallthrough
		 		case .VARCHAR2:fallthrough
		 		case .VARIABLE:fallthrough
		 		case .VARRAY:fallthrough
		 		case .VARYING:fallthrough
		 		case .VERSION:fallthrough
		 		case .VERSIONS:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNING:fallthrough
		 		case .WELLFORMED:fallthrough
		 		case .WHENEVER:fallthrough
		 		case .WHILE:fallthrough
		 		case .WITHIN:fallthrough
		 		case .WORK:fallthrough
		 		case .WRITE:fallthrough
		 		case .XML:fallthrough
		 		case .XMLAGG:fallthrough
		 		case .XMLATTRIBUTES:fallthrough
		 		case .XMLCAST:fallthrough
		 		case .XMLCOLATTVAL:fallthrough
		 		case .XMLELEMENT:fallthrough
		 		case .XMLEXISTS:fallthrough
		 		case .XMLFOREST:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .XMLPARSE:fallthrough
		 		case .XMLPI:fallthrough
		 		case .XMLQUERY:fallthrough
		 		case .XMLROOT:fallthrough
		 		case .XMLSERIALIZE:fallthrough
		 		case .XMLTABLE:fallthrough
		 		case .YEAR:fallthrough
		 		case .YES:fallthrough
		 		case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 		case .ZONE:fallthrough
		 		case .PREDICTION:fallthrough
		 		case .PREDICTION_BOUNDS:fallthrough
		 		case .PREDICTION_COST:fallthrough
		 		case .PREDICTION_DETAILS:fallthrough
		 		case .PREDICTION_PROBABILITY:fallthrough
		 		case .PREDICTION_SET:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .LISTAGG:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .PERCENTILE_CONT:fallthrough
		 		case .PERCENTILE_DISC:fallthrough
		 		case .RANK:fallthrough
		 		case .AVG:fallthrough
		 		case .CORR:fallthrough
		 		case .COVAR_:fallthrough
		 		case .LAG:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MEDIAN:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .RATIO_TO_REPORT:fallthrough
		 		case .REGR_:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .TRIM:fallthrough
		 		case .SUM:fallthrough
		 		case .STDDEV:fallthrough
		 		case .VAR_:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .DELIMITED_ID:fallthrough
		 		case .INTRODUCER:fallthrough
		 		case .REGULAR_ID:
		 			setState(4905)
		 			try identifier()

		 			break
		 		case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 		case .CHAR_STRING:
		 			setState(4906)
		 			try alias_quoted_string()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4909)
		 		try match(plsqlParser.Tokens.AS.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_aliasContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func alias_quoted_string() -> Alias_quoted_stringContext? {
			return getRuleContext(Alias_quoted_stringContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_alias }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_alias(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_alias(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_alias(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_alias(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_alias() throws -> Table_aliasContext {
		var _localctx: Table_aliasContext = Table_aliasContext(_ctx, getState())
		try enterRule(_localctx, 638, plsqlParser.RULE_table_alias)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4914)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(4912)
		 		try identifier()

		 		break
		 	case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case .CHAR_STRING:
		 		setState(4913)
		 		try alias_quoted_string()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alias_quoted_stringContext:ParserRuleContext {
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_alias_quoted_string }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAlias_quoted_string(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAlias_quoted_string(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAlias_quoted_string(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAlias_quoted_string(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alias_quoted_string() throws -> Alias_quoted_stringContext {
		var _localctx: Alias_quoted_stringContext = Alias_quoted_stringContext(_ctx, getState())
		try enterRule(_localctx, 640, plsqlParser.RULE_alias_quoted_string)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4916)
		 	try quoted_string()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Where_clauseContext:ParserRuleContext {
		open func WHERE() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHERE.rawValue, 0) }
		open func current_of_clause() -> Current_of_clauseContext? {
			return getRuleContext(Current_of_clauseContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_where_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterWhere_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitWhere_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitWhere_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitWhere_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func where_clause() throws -> Where_clauseContext {
		var _localctx: Where_clauseContext = Where_clauseContext(_ctx, getState())
		try enterRule(_localctx, 642, plsqlParser.RULE_where_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4918)
		 	try match(plsqlParser.Tokens.WHERE.rawValue)
		 	setState(4921)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CURRENT:
		 		setState(4919)
		 		try current_of_clause()

		 		break
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALL:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ANY:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CASE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COALESCE:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONNECT_BY_ROOT:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DISTINCT:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXISTS:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FALSE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NOT:fallthrough
		 	case .NULL:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .PRIOR:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUE:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .DECODE:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NVL:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .TO_CHAR:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case .UNSIGNED_INTEGER:fallthrough
		 	case .APPROXIMATE_NUM_LIT:fallthrough
		 	case .CHAR_STRING:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .LEFT_PAREN:fallthrough
		 	case .PLUS_SIGN:fallthrough
		 	case .MINUS_SIGN:fallthrough
		 	case .BINDVAR:fallthrough
		 	case .COLON:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		setState(4920)
		 		try expression()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Current_of_clauseContext:ParserRuleContext {
		open func CURRENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CURRENT.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OF.rawValue, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_current_of_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCurrent_of_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCurrent_of_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCurrent_of_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCurrent_of_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func current_of_clause() throws -> Current_of_clauseContext {
		var _localctx: Current_of_clauseContext = Current_of_clauseContext(_ctx, getState())
		try enterRule(_localctx, 644, plsqlParser.RULE_current_of_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4923)
		 	try match(plsqlParser.Tokens.CURRENT.rawValue)
		 	setState(4924)
		 	try match(plsqlParser.Tokens.OF.rawValue)
		 	setState(4925)
		 	try cursor_name()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Into_clauseContext:ParserRuleContext {
		open func INTO() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTO.rawValue, 0) }
		open func variable_name() -> Array<Variable_nameContext> {
			return getRuleContexts(Variable_nameContext.self)
		}
		open func variable_name(_ i: Int) -> Variable_nameContext? {
			return getRuleContext(Variable_nameContext.self,i)
		}
		open func BULK() -> TerminalNode? { return getToken(plsqlParser.Tokens.BULK.rawValue, 0) }
		open func COLLECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COLLECT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_into_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterInto_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitInto_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitInto_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitInto_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func into_clause() throws -> Into_clauseContext {
		var _localctx: Into_clauseContext = Into_clauseContext(_ctx, getState())
		try enterRule(_localctx, 646, plsqlParser.RULE_into_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4947)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .INTO:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4927)
		 		try match(plsqlParser.Tokens.INTO.rawValue)
		 		setState(4928)
		 		try variable_name()
		 		setState(4933)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4929)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4930)
		 			try variable_name()


		 			setState(4935)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break

		 	case .BULK:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4936)
		 		try match(plsqlParser.Tokens.BULK.rawValue)
		 		setState(4937)
		 		try match(plsqlParser.Tokens.COLLECT.rawValue)
		 		setState(4938)
		 		try match(plsqlParser.Tokens.INTO.rawValue)
		 		setState(4939)
		 		try variable_name()
		 		setState(4944)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4940)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(4941)
		 			try variable_name()


		 			setState(4946)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_column_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func quoted_string() -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_xml_column_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterXml_column_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitXml_column_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitXml_column_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitXml_column_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_column_name() throws -> Xml_column_nameContext {
		var _localctx: Xml_column_nameContext = Xml_column_nameContext(_ctx, getState())
		try enterRule(_localctx, 648, plsqlParser.RULE_xml_column_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4951)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4949)
		 		try identifier()

		 		break
		 	case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case .CHAR_STRING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4950)
		 		try quoted_string()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cost_class_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cost_class_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCost_class_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCost_class_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCost_class_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCost_class_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cost_class_name() throws -> Cost_class_nameContext {
		var _localctx: Cost_class_nameContext = Cost_class_nameContext(_ctx, getState())
		try enterRule(_localctx, 650, plsqlParser.RULE_cost_class_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4953)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Attribute_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_attribute_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAttribute_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAttribute_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAttribute_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAttribute_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func attribute_name() throws -> Attribute_nameContext {
		var _localctx: Attribute_nameContext = Attribute_nameContext(_ctx, getState())
		try enterRule(_localctx, 652, plsqlParser.RULE_attribute_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4955)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Savepoint_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_savepoint_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSavepoint_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSavepoint_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSavepoint_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSavepoint_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func savepoint_name() throws -> Savepoint_nameContext {
		var _localctx: Savepoint_nameContext = Savepoint_nameContext(_ctx, getState())
		try enterRule(_localctx, 654, plsqlParser.RULE_savepoint_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4957)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Rollback_segment_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_rollback_segment_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRollback_segment_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRollback_segment_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRollback_segment_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRollback_segment_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rollback_segment_name() throws -> Rollback_segment_nameContext {
		var _localctx: Rollback_segment_nameContext = Rollback_segment_nameContext(_ctx, getState())
		try enterRule(_localctx, 656, plsqlParser.RULE_rollback_segment_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4959)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_var_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_var_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_var_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_var_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_var_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_var_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_var_name() throws -> Table_var_nameContext {
		var _localctx: Table_var_nameContext = Table_var_nameContext(_ctx, getState())
		try enterRule(_localctx, 658, plsqlParser.RULE_table_var_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4961)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Schema_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_schema_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSchema_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSchema_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSchema_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSchema_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func schema_name() throws -> Schema_nameContext {
		var _localctx: Schema_nameContext = Schema_nameContext(_ctx, getState())
		try enterRule(_localctx, 660, plsqlParser.RULE_schema_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4963)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Routine_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open func link_name() -> Link_nameContext? {
			return getRuleContext(Link_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_routine_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRoutine_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRoutine_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRoutine_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRoutine_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func routine_name() throws -> Routine_nameContext {
		var _localctx: Routine_nameContext = Routine_nameContext(_ctx, getState())
		try enterRule(_localctx, 662, plsqlParser.RULE_routine_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4965)
		 	try identifier()
		 	setState(4970)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4966)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(4967)
		 		try id_expression()


		 		setState(4972)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4975)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.AT_SIGN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4973)
		 		try match(plsqlParser.Tokens.AT_SIGN.rawValue)
		 		setState(4974)
		 		try link_name()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Package_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_package_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPackage_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPackage_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPackage_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPackage_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func package_name() throws -> Package_nameContext {
		var _localctx: Package_nameContext = Package_nameContext(_ctx, getState())
		try enterRule(_localctx, 664, plsqlParser.RULE_package_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4977)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Implementation_type_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_implementation_type_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterImplementation_type_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitImplementation_type_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitImplementation_type_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitImplementation_type_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func implementation_type_name() throws -> Implementation_type_nameContext {
		var _localctx: Implementation_type_nameContext = Implementation_type_nameContext(_ctx, getState())
		try enterRule(_localctx, 666, plsqlParser.RULE_implementation_type_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4979)
		 	try identifier()
		 	setState(4982)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4980)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(4981)
		 		try id_expression()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Parameter_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_parameter_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterParameter_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitParameter_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitParameter_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitParameter_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func parameter_name() throws -> Parameter_nameContext {
		var _localctx: Parameter_nameContext = Parameter_nameContext(_ctx, getState())
		try enterRule(_localctx, 668, plsqlParser.RULE_parameter_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4984)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Reference_model_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_reference_model_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterReference_model_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitReference_model_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitReference_model_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitReference_model_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func reference_model_name() throws -> Reference_model_nameContext {
		var _localctx: Reference_model_nameContext = Reference_model_nameContext(_ctx, getState())
		try enterRule(_localctx, 670, plsqlParser.RULE_reference_model_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4986)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Main_model_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_main_model_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterMain_model_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitMain_model_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitMain_model_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitMain_model_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func main_model_name() throws -> Main_model_nameContext {
		var _localctx: Main_model_nameContext = Main_model_nameContext(_ctx, getState())
		try enterRule(_localctx, 672, plsqlParser.RULE_main_model_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4988)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Aggregate_function_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_aggregate_function_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterAggregate_function_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitAggregate_function_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitAggregate_function_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitAggregate_function_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func aggregate_function_name() throws -> Aggregate_function_nameContext {
		var _localctx: Aggregate_function_nameContext = Aggregate_function_nameContext(_ctx, getState())
		try enterRule(_localctx, 674, plsqlParser.RULE_aggregate_function_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4990)
		 	try identifier()
		 	setState(4995)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4991)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(4992)
		 		try id_expression()


		 		setState(4997)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Query_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_query_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterQuery_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitQuery_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitQuery_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitQuery_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func query_name() throws -> Query_nameContext {
		var _localctx: Query_nameContext = Query_nameContext(_ctx, getState())
		try enterRule(_localctx, 676, plsqlParser.RULE_query_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4998)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Constraint_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open func link_name() -> Link_nameContext? {
			return getRuleContext(Link_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_constraint_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConstraint_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConstraint_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConstraint_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConstraint_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func constraint_name() throws -> Constraint_nameContext {
		var _localctx: Constraint_nameContext = Constraint_nameContext(_ctx, getState())
		try enterRule(_localctx, 678, plsqlParser.RULE_constraint_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5000)
		 	try identifier()
		 	setState(5005)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5001)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5002)
		 		try id_expression()


		 		setState(5007)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5010)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.AT_SIGN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5008)
		 		try match(plsqlParser.Tokens.AT_SIGN.rawValue)
		 		setState(5009)
		 		try link_name()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Label_nameContext:ParserRuleContext {
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_label_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLabel_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLabel_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLabel_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLabel_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func label_name() throws -> Label_nameContext {
		var _localctx: Label_nameContext = Label_nameContext(_ctx, getState())
		try enterRule(_localctx, 680, plsqlParser.RULE_label_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5012)
		 	try id_expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_nameContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_name() throws -> Type_nameContext {
		var _localctx: Type_nameContext = Type_nameContext(_ctx, getState())
		try enterRule(_localctx, 682, plsqlParser.RULE_type_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5014)
		 	try id_expression()
		 	setState(5019)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5015)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5016)
		 		try id_expression()


		 		setState(5021)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sequence_nameContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_sequence_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterSequence_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitSequence_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitSequence_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitSequence_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sequence_name() throws -> Sequence_nameContext {
		var _localctx: Sequence_nameContext = Sequence_nameContext(_ctx, getState())
		try enterRule(_localctx, 684, plsqlParser.RULE_sequence_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5022)
		 	try id_expression()
		 	setState(5027)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5023)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5024)
		 		try id_expression()


		 		setState(5029)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Exception_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_exception_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterException_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitException_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitException_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitException_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exception_name() throws -> Exception_nameContext {
		var _localctx: Exception_nameContext = Exception_nameContext(_ctx, getState())
		try enterRule(_localctx, 686, plsqlParser.RULE_exception_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5030)
		 	try identifier()
		 	setState(5035)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5031)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5032)
		 		try id_expression()


		 		setState(5037)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_name() throws -> Function_nameContext {
		var _localctx: Function_nameContext = Function_nameContext(_ctx, getState())
		try enterRule(_localctx, 688, plsqlParser.RULE_function_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5038)
		 	try identifier()
		 	setState(5041)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5039)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5040)
		 		try id_expression()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Procedure_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_procedure_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterProcedure_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitProcedure_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitProcedure_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitProcedure_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedure_name() throws -> Procedure_nameContext {
		var _localctx: Procedure_nameContext = Procedure_nameContext(_ctx, getState())
		try enterRule(_localctx, 690, plsqlParser.RULE_procedure_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5043)
		 	try identifier()
		 	setState(5046)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5044)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5045)
		 		try id_expression()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Trigger_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_trigger_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTrigger_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTrigger_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTrigger_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTrigger_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func trigger_name() throws -> Trigger_nameContext {
		var _localctx: Trigger_nameContext = Trigger_nameContext(_ctx, getState())
		try enterRule(_localctx, 692, plsqlParser.RULE_trigger_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5048)
		 	try identifier()
		 	setState(5051)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5049)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5050)
		 		try id_expression()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Variable_nameContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open func INTRODUCER() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTRODUCER.rawValue, 0) }
		open func char_set_name() -> Char_set_nameContext? {
			return getRuleContext(Char_set_nameContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_variable_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterVariable_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitVariable_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitVariable_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitVariable_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func variable_name() throws -> Variable_nameContext {
		var _localctx: Variable_nameContext = Variable_nameContext(_ctx, getState())
		try enterRule(_localctx, 694, plsqlParser.RULE_variable_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5063)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5055)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.INTRODUCER.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5053)
		 			try match(plsqlParser.Tokens.INTRODUCER.rawValue)
		 			setState(5054)
		 			try char_set_name()

		 		}

		 		setState(5057)
		 		try id_expression()
		 		setState(5060)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5058)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(5059)
		 			try id_expression()

		 		}


		 		break
		 	case .BINDVAR:fallthrough
		 	case .COLON:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5062)
		 		try bind_variable()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Index_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_index_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterIndex_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitIndex_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitIndex_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitIndex_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func index_name() throws -> Index_nameContext {
		var _localctx: Index_nameContext = Index_nameContext(_ctx, getState())
		try enterRule(_localctx, 696, plsqlParser.RULE_index_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5065)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_cursor_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCursor_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCursor_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCursor_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCursor_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_name() throws -> Cursor_nameContext {
		var _localctx: Cursor_nameContext = Cursor_nameContext(_ctx, getState())
		try enterRule(_localctx, 698, plsqlParser.RULE_cursor_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5069)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5067)
		 		try identifier()

		 		break
		 	case .BINDVAR:fallthrough
		 	case .COLON:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5068)
		 		try bind_variable()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Record_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func bind_variable() -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_record_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRecord_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRecord_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRecord_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRecord_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func record_name() throws -> Record_nameContext {
		var _localctx: Record_nameContext = Record_nameContext(_ctx, getState())
		try enterRule(_localctx, 700, plsqlParser.RULE_record_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5073)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .DELIMITED_ID:fallthrough
		 	case .INTRODUCER:fallthrough
		 	case .REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5071)
		 		try identifier()

		 		break
		 	case .BINDVAR:fallthrough
		 	case .COLON:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5072)
		 		try bind_variable()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Collection_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_collection_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterCollection_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitCollection_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitCollection_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitCollection_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func collection_name() throws -> Collection_nameContext {
		var _localctx: Collection_nameContext = Collection_nameContext(_ctx, getState())
		try enterRule(_localctx, 702, plsqlParser.RULE_collection_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5075)
		 	try identifier()
		 	setState(5078)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5076)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5077)
		 		try id_expression()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Link_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_link_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLink_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLink_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLink_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLink_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func link_name() throws -> Link_nameContext {
		var _localctx: Link_nameContext = Link_nameContext(_ctx, getState())
		try enterRule(_localctx, 704, plsqlParser.RULE_link_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5080)
		 	try identifier()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_column_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterColumn_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitColumn_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitColumn_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitColumn_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_name() throws -> Column_nameContext {
		var _localctx: Column_nameContext = Column_nameContext(_ctx, getState())
		try enterRule(_localctx, 706, plsqlParser.RULE_column_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5082)
		 	try identifier()
		 	setState(5087)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5083)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5084)
		 		try id_expression()


		 		setState(5089)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Tableview_nameContext:ParserRuleContext {
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open func link_name() -> Link_nameContext? {
			return getRuleContext(Link_nameContext.self,0)
		}
		open func partition_extension_clause() -> Partition_extension_clauseContext? {
			return getRuleContext(Partition_extension_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_tableview_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTableview_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTableview_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTableview_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTableview_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func tableview_name() throws -> Tableview_nameContext {
		var _localctx: Tableview_nameContext = Tableview_nameContext(_ctx, getState())
		try enterRule(_localctx, 708, plsqlParser.RULE_tableview_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5090)
		 	try identifier()
		 	setState(5093)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,661,_ctx)) {
		 	case 1:
		 		setState(5091)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5092)
		 		try id_expression()

		 		break
		 	default: break
		 	}
		 	setState(5098)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,662,_ctx)) {
		 	case 1:
		 		setState(5095)
		 		try match(plsqlParser.Tokens.AT_SIGN.rawValue)
		 		setState(5096)
		 		try link_name()

		 		break
		 	case 2:
		 		setState(5097)
		 		try partition_extension_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Char_set_nameContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_char_set_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterChar_set_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitChar_set_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitChar_set_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitChar_set_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func char_set_name() throws -> Char_set_nameContext {
		var _localctx: Char_set_nameContext = Char_set_nameContext(_ctx, getState())
		try enterRule(_localctx, 710, plsqlParser.RULE_char_set_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5100)
		 	try id_expression()
		 	setState(5105)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5101)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5102)
		 		try id_expression()


		 		setState(5107)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Keep_clauseContext:ParserRuleContext {
		open func KEEP() -> TerminalNode? { return getToken(plsqlParser.Tokens.KEEP.rawValue, 0) }
		open func DENSE_RANK() -> TerminalNode? { return getToken(plsqlParser.Tokens.DENSE_RANK.rawValue, 0) }
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func FIRST() -> TerminalNode? { return getToken(plsqlParser.Tokens.FIRST.rawValue, 0) }
		open func LAST() -> TerminalNode? { return getToken(plsqlParser.Tokens.LAST.rawValue, 0) }
		open func over_clause() -> Over_clauseContext? {
			return getRuleContext(Over_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_keep_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterKeep_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitKeep_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitKeep_clause(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitKeep_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func keep_clause() throws -> Keep_clauseContext {
		var _localctx: Keep_clauseContext = Keep_clauseContext(_ctx, getState())
		try enterRule(_localctx, 712, plsqlParser.RULE_keep_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5108)
		 	try match(plsqlParser.Tokens.KEEP.rawValue)
		 	setState(5109)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(5110)
		 	try match(plsqlParser.Tokens.DENSE_RANK.rawValue)
		 	setState(5111)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.FIRST.rawValue || _la == plsqlParser.Tokens.LAST.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5112)
		 	try order_by_clause()
		 	setState(5113)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(5115)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,664,_ctx)) {
		 	case 1:
		 		setState(5114)
		 		try over_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_argumentContext:ParserRuleContext {
		open func argument() -> Array<ArgumentContext> {
			return getRuleContexts(ArgumentContext.self)
		}
		open func argument(_ i: Int) -> ArgumentContext? {
			return getRuleContext(ArgumentContext.self,i)
		}
		open func keep_clause() -> Keep_clauseContext? {
			return getRuleContext(Keep_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_argument }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_argument(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_argument(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_argument(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_argument(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_argument() throws -> Function_argumentContext {
		var _localctx: Function_argumentContext = Function_argumentContext(_ctx, getState())
		try enterRule(_localctx, 714, plsqlParser.RULE_function_argument)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5117)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(5119)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ALL.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ANY.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CASE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COALESCE.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONNECT_BY_ROOT.rawValue,plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DATE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DISTINCT.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTION_INIT.rawValue,plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXISTS.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FALSE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LANGUAGE.rawValue,plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NOT.rawValue,plsqlParser.Tokens.NULL.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OBJECT.rawValue,plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PRIOR.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 257)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.RIGHT.rawValue,plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUE.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YES.rawValue,plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.DECODE.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.NVL.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROUND.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.SUBSTR.rawValue,plsqlParser.Tokens.TO_CHAR.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue,plsqlParser.Tokens.APPROXIMATE_NUM_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue,plsqlParser.Tokens.LEFT_PAREN.rawValue,plsqlParser.Tokens.PLUS_SIGN.rawValue,plsqlParser.Tokens.MINUS_SIGN.rawValue,plsqlParser.Tokens.BINDVAR.rawValue,plsqlParser.Tokens.COLON.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5118)
		 		try argument()

		 	}

		 	setState(5125)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5121)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(5122)
		 		try argument()


		 		setState(5127)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5128)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(5130)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,667,_ctx)) {
		 	case 1:
		 		setState(5129)
		 		try keep_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_argument_analyticContext:ParserRuleContext {
		open func argument() -> Array<ArgumentContext> {
			return getRuleContexts(ArgumentContext.self)
		}
		open func argument(_ i: Int) -> ArgumentContext? {
			return getRuleContext(ArgumentContext.self,i)
		}
		open func keep_clause() -> Keep_clauseContext? {
			return getRuleContext(Keep_clauseContext.self,0)
		}
		open func respect_or_ignore_nulls() -> Array<Respect_or_ignore_nullsContext> {
			return getRuleContexts(Respect_or_ignore_nullsContext.self)
		}
		open func respect_or_ignore_nulls(_ i: Int) -> Respect_or_ignore_nullsContext? {
			return getRuleContext(Respect_or_ignore_nullsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_argument_analytic }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_argument_analytic(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_argument_analytic(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_argument_analytic(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_argument_analytic(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_argument_analytic() throws -> Function_argument_analyticContext {
		var _localctx: Function_argument_analyticContext = Function_argument_analyticContext(_ctx, getState())
		try enterRule(_localctx, 716, plsqlParser.RULE_function_argument_analytic)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5132)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(5137)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ALL.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ANY.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CASE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COALESCE.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONNECT_BY_ROOT.rawValue,plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DATE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DISTINCT.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 65)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTION_INIT.rawValue,plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXISTS.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FALSE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 129)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LANGUAGE.rawValue,plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NOT.rawValue,plsqlParser.Tokens.NULL.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 193)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OBJECT.rawValue,plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.PRIOR.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 257)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.RIGHT.rawValue,plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 322)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUE.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 386)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YES.rawValue,plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.DECODE.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.NVL.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROUND.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.SUBSTR.rawValue,plsqlParser.Tokens.TO_CHAR.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue,plsqlParser.Tokens.APPROXIMATE_NUM_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue,plsqlParser.Tokens.LEFT_PAREN.rawValue,plsqlParser.Tokens.PLUS_SIGN.rawValue,plsqlParser.Tokens.MINUS_SIGN.rawValue,plsqlParser.Tokens.BINDVAR.rawValue,plsqlParser.Tokens.COLON.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 450)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5133)
		 		try argument()
		 		setState(5135)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.IGNORE.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.RESPECT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5134)
		 			try respect_or_ignore_nulls()

		 		}


		 	}

		 	setState(5146)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5139)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(5140)
		 		try argument()
		 		setState(5142)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.IGNORE.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.RESPECT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5141)
		 			try respect_or_ignore_nulls()

		 		}



		 		setState(5148)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5149)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(5151)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,672,_ctx)) {
		 	case 1:
		 		setState(5150)
		 		try keep_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_argument_modelingContext:ParserRuleContext {
		open func column_name() -> Column_nameContext? {
			return getRuleContext(Column_nameContext.self,0)
		}
		open func USING() -> TerminalNode? { return getToken(plsqlParser.Tokens.USING.rawValue, 0) }
		open func tableview_name() -> Tableview_nameContext? {
			return getRuleContext(Tableview_nameContext.self,0)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func keep_clause() -> Keep_clauseContext? {
			return getRuleContext(Keep_clauseContext.self,0)
		}
		open func numeric() -> Array<NumericContext> {
			return getRuleContexts(NumericContext.self)
		}
		open func numeric(_ i: Int) -> NumericContext? {
			return getRuleContext(NumericContext.self,i)
		}
		open func NULL() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.NULL.rawValue) }
		open func NULL(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.NULL.rawValue, i)
		}
		open func column_alias() -> Array<Column_aliasContext> {
			return getRuleContexts(Column_aliasContext.self)
		}
		open func column_alias(_ i: Int) -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_function_argument_modeling }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterFunction_argument_modeling(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitFunction_argument_modeling(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitFunction_argument_modeling(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitFunction_argument_modeling(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_argument_modeling() throws -> Function_argument_modelingContext {
		var _localctx: Function_argument_modelingContext = Function_argument_modelingContext(_ctx, getState())
		try enterRule(_localctx, 718, plsqlParser.RULE_function_argument_modeling)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5153)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(5154)
		 	try column_name()
		 	setState(5167)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5155)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(5158)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .UNSIGNED_INTEGER:fallthrough
		 		case .APPROXIMATE_NUM_LIT:
		 			setState(5156)
		 			try numeric()

		 			break

		 		case .NULL:
		 			setState(5157)
		 			try match(plsqlParser.Tokens.NULL.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5165)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5160)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(5163)
		 			try _errHandler.sync(self)
		 			switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .UNSIGNED_INTEGER:fallthrough
		 			case .APPROXIMATE_NUM_LIT:
		 				setState(5161)
		 				try numeric()

		 				break

		 			case .NULL:
		 				setState(5162)
		 				try match(plsqlParser.Tokens.NULL.rawValue)

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 		}


		 	}

		 	setState(5169)
		 	try match(plsqlParser.Tokens.USING.rawValue)
		 	setState(5189)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,680, _ctx)) {
		 	case 1:
		 		setState(5170)
		 		try tableview_name()
		 		setState(5171)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5172)
		 		try match(plsqlParser.Tokens.ASTERISK.rawValue)

		 		break
		 	case 2:
		 		setState(5174)
		 		try match(plsqlParser.Tokens.ASTERISK.rawValue)

		 		break
		 	case 3:
		 		setState(5175)
		 		try expression()
		 		setState(5177)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.AS.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 0)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 66)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 130)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 194)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 259)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 323)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 387)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 451)
		 		          }()
		 		          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5176)
		 			try column_alias()

		 		}

		 		setState(5186)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5179)
		 			try match(plsqlParser.Tokens.COMMA.rawValue)
		 			setState(5180)
		 			try expression()
		 			setState(5182)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = {  () -> Bool in
		 			   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.AS.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 			    return  Utils.testBitLeftShiftArray(testArray, 0)
		 			}()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 66)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 130)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 194)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 259)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 323)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 387)
		 			          }()
		 			          testSet = testSet || {  () -> Bool in
		 			             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue,plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue,plsqlParser.Tokens.CHAR_STRING.rawValue,plsqlParser.Tokens.DELIMITED_ID.rawValue]
		 			              return  Utils.testBitLeftShiftArray(testArray, 451)
		 			          }()
		 			          testSet = testSet || _la == plsqlParser.Tokens.INTRODUCER.rawValue || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(5181)
		 				try column_alias()

		 			}



		 			setState(5188)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}
		 	setState(5191)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)
		 	setState(5193)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,681,_ctx)) {
		 	case 1:
		 		setState(5192)
		 		try keep_clause()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Respect_or_ignore_nullsContext:ParserRuleContext {
		open func NULLS() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULLS.rawValue, 0) }
		open func RESPECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESPECT.rawValue, 0) }
		open func IGNORE() -> TerminalNode? { return getToken(plsqlParser.Tokens.IGNORE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_respect_or_ignore_nulls }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRespect_or_ignore_nulls(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRespect_or_ignore_nulls(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRespect_or_ignore_nulls(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRespect_or_ignore_nulls(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func respect_or_ignore_nulls() throws -> Respect_or_ignore_nullsContext {
		var _localctx: Respect_or_ignore_nullsContext = Respect_or_ignore_nullsContext(_ctx, getState())
		try enterRule(_localctx, 720, plsqlParser.RULE_respect_or_ignore_nulls)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5195)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.IGNORE.rawValue
		 	          testSet = testSet || _la == plsqlParser.Tokens.RESPECT.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5196)
		 	try match(plsqlParser.Tokens.NULLS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ArgumentContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func identifier() -> IdentifierContext? {
			return getRuleContext(IdentifierContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_argument }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterArgument(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitArgument(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitArgument(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitArgument(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func argument() throws -> ArgumentContext {
		var _localctx: ArgumentContext = ArgumentContext(_ctx, getState())
		try enterRule(_localctx, 722, plsqlParser.RULE_argument)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5202)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,682,_ctx)) {
		 	case 1:
		 		setState(5198)
		 		try identifier()
		 		setState(5199)
		 		try match(plsqlParser.Tokens.EQUALS_OP.rawValue)
		 		setState(5200)
		 		try match(plsqlParser.Tokens.GREATER_THAN_OP.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(5204)
		 	try expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Type_specContext:ParserRuleContext {
		open func datatype() -> DatatypeContext? {
			return getRuleContext(DatatypeContext.self,0)
		}
		open func type_name() -> Type_nameContext? {
			return getRuleContext(Type_nameContext.self,0)
		}
		open func REF() -> TerminalNode? { return getToken(plsqlParser.Tokens.REF.rawValue, 0) }
		open func PERCENT_ROWTYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENT_ROWTYPE.rawValue, 0) }
		open func PERCENT_TYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENT_TYPE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_type_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterType_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitType_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitType_spec(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitType_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func type_spec() throws -> Type_specContext {
		var _localctx: Type_specContext = Type_specContext(_ctx, getState())
		try enterRule(_localctx, 724, plsqlParser.RULE_type_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5214)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,685, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5206)
		 		try datatype()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5208)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,683,_ctx)) {
		 		case 1:
		 			setState(5207)
		 			try match(plsqlParser.Tokens.REF.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(5210)
		 		try type_name()
		 		setState(5212)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.PERCENT_ROWTYPE.rawValue || _la == plsqlParser.Tokens.PERCENT_TYPE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5211)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.PERCENT_ROWTYPE.rawValue || _la == plsqlParser.Tokens.PERCENT_TYPE.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}


		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class DatatypeContext:ParserRuleContext {
		open func native_datatype_element() -> Native_datatype_elementContext? {
			return getRuleContext(Native_datatype_elementContext.self,0)
		}
		open func precision_part() -> Precision_partContext? {
			return getRuleContext(Precision_partContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(plsqlParser.Tokens.WITH.rawValue, 0) }
		open func TIME() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIME.rawValue, 0) }
		open func ZONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ZONE.rawValue, 0) }
		open func LOCAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOCAL.rawValue, 0) }
		open func INTERVAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTERVAL.rawValue, 0) }
		open func TO() -> TerminalNode? { return getToken(plsqlParser.Tokens.TO.rawValue, 0) }
		open func YEAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.YEAR.rawValue, 0) }
		open func DAY() -> TerminalNode? { return getToken(plsqlParser.Tokens.DAY.rawValue, 0) }
		open func MONTH() -> TerminalNode? { return getToken(plsqlParser.Tokens.MONTH.rawValue, 0) }
		open func SECOND() -> TerminalNode? { return getToken(plsqlParser.Tokens.SECOND.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_datatype }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterDatatype(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitDatatype(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitDatatype(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitDatatype(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func datatype() throws -> DatatypeContext {
		var _localctx: DatatypeContext = DatatypeContext(_ctx, getState())
		try enterRule(_localctx, 726, plsqlParser.RULE_datatype)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5244)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CLOB:fallthrough
		 	case .DATE:fallthrough
		 	case .DAY:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .FLOAT:fallthrough
		 	case .HOUR:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .LONG:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MONTH:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .RAW:fallthrough
		 	case .REAL:fallthrough
		 	case .ROWID:fallthrough
		 	case .SECOND:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .STRING:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .UROWID:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .YEAR:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5216)
		 		try native_datatype_element()
		 		setState(5218)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,686,_ctx)) {
		 		case 1:
		 			setState(5217)
		 			try precision_part()

		 			break
		 		default: break
		 		}
		 		setState(5226)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.WITH.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5220)
		 			try match(plsqlParser.Tokens.WITH.rawValue)
		 			setState(5222)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.LOCAL.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(5221)
		 				try match(plsqlParser.Tokens.LOCAL.rawValue)

		 			}

		 			setState(5224)
		 			try match(plsqlParser.Tokens.TIME.rawValue)
		 			setState(5225)
		 			try match(plsqlParser.Tokens.ZONE.rawValue)

		 		}


		 		break

		 	case .INTERVAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5228)
		 		try match(plsqlParser.Tokens.INTERVAL.rawValue)
		 		setState(5229)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.DAY.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.YEAR.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5234)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.LEFT_PAREN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5230)
		 			try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 			setState(5231)
		 			try expression()
		 			setState(5232)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 		}

		 		setState(5236)
		 		try match(plsqlParser.Tokens.TO.rawValue)
		 		setState(5237)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.MONTH.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.SECOND.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5242)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,690,_ctx)) {
		 		case 1:
		 			setState(5238)
		 			try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 			setState(5239)
		 			try expression()
		 			setState(5240)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Precision_partContext:ParserRuleContext {
		open func numeric() -> Array<NumericContext> {
			return getRuleContexts(NumericContext.self)
		}
		open func numeric(_ i: Int) -> NumericContext? {
			return getRuleContext(NumericContext.self,i)
		}
		open func CHAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHAR.rawValue, 0) }
		open func BYTE() -> TerminalNode? { return getToken(plsqlParser.Tokens.BYTE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_precision_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterPrecision_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitPrecision_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitPrecision_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitPrecision_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func precision_part() throws -> Precision_partContext {
		var _localctx: Precision_partContext = Precision_partContext(_ctx, getState())
		try enterRule(_localctx, 728, plsqlParser.RULE_precision_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5246)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(5247)
		 	try numeric()
		 	setState(5250)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5248)
		 		try match(plsqlParser.Tokens.COMMA.rawValue)
		 		setState(5249)
		 		try numeric()

		 	}

		 	setState(5253)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.BYTE.rawValue || _la == plsqlParser.Tokens.CHAR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5252)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.BYTE.rawValue || _la == plsqlParser.Tokens.CHAR.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(5255)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Native_datatype_elementContext:ParserRuleContext {
		open func BINARY_INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.BINARY_INTEGER.rawValue, 0) }
		open func PLS_INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.PLS_INTEGER.rawValue, 0) }
		open func NATURAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NATURAL.rawValue, 0) }
		open func BINARY_FLOAT() -> TerminalNode? { return getToken(plsqlParser.Tokens.BINARY_FLOAT.rawValue, 0) }
		open func BINARY_DOUBLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.BINARY_DOUBLE.rawValue, 0) }
		open func NATURALN() -> TerminalNode? { return getToken(plsqlParser.Tokens.NATURALN.rawValue, 0) }
		open func POSITIVE() -> TerminalNode? { return getToken(plsqlParser.Tokens.POSITIVE.rawValue, 0) }
		open func POSITIVEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.POSITIVEN.rawValue, 0) }
		open func SIGNTYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SIGNTYPE.rawValue, 0) }
		open func SIMPLE_INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.SIMPLE_INTEGER.rawValue, 0) }
		open func NVARCHAR2() -> TerminalNode? { return getToken(plsqlParser.Tokens.NVARCHAR2.rawValue, 0) }
		open func DEC() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEC.rawValue, 0) }
		open func INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTEGER.rawValue, 0) }
		open func INT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INT.rawValue, 0) }
		open func NUMERIC() -> TerminalNode? { return getToken(plsqlParser.Tokens.NUMERIC.rawValue, 0) }
		open func SMALLINT() -> TerminalNode? { return getToken(plsqlParser.Tokens.SMALLINT.rawValue, 0) }
		open func NUMBER() -> TerminalNode? { return getToken(plsqlParser.Tokens.NUMBER.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func DOUBLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DOUBLE.rawValue, 0) }
		open func PRECISION() -> TerminalNode? { return getToken(plsqlParser.Tokens.PRECISION.rawValue, 0) }
		open func FLOAT() -> TerminalNode? { return getToken(plsqlParser.Tokens.FLOAT.rawValue, 0) }
		open func REAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.REAL.rawValue, 0) }
		open func NCHAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.NCHAR.rawValue, 0) }
		open func LONG() -> TerminalNode? { return getToken(plsqlParser.Tokens.LONG.rawValue, 0) }
		open func RAW() -> TerminalNode? { return getToken(plsqlParser.Tokens.RAW.rawValue, 0) }
		open func CHAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHAR.rawValue, 0) }
		open func CHARACTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHARACTER.rawValue, 0) }
		open func VARCHAR2() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARCHAR2.rawValue, 0) }
		open func VARCHAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARCHAR.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(plsqlParser.Tokens.STRING.rawValue, 0) }
		open func BOOLEAN() -> TerminalNode? { return getToken(plsqlParser.Tokens.BOOLEAN.rawValue, 0) }
		open func DATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DATE.rawValue, 0) }
		open func ROWID() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROWID.rawValue, 0) }
		open func UROWID() -> TerminalNode? { return getToken(plsqlParser.Tokens.UROWID.rawValue, 0) }
		open func YEAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.YEAR.rawValue, 0) }
		open func MONTH() -> TerminalNode? { return getToken(plsqlParser.Tokens.MONTH.rawValue, 0) }
		open func DAY() -> TerminalNode? { return getToken(plsqlParser.Tokens.DAY.rawValue, 0) }
		open func HOUR() -> TerminalNode? { return getToken(plsqlParser.Tokens.HOUR.rawValue, 0) }
		open func MINUTE() -> TerminalNode? { return getToken(plsqlParser.Tokens.MINUTE.rawValue, 0) }
		open func SECOND() -> TerminalNode? { return getToken(plsqlParser.Tokens.SECOND.rawValue, 0) }
		open func TIMEZONE_HOUR() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMEZONE_HOUR.rawValue, 0) }
		open func TIMEZONE_MINUTE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue, 0) }
		open func TIMEZONE_REGION() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMEZONE_REGION.rawValue, 0) }
		open func TIMEZONE_ABBR() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMEZONE_ABBR.rawValue, 0) }
		open func TIMESTAMP() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMESTAMP.rawValue, 0) }
		open func TIMESTAMP_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue, 0) }
		open func TIMESTAMP_TZ_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue, 0) }
		open func TIMESTAMP_LTZ_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue, 0) }
		open func YMINTERVAL_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue, 0) }
		open func DSINTERVAL_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue, 0) }
		open func BFILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.BFILE.rawValue, 0) }
		open func BLOB() -> TerminalNode? { return getToken(plsqlParser.Tokens.BLOB.rawValue, 0) }
		open func CLOB() -> TerminalNode? { return getToken(plsqlParser.Tokens.CLOB.rawValue, 0) }
		open func NCLOB() -> TerminalNode? { return getToken(plsqlParser.Tokens.NCLOB.rawValue, 0) }
		open func MLSLABEL() -> TerminalNode? { return getToken(plsqlParser.Tokens.MLSLABEL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_native_datatype_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNative_datatype_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNative_datatype_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNative_datatype_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNative_datatype_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func native_datatype_element() throws -> Native_datatype_elementContext {
		var _localctx: Native_datatype_elementContext = Native_datatype_elementContext(_ctx, getState())
		try enterRule(_localctx, 730, plsqlParser.RULE_native_datatype_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5317)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .BINARY_INTEGER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5257)
		 		try match(plsqlParser.Tokens.BINARY_INTEGER.rawValue)

		 		break

		 	case .PLS_INTEGER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5258)
		 		try match(plsqlParser.Tokens.PLS_INTEGER.rawValue)

		 		break

		 	case .NATURAL:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5259)
		 		try match(plsqlParser.Tokens.NATURAL.rawValue)

		 		break

		 	case .BINARY_FLOAT:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5260)
		 		try match(plsqlParser.Tokens.BINARY_FLOAT.rawValue)

		 		break

		 	case .BINARY_DOUBLE:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5261)
		 		try match(plsqlParser.Tokens.BINARY_DOUBLE.rawValue)

		 		break

		 	case .NATURALN:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5262)
		 		try match(plsqlParser.Tokens.NATURALN.rawValue)

		 		break

		 	case .POSITIVE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(5263)
		 		try match(plsqlParser.Tokens.POSITIVE.rawValue)

		 		break

		 	case .POSITIVEN:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(5264)
		 		try match(plsqlParser.Tokens.POSITIVEN.rawValue)

		 		break

		 	case .SIGNTYPE:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(5265)
		 		try match(plsqlParser.Tokens.SIGNTYPE.rawValue)

		 		break

		 	case .SIMPLE_INTEGER:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(5266)
		 		try match(plsqlParser.Tokens.SIMPLE_INTEGER.rawValue)

		 		break

		 	case .NVARCHAR2:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(5267)
		 		try match(plsqlParser.Tokens.NVARCHAR2.rawValue)

		 		break

		 	case .DEC:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(5268)
		 		try match(plsqlParser.Tokens.DEC.rawValue)

		 		break

		 	case .INTEGER:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(5269)
		 		try match(plsqlParser.Tokens.INTEGER.rawValue)

		 		break

		 	case .INT:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(5270)
		 		try match(plsqlParser.Tokens.INT.rawValue)

		 		break

		 	case .NUMERIC:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(5271)
		 		try match(plsqlParser.Tokens.NUMERIC.rawValue)

		 		break

		 	case .SMALLINT:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(5272)
		 		try match(plsqlParser.Tokens.SMALLINT.rawValue)

		 		break

		 	case .NUMBER:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(5273)
		 		try match(plsqlParser.Tokens.NUMBER.rawValue)

		 		break

		 	case .DECIMAL:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(5274)
		 		try match(plsqlParser.Tokens.DECIMAL.rawValue)

		 		break

		 	case .DOUBLE:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(5275)
		 		try match(plsqlParser.Tokens.DOUBLE.rawValue)
		 		setState(5277)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.PRECISION.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5276)
		 			try match(plsqlParser.Tokens.PRECISION.rawValue)

		 		}


		 		break

		 	case .FLOAT:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(5279)
		 		try match(plsqlParser.Tokens.FLOAT.rawValue)

		 		break

		 	case .REAL:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(5280)
		 		try match(plsqlParser.Tokens.REAL.rawValue)

		 		break

		 	case .NCHAR:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(5281)
		 		try match(plsqlParser.Tokens.NCHAR.rawValue)

		 		break

		 	case .LONG:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(5282)
		 		try match(plsqlParser.Tokens.LONG.rawValue)
		 		setState(5284)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.RAW.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5283)
		 			try match(plsqlParser.Tokens.RAW.rawValue)

		 		}


		 		break

		 	case .CHAR:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(5286)
		 		try match(plsqlParser.Tokens.CHAR.rawValue)

		 		break

		 	case .CHARACTER:
		 		try enterOuterAlt(_localctx, 25)
		 		setState(5287)
		 		try match(plsqlParser.Tokens.CHARACTER.rawValue)

		 		break

		 	case .VARCHAR2:
		 		try enterOuterAlt(_localctx, 26)
		 		setState(5288)
		 		try match(plsqlParser.Tokens.VARCHAR2.rawValue)

		 		break

		 	case .VARCHAR:
		 		try enterOuterAlt(_localctx, 27)
		 		setState(5289)
		 		try match(plsqlParser.Tokens.VARCHAR.rawValue)

		 		break

		 	case .STRING:
		 		try enterOuterAlt(_localctx, 28)
		 		setState(5290)
		 		try match(plsqlParser.Tokens.STRING.rawValue)

		 		break

		 	case .RAW:
		 		try enterOuterAlt(_localctx, 29)
		 		setState(5291)
		 		try match(plsqlParser.Tokens.RAW.rawValue)

		 		break

		 	case .BOOLEAN:
		 		try enterOuterAlt(_localctx, 30)
		 		setState(5292)
		 		try match(plsqlParser.Tokens.BOOLEAN.rawValue)

		 		break

		 	case .DATE:
		 		try enterOuterAlt(_localctx, 31)
		 		setState(5293)
		 		try match(plsqlParser.Tokens.DATE.rawValue)

		 		break

		 	case .ROWID:
		 		try enterOuterAlt(_localctx, 32)
		 		setState(5294)
		 		try match(plsqlParser.Tokens.ROWID.rawValue)

		 		break

		 	case .UROWID:
		 		try enterOuterAlt(_localctx, 33)
		 		setState(5295)
		 		try match(plsqlParser.Tokens.UROWID.rawValue)

		 		break

		 	case .YEAR:
		 		try enterOuterAlt(_localctx, 34)
		 		setState(5296)
		 		try match(plsqlParser.Tokens.YEAR.rawValue)

		 		break

		 	case .MONTH:
		 		try enterOuterAlt(_localctx, 35)
		 		setState(5297)
		 		try match(plsqlParser.Tokens.MONTH.rawValue)

		 		break

		 	case .DAY:
		 		try enterOuterAlt(_localctx, 36)
		 		setState(5298)
		 		try match(plsqlParser.Tokens.DAY.rawValue)

		 		break

		 	case .HOUR:
		 		try enterOuterAlt(_localctx, 37)
		 		setState(5299)
		 		try match(plsqlParser.Tokens.HOUR.rawValue)

		 		break

		 	case .MINUTE:
		 		try enterOuterAlt(_localctx, 38)
		 		setState(5300)
		 		try match(plsqlParser.Tokens.MINUTE.rawValue)

		 		break

		 	case .SECOND:
		 		try enterOuterAlt(_localctx, 39)
		 		setState(5301)
		 		try match(plsqlParser.Tokens.SECOND.rawValue)

		 		break

		 	case .TIMEZONE_HOUR:
		 		try enterOuterAlt(_localctx, 40)
		 		setState(5302)
		 		try match(plsqlParser.Tokens.TIMEZONE_HOUR.rawValue)

		 		break

		 	case .TIMEZONE_MINUTE:
		 		try enterOuterAlt(_localctx, 41)
		 		setState(5303)
		 		try match(plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue)

		 		break

		 	case .TIMEZONE_REGION:
		 		try enterOuterAlt(_localctx, 42)
		 		setState(5304)
		 		try match(plsqlParser.Tokens.TIMEZONE_REGION.rawValue)

		 		break

		 	case .TIMEZONE_ABBR:
		 		try enterOuterAlt(_localctx, 43)
		 		setState(5305)
		 		try match(plsqlParser.Tokens.TIMEZONE_ABBR.rawValue)

		 		break

		 	case .TIMESTAMP:
		 		try enterOuterAlt(_localctx, 44)
		 		setState(5306)
		 		try match(plsqlParser.Tokens.TIMESTAMP.rawValue)

		 		break

		 	case .TIMESTAMP_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 45)
		 		setState(5307)
		 		try match(plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue)

		 		break

		 	case .TIMESTAMP_TZ_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 46)
		 		setState(5308)
		 		try match(plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue)

		 		break

		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 47)
		 		setState(5309)
		 		try match(plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue)

		 		break

		 	case .YMINTERVAL_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 48)
		 		setState(5310)
		 		try match(plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue)

		 		break

		 	case .DSINTERVAL_UNCONSTRAINED:
		 		try enterOuterAlt(_localctx, 49)
		 		setState(5311)
		 		try match(plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue)

		 		break

		 	case .BFILE:
		 		try enterOuterAlt(_localctx, 50)
		 		setState(5312)
		 		try match(plsqlParser.Tokens.BFILE.rawValue)

		 		break

		 	case .BLOB:
		 		try enterOuterAlt(_localctx, 51)
		 		setState(5313)
		 		try match(plsqlParser.Tokens.BLOB.rawValue)

		 		break

		 	case .CLOB:
		 		try enterOuterAlt(_localctx, 52)
		 		setState(5314)
		 		try match(plsqlParser.Tokens.CLOB.rawValue)

		 		break

		 	case .NCLOB:
		 		try enterOuterAlt(_localctx, 53)
		 		setState(5315)
		 		try match(plsqlParser.Tokens.NCLOB.rawValue)

		 		break

		 	case .MLSLABEL:
		 		try enterOuterAlt(_localctx, 54)
		 		setState(5316)
		 		try match(plsqlParser.Tokens.MLSLABEL.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Bind_variableContext:ParserRuleContext {
		open func BINDVAR() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.BINDVAR.rawValue) }
		open func BINDVAR(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.BINDVAR.rawValue, i)
		}
		open func UNSIGNED_INTEGER() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue) }
		open func UNSIGNED_INTEGER(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue, i)
		}
		open func general_element_part() -> Array<General_element_partContext> {
			return getRuleContexts(General_element_partContext.self)
		}
		open func general_element_part(_ i: Int) -> General_element_partContext? {
			return getRuleContext(General_element_partContext.self,i)
		}
		open func INDICATOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.INDICATOR.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_bind_variable }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterBind_variable(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitBind_variable(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitBind_variable(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitBind_variable(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func bind_variable() throws -> Bind_variableContext {
		var _localctx: Bind_variableContext = Bind_variableContext(_ctx, getState())
		try enterRule(_localctx, 732, plsqlParser.RULE_bind_variable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5322)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .BINDVAR:
		 		setState(5319)
		 		try match(plsqlParser.Tokens.BINDVAR.rawValue)

		 		break

		 	case .COLON:
		 		setState(5320)
		 		try match(plsqlParser.Tokens.COLON.rawValue)
		 		setState(5321)
		 		try match(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5332)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,700,_ctx)) {
		 	case 1:
		 		setState(5325)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == plsqlParser.Tokens.INDICATOR.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(5324)
		 			try match(plsqlParser.Tokens.INDICATOR.rawValue)

		 		}

		 		setState(5330)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .BINDVAR:
		 			setState(5327)
		 			try match(plsqlParser.Tokens.BINDVAR.rawValue)

		 			break

		 		case .COLON:
		 			setState(5328)
		 			try match(plsqlParser.Tokens.COLON.rawValue)
		 			setState(5329)
		 			try match(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default: break
		 	}
		 	setState(5338)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,701,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5334)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(5335)
		 			try general_element_part()

		 	 
		 		}
		 		setState(5340)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,701,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class General_elementContext:ParserRuleContext {
		open func general_element_part() -> Array<General_element_partContext> {
			return getRuleContexts(General_element_partContext.self)
		}
		open func general_element_part(_ i: Int) -> General_element_partContext? {
			return getRuleContext(General_element_partContext.self,i)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_general_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGeneral_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGeneral_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGeneral_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGeneral_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func general_element() throws -> General_elementContext {
		var _localctx: General_elementContext = General_elementContext(_ctx, getState())
		try enterRule(_localctx, 734, plsqlParser.RULE_general_element)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5341)
		 	try general_element_part()
		 	setState(5346)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,702,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5342)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(5343)
		 			try general_element_part()

		 	 
		 		}
		 		setState(5348)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,702,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class General_element_partContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open func INTRODUCER() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTRODUCER.rawValue, 0) }
		open func char_set_name() -> Char_set_nameContext? {
			return getRuleContext(Char_set_nameContext.self,0)
		}
		open func function_argument() -> Function_argumentContext? {
			return getRuleContext(Function_argumentContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_general_element_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGeneral_element_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGeneral_element_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGeneral_element_part(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGeneral_element_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func general_element_part() throws -> General_element_partContext {
		var _localctx: General_element_partContext = General_element_partContext(_ctx, getState())
		try enterRule(_localctx, 736, plsqlParser.RULE_general_element_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5351)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.INTRODUCER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5349)
		 		try match(plsqlParser.Tokens.INTRODUCER.rawValue)
		 		setState(5350)
		 		try char_set_name()

		 	}

		 	setState(5353)
		 	try id_expression()
		 	setState(5358)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,704,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(5354)
		 			try match(plsqlParser.Tokens.PERIOD.rawValue)
		 			setState(5355)
		 			try id_expression()

		 	 
		 		}
		 		setState(5360)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,704,_ctx)
		 	}
		 	setState(5362)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,705,_ctx)) {
		 	case 1:
		 		setState(5361)
		 		try function_argument()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_elementContext:ParserRuleContext {
		open func id_expression() -> Array<Id_expressionContext> {
			return getRuleContexts(Id_expressionContext.self)
		}
		open func id_expression(_ i: Int) -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,i)
		}
		open func INTRODUCER() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTRODUCER.rawValue, 0) }
		open func char_set_name() -> Char_set_nameContext? {
			return getRuleContext(Char_set_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_table_element }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterTable_element(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitTable_element(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitTable_element(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitTable_element(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_element() throws -> Table_elementContext {
		var _localctx: Table_elementContext = Table_elementContext(_ctx, getState())
		try enterRule(_localctx, 738, plsqlParser.RULE_table_element)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5366)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.INTRODUCER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5364)
		 		try match(plsqlParser.Tokens.INTRODUCER.rawValue)
		 		setState(5365)
		 		try char_set_name()

		 	}

		 	setState(5368)
		 	try id_expression()
		 	setState(5373)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.PERIOD.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5369)
		 		try match(plsqlParser.Tokens.PERIOD.rawValue)
		 		setState(5370)
		 		try id_expression()


		 		setState(5375)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConstantContext:ParserRuleContext {
		open func TIMESTAMP() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMESTAMP.rawValue, 0) }
		open func quoted_string() -> Array<Quoted_stringContext> {
			return getRuleContexts(Quoted_stringContext.self)
		}
		open func quoted_string(_ i: Int) -> Quoted_stringContext? {
			return getRuleContext(Quoted_stringContext.self,i)
		}
		open func bind_variable() -> Array<Bind_variableContext> {
			return getRuleContexts(Bind_variableContext.self)
		}
		open func bind_variable(_ i: Int) -> Bind_variableContext? {
			return getRuleContext(Bind_variableContext.self,i)
		}
		open func AT() -> TerminalNode? { return getToken(plsqlParser.Tokens.AT.rawValue, 0) }
		open func TIME() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIME.rawValue, 0) }
		open func ZONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ZONE.rawValue, 0) }
		open func INTERVAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTERVAL.rawValue, 0) }
		open func DAY() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.DAY.rawValue) }
		open func DAY(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.DAY.rawValue, i)
		}
		open func HOUR() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.HOUR.rawValue) }
		open func HOUR(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.HOUR.rawValue, i)
		}
		open func MINUTE() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.MINUTE.rawValue) }
		open func MINUTE(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.MINUTE.rawValue, i)
		}
		open func SECOND() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.SECOND.rawValue) }
		open func SECOND(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.SECOND.rawValue, i)
		}
		open func general_element_part() -> General_element_partContext? {
			return getRuleContext(General_element_partContext.self,0)
		}
		open func TO() -> TerminalNode? { return getToken(plsqlParser.Tokens.TO.rawValue, 0) }
		open func UNSIGNED_INTEGER() -> Array<TerminalNode> { return getTokens(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue) }
		open func UNSIGNED_INTEGER(_ i:Int) -> TerminalNode?{
			return getToken(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue, i)
		}
		open func numeric() -> NumericContext? {
			return getRuleContext(NumericContext.self,0)
		}
		open func DATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DATE.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULL.rawValue, 0) }
		open func TRUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRUE.rawValue, 0) }
		open func FALSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.FALSE.rawValue, 0) }
		open func DBTIMEZONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DBTIMEZONE.rawValue, 0) }
		open func SESSIONTIMEZONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SESSIONTIMEZONE.rawValue, 0) }
		open func MINVALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.MINVALUE.rawValue, 0) }
		open func MAXVALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.MAXVALUE.rawValue, 0) }
		open func DEFAULT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_constant }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConstant(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConstant(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConstant(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConstant(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func constant() throws -> ConstantContext {
		var _localctx: ConstantContext = ConstantContext(_ctx, getState())
		try enterRule(_localctx, 740, plsqlParser.RULE_constant)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5438)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .TIMESTAMP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5376)
		 		try match(plsqlParser.Tokens.TIMESTAMP.rawValue)
		 		setState(5379)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 		case .CHAR_STRING:
		 			setState(5377)
		 			try quoted_string()

		 			break
		 		case .BINDVAR:fallthrough
		 		case .COLON:
		 			setState(5378)
		 			try bind_variable()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5385)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,709,_ctx)) {
		 		case 1:
		 			setState(5381)
		 			try match(plsqlParser.Tokens.AT.rawValue)
		 			setState(5382)
		 			try match(plsqlParser.Tokens.TIME.rawValue)
		 			setState(5383)
		 			try match(plsqlParser.Tokens.ZONE.rawValue)
		 			setState(5384)
		 			try quoted_string()

		 			break
		 		default: break
		 		}

		 		break

		 	case .INTERVAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5387)
		 		try match(plsqlParser.Tokens.INTERVAL.rawValue)
		 		setState(5391)
		 		try _errHandler.sync(self)
		 		switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 		case .CHAR_STRING:
		 			setState(5388)
		 			try quoted_string()

		 			break
		 		case .BINDVAR:fallthrough
		 		case .COLON:
		 			setState(5389)
		 			try bind_variable()

		 			break
		 		case .A_LETTER:fallthrough
		 		case .ADD:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGENT:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .ARRAY:fallthrough
		 		case .ASSOCIATE:fallthrough
		 		case .AT:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .AUDIT:fallthrough
		 		case .AUTHID:fallthrough
		 		case .AUTO:fallthrough
		 		case .AUTOMATIC:fallthrough
		 		case .AUTONOMOUS_TRANSACTION:fallthrough
		 		case .BATCH:fallthrough
		 		case .BEFORE:fallthrough
		 		case .BFILE:fallthrough
		 		case .BINARY_DOUBLE:fallthrough
		 		case .BINARY_FLOAT:fallthrough
		 		case .BINARY_INTEGER:fallthrough
		 		case .BLOB:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BODY:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BOTH:fallthrough
		 		case .BULK:fallthrough
		 		case .BYTE:fallthrough
		 		case .C_LETTER:fallthrough
		 		case .CALL:fallthrough
		 		case .CANONICAL:fallthrough
		 		case .CASCADE:fallthrough
		 		case .CAST:fallthrough
		 		case .CHAR:fallthrough
		 		case .CHAR_CS:fallthrough
		 		case .CHARACTER:fallthrough
		 		case .CHR:fallthrough
		 		case .CLOB:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTER:fallthrough
		 		case .COLLECT:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .COMPATIBILITY:fallthrough
		 		case .COMPILE:fallthrough
		 		case .COMPOUND:fallthrough
		 		case .CONSTANT:fallthrough
		 		case .CONSTRAINT:fallthrough
		 		case .CONSTRAINTS:fallthrough
		 		case .CONSTRUCTOR:fallthrough
		 		case .CONTENT:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTINUE:fallthrough
		 		case .CONVERT:fallthrough
		 		case .CORRUPT_XID:fallthrough
		 		case .CORRUPT_XID_ALL:fallthrough
		 		case .COST:fallthrough
		 		case .COUNT:fallthrough
		 		case .CROSS:fallthrough
		 		case .CUBE:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .CURSOR:fallthrough
		 		case .CUSTOMDATUM:fallthrough
		 		case .CYCLE:fallthrough
		 		case .DATA:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DAY:fallthrough
		 		case .DB_ROLE_CHANGE:fallthrough
		 		case .DBTIMEZONE:fallthrough
		 		case .DDL:fallthrough
		 		case .DEBUG:fallthrough
		 		case .DEC:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .DECOMPOSE:fallthrough
		 		case .DECREMENT:fallthrough
		 		case .DEFAULTS:fallthrough
		 		case .DEFERRED:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DETERMINISTIC:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISASSOCIATE:fallthrough
		 		case .DOCUMENT:fallthrough
		 		case .DOUBLE:fallthrough
		 		case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 		case .EACH:fallthrough
		 		case .ELEMENT:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCODING:fallthrough
		 		case .ENTITYESCAPING:fallthrough
		 		case .ERR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVALNAME:fallthrough
		 		case .EXCEPTION:fallthrough
		 		case .EXCEPTION_INIT:fallthrough
		 		case .EXCEPTIONS:fallthrough
		 		case .EXCLUDE:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .EXIT:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .EXTERNAL:fallthrough
		 		case .EXTRACT:fallthrough
		 		case .FAILURE:fallthrough
		 		case .FINAL:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .FLOAT:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FORALL:fallthrough
		 		case .FORCE:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GROUPING:fallthrough
		 		case .HASH:fallthrough
		 		case .HIDE:fallthrough
		 		case .HOUR:fallthrough
		 		case .IGNORE:fallthrough
		 		case .IMMEDIATE:fallthrough
		 		case .INCLUDE:fallthrough
		 		case .INCLUDING:fallthrough
		 		case .INCREMENT:fallthrough
		 		case .INDENT:fallthrough
		 		case .INDEXED:fallthrough
		 		case .INDICATOR:fallthrough
		 		case .INDICES:fallthrough
		 		case .INFINITE:fallthrough
		 		case .INLINE:fallthrough
		 		case .INNER:fallthrough
		 		case .INOUT:fallthrough
		 		case .INSTANTIABLE:fallthrough
		 		case .INSTEAD:fallthrough
		 		case .INT:fallthrough
		 		case .INTEGER:fallthrough
		 		case .INTERVAL:fallthrough
		 		case .INVALIDATE:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ITERATE:fallthrough
		 		case .JAVA:fallthrough
		 		case .JOIN:fallthrough
		 		case .KEEP:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEADING:fallthrough
		 		case .LEFT:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIBRARY:fallthrough
		 		case .LIKE2:fallthrough
		 		case .LIKE4:fallthrough
		 		case .LIKEC:fallthrough
		 		case .LIMIT:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCKED:fallthrough
		 		case .LOG:fallthrough
		 		case .LOGOFF:fallthrough
		 		case .LOGON:fallthrough
		 		case .LONG:fallthrough
		 		case .LOOP:fallthrough
		 		case .MAIN:fallthrough
		 		case .MAP:fallthrough
		 		case .MATCHED:fallthrough
		 		case .MAXVALUE:fallthrough
		 		case .MEASURES:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MINUTE:fallthrough
		 		case .MINVALUE:fallthrough
		 		case .MLSLABEL:fallthrough
		 		case .MODEL:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MONTH:fallthrough
		 		case .MULTISET:fallthrough
		 		case .NAME:fallthrough
		 		case .NAN:fallthrough
		 		case .NATURAL:fallthrough
		 		case .NATURALN:fallthrough
		 		case .NAV:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NCHAR_CS:fallthrough
		 		case .NCLOB:fallthrough
		 		case .NESTED:fallthrough
		 		case .NEW:fallthrough
		 		case .NO:fallthrough
		 		case .NOAUDIT:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOCYCLE:fallthrough
		 		case .NOENTITYESCAPING:fallthrough
		 		case .NONE:fallthrough
		 		case .NOSCHEMACHECK:fallthrough
		 		case .NULLS:fallthrough
		 		case .NUMBER:fallthrough
		 		case .NUMERIC:fallthrough
		 		case .NVARCHAR2:fallthrough
		 		case .OBJECT:fallthrough
		 		case .OFF:fallthrough
		 		case .OID:fallthrough
		 		case .OLD:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .ORADATA:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .OSERROR:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTER:fallthrough
		 		case .OVER:fallthrough
		 		case .OVERRIDING:fallthrough
		 		case .PACKAGE:fallthrough
		 		case .PARALLEL_ENABLE:fallthrough
		 		case .PARAMETERS:fallthrough
		 		case .PARENT:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PASSING:fallthrough
		 		case .PATH:fallthrough
		 		case .PIPELINED:fallthrough
		 		case .PLAN:fallthrough
		 		case .PLS_INTEGER:fallthrough
		 		case .POSITIVE:fallthrough
		 		case .POSITIVEN:fallthrough
		 		case .PRAGMA:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRECISION:fallthrough
		 		case .PRESENT:fallthrough
		 		case .RAISE:fallthrough
		 		case .RANGE:fallthrough
		 		case .RAW:fallthrough
		 		case .READ:fallthrough
		 		case .REAL:fallthrough
		 		case .RECORD:fallthrough
		 		case .REF:fallthrough
		 		case .REFERENCE:fallthrough
		 		case .REFERENCING:fallthrough
		 		case .REJECT:fallthrough
		 		case .RELIES_ON:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESPECT:fallthrough
		 		case .RESTRICT_REFERENCES:fallthrough
		 		case .RESULT:fallthrough
		 		case .RESULT_CACHE:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNING:fallthrough
		 		case .REUSE:fallthrough
		 		case .REVERSE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWID:fallthrough
		 		case .ROWS:fallthrough
		 		case .RULES:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SAVE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SCHEMACHECK:fallthrough
		 		case .SCN:fallthrough
		 		case .SECOND:fallthrough
		 		case .SEED:fallthrough
		 		case .SEGMENT:fallthrough
		 		case .SELF:fallthrough
		 		case .SEQUENTIAL:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SERIALLY_REUSABLE:fallthrough
		 		case .SERVERERROR:fallthrough
		 		case .SESSIONTIMEZONE:fallthrough
		 		case .SET:fallthrough
		 		case .SETS:fallthrough
		 		case .SETTINGS:fallthrough
		 		case .SHOW:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SIBLINGS:fallthrough
		 		case .SIGNTYPE:fallthrough
		 		case .SIMPLE_INTEGER:fallthrough
		 		case .SINGLE:fallthrough
		 		case .SKIP_:fallthrough
		 		case .SMALLINT:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOME:fallthrough
		 		case .SPECIFICATION:fallthrough
		 		case .SQLDATA:fallthrough
		 		case .SQLERROR:fallthrough
		 		case .STANDALONE:fallthrough
		 		case .STARTUP:fallthrough
		 		case .STATEMENT:fallthrough
		 		case .STATEMENT_ID:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATISTICS:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBMULTISET:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBSTITUTABLE:fallthrough
		 		case .SUBTYPE:fallthrough
		 		case .SUCCESS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 		case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 		case .TIMEZONE_ABBR:fallthrough
		 		case .TIMEZONE_HOUR:fallthrough
		 		case .TIMEZONE_MINUTE:fallthrough
		 		case .TIMEZONE_REGION:fallthrough
		 		case .TRAILING:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSLATE:fallthrough
		 		case .TREAT:fallthrough
		 		case .TRIGGER:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .TYPE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDER:fallthrough
		 		case .UNLIMITED:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPDATED:fallthrough
		 		case .UPSERT:fallthrough
		 		case .UROWID:fallthrough
		 		case .USE:fallthrough
		 		case .VALIDATE:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARCHAR:fallthrough
		 		case .VARCHAR2:fallthrough
		 		case .VARIABLE:fallthrough
		 		case .VARRAY:fallthrough
		 		case .VARYING:fallthrough
		 		case .VERSION:fallthrough
		 		case .VERSIONS:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNING:fallthrough
		 		case .WELLFORMED:fallthrough
		 		case .WHENEVER:fallthrough
		 		case .WHILE:fallthrough
		 		case .WITHIN:fallthrough
		 		case .WORK:fallthrough
		 		case .WRITE:fallthrough
		 		case .XML:fallthrough
		 		case .XMLAGG:fallthrough
		 		case .XMLATTRIBUTES:fallthrough
		 		case .XMLCAST:fallthrough
		 		case .XMLCOLATTVAL:fallthrough
		 		case .XMLELEMENT:fallthrough
		 		case .XMLEXISTS:fallthrough
		 		case .XMLFOREST:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .XMLPARSE:fallthrough
		 		case .XMLPI:fallthrough
		 		case .XMLQUERY:fallthrough
		 		case .XMLROOT:fallthrough
		 		case .XMLSERIALIZE:fallthrough
		 		case .XMLTABLE:fallthrough
		 		case .YEAR:fallthrough
		 		case .YES:fallthrough
		 		case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 		case .ZONE:fallthrough
		 		case .PREDICTION:fallthrough
		 		case .PREDICTION_BOUNDS:fallthrough
		 		case .PREDICTION_COST:fallthrough
		 		case .PREDICTION_DETAILS:fallthrough
		 		case .PREDICTION_PROBABILITY:fallthrough
		 		case .PREDICTION_SET:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .LISTAGG:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .PERCENTILE_CONT:fallthrough
		 		case .PERCENTILE_DISC:fallthrough
		 		case .RANK:fallthrough
		 		case .AVG:fallthrough
		 		case .CORR:fallthrough
		 		case .COVAR_:fallthrough
		 		case .LAG:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MEDIAN:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .RATIO_TO_REPORT:fallthrough
		 		case .REGR_:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .TRIM:fallthrough
		 		case .SUM:fallthrough
		 		case .STDDEV:fallthrough
		 		case .VAR_:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .DELIMITED_ID:fallthrough
		 		case .INTRODUCER:fallthrough
		 		case .REGULAR_ID:
		 			setState(5390)
		 			try general_element_part()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(5393)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == plsqlParser.Tokens.DAY.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.HOUR.rawValue || _la == plsqlParser.Tokens.MINUTE.rawValue
		 		          testSet = testSet || _la == plsqlParser.Tokens.SECOND.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5407)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,714,_ctx)) {
		 		case 1:
		 			setState(5394)
		 			try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 			setState(5397)
		 			try _errHandler.sync(self)
		 			switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .UNSIGNED_INTEGER:
		 				setState(5395)
		 				try match(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue)

		 				break
		 			case .BINDVAR:fallthrough
		 			case .COLON:
		 				setState(5396)
		 				try bind_variable()

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(5404)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == plsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(5399)
		 				try match(plsqlParser.Tokens.COMMA.rawValue)
		 				setState(5402)
		 				try _errHandler.sync(self)
		 				switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 				case .UNSIGNED_INTEGER:
		 					setState(5400)
		 					try match(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue)

		 					break
		 				case .BINDVAR:fallthrough
		 				case .COLON:
		 					setState(5401)
		 					try bind_variable()

		 					break
		 				default:
		 					throw try ANTLRException.recognition(e: NoViableAltException(self))
		 				}

		 			}

		 			setState(5406)
		 			try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(5424)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,718,_ctx)) {
		 		case 1:
		 			setState(5409)
		 			try match(plsqlParser.Tokens.TO.rawValue)
		 			setState(5422)
		 			try _errHandler.sync(self)
		 			switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .DAY:
		 				setState(5410)
		 				try match(plsqlParser.Tokens.DAY.rawValue)

		 				break

		 			case .HOUR:
		 				setState(5411)
		 				try match(plsqlParser.Tokens.HOUR.rawValue)

		 				break

		 			case .MINUTE:
		 				setState(5412)
		 				try match(plsqlParser.Tokens.MINUTE.rawValue)

		 				break

		 			case .SECOND:
		 				setState(5413)
		 				try match(plsqlParser.Tokens.SECOND.rawValue)
		 				setState(5420)
		 				try _errHandler.sync(self)
		 				switch (try getInterpreter().adaptivePredict(_input,716,_ctx)) {
		 				case 1:
		 					setState(5414)
		 					try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 					setState(5417)
		 					try _errHandler.sync(self)
		 					switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 					case .UNSIGNED_INTEGER:
		 						setState(5415)
		 						try match(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue)

		 						break
		 					case .BINDVAR:fallthrough
		 					case .COLON:
		 						setState(5416)
		 						try bind_variable()

		 						break
		 					default:
		 						throw try ANTLRException.recognition(e: NoViableAltException(self))
		 					}
		 					setState(5419)
		 					try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		 					break
		 				default: break
		 				}

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			break
		 		default: break
		 		}

		 		break
		 	case .UNSIGNED_INTEGER:fallthrough
		 	case .APPROXIMATE_NUM_LIT:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5426)
		 		try numeric()

		 		break

		 	case .DATE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5427)
		 		try match(plsqlParser.Tokens.DATE.rawValue)
		 		setState(5428)
		 		try quoted_string()

		 		break
		 	case .NATIONAL_CHAR_STRING_LIT:fallthrough
		 	case .CHAR_STRING:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5429)
		 		try quoted_string()

		 		break

		 	case .NULL:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5430)
		 		try match(plsqlParser.Tokens.NULL.rawValue)

		 		break

		 	case .TRUE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(5431)
		 		try match(plsqlParser.Tokens.TRUE.rawValue)

		 		break

		 	case .FALSE:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(5432)
		 		try match(plsqlParser.Tokens.FALSE.rawValue)

		 		break

		 	case .DBTIMEZONE:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(5433)
		 		try match(plsqlParser.Tokens.DBTIMEZONE.rawValue)

		 		break

		 	case .SESSIONTIMEZONE:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(5434)
		 		try match(plsqlParser.Tokens.SESSIONTIMEZONE.rawValue)

		 		break

		 	case .MINVALUE:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(5435)
		 		try match(plsqlParser.Tokens.MINVALUE.rawValue)

		 		break

		 	case .MAXVALUE:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(5436)
		 		try match(plsqlParser.Tokens.MAXVALUE.rawValue)

		 		break

		 	case .DEFAULT:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(5437)
		 		try match(plsqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class NumericContext:ParserRuleContext {
		open func UNSIGNED_INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue, 0) }
		open func APPROXIMATE_NUM_LIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.APPROXIMATE_NUM_LIT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_numeric }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNumeric(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNumeric(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNumeric(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNumeric(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func numeric() throws -> NumericContext {
		var _localctx: NumericContext = NumericContext(_ctx, getState())
		try enterRule(_localctx, 742, plsqlParser.RULE_numeric)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5440)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.UNSIGNED_INTEGER.rawValue || _la == plsqlParser.Tokens.APPROXIMATE_NUM_LIT.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Numeric_negativeContext:ParserRuleContext {
		open func MINUS_SIGN() -> TerminalNode? { return getToken(plsqlParser.Tokens.MINUS_SIGN.rawValue, 0) }
		open func numeric() -> NumericContext? {
			return getRuleContext(NumericContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_numeric_negative }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNumeric_negative(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNumeric_negative(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNumeric_negative(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNumeric_negative(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func numeric_negative() throws -> Numeric_negativeContext {
		var _localctx: Numeric_negativeContext = Numeric_negativeContext(_ctx, getState())
		try enterRule(_localctx, 744, plsqlParser.RULE_numeric_negative)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5442)
		 	try match(plsqlParser.Tokens.MINUS_SIGN.rawValue)
		 	setState(5443)
		 	try numeric()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Quoted_stringContext:ParserRuleContext {
		open func CHAR_STRING() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHAR_STRING.rawValue, 0) }
		open func NATIONAL_CHAR_STRING_LIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_quoted_string }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterQuoted_string(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitQuoted_string(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitQuoted_string(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitQuoted_string(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func quoted_string() throws -> Quoted_stringContext {
		var _localctx: Quoted_stringContext = Quoted_stringContext(_ctx, getState())
		try enterRule(_localctx, 746, plsqlParser.RULE_quoted_string)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5445)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.NATIONAL_CHAR_STRING_LIT.rawValue || _la == plsqlParser.Tokens.CHAR_STRING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IdentifierContext:ParserRuleContext {
		open func id_expression() -> Id_expressionContext? {
			return getRuleContext(Id_expressionContext.self,0)
		}
		open func INTRODUCER() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTRODUCER.rawValue, 0) }
		open func char_set_name() -> Char_set_nameContext? {
			return getRuleContext(Char_set_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_identifier }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterIdentifier(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitIdentifier(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitIdentifier(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitIdentifier(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func identifier() throws -> IdentifierContext {
		var _localctx: IdentifierContext = IdentifierContext(_ctx, getState())
		try enterRule(_localctx, 748, plsqlParser.RULE_identifier)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5449)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == plsqlParser.Tokens.INTRODUCER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5447)
		 		try match(plsqlParser.Tokens.INTRODUCER.rawValue)
		 		setState(5448)
		 		try char_set_name()

		 	}

		 	setState(5451)
		 	try id_expression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Id_expressionContext:ParserRuleContext {
		open func regular_id() -> Regular_idContext? {
			return getRuleContext(Regular_idContext.self,0)
		}
		open func DELIMITED_ID() -> TerminalNode? { return getToken(plsqlParser.Tokens.DELIMITED_ID.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_id_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterId_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitId_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitId_expression(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitId_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func id_expression() throws -> Id_expressionContext {
		var _localctx: Id_expressionContext = Id_expressionContext(_ctx, getState())
		try enterRule(_localctx, 750, plsqlParser.RULE_id_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5455)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .A_LETTER:fallthrough
		 	case .ADD:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGENT:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ASSOCIATE:fallthrough
		 	case .AT:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .AUDIT:fallthrough
		 	case .AUTHID:fallthrough
		 	case .AUTO:fallthrough
		 	case .AUTOMATIC:fallthrough
		 	case .AUTONOMOUS_TRANSACTION:fallthrough
		 	case .BATCH:fallthrough
		 	case .BEFORE:fallthrough
		 	case .BFILE:fallthrough
		 	case .BINARY_DOUBLE:fallthrough
		 	case .BINARY_FLOAT:fallthrough
		 	case .BINARY_INTEGER:fallthrough
		 	case .BLOB:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BODY:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BOTH:fallthrough
		 	case .BULK:fallthrough
		 	case .BYTE:fallthrough
		 	case .C_LETTER:fallthrough
		 	case .CALL:fallthrough
		 	case .CANONICAL:fallthrough
		 	case .CASCADE:fallthrough
		 	case .CAST:fallthrough
		 	case .CHAR:fallthrough
		 	case .CHAR_CS:fallthrough
		 	case .CHARACTER:fallthrough
		 	case .CHR:fallthrough
		 	case .CLOB:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTER:fallthrough
		 	case .COLLECT:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .COMPATIBILITY:fallthrough
		 	case .COMPILE:fallthrough
		 	case .COMPOUND:fallthrough
		 	case .CONSTANT:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .CONSTRAINTS:fallthrough
		 	case .CONSTRUCTOR:fallthrough
		 	case .CONTENT:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CONVERT:fallthrough
		 	case .CORRUPT_XID:fallthrough
		 	case .CORRUPT_XID_ALL:fallthrough
		 	case .COST:fallthrough
		 	case .COUNT:fallthrough
		 	case .CROSS:fallthrough
		 	case .CUBE:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .CURSOR:fallthrough
		 	case .CUSTOMDATUM:fallthrough
		 	case .CYCLE:fallthrough
		 	case .DATA:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DAY:fallthrough
		 	case .DB_ROLE_CHANGE:fallthrough
		 	case .DBTIMEZONE:fallthrough
		 	case .DDL:fallthrough
		 	case .DEBUG:fallthrough
		 	case .DEC:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .DECOMPOSE:fallthrough
		 	case .DECREMENT:fallthrough
		 	case .DEFAULTS:fallthrough
		 	case .DEFERRED:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DETERMINISTIC:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISASSOCIATE:fallthrough
		 	case .DOCUMENT:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DSINTERVAL_UNCONSTRAINED:fallthrough
		 	case .EACH:fallthrough
		 	case .ELEMENT:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCODING:fallthrough
		 	case .ENTITYESCAPING:fallthrough
		 	case .ERR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVALNAME:fallthrough
		 	case .EXCEPTION:fallthrough
		 	case .EXCEPTION_INIT:fallthrough
		 	case .EXCEPTIONS:fallthrough
		 	case .EXCLUDE:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .EXIT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .EXTERNAL:fallthrough
		 	case .EXTRACT:fallthrough
		 	case .FAILURE:fallthrough
		 	case .FINAL:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .FLOAT:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FORALL:fallthrough
		 	case .FORCE:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GROUPING:fallthrough
		 	case .HASH:fallthrough
		 	case .HIDE:fallthrough
		 	case .HOUR:fallthrough
		 	case .IGNORE:fallthrough
		 	case .IMMEDIATE:fallthrough
		 	case .INCLUDE:fallthrough
		 	case .INCLUDING:fallthrough
		 	case .INCREMENT:fallthrough
		 	case .INDENT:fallthrough
		 	case .INDEXED:fallthrough
		 	case .INDICATOR:fallthrough
		 	case .INDICES:fallthrough
		 	case .INFINITE:fallthrough
		 	case .INLINE:fallthrough
		 	case .INNER:fallthrough
		 	case .INOUT:fallthrough
		 	case .INSTANTIABLE:fallthrough
		 	case .INSTEAD:fallthrough
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .INTERVAL:fallthrough
		 	case .INVALIDATE:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ITERATE:fallthrough
		 	case .JAVA:fallthrough
		 	case .JOIN:fallthrough
		 	case .KEEP:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEADING:fallthrough
		 	case .LEFT:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIBRARY:fallthrough
		 	case .LIKE2:fallthrough
		 	case .LIKE4:fallthrough
		 	case .LIKEC:fallthrough
		 	case .LIMIT:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCKED:fallthrough
		 	case .LOG:fallthrough
		 	case .LOGOFF:fallthrough
		 	case .LOGON:fallthrough
		 	case .LONG:fallthrough
		 	case .LOOP:fallthrough
		 	case .MAIN:fallthrough
		 	case .MAP:fallthrough
		 	case .MATCHED:fallthrough
		 	case .MAXVALUE:fallthrough
		 	case .MEASURES:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MINUTE:fallthrough
		 	case .MINVALUE:fallthrough
		 	case .MLSLABEL:fallthrough
		 	case .MODEL:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MONTH:fallthrough
		 	case .MULTISET:fallthrough
		 	case .NAME:fallthrough
		 	case .NAN:fallthrough
		 	case .NATURAL:fallthrough
		 	case .NATURALN:fallthrough
		 	case .NAV:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NCHAR_CS:fallthrough
		 	case .NCLOB:fallthrough
		 	case .NESTED:fallthrough
		 	case .NEW:fallthrough
		 	case .NO:fallthrough
		 	case .NOAUDIT:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOCYCLE:fallthrough
		 	case .NOENTITYESCAPING:fallthrough
		 	case .NONE:fallthrough
		 	case .NOSCHEMACHECK:fallthrough
		 	case .NULLS:fallthrough
		 	case .NUMBER:fallthrough
		 	case .NUMERIC:fallthrough
		 	case .NVARCHAR2:fallthrough
		 	case .OBJECT:fallthrough
		 	case .OFF:fallthrough
		 	case .OID:fallthrough
		 	case .OLD:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .ORADATA:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .OSERROR:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTER:fallthrough
		 	case .OVER:fallthrough
		 	case .OVERRIDING:fallthrough
		 	case .PACKAGE:fallthrough
		 	case .PARALLEL_ENABLE:fallthrough
		 	case .PARAMETERS:fallthrough
		 	case .PARENT:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PASSING:fallthrough
		 	case .PATH:fallthrough
		 	case .PIPELINED:fallthrough
		 	case .PLAN:fallthrough
		 	case .PLS_INTEGER:fallthrough
		 	case .POSITIVE:fallthrough
		 	case .POSITIVEN:fallthrough
		 	case .PRAGMA:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRECISION:fallthrough
		 	case .PRESENT:fallthrough
		 	case .RAISE:fallthrough
		 	case .RANGE:fallthrough
		 	case .RAW:fallthrough
		 	case .READ:fallthrough
		 	case .REAL:fallthrough
		 	case .RECORD:fallthrough
		 	case .REF:fallthrough
		 	case .REFERENCE:fallthrough
		 	case .REFERENCING:fallthrough
		 	case .REJECT:fallthrough
		 	case .RELIES_ON:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESPECT:fallthrough
		 	case .RESTRICT_REFERENCES:fallthrough
		 	case .RESULT:fallthrough
		 	case .RESULT_CACHE:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNING:fallthrough
		 	case .REUSE:fallthrough
		 	case .REVERSE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWID:fallthrough
		 	case .ROWS:fallthrough
		 	case .RULES:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SAVE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SCHEMACHECK:fallthrough
		 	case .SCN:fallthrough
		 	case .SECOND:fallthrough
		 	case .SEED:fallthrough
		 	case .SEGMENT:fallthrough
		 	case .SELF:fallthrough
		 	case .SEQUENTIAL:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SERIALLY_REUSABLE:fallthrough
		 	case .SERVERERROR:fallthrough
		 	case .SESSIONTIMEZONE:fallthrough
		 	case .SET:fallthrough
		 	case .SETS:fallthrough
		 	case .SETTINGS:fallthrough
		 	case .SHOW:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SIBLINGS:fallthrough
		 	case .SIGNTYPE:fallthrough
		 	case .SIMPLE_INTEGER:fallthrough
		 	case .SINGLE:fallthrough
		 	case .SKIP_:fallthrough
		 	case .SMALLINT:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOME:fallthrough
		 	case .SPECIFICATION:fallthrough
		 	case .SQLDATA:fallthrough
		 	case .SQLERROR:fallthrough
		 	case .STANDALONE:fallthrough
		 	case .STARTUP:fallthrough
		 	case .STATEMENT:fallthrough
		 	case .STATEMENT_ID:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATISTICS:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBMULTISET:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBSTITUTABLE:fallthrough
		 	case .SUBTYPE:fallthrough
		 	case .SUCCESS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .TIMESTAMP_LTZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_TZ_UNCONSTRAINED:fallthrough
		 	case .TIMESTAMP_UNCONSTRAINED:fallthrough
		 	case .TIMEZONE_ABBR:fallthrough
		 	case .TIMEZONE_HOUR:fallthrough
		 	case .TIMEZONE_MINUTE:fallthrough
		 	case .TIMEZONE_REGION:fallthrough
		 	case .TRAILING:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSLATE:fallthrough
		 	case .TREAT:fallthrough
		 	case .TRIGGER:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .TYPE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDER:fallthrough
		 	case .UNLIMITED:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPDATED:fallthrough
		 	case .UPSERT:fallthrough
		 	case .UROWID:fallthrough
		 	case .USE:fallthrough
		 	case .VALIDATE:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARCHAR:fallthrough
		 	case .VARCHAR2:fallthrough
		 	case .VARIABLE:fallthrough
		 	case .VARRAY:fallthrough
		 	case .VARYING:fallthrough
		 	case .VERSION:fallthrough
		 	case .VERSIONS:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNING:fallthrough
		 	case .WELLFORMED:fallthrough
		 	case .WHENEVER:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITHIN:fallthrough
		 	case .WORK:fallthrough
		 	case .WRITE:fallthrough
		 	case .XML:fallthrough
		 	case .XMLAGG:fallthrough
		 	case .XMLATTRIBUTES:fallthrough
		 	case .XMLCAST:fallthrough
		 	case .XMLCOLATTVAL:fallthrough
		 	case .XMLELEMENT:fallthrough
		 	case .XMLEXISTS:fallthrough
		 	case .XMLFOREST:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .XMLPARSE:fallthrough
		 	case .XMLPI:fallthrough
		 	case .XMLQUERY:fallthrough
		 	case .XMLROOT:fallthrough
		 	case .XMLSERIALIZE:fallthrough
		 	case .XMLTABLE:fallthrough
		 	case .YEAR:fallthrough
		 	case .YES:fallthrough
		 	case .YMINTERVAL_UNCONSTRAINED:fallthrough
		 	case .ZONE:fallthrough
		 	case .PREDICTION:fallthrough
		 	case .PREDICTION_BOUNDS:fallthrough
		 	case .PREDICTION_COST:fallthrough
		 	case .PREDICTION_DETAILS:fallthrough
		 	case .PREDICTION_PROBABILITY:fallthrough
		 	case .PREDICTION_SET:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .LISTAGG:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .PERCENTILE_CONT:fallthrough
		 	case .PERCENTILE_DISC:fallthrough
		 	case .RANK:fallthrough
		 	case .AVG:fallthrough
		 	case .CORR:fallthrough
		 	case .COVAR_:fallthrough
		 	case .LAG:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MEDIAN:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .RATIO_TO_REPORT:fallthrough
		 	case .REGR_:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .TRIM:fallthrough
		 	case .SUM:fallthrough
		 	case .STDDEV:fallthrough
		 	case .VAR_:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .REGULAR_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5453)
		 		try regular_id()

		 		break

		 	case .DELIMITED_ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5454)
		 		try match(plsqlParser.Tokens.DELIMITED_ID.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Not_equal_opContext:ParserRuleContext {
		open func NOT_EQUAL_OP() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOT_EQUAL_OP.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_not_equal_op }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNot_equal_op(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNot_equal_op(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNot_equal_op(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNot_equal_op(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func not_equal_op() throws -> Not_equal_opContext {
		var _localctx: Not_equal_opContext = Not_equal_opContext(_ctx, getState())
		try enterRule(_localctx, 752, plsqlParser.RULE_not_equal_op)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5464)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NOT_EQUAL_OP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5457)
		 		try match(plsqlParser.Tokens.NOT_EQUAL_OP.rawValue)

		 		break

		 	case .LESS_THAN_OP:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5458)
		 		try match(plsqlParser.Tokens.LESS_THAN_OP.rawValue)
		 		setState(5459)
		 		try match(plsqlParser.Tokens.GREATER_THAN_OP.rawValue)

		 		break

		 	case .EXCLAMATION_OPERATOR_PART:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5460)
		 		try match(plsqlParser.Tokens.EXCLAMATION_OPERATOR_PART.rawValue)
		 		setState(5461)
		 		try match(plsqlParser.Tokens.EQUALS_OP.rawValue)

		 		break

		 	case .CARRET_OPERATOR_PART:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5462)
		 		try match(plsqlParser.Tokens.CARRET_OPERATOR_PART.rawValue)
		 		setState(5463)
		 		try match(plsqlParser.Tokens.EQUALS_OP.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Greater_than_or_equals_opContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_greater_than_or_equals_op }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterGreater_than_or_equals_op(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitGreater_than_or_equals_op(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitGreater_than_or_equals_op(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitGreater_than_or_equals_op(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func greater_than_or_equals_op() throws -> Greater_than_or_equals_opContext {
		var _localctx: Greater_than_or_equals_opContext = Greater_than_or_equals_opContext(_ctx, getState())
		try enterRule(_localctx, 754, plsqlParser.RULE_greater_than_or_equals_op)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5469)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .GREATER_THAN_OR_EQUALS_OP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5466)
		 		try match(plsqlParser.Tokens.GREATER_THAN_OR_EQUALS_OP.rawValue)

		 		break

		 	case .GREATER_THAN_OP:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5467)
		 		try match(plsqlParser.Tokens.GREATER_THAN_OP.rawValue)
		 		setState(5468)
		 		try match(plsqlParser.Tokens.EQUALS_OP.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Less_than_or_equals_opContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_less_than_or_equals_op }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterLess_than_or_equals_op(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitLess_than_or_equals_op(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitLess_than_or_equals_op(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitLess_than_or_equals_op(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func less_than_or_equals_op() throws -> Less_than_or_equals_opContext {
		var _localctx: Less_than_or_equals_opContext = Less_than_or_equals_opContext(_ctx, getState())
		try enterRule(_localctx, 756, plsqlParser.RULE_less_than_or_equals_op)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5474)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LESS_THAN_OR_EQUALS_OP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5471)
		 		try match(plsqlParser.Tokens.LESS_THAN_OR_EQUALS_OP.rawValue)

		 		break

		 	case .LESS_THAN_OP:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5472)
		 		try match(plsqlParser.Tokens.LESS_THAN_OP.rawValue)
		 		setState(5473)
		 		try match(plsqlParser.Tokens.EQUALS_OP.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Concatenation_opContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_concatenation_op }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterConcatenation_op(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitConcatenation_op(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitConcatenation_op(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitConcatenation_op(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func concatenation_op() throws -> Concatenation_opContext {
		var _localctx: Concatenation_opContext = Concatenation_opContext(_ctx, getState())
		try enterRule(_localctx, 758, plsqlParser.RULE_concatenation_op)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5479)
		 	try _errHandler.sync(self)
		 	switch (plsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CONCATENATION_OP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5476)
		 		try match(plsqlParser.Tokens.CONCATENATION_OP.rawValue)

		 		break

		 	case .VERTICAL_BAR:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5477)
		 		try match(plsqlParser.Tokens.VERTICAL_BAR.rawValue)
		 		setState(5478)
		 		try match(plsqlParser.Tokens.VERTICAL_BAR.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Outer_join_signContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_outer_join_sign }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterOuter_join_sign(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitOuter_join_sign(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitOuter_join_sign(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitOuter_join_sign(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func outer_join_sign() throws -> Outer_join_signContext {
		var _localctx: Outer_join_signContext = Outer_join_signContext(_ctx, getState())
		try enterRule(_localctx, 760, plsqlParser.RULE_outer_join_sign)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5481)
		 	try match(plsqlParser.Tokens.LEFT_PAREN.rawValue)
		 	setState(5482)
		 	try match(plsqlParser.Tokens.PLUS_SIGN.rawValue)
		 	setState(5483)
		 	try match(plsqlParser.Tokens.RIGHT_PAREN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Regular_idContext:ParserRuleContext {
		open func REGULAR_ID() -> TerminalNode? { return getToken(plsqlParser.Tokens.REGULAR_ID.rawValue, 0) }
		open func A_LETTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.A_LETTER.rawValue, 0) }
		open func ADD() -> TerminalNode? { return getToken(plsqlParser.Tokens.ADD.rawValue, 0) }
		open func AFTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.AFTER.rawValue, 0) }
		open func AGENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.AGENT.rawValue, 0) }
		open func AGGREGATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.AGGREGATE.rawValue, 0) }
		open func ANALYZE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ANALYZE.rawValue, 0) }
		open func ARRAY() -> TerminalNode? { return getToken(plsqlParser.Tokens.ARRAY.rawValue, 0) }
		open func ASSOCIATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ASSOCIATE.rawValue, 0) }
		open func AT() -> TerminalNode? { return getToken(plsqlParser.Tokens.AT.rawValue, 0) }
		open func ATTRIBUTE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ATTRIBUTE.rawValue, 0) }
		open func AUDIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.AUDIT.rawValue, 0) }
		open func AUTHID() -> TerminalNode? { return getToken(plsqlParser.Tokens.AUTHID.rawValue, 0) }
		open func AUTO() -> TerminalNode? { return getToken(plsqlParser.Tokens.AUTO.rawValue, 0) }
		open func AUTOMATIC() -> TerminalNode? { return getToken(plsqlParser.Tokens.AUTOMATIC.rawValue, 0) }
		open func AUTONOMOUS_TRANSACTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue, 0) }
		open func BATCH() -> TerminalNode? { return getToken(plsqlParser.Tokens.BATCH.rawValue, 0) }
		open func BEFORE() -> TerminalNode? { return getToken(plsqlParser.Tokens.BEFORE.rawValue, 0) }
		open func BFILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.BFILE.rawValue, 0) }
		open func BINARY_DOUBLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.BINARY_DOUBLE.rawValue, 0) }
		open func BINARY_FLOAT() -> TerminalNode? { return getToken(plsqlParser.Tokens.BINARY_FLOAT.rawValue, 0) }
		open func BINARY_INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.BINARY_INTEGER.rawValue, 0) }
		open func BLOB() -> TerminalNode? { return getToken(plsqlParser.Tokens.BLOB.rawValue, 0) }
		open func BLOCK() -> TerminalNode? { return getToken(plsqlParser.Tokens.BLOCK.rawValue, 0) }
		open func BODY() -> TerminalNode? { return getToken(plsqlParser.Tokens.BODY.rawValue, 0) }
		open func BOOLEAN() -> TerminalNode? { return getToken(plsqlParser.Tokens.BOOLEAN.rawValue, 0) }
		open func BOTH() -> TerminalNode? { return getToken(plsqlParser.Tokens.BOTH.rawValue, 0) }
		open func BULK() -> TerminalNode? { return getToken(plsqlParser.Tokens.BULK.rawValue, 0) }
		open func BYTE() -> TerminalNode? { return getToken(plsqlParser.Tokens.BYTE.rawValue, 0) }
		open func C_LETTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.C_LETTER.rawValue, 0) }
		open func CALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.CALL.rawValue, 0) }
		open func CANONICAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.CANONICAL.rawValue, 0) }
		open func CASCADE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CASCADE.rawValue, 0) }
		open func CAST() -> TerminalNode? { return getToken(plsqlParser.Tokens.CAST.rawValue, 0) }
		open func CHAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHAR.rawValue, 0) }
		open func CHAR_CS() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHAR_CS.rawValue, 0) }
		open func CHARACTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHARACTER.rawValue, 0) }
		open func CHR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHR.rawValue, 0) }
		open func CLOB() -> TerminalNode? { return getToken(plsqlParser.Tokens.CLOB.rawValue, 0) }
		open func CLOSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CLOSE.rawValue, 0) }
		open func CLUSTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.CLUSTER.rawValue, 0) }
		open func COLLECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COLLECT.rawValue, 0) }
		open func COLUMNS() -> TerminalNode? { return getToken(plsqlParser.Tokens.COLUMNS.rawValue, 0) }
		open func COMMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMMENT.rawValue, 0) }
		open func COMMIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMMIT.rawValue, 0) }
		open func COMMITTED() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMMITTED.rawValue, 0) }
		open func COMPATIBILITY() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMPATIBILITY.rawValue, 0) }
		open func COMPILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMPILE.rawValue, 0) }
		open func COMPOUND() -> TerminalNode? { return getToken(plsqlParser.Tokens.COMPOUND.rawValue, 0) }
		open func CONSTANT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONSTANT.rawValue, 0) }
		open func CONSTRAINT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONSTRAINT.rawValue, 0) }
		open func CONSTRAINTS() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONSTRAINTS.rawValue, 0) }
		open func CONSTRUCTOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONSTRUCTOR.rawValue, 0) }
		open func CONTENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONTENT.rawValue, 0) }
		open func CONTEXT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONTEXT.rawValue, 0) }
		open func CONTINUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONTINUE.rawValue, 0) }
		open func CONVERT() -> TerminalNode? { return getToken(plsqlParser.Tokens.CONVERT.rawValue, 0) }
		open func CORRUPT_XID() -> TerminalNode? { return getToken(plsqlParser.Tokens.CORRUPT_XID.rawValue, 0) }
		open func CORRUPT_XID_ALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue, 0) }
		open func COST() -> TerminalNode? { return getToken(plsqlParser.Tokens.COST.rawValue, 0) }
		open func COUNT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COUNT.rawValue, 0) }
		open func CROSS() -> TerminalNode? { return getToken(plsqlParser.Tokens.CROSS.rawValue, 0) }
		open func CUBE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CUBE.rawValue, 0) }
		open func CURRENT_USER() -> TerminalNode? { return getToken(plsqlParser.Tokens.CURRENT_USER.rawValue, 0) }
		open func CURSOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CURSOR.rawValue, 0) }
		open func CUSTOMDATUM() -> TerminalNode? { return getToken(plsqlParser.Tokens.CUSTOMDATUM.rawValue, 0) }
		open func CYCLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.CYCLE.rawValue, 0) }
		open func DATA() -> TerminalNode? { return getToken(plsqlParser.Tokens.DATA.rawValue, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DATABASE.rawValue, 0) }
		open func DAY() -> TerminalNode? { return getToken(plsqlParser.Tokens.DAY.rawValue, 0) }
		open func DB_ROLE_CHANGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue, 0) }
		open func DBTIMEZONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DBTIMEZONE.rawValue, 0) }
		open func DDL() -> TerminalNode? { return getToken(plsqlParser.Tokens.DDL.rawValue, 0) }
		open func DEBUG() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEBUG.rawValue, 0) }
		open func DEC() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEC.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func DECOMPOSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECOMPOSE.rawValue, 0) }
		open func DECREMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECREMENT.rawValue, 0) }
		open func DEFAULTS() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFAULTS.rawValue, 0) }
		open func DEFERRED() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFERRED.rawValue, 0) }
		open func DEFINER() -> TerminalNode? { return getToken(plsqlParser.Tokens.DEFINER.rawValue, 0) }
		open func DETERMINISTIC() -> TerminalNode? { return getToken(plsqlParser.Tokens.DETERMINISTIC.rawValue, 0) }
		open func DIMENSION() -> TerminalNode? { return getToken(plsqlParser.Tokens.DIMENSION.rawValue, 0) }
		open func DISABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DISABLE.rawValue, 0) }
		open func DISASSOCIATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DISASSOCIATE.rawValue, 0) }
		open func DOCUMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.DOCUMENT.rawValue, 0) }
		open func DOUBLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DOUBLE.rawValue, 0) }
		open func DSINTERVAL_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue, 0) }
		open func EACH() -> TerminalNode? { return getToken(plsqlParser.Tokens.EACH.rawValue, 0) }
		open func ELEMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.ELEMENT.rawValue, 0) }
		open func EMPTY() -> TerminalNode? { return getToken(plsqlParser.Tokens.EMPTY.rawValue, 0) }
		open func ENABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ENABLE.rawValue, 0) }
		open func ENCODING() -> TerminalNode? { return getToken(plsqlParser.Tokens.ENCODING.rawValue, 0) }
		open func ENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.Tokens.ENTITYESCAPING.rawValue, 0) }
		open func ERR() -> TerminalNode? { return getToken(plsqlParser.Tokens.ERR.rawValue, 0) }
		open func ERRORS() -> TerminalNode? { return getToken(plsqlParser.Tokens.ERRORS.rawValue, 0) }
		open func ESCAPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ESCAPE.rawValue, 0) }
		open func EVALNAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.EVALNAME.rawValue, 0) }
		open func EXCEPTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXCEPTION.rawValue, 0) }
		open func EXCEPTION_INIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXCEPTION_INIT.rawValue, 0) }
		open func EXCEPTIONS() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXCEPTIONS.rawValue, 0) }
		open func EXCLUDE() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXCLUDE.rawValue, 0) }
		open func EXECUTE() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXECUTE.rawValue, 0) }
		open func EXIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXIT.rawValue, 0) }
		open func EXPLAIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXPLAIN.rawValue, 0) }
		open func EXTERNAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXTERNAL.rawValue, 0) }
		open func EXTRACT() -> TerminalNode? { return getToken(plsqlParser.Tokens.EXTRACT.rawValue, 0) }
		open func FAILURE() -> TerminalNode? { return getToken(plsqlParser.Tokens.FAILURE.rawValue, 0) }
		open func FINAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.FINAL.rawValue, 0) }
		open func FIRST() -> TerminalNode? { return getToken(plsqlParser.Tokens.FIRST.rawValue, 0) }
		open func FIRST_VALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.FIRST_VALUE.rawValue, 0) }
		open func FLOAT() -> TerminalNode? { return getToken(plsqlParser.Tokens.FLOAT.rawValue, 0) }
		open func FOLLOWING() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOLLOWING.rawValue, 0) }
		open func FOLLOWS() -> TerminalNode? { return getToken(plsqlParser.Tokens.FOLLOWS.rawValue, 0) }
		open func FORALL() -> TerminalNode? { return getToken(plsqlParser.Tokens.FORALL.rawValue, 0) }
		open func FORCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.FORCE.rawValue, 0) }
		open func FULL() -> TerminalNode? { return getToken(plsqlParser.Tokens.FULL.rawValue, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func GROUPING() -> TerminalNode? { return getToken(plsqlParser.Tokens.GROUPING.rawValue, 0) }
		open func HASH() -> TerminalNode? { return getToken(plsqlParser.Tokens.HASH.rawValue, 0) }
		open func HIDE() -> TerminalNode? { return getToken(plsqlParser.Tokens.HIDE.rawValue, 0) }
		open func HOUR() -> TerminalNode? { return getToken(plsqlParser.Tokens.HOUR.rawValue, 0) }
		open func IGNORE() -> TerminalNode? { return getToken(plsqlParser.Tokens.IGNORE.rawValue, 0) }
		open func IMMEDIATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.IMMEDIATE.rawValue, 0) }
		open func INCLUDE() -> TerminalNode? { return getToken(plsqlParser.Tokens.INCLUDE.rawValue, 0) }
		open func INCLUDING() -> TerminalNode? { return getToken(plsqlParser.Tokens.INCLUDING.rawValue, 0) }
		open func INCREMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INCREMENT.rawValue, 0) }
		open func INDENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INDENT.rawValue, 0) }
		open func INDEXED() -> TerminalNode? { return getToken(plsqlParser.Tokens.INDEXED.rawValue, 0) }
		open func INDICATOR() -> TerminalNode? { return getToken(plsqlParser.Tokens.INDICATOR.rawValue, 0) }
		open func INDICES() -> TerminalNode? { return getToken(plsqlParser.Tokens.INDICES.rawValue, 0) }
		open func INFINITE() -> TerminalNode? { return getToken(plsqlParser.Tokens.INFINITE.rawValue, 0) }
		open func INLINE() -> TerminalNode? { return getToken(plsqlParser.Tokens.INLINE.rawValue, 0) }
		open func INNER() -> TerminalNode? { return getToken(plsqlParser.Tokens.INNER.rawValue, 0) }
		open func INOUT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INOUT.rawValue, 0) }
		open func INSTANTIABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.INSTANTIABLE.rawValue, 0) }
		open func INSTEAD() -> TerminalNode? { return getToken(plsqlParser.Tokens.INSTEAD.rawValue, 0) }
		open func INT() -> TerminalNode? { return getToken(plsqlParser.Tokens.INT.rawValue, 0) }
		open func INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTEGER.rawValue, 0) }
		open func INTERVAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.INTERVAL.rawValue, 0) }
		open func INVALIDATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.INVALIDATE.rawValue, 0) }
		open func ISOLATION() -> TerminalNode? { return getToken(plsqlParser.Tokens.ISOLATION.rawValue, 0) }
		open func ITERATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ITERATE.rawValue, 0) }
		open func JAVA() -> TerminalNode? { return getToken(plsqlParser.Tokens.JAVA.rawValue, 0) }
		open func JOIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.JOIN.rawValue, 0) }
		open func KEEP() -> TerminalNode? { return getToken(plsqlParser.Tokens.KEEP.rawValue, 0) }
		open func LANGUAGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.LANGUAGE.rawValue, 0) }
		open func LAST() -> TerminalNode? { return getToken(plsqlParser.Tokens.LAST.rawValue, 0) }
		open func LAST_VALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.LAST_VALUE.rawValue, 0) }
		open func LEADING() -> TerminalNode? { return getToken(plsqlParser.Tokens.LEADING.rawValue, 0) }
		open func LEFT() -> TerminalNode? { return getToken(plsqlParser.Tokens.LEFT.rawValue, 0) }
		open func LEVEL() -> TerminalNode? { return getToken(plsqlParser.Tokens.LEVEL.rawValue, 0) }
		open func LIBRARY() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIBRARY.rawValue, 0) }
		open func LIKE2() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIKE2.rawValue, 0) }
		open func LIKE4() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIKE4.rawValue, 0) }
		open func LIKEC() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIKEC.rawValue, 0) }
		open func LIMIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.LIMIT.rawValue, 0) }
		open func LOCAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOCAL.rawValue, 0) }
		open func LOCKED() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOCKED.rawValue, 0) }
		open func LOG() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOG.rawValue, 0) }
		open func LOGOFF() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOGOFF.rawValue, 0) }
		open func LOGON() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOGON.rawValue, 0) }
		open func LONG() -> TerminalNode? { return getToken(plsqlParser.Tokens.LONG.rawValue, 0) }
		open func LOOP() -> TerminalNode? { return getToken(plsqlParser.Tokens.LOOP.rawValue, 0) }
		open func MAIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.MAIN.rawValue, 0) }
		open func MAP() -> TerminalNode? { return getToken(plsqlParser.Tokens.MAP.rawValue, 0) }
		open func MATCHED() -> TerminalNode? { return getToken(plsqlParser.Tokens.MATCHED.rawValue, 0) }
		open func MAXVALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.MAXVALUE.rawValue, 0) }
		open func MEASURES() -> TerminalNode? { return getToken(plsqlParser.Tokens.MEASURES.rawValue, 0) }
		open func MEMBER() -> TerminalNode? { return getToken(plsqlParser.Tokens.MEMBER.rawValue, 0) }
		open func MERGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.MERGE.rawValue, 0) }
		open func MINUTE() -> TerminalNode? { return getToken(plsqlParser.Tokens.MINUTE.rawValue, 0) }
		open func MINVALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.MINVALUE.rawValue, 0) }
		open func MLSLABEL() -> TerminalNode? { return getToken(plsqlParser.Tokens.MLSLABEL.rawValue, 0) }
		open func MODEL() -> TerminalNode? { return getToken(plsqlParser.Tokens.MODEL.rawValue, 0) }
		open func MODIFY() -> TerminalNode? { return getToken(plsqlParser.Tokens.MODIFY.rawValue, 0) }
		open func MONTH() -> TerminalNode? { return getToken(plsqlParser.Tokens.MONTH.rawValue, 0) }
		open func MULTISET() -> TerminalNode? { return getToken(plsqlParser.Tokens.MULTISET.rawValue, 0) }
		open func NAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.NAME.rawValue, 0) }
		open func NAN() -> TerminalNode? { return getToken(plsqlParser.Tokens.NAN.rawValue, 0) }
		open func NATURAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NATURAL.rawValue, 0) }
		open func NATURALN() -> TerminalNode? { return getToken(plsqlParser.Tokens.NATURALN.rawValue, 0) }
		open func NAV() -> TerminalNode? { return getToken(plsqlParser.Tokens.NAV.rawValue, 0) }
		open func NCHAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.NCHAR.rawValue, 0) }
		open func NCHAR_CS() -> TerminalNode? { return getToken(plsqlParser.Tokens.NCHAR_CS.rawValue, 0) }
		open func NCLOB() -> TerminalNode? { return getToken(plsqlParser.Tokens.NCLOB.rawValue, 0) }
		open func NESTED() -> TerminalNode? { return getToken(plsqlParser.Tokens.NESTED.rawValue, 0) }
		open func NEW() -> TerminalNode? { return getToken(plsqlParser.Tokens.NEW.rawValue, 0) }
		open func NO() -> TerminalNode? { return getToken(plsqlParser.Tokens.NO.rawValue, 0) }
		open func NOAUDIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOAUDIT.rawValue, 0) }
		open func NOCOPY() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOCOPY.rawValue, 0) }
		open func NOCYCLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOCYCLE.rawValue, 0) }
		open func NOENTITYESCAPING() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOENTITYESCAPING.rawValue, 0) }
		open func NONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.NONE.rawValue, 0) }
		open func NOSCHEMACHECK() -> TerminalNode? { return getToken(plsqlParser.Tokens.NOSCHEMACHECK.rawValue, 0) }
		open func NULLS() -> TerminalNode? { return getToken(plsqlParser.Tokens.NULLS.rawValue, 0) }
		open func NUMBER() -> TerminalNode? { return getToken(plsqlParser.Tokens.NUMBER.rawValue, 0) }
		open func NUMERIC() -> TerminalNode? { return getToken(plsqlParser.Tokens.NUMERIC.rawValue, 0) }
		open func NVARCHAR2() -> TerminalNode? { return getToken(plsqlParser.Tokens.NVARCHAR2.rawValue, 0) }
		open func OBJECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.OBJECT.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(plsqlParser.Tokens.OFF.rawValue, 0) }
		open func OID() -> TerminalNode? { return getToken(plsqlParser.Tokens.OID.rawValue, 0) }
		open func OLD() -> TerminalNode? { return getToken(plsqlParser.Tokens.OLD.rawValue, 0) }
		open func ONLY() -> TerminalNode? { return getToken(plsqlParser.Tokens.ONLY.rawValue, 0) }
		open func OPEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.OPEN.rawValue, 0) }
		open func ORADATA() -> TerminalNode? { return getToken(plsqlParser.Tokens.ORADATA.rawValue, 0) }
		open func ORDINALITY() -> TerminalNode? { return getToken(plsqlParser.Tokens.ORDINALITY.rawValue, 0) }
		open func OSERROR() -> TerminalNode? { return getToken(plsqlParser.Tokens.OSERROR.rawValue, 0) }
		open func OUT() -> TerminalNode? { return getToken(plsqlParser.Tokens.OUT.rawValue, 0) }
		open func OUTER() -> TerminalNode? { return getToken(plsqlParser.Tokens.OUTER.rawValue, 0) }
		open func OVER() -> TerminalNode? { return getToken(plsqlParser.Tokens.OVER.rawValue, 0) }
		open func OVERRIDING() -> TerminalNode? { return getToken(plsqlParser.Tokens.OVERRIDING.rawValue, 0) }
		open func PACKAGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PACKAGE.rawValue, 0) }
		open func PARALLEL_ENABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.PARALLEL_ENABLE.rawValue, 0) }
		open func PARAMETERS() -> TerminalNode? { return getToken(plsqlParser.Tokens.PARAMETERS.rawValue, 0) }
		open func PARENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.PARENT.rawValue, 0) }
		open func PARTITION() -> TerminalNode? { return getToken(plsqlParser.Tokens.PARTITION.rawValue, 0) }
		open func PASSING() -> TerminalNode? { return getToken(plsqlParser.Tokens.PASSING.rawValue, 0) }
		open func PATH() -> TerminalNode? { return getToken(plsqlParser.Tokens.PATH.rawValue, 0) }
		open func PIPELINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.PIPELINED.rawValue, 0) }
		open func PLAN() -> TerminalNode? { return getToken(plsqlParser.Tokens.PLAN.rawValue, 0) }
		open func PLS_INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.PLS_INTEGER.rawValue, 0) }
		open func POSITIVE() -> TerminalNode? { return getToken(plsqlParser.Tokens.POSITIVE.rawValue, 0) }
		open func POSITIVEN() -> TerminalNode? { return getToken(plsqlParser.Tokens.POSITIVEN.rawValue, 0) }
		open func PRAGMA() -> TerminalNode? { return getToken(plsqlParser.Tokens.PRAGMA.rawValue, 0) }
		open func PRECEDING() -> TerminalNode? { return getToken(plsqlParser.Tokens.PRECEDING.rawValue, 0) }
		open func PRECISION() -> TerminalNode? { return getToken(plsqlParser.Tokens.PRECISION.rawValue, 0) }
		open func PRESENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.PRESENT.rawValue, 0) }
		open func RAISE() -> TerminalNode? { return getToken(plsqlParser.Tokens.RAISE.rawValue, 0) }
		open func RANGE() -> TerminalNode? { return getToken(plsqlParser.Tokens.RANGE.rawValue, 0) }
		open func RAW() -> TerminalNode? { return getToken(plsqlParser.Tokens.RAW.rawValue, 0) }
		open func READ() -> TerminalNode? { return getToken(plsqlParser.Tokens.READ.rawValue, 0) }
		open func REAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.REAL.rawValue, 0) }
		open func RECORD() -> TerminalNode? { return getToken(plsqlParser.Tokens.RECORD.rawValue, 0) }
		open func REF() -> TerminalNode? { return getToken(plsqlParser.Tokens.REF.rawValue, 0) }
		open func REFERENCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REFERENCE.rawValue, 0) }
		open func REFERENCING() -> TerminalNode? { return getToken(plsqlParser.Tokens.REFERENCING.rawValue, 0) }
		open func REJECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.REJECT.rawValue, 0) }
		open func RELIES_ON() -> TerminalNode? { return getToken(plsqlParser.Tokens.RELIES_ON.rawValue, 0) }
		open func RENAME() -> TerminalNode? { return getToken(plsqlParser.Tokens.RENAME.rawValue, 0) }
		open func REPLACE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REPLACE.rawValue, 0) }
		open func RESPECT() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESPECT.rawValue, 0) }
		open func RESTRICT_REFERENCES() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue, 0) }
		open func RESULT() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESULT.rawValue, 0) }
		open func RESULT_CACHE() -> TerminalNode? { return getToken(plsqlParser.Tokens.RESULT_CACHE.rawValue, 0) }
		open func RETURN() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURN.rawValue, 0) }
		open func RETURNING() -> TerminalNode? { return getToken(plsqlParser.Tokens.RETURNING.rawValue, 0) }
		open func REUSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REUSE.rawValue, 0) }
		open func REVERSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.REVERSE.rawValue, 0) }
		open func RIGHT() -> TerminalNode? { return getToken(plsqlParser.Tokens.RIGHT.rawValue, 0) }
		open func ROLLBACK() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROLLBACK.rawValue, 0) }
		open func ROLLUP() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROLLUP.rawValue, 0) }
		open func ROW() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROW.rawValue, 0) }
		open func ROWID() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROWID.rawValue, 0) }
		open func ROWS() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROWS.rawValue, 0) }
		open func RULES() -> TerminalNode? { return getToken(plsqlParser.Tokens.RULES.rawValue, 0) }
		open func SAMPLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SAMPLE.rawValue, 0) }
		open func SAVE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SAVE.rawValue, 0) }
		open func SAVEPOINT() -> TerminalNode? { return getToken(plsqlParser.Tokens.SAVEPOINT.rawValue, 0) }
		open func SCHEMA() -> TerminalNode? { return getToken(plsqlParser.Tokens.SCHEMA.rawValue, 0) }
		open func SCHEMACHECK() -> TerminalNode? { return getToken(plsqlParser.Tokens.SCHEMACHECK.rawValue, 0) }
		open func SCN() -> TerminalNode? { return getToken(plsqlParser.Tokens.SCN.rawValue, 0) }
		open func SECOND() -> TerminalNode? { return getToken(plsqlParser.Tokens.SECOND.rawValue, 0) }
		open func SEED() -> TerminalNode? { return getToken(plsqlParser.Tokens.SEED.rawValue, 0) }
		open func SEGMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.SEGMENT.rawValue, 0) }
		open func SELF() -> TerminalNode? { return getToken(plsqlParser.Tokens.SELF.rawValue, 0) }
		open func SEQUENTIAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.SEQUENTIAL.rawValue, 0) }
		open func SERIALIZABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SERIALIZABLE.rawValue, 0) }
		open func SERIALLY_REUSABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue, 0) }
		open func SERVERERROR() -> TerminalNode? { return getToken(plsqlParser.Tokens.SERVERERROR.rawValue, 0) }
		open func SESSIONTIMEZONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SESSIONTIMEZONE.rawValue, 0) }
		open func SET() -> TerminalNode? { return getToken(plsqlParser.Tokens.SET.rawValue, 0) }
		open func SETS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SETS.rawValue, 0) }
		open func SETTINGS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SETTINGS.rawValue, 0) }
		open func SHOW() -> TerminalNode? { return getToken(plsqlParser.Tokens.SHOW.rawValue, 0) }
		open func SHUTDOWN() -> TerminalNode? { return getToken(plsqlParser.Tokens.SHUTDOWN.rawValue, 0) }
		open func SIBLINGS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SIBLINGS.rawValue, 0) }
		open func SIGNTYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SIGNTYPE.rawValue, 0) }
		open func SIMPLE_INTEGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.SIMPLE_INTEGER.rawValue, 0) }
		open func SINGLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SINGLE.rawValue, 0) }
		open func SKIP_() -> TerminalNode? { return getToken(plsqlParser.Tokens.SKIP_.rawValue, 0) }
		open func SMALLINT() -> TerminalNode? { return getToken(plsqlParser.Tokens.SMALLINT.rawValue, 0) }
		open func SNAPSHOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.SNAPSHOT.rawValue, 0) }
		open func SOME() -> TerminalNode? { return getToken(plsqlParser.Tokens.SOME.rawValue, 0) }
		open func SPECIFICATION() -> TerminalNode? { return getToken(plsqlParser.Tokens.SPECIFICATION.rawValue, 0) }
		open func SQLDATA() -> TerminalNode? { return getToken(plsqlParser.Tokens.SQLDATA.rawValue, 0) }
		open func SQLERROR() -> TerminalNode? { return getToken(plsqlParser.Tokens.SQLERROR.rawValue, 0) }
		open func STANDALONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.STANDALONE.rawValue, 0) }
		open func STARTUP() -> TerminalNode? { return getToken(plsqlParser.Tokens.STARTUP.rawValue, 0) }
		open func STATEMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.STATEMENT.rawValue, 0) }
		open func STATEMENT_ID() -> TerminalNode? { return getToken(plsqlParser.Tokens.STATEMENT_ID.rawValue, 0) }
		open func STATIC() -> TerminalNode? { return getToken(plsqlParser.Tokens.STATIC.rawValue, 0) }
		open func STATISTICS() -> TerminalNode? { return getToken(plsqlParser.Tokens.STATISTICS.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(plsqlParser.Tokens.STRING.rawValue, 0) }
		open func SUBMULTISET() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUBMULTISET.rawValue, 0) }
		open func SUBPARTITION() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUBPARTITION.rawValue, 0) }
		open func SUBSTITUTABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUBSTITUTABLE.rawValue, 0) }
		open func SUBTYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUBTYPE.rawValue, 0) }
		open func SUCCESS() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUCCESS.rawValue, 0) }
		open func SUSPEND() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUSPEND.rawValue, 0) }
		open func TIME() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIME.rawValue, 0) }
		open func TIMESTAMP() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMESTAMP.rawValue, 0) }
		open func TIMESTAMP_LTZ_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue, 0) }
		open func TIMESTAMP_TZ_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue, 0) }
		open func TIMESTAMP_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue, 0) }
		open func TIMEZONE_ABBR() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMEZONE_ABBR.rawValue, 0) }
		open func TIMEZONE_HOUR() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMEZONE_HOUR.rawValue, 0) }
		open func TIMEZONE_MINUTE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue, 0) }
		open func TIMEZONE_REGION() -> TerminalNode? { return getToken(plsqlParser.Tokens.TIMEZONE_REGION.rawValue, 0) }
		open func TRAILING() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRAILING.rawValue, 0) }
		open func TRANSACTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRANSACTION.rawValue, 0) }
		open func TRANSLATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRANSLATE.rawValue, 0) }
		open func TREAT() -> TerminalNode? { return getToken(plsqlParser.Tokens.TREAT.rawValue, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRIGGER.rawValue, 0) }
		open func TRIM() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRIM.rawValue, 0) }
		open func TRUNCATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRUNCATE.rawValue, 0) }
		open func TYPE() -> TerminalNode? { return getToken(plsqlParser.Tokens.TYPE.rawValue, 0) }
		open func UNBOUNDED() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNBOUNDED.rawValue, 0) }
		open func UNDER() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNDER.rawValue, 0) }
		open func UNLIMITED() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNLIMITED.rawValue, 0) }
		open func UNTIL() -> TerminalNode? { return getToken(plsqlParser.Tokens.UNTIL.rawValue, 0) }
		open func UPDATED() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPDATED.rawValue, 0) }
		open func UPSERT() -> TerminalNode? { return getToken(plsqlParser.Tokens.UPSERT.rawValue, 0) }
		open func UROWID() -> TerminalNode? { return getToken(plsqlParser.Tokens.UROWID.rawValue, 0) }
		open func USE() -> TerminalNode? { return getToken(plsqlParser.Tokens.USE.rawValue, 0) }
		open func VALIDATE() -> TerminalNode? { return getToken(plsqlParser.Tokens.VALIDATE.rawValue, 0) }
		open func VALUE() -> TerminalNode? { return getToken(plsqlParser.Tokens.VALUE.rawValue, 0) }
		open func VARCHAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARCHAR.rawValue, 0) }
		open func VARCHAR2() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARCHAR2.rawValue, 0) }
		open func VARIABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARIABLE.rawValue, 0) }
		open func VARRAY() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARRAY.rawValue, 0) }
		open func VARYING() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARYING.rawValue, 0) }
		open func VERSION() -> TerminalNode? { return getToken(plsqlParser.Tokens.VERSION.rawValue, 0) }
		open func VERSIONS() -> TerminalNode? { return getToken(plsqlParser.Tokens.VERSIONS.rawValue, 0) }
		open func WAIT() -> TerminalNode? { return getToken(plsqlParser.Tokens.WAIT.rawValue, 0) }
		open func WARNING() -> TerminalNode? { return getToken(plsqlParser.Tokens.WARNING.rawValue, 0) }
		open func WELLFORMED() -> TerminalNode? { return getToken(plsqlParser.Tokens.WELLFORMED.rawValue, 0) }
		open func WHENEVER() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHENEVER.rawValue, 0) }
		open func WHILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.WHILE.rawValue, 0) }
		open func WITHIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.WITHIN.rawValue, 0) }
		open func WORK() -> TerminalNode? { return getToken(plsqlParser.Tokens.WORK.rawValue, 0) }
		open func WRITE() -> TerminalNode? { return getToken(plsqlParser.Tokens.WRITE.rawValue, 0) }
		open func XML() -> TerminalNode? { return getToken(plsqlParser.Tokens.XML.rawValue, 0) }
		open func XMLAGG() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLAGG.rawValue, 0) }
		open func XMLATTRIBUTES() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLATTRIBUTES.rawValue, 0) }
		open func XMLCAST() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLCAST.rawValue, 0) }
		open func XMLCOLATTVAL() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLCOLATTVAL.rawValue, 0) }
		open func XMLELEMENT() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLELEMENT.rawValue, 0) }
		open func XMLEXISTS() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLEXISTS.rawValue, 0) }
		open func XMLFOREST() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLFOREST.rawValue, 0) }
		open func XMLNAMESPACES() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLNAMESPACES.rawValue, 0) }
		open func XMLPARSE() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLPARSE.rawValue, 0) }
		open func XMLPI() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLPI.rawValue, 0) }
		open func XMLQUERY() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLQUERY.rawValue, 0) }
		open func XMLROOT() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLROOT.rawValue, 0) }
		open func XMLSERIALIZE() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLSERIALIZE.rawValue, 0) }
		open func XMLTABLE() -> TerminalNode? { return getToken(plsqlParser.Tokens.XMLTABLE.rawValue, 0) }
		open func YEAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.YEAR.rawValue, 0) }
		open func YES() -> TerminalNode? { return getToken(plsqlParser.Tokens.YES.rawValue, 0) }
		open func YMINTERVAL_UNCONSTRAINED() -> TerminalNode? { return getToken(plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue, 0) }
		open func ZONE() -> TerminalNode? { return getToken(plsqlParser.Tokens.ZONE.rawValue, 0) }
		open func PREDICTION() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION.rawValue, 0) }
		open func PREDICTION_BOUNDS() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue, 0) }
		open func PREDICTION_COST() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION_COST.rawValue, 0) }
		open func PREDICTION_DETAILS() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION_DETAILS.rawValue, 0) }
		open func PREDICTION_PROBABILITY() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue, 0) }
		open func PREDICTION_SET() -> TerminalNode? { return getToken(plsqlParser.Tokens.PREDICTION_SET.rawValue, 0) }
		open func CUME_DIST() -> TerminalNode? { return getToken(plsqlParser.Tokens.CUME_DIST.rawValue, 0) }
		open func DENSE_RANK() -> TerminalNode? { return getToken(plsqlParser.Tokens.DENSE_RANK.rawValue, 0) }
		open func LISTAGG() -> TerminalNode? { return getToken(plsqlParser.Tokens.LISTAGG.rawValue, 0) }
		open func PERCENT_RANK() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENT_RANK.rawValue, 0) }
		open func PERCENTILE_CONT() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENTILE_CONT.rawValue, 0) }
		open func PERCENTILE_DISC() -> TerminalNode? { return getToken(plsqlParser.Tokens.PERCENTILE_DISC.rawValue, 0) }
		open func RANK() -> TerminalNode? { return getToken(plsqlParser.Tokens.RANK.rawValue, 0) }
		open func AVG() -> TerminalNode? { return getToken(plsqlParser.Tokens.AVG.rawValue, 0) }
		open func CORR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CORR.rawValue, 0) }
		open func LAG() -> TerminalNode? { return getToken(plsqlParser.Tokens.LAG.rawValue, 0) }
		open func LEAD() -> TerminalNode? { return getToken(plsqlParser.Tokens.LEAD.rawValue, 0) }
		open func MAX() -> TerminalNode? { return getToken(plsqlParser.Tokens.MAX.rawValue, 0) }
		open func MEDIAN() -> TerminalNode? { return getToken(plsqlParser.Tokens.MEDIAN.rawValue, 0) }
		open func MIN() -> TerminalNode? { return getToken(plsqlParser.Tokens.MIN.rawValue, 0) }
		open func NTILE() -> TerminalNode? { return getToken(plsqlParser.Tokens.NTILE.rawValue, 0) }
		open func RATIO_TO_REPORT() -> TerminalNode? { return getToken(plsqlParser.Tokens.RATIO_TO_REPORT.rawValue, 0) }
		open func ROW_NUMBER() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROW_NUMBER.rawValue, 0) }
		open func SUM() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUM.rawValue, 0) }
		open func VARIANCE() -> TerminalNode? { return getToken(plsqlParser.Tokens.VARIANCE.rawValue, 0) }
		open func REGR_() -> TerminalNode? { return getToken(plsqlParser.Tokens.REGR_.rawValue, 0) }
		open func STDDEV() -> TerminalNode? { return getToken(plsqlParser.Tokens.STDDEV.rawValue, 0) }
		open func VAR_() -> TerminalNode? { return getToken(plsqlParser.Tokens.VAR_.rawValue, 0) }
		open func COVAR_() -> TerminalNode? { return getToken(plsqlParser.Tokens.COVAR_.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_regular_id }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterRegular_id(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitRegular_id(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitRegular_id(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitRegular_id(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func regular_id() throws -> Regular_idContext {
		var _localctx: Regular_idContext = Regular_idContext(_ctx, getState())
		try enterRule(_localctx, 762, plsqlParser.RULE_regular_id)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5485)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, plsqlParser.Tokens.A_LETTER.rawValue,plsqlParser.Tokens.ADD.rawValue,plsqlParser.Tokens.AFTER.rawValue,plsqlParser.Tokens.AGENT.rawValue,plsqlParser.Tokens.AGGREGATE.rawValue,plsqlParser.Tokens.ANALYZE.rawValue,plsqlParser.Tokens.ARRAY.rawValue,plsqlParser.Tokens.ASSOCIATE.rawValue,plsqlParser.Tokens.AT.rawValue,plsqlParser.Tokens.ATTRIBUTE.rawValue,plsqlParser.Tokens.AUDIT.rawValue,plsqlParser.Tokens.AUTHID.rawValue,plsqlParser.Tokens.AUTO.rawValue,plsqlParser.Tokens.AUTOMATIC.rawValue,plsqlParser.Tokens.AUTONOMOUS_TRANSACTION.rawValue,plsqlParser.Tokens.BATCH.rawValue,plsqlParser.Tokens.BEFORE.rawValue,plsqlParser.Tokens.BFILE.rawValue,plsqlParser.Tokens.BINARY_DOUBLE.rawValue,plsqlParser.Tokens.BINARY_FLOAT.rawValue,plsqlParser.Tokens.BINARY_INTEGER.rawValue,plsqlParser.Tokens.BLOB.rawValue,plsqlParser.Tokens.BLOCK.rawValue,plsqlParser.Tokens.BODY.rawValue,plsqlParser.Tokens.BOOLEAN.rawValue,plsqlParser.Tokens.BOTH.rawValue,plsqlParser.Tokens.BULK.rawValue,plsqlParser.Tokens.BYTE.rawValue,plsqlParser.Tokens.C_LETTER.rawValue,plsqlParser.Tokens.CALL.rawValue,plsqlParser.Tokens.CANONICAL.rawValue,plsqlParser.Tokens.CASCADE.rawValue,plsqlParser.Tokens.CAST.rawValue,plsqlParser.Tokens.CHAR.rawValue,plsqlParser.Tokens.CHAR_CS.rawValue,plsqlParser.Tokens.CHARACTER.rawValue,plsqlParser.Tokens.CHR.rawValue,plsqlParser.Tokens.CLOB.rawValue,plsqlParser.Tokens.CLOSE.rawValue,plsqlParser.Tokens.CLUSTER.rawValue,plsqlParser.Tokens.COLLECT.rawValue,plsqlParser.Tokens.COLUMNS.rawValue,plsqlParser.Tokens.COMMENT.rawValue,plsqlParser.Tokens.COMMIT.rawValue,plsqlParser.Tokens.COMMITTED.rawValue,plsqlParser.Tokens.COMPATIBILITY.rawValue,plsqlParser.Tokens.COMPILE.rawValue,plsqlParser.Tokens.COMPOUND.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.CONSTANT.rawValue,plsqlParser.Tokens.CONSTRAINT.rawValue,plsqlParser.Tokens.CONSTRAINTS.rawValue,plsqlParser.Tokens.CONSTRUCTOR.rawValue,plsqlParser.Tokens.CONTENT.rawValue,plsqlParser.Tokens.CONTEXT.rawValue,plsqlParser.Tokens.CONTINUE.rawValue,plsqlParser.Tokens.CONVERT.rawValue,plsqlParser.Tokens.CORRUPT_XID.rawValue,plsqlParser.Tokens.CORRUPT_XID_ALL.rawValue,plsqlParser.Tokens.COST.rawValue,plsqlParser.Tokens.COUNT.rawValue,plsqlParser.Tokens.CROSS.rawValue,plsqlParser.Tokens.CUBE.rawValue,plsqlParser.Tokens.CURRENT_USER.rawValue,plsqlParser.Tokens.CURSOR.rawValue,plsqlParser.Tokens.CUSTOMDATUM.rawValue,plsqlParser.Tokens.CYCLE.rawValue,plsqlParser.Tokens.DATA.rawValue,plsqlParser.Tokens.DATABASE.rawValue,plsqlParser.Tokens.DAY.rawValue,plsqlParser.Tokens.DB_ROLE_CHANGE.rawValue,plsqlParser.Tokens.DBTIMEZONE.rawValue,plsqlParser.Tokens.DDL.rawValue,plsqlParser.Tokens.DEBUG.rawValue,plsqlParser.Tokens.DEC.rawValue,plsqlParser.Tokens.DECIMAL.rawValue,plsqlParser.Tokens.DECOMPOSE.rawValue,plsqlParser.Tokens.DECREMENT.rawValue,plsqlParser.Tokens.DEFAULTS.rawValue,plsqlParser.Tokens.DEFERRED.rawValue,plsqlParser.Tokens.DEFINER.rawValue,plsqlParser.Tokens.DETERMINISTIC.rawValue,plsqlParser.Tokens.DIMENSION.rawValue,plsqlParser.Tokens.DISABLE.rawValue,plsqlParser.Tokens.DISASSOCIATE.rawValue,plsqlParser.Tokens.DOCUMENT.rawValue,plsqlParser.Tokens.DOUBLE.rawValue,plsqlParser.Tokens.DSINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.EACH.rawValue,plsqlParser.Tokens.ELEMENT.rawValue,plsqlParser.Tokens.EMPTY.rawValue,plsqlParser.Tokens.ENABLE.rawValue,plsqlParser.Tokens.ENCODING.rawValue,plsqlParser.Tokens.ENTITYESCAPING.rawValue,plsqlParser.Tokens.ERR.rawValue,plsqlParser.Tokens.ERRORS.rawValue,plsqlParser.Tokens.ESCAPE.rawValue,plsqlParser.Tokens.EVALNAME.rawValue,plsqlParser.Tokens.EXCEPTION.rawValue,plsqlParser.Tokens.EXCEPTION_INIT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 66)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.EXCEPTIONS.rawValue,plsqlParser.Tokens.EXCLUDE.rawValue,plsqlParser.Tokens.EXECUTE.rawValue,plsqlParser.Tokens.EXIT.rawValue,plsqlParser.Tokens.EXPLAIN.rawValue,plsqlParser.Tokens.EXTERNAL.rawValue,plsqlParser.Tokens.EXTRACT.rawValue,plsqlParser.Tokens.FAILURE.rawValue,plsqlParser.Tokens.FINAL.rawValue,plsqlParser.Tokens.FIRST.rawValue,plsqlParser.Tokens.FIRST_VALUE.rawValue,plsqlParser.Tokens.FLOAT.rawValue,plsqlParser.Tokens.FOLLOWING.rawValue,plsqlParser.Tokens.FOLLOWS.rawValue,plsqlParser.Tokens.FORALL.rawValue,plsqlParser.Tokens.FORCE.rawValue,plsqlParser.Tokens.FULL.rawValue,plsqlParser.Tokens.FUNCTION.rawValue,plsqlParser.Tokens.GROUPING.rawValue,plsqlParser.Tokens.HASH.rawValue,plsqlParser.Tokens.HIDE.rawValue,plsqlParser.Tokens.HOUR.rawValue,plsqlParser.Tokens.IGNORE.rawValue,plsqlParser.Tokens.IMMEDIATE.rawValue,plsqlParser.Tokens.INCLUDE.rawValue,plsqlParser.Tokens.INCLUDING.rawValue,plsqlParser.Tokens.INCREMENT.rawValue,plsqlParser.Tokens.INDENT.rawValue,plsqlParser.Tokens.INDEXED.rawValue,plsqlParser.Tokens.INDICATOR.rawValue,plsqlParser.Tokens.INDICES.rawValue,plsqlParser.Tokens.INFINITE.rawValue,plsqlParser.Tokens.INLINE.rawValue,plsqlParser.Tokens.INNER.rawValue,plsqlParser.Tokens.INOUT.rawValue,plsqlParser.Tokens.INSTANTIABLE.rawValue,plsqlParser.Tokens.INSTEAD.rawValue,plsqlParser.Tokens.INT.rawValue,plsqlParser.Tokens.INTEGER.rawValue,plsqlParser.Tokens.INTERVAL.rawValue,plsqlParser.Tokens.INVALIDATE.rawValue,plsqlParser.Tokens.ISOLATION.rawValue,plsqlParser.Tokens.ITERATE.rawValue,plsqlParser.Tokens.JAVA.rawValue,plsqlParser.Tokens.JOIN.rawValue,plsqlParser.Tokens.KEEP.rawValue,plsqlParser.Tokens.LANGUAGE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 130)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.LAST.rawValue,plsqlParser.Tokens.LAST_VALUE.rawValue,plsqlParser.Tokens.LEADING.rawValue,plsqlParser.Tokens.LEFT.rawValue,plsqlParser.Tokens.LEVEL.rawValue,plsqlParser.Tokens.LIBRARY.rawValue,plsqlParser.Tokens.LIKE2.rawValue,plsqlParser.Tokens.LIKE4.rawValue,plsqlParser.Tokens.LIKEC.rawValue,plsqlParser.Tokens.LIMIT.rawValue,plsqlParser.Tokens.LOCAL.rawValue,plsqlParser.Tokens.LOCKED.rawValue,plsqlParser.Tokens.LOG.rawValue,plsqlParser.Tokens.LOGOFF.rawValue,plsqlParser.Tokens.LOGON.rawValue,plsqlParser.Tokens.LONG.rawValue,plsqlParser.Tokens.LOOP.rawValue,plsqlParser.Tokens.MAIN.rawValue,plsqlParser.Tokens.MAP.rawValue,plsqlParser.Tokens.MATCHED.rawValue,plsqlParser.Tokens.MAXVALUE.rawValue,plsqlParser.Tokens.MEASURES.rawValue,plsqlParser.Tokens.MEMBER.rawValue,plsqlParser.Tokens.MERGE.rawValue,plsqlParser.Tokens.MINUTE.rawValue,plsqlParser.Tokens.MINVALUE.rawValue,plsqlParser.Tokens.MLSLABEL.rawValue,plsqlParser.Tokens.MODEL.rawValue,plsqlParser.Tokens.MODIFY.rawValue,plsqlParser.Tokens.MONTH.rawValue,plsqlParser.Tokens.MULTISET.rawValue,plsqlParser.Tokens.NAME.rawValue,plsqlParser.Tokens.NAN.rawValue,plsqlParser.Tokens.NATURAL.rawValue,plsqlParser.Tokens.NATURALN.rawValue,plsqlParser.Tokens.NAV.rawValue,plsqlParser.Tokens.NCHAR.rawValue,plsqlParser.Tokens.NCHAR_CS.rawValue,plsqlParser.Tokens.NCLOB.rawValue,plsqlParser.Tokens.NESTED.rawValue,plsqlParser.Tokens.NEW.rawValue,plsqlParser.Tokens.NO.rawValue,plsqlParser.Tokens.NOAUDIT.rawValue,plsqlParser.Tokens.NOCOPY.rawValue,plsqlParser.Tokens.NOCYCLE.rawValue,plsqlParser.Tokens.NOENTITYESCAPING.rawValue,plsqlParser.Tokens.NONE.rawValue,plsqlParser.Tokens.NOSCHEMACHECK.rawValue,plsqlParser.Tokens.NULLS.rawValue,plsqlParser.Tokens.NUMBER.rawValue,plsqlParser.Tokens.NUMERIC.rawValue,plsqlParser.Tokens.NVARCHAR2.rawValue,plsqlParser.Tokens.OBJECT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 194)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.OFF.rawValue,plsqlParser.Tokens.OID.rawValue,plsqlParser.Tokens.OLD.rawValue,plsqlParser.Tokens.ONLY.rawValue,plsqlParser.Tokens.OPEN.rawValue,plsqlParser.Tokens.ORADATA.rawValue,plsqlParser.Tokens.ORDINALITY.rawValue,plsqlParser.Tokens.OSERROR.rawValue,plsqlParser.Tokens.OUT.rawValue,plsqlParser.Tokens.OUTER.rawValue,plsqlParser.Tokens.OVER.rawValue,plsqlParser.Tokens.OVERRIDING.rawValue,plsqlParser.Tokens.PACKAGE.rawValue,plsqlParser.Tokens.PARALLEL_ENABLE.rawValue,plsqlParser.Tokens.PARAMETERS.rawValue,plsqlParser.Tokens.PARENT.rawValue,plsqlParser.Tokens.PARTITION.rawValue,plsqlParser.Tokens.PASSING.rawValue,plsqlParser.Tokens.PATH.rawValue,plsqlParser.Tokens.PIPELINED.rawValue,plsqlParser.Tokens.PLAN.rawValue,plsqlParser.Tokens.PLS_INTEGER.rawValue,plsqlParser.Tokens.POSITIVE.rawValue,plsqlParser.Tokens.POSITIVEN.rawValue,plsqlParser.Tokens.PRAGMA.rawValue,plsqlParser.Tokens.PRECEDING.rawValue,plsqlParser.Tokens.PRECISION.rawValue,plsqlParser.Tokens.PRESENT.rawValue,plsqlParser.Tokens.RAISE.rawValue,plsqlParser.Tokens.RANGE.rawValue,plsqlParser.Tokens.RAW.rawValue,plsqlParser.Tokens.READ.rawValue,plsqlParser.Tokens.REAL.rawValue,plsqlParser.Tokens.RECORD.rawValue,plsqlParser.Tokens.REF.rawValue,plsqlParser.Tokens.REFERENCE.rawValue,plsqlParser.Tokens.REFERENCING.rawValue,plsqlParser.Tokens.REJECT.rawValue,plsqlParser.Tokens.RELIES_ON.rawValue,plsqlParser.Tokens.RENAME.rawValue,plsqlParser.Tokens.REPLACE.rawValue,plsqlParser.Tokens.RESPECT.rawValue,plsqlParser.Tokens.RESTRICT_REFERENCES.rawValue,plsqlParser.Tokens.RESULT.rawValue,plsqlParser.Tokens.RESULT_CACHE.rawValue,plsqlParser.Tokens.RETURN.rawValue,plsqlParser.Tokens.RETURNING.rawValue,plsqlParser.Tokens.REUSE.rawValue,plsqlParser.Tokens.REVERSE.rawValue,plsqlParser.Tokens.RIGHT.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 259)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.ROLLBACK.rawValue,plsqlParser.Tokens.ROLLUP.rawValue,plsqlParser.Tokens.ROW.rawValue,plsqlParser.Tokens.ROWID.rawValue,plsqlParser.Tokens.ROWS.rawValue,plsqlParser.Tokens.RULES.rawValue,plsqlParser.Tokens.SAMPLE.rawValue,plsqlParser.Tokens.SAVE.rawValue,plsqlParser.Tokens.SAVEPOINT.rawValue,plsqlParser.Tokens.SCHEMA.rawValue,plsqlParser.Tokens.SCHEMACHECK.rawValue,plsqlParser.Tokens.SCN.rawValue,plsqlParser.Tokens.SECOND.rawValue,plsqlParser.Tokens.SEED.rawValue,plsqlParser.Tokens.SEGMENT.rawValue,plsqlParser.Tokens.SELF.rawValue,plsqlParser.Tokens.SEQUENTIAL.rawValue,plsqlParser.Tokens.SERIALIZABLE.rawValue,plsqlParser.Tokens.SERIALLY_REUSABLE.rawValue,plsqlParser.Tokens.SERVERERROR.rawValue,plsqlParser.Tokens.SESSIONTIMEZONE.rawValue,plsqlParser.Tokens.SET.rawValue,plsqlParser.Tokens.SETS.rawValue,plsqlParser.Tokens.SETTINGS.rawValue,plsqlParser.Tokens.SHOW.rawValue,plsqlParser.Tokens.SHUTDOWN.rawValue,plsqlParser.Tokens.SIBLINGS.rawValue,plsqlParser.Tokens.SIGNTYPE.rawValue,plsqlParser.Tokens.SIMPLE_INTEGER.rawValue,plsqlParser.Tokens.SINGLE.rawValue,plsqlParser.Tokens.SKIP_.rawValue,plsqlParser.Tokens.SMALLINT.rawValue,plsqlParser.Tokens.SNAPSHOT.rawValue,plsqlParser.Tokens.SOME.rawValue,plsqlParser.Tokens.SPECIFICATION.rawValue,plsqlParser.Tokens.SQLDATA.rawValue,plsqlParser.Tokens.SQLERROR.rawValue,plsqlParser.Tokens.STANDALONE.rawValue,plsqlParser.Tokens.STARTUP.rawValue,plsqlParser.Tokens.STATEMENT.rawValue,plsqlParser.Tokens.STATEMENT_ID.rawValue,plsqlParser.Tokens.STATIC.rawValue,plsqlParser.Tokens.STATISTICS.rawValue,plsqlParser.Tokens.STRING.rawValue,plsqlParser.Tokens.SUBMULTISET.rawValue,plsqlParser.Tokens.SUBPARTITION.rawValue,plsqlParser.Tokens.SUBSTITUTABLE.rawValue,plsqlParser.Tokens.SUBTYPE.rawValue,plsqlParser.Tokens.SUCCESS.rawValue,plsqlParser.Tokens.SUSPEND.rawValue,plsqlParser.Tokens.TIME.rawValue,plsqlParser.Tokens.TIMESTAMP.rawValue,plsqlParser.Tokens.TIMESTAMP_LTZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_TZ_UNCONSTRAINED.rawValue,plsqlParser.Tokens.TIMESTAMP_UNCONSTRAINED.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 323)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.TIMEZONE_ABBR.rawValue,plsqlParser.Tokens.TIMEZONE_HOUR.rawValue,plsqlParser.Tokens.TIMEZONE_MINUTE.rawValue,plsqlParser.Tokens.TIMEZONE_REGION.rawValue,plsqlParser.Tokens.TRAILING.rawValue,plsqlParser.Tokens.TRANSACTION.rawValue,plsqlParser.Tokens.TRANSLATE.rawValue,plsqlParser.Tokens.TREAT.rawValue,plsqlParser.Tokens.TRIGGER.rawValue,plsqlParser.Tokens.TRUNCATE.rawValue,plsqlParser.Tokens.TYPE.rawValue,plsqlParser.Tokens.UNBOUNDED.rawValue,plsqlParser.Tokens.UNDER.rawValue,plsqlParser.Tokens.UNLIMITED.rawValue,plsqlParser.Tokens.UNTIL.rawValue,plsqlParser.Tokens.UPDATED.rawValue,plsqlParser.Tokens.UPSERT.rawValue,plsqlParser.Tokens.UROWID.rawValue,plsqlParser.Tokens.USE.rawValue,plsqlParser.Tokens.VALIDATE.rawValue,plsqlParser.Tokens.VALUE.rawValue,plsqlParser.Tokens.VARCHAR.rawValue,plsqlParser.Tokens.VARCHAR2.rawValue,plsqlParser.Tokens.VARIABLE.rawValue,plsqlParser.Tokens.VARRAY.rawValue,plsqlParser.Tokens.VARYING.rawValue,plsqlParser.Tokens.VERSION.rawValue,plsqlParser.Tokens.VERSIONS.rawValue,plsqlParser.Tokens.WAIT.rawValue,plsqlParser.Tokens.WARNING.rawValue,plsqlParser.Tokens.WELLFORMED.rawValue,plsqlParser.Tokens.WHENEVER.rawValue,plsqlParser.Tokens.WHILE.rawValue,plsqlParser.Tokens.WITHIN.rawValue,plsqlParser.Tokens.WORK.rawValue,plsqlParser.Tokens.WRITE.rawValue,plsqlParser.Tokens.XML.rawValue,plsqlParser.Tokens.XMLAGG.rawValue,plsqlParser.Tokens.XMLATTRIBUTES.rawValue,plsqlParser.Tokens.XMLCAST.rawValue,plsqlParser.Tokens.XMLCOLATTVAL.rawValue,plsqlParser.Tokens.XMLELEMENT.rawValue,plsqlParser.Tokens.XMLEXISTS.rawValue,plsqlParser.Tokens.XMLFOREST.rawValue,plsqlParser.Tokens.XMLNAMESPACES.rawValue,plsqlParser.Tokens.XMLPARSE.rawValue,plsqlParser.Tokens.XMLPI.rawValue,plsqlParser.Tokens.XMLQUERY.rawValue,plsqlParser.Tokens.XMLROOT.rawValue,plsqlParser.Tokens.XMLSERIALIZE.rawValue,plsqlParser.Tokens.XMLTABLE.rawValue,plsqlParser.Tokens.YEAR.rawValue,plsqlParser.Tokens.YES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 387)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.YMINTERVAL_UNCONSTRAINED.rawValue,plsqlParser.Tokens.ZONE.rawValue,plsqlParser.Tokens.PREDICTION.rawValue,plsqlParser.Tokens.PREDICTION_BOUNDS.rawValue,plsqlParser.Tokens.PREDICTION_COST.rawValue,plsqlParser.Tokens.PREDICTION_DETAILS.rawValue,plsqlParser.Tokens.PREDICTION_PROBABILITY.rawValue,plsqlParser.Tokens.PREDICTION_SET.rawValue,plsqlParser.Tokens.CUME_DIST.rawValue,plsqlParser.Tokens.DENSE_RANK.rawValue,plsqlParser.Tokens.LISTAGG.rawValue,plsqlParser.Tokens.PERCENT_RANK.rawValue,plsqlParser.Tokens.PERCENTILE_CONT.rawValue,plsqlParser.Tokens.PERCENTILE_DISC.rawValue,plsqlParser.Tokens.RANK.rawValue,plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.CORR.rawValue,plsqlParser.Tokens.COVAR_.rawValue,plsqlParser.Tokens.LAG.rawValue,plsqlParser.Tokens.LEAD.rawValue,plsqlParser.Tokens.MAX.rawValue,plsqlParser.Tokens.MEDIAN.rawValue,plsqlParser.Tokens.MIN.rawValue,plsqlParser.Tokens.NTILE.rawValue,plsqlParser.Tokens.RATIO_TO_REPORT.rawValue,plsqlParser.Tokens.REGR_.rawValue,plsqlParser.Tokens.ROW_NUMBER.rawValue,plsqlParser.Tokens.TRIM.rawValue,plsqlParser.Tokens.SUM.rawValue,plsqlParser.Tokens.STDDEV.rawValue,plsqlParser.Tokens.VAR_.rawValue,plsqlParser.Tokens.VARIANCE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 451)
		 	          }()
		 	          testSet = testSet || _la == plsqlParser.Tokens.REGULAR_ID.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class String_function_nameContext:ParserRuleContext {
		open func CHR() -> TerminalNode? { return getToken(plsqlParser.Tokens.CHR.rawValue, 0) }
		open func DECODE() -> TerminalNode? { return getToken(plsqlParser.Tokens.DECODE.rawValue, 0) }
		open func SUBSTR() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUBSTR.rawValue, 0) }
		open func TO_CHAR() -> TerminalNode? { return getToken(plsqlParser.Tokens.TO_CHAR.rawValue, 0) }
		open func TRIM() -> TerminalNode? { return getToken(plsqlParser.Tokens.TRIM.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_string_function_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterString_function_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitString_function_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitString_function_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitString_function_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func string_function_name() throws -> String_function_nameContext {
		var _localctx: String_function_nameContext = String_function_nameContext(_ctx, getState())
		try enterRule(_localctx, 764, plsqlParser.RULE_string_function_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5487)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.CHR.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.DECODE.rawValue,plsqlParser.Tokens.SUBSTR.rawValue,plsqlParser.Tokens.TO_CHAR.rawValue,plsqlParser.Tokens.TRIM.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 469)
		 	          }()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Numeric_function_nameContext:ParserRuleContext {
		open func AVG() -> TerminalNode? { return getToken(plsqlParser.Tokens.AVG.rawValue, 0) }
		open func COUNT() -> TerminalNode? { return getToken(plsqlParser.Tokens.COUNT.rawValue, 0) }
		open func NVL() -> TerminalNode? { return getToken(plsqlParser.Tokens.NVL.rawValue, 0) }
		open func ROUND() -> TerminalNode? { return getToken(plsqlParser.Tokens.ROUND.rawValue, 0) }
		open func SUM() -> TerminalNode? { return getToken(plsqlParser.Tokens.SUM.rawValue, 0) }
		open override func getRuleIndex() -> Int { return plsqlParser.RULE_numeric_function_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).enterNumeric_function_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is plsqlListener {
			 	(listener as! plsqlListener).exitNumeric_function_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is plsqlVisitor {
			     return (visitor as! plsqlVisitor<T>).visitNumeric_function_name(self)
			}else if visitor is plsqlBaseVisitor {
		    	 return (visitor as! plsqlBaseVisitor<T>).visitNumeric_function_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func numeric_function_name() throws -> Numeric_function_nameContext {
		var _localctx: Numeric_function_nameContext = Numeric_function_nameContext(_ctx, getState())
		try enterRule(_localctx, 766, plsqlParser.RULE_numeric_function_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5489)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == plsqlParser.Tokens.COUNT.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, plsqlParser.Tokens.AVG.rawValue,plsqlParser.Tokens.NVL.rawValue,plsqlParser.Tokens.ROUND.rawValue,plsqlParser.Tokens.SUM.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

    override
	open func sempred(_ _localctx: RuleContext?, _ ruleIndex: Int,  _ predIndex: Int)throws -> Bool {
		switch (ruleIndex) {
		case  248:
			return try logical_or_expression_sempred(_localctx?.castdown(Logical_or_expressionContext.self), predIndex)
		case  249:
			return try logical_and_expression_sempred(_localctx?.castdown(Logical_and_expressionContext.self), predIndex)
		case  254:
			return try relational_expression_sempred(_localctx?.castdown(Relational_expressionContext.self), predIndex)
	    default: return true
		}
	}
	private func logical_or_expression_sempred(_ _localctx: Logical_or_expressionContext!,  _ predIndex: Int) throws -> Bool {
		switch (predIndex) {
		    case 0:return precpred(_ctx, 1)
		    default: return true
		}
	}
	private func logical_and_expression_sempred(_ _localctx: Logical_and_expressionContext!,  _ predIndex: Int) throws -> Bool {
		switch (predIndex) {
		    case 1:return precpred(_ctx, 1)
		    default: return true
		}
	}
	private func relational_expression_sempred(_ _localctx: Relational_expressionContext!,  _ predIndex: Int) throws -> Bool {
		switch (predIndex) {
		    case 2:return precpred(_ctx, 2)
		    default: return true
		}
	}

   public static let _serializedATN : String = plsqlParserATN().jsonString
   public static let _ATN: ATN = ATNDeserializer().deserializeFromJson(_serializedATN)
}