// Generated from ./grammars-v4/edif300/EDIF300.g4 by ANTLR 4.7.1
import Antlr4

open class EDIF300Parser: Parser {

	internal static var _decisionToDFA: [DFA] = {
          var decisionToDFA = [DFA]()
          let length = EDIF300Parser._ATN.getNumberOfDecisions()
          for i in 0..<length {
            decisionToDFA.append(DFA(EDIF300Parser._ATN.getDecisionState(i)!, i))
           }
           return decisionToDFA
     }()

	internal static let _sharedContextCache = PredictionContextCache()

	public
	enum Tokens: Int {
		case EOF = -1, T__0 = 1, T__1 = 2, T__2 = 3, T__3 = 4, T__4 = 5, T__5 = 6, 
                 T__6 = 7, T__7 = 8, T__8 = 9, T__9 = 10, T__10 = 11, T__11 = 12, 
                 T__12 = 13, T__13 = 14, T__14 = 15, T__15 = 16, T__16 = 17, 
                 T__17 = 18, T__18 = 19, T__19 = 20, T__20 = 21, T__21 = 22, 
                 T__22 = 23, T__23 = 24, T__24 = 25, T__25 = 26, T__26 = 27, 
                 T__27 = 28, T__28 = 29, T__29 = 30, T__30 = 31, T__31 = 32, 
                 T__32 = 33, T__33 = 34, T__34 = 35, T__35 = 36, T__36 = 37, 
                 T__37 = 38, T__38 = 39, T__39 = 40, T__40 = 41, T__41 = 42, 
                 T__42 = 43, T__43 = 44, T__44 = 45, T__45 = 46, T__46 = 47, 
                 T__47 = 48, T__48 = 49, T__49 = 50, T__50 = 51, T__51 = 52, 
                 T__52 = 53, T__53 = 54, T__54 = 55, T__55 = 56, T__56 = 57, 
                 T__57 = 58, T__58 = 59, T__59 = 60, T__60 = 61, T__61 = 62, 
                 T__62 = 63, T__63 = 64, T__64 = 65, T__65 = 66, T__66 = 67, 
                 T__67 = 68, T__68 = 69, T__69 = 70, T__70 = 71, T__71 = 72, 
                 T__72 = 73, T__73 = 74, T__74 = 75, T__75 = 76, T__76 = 77, 
                 T__77 = 78, T__78 = 79, T__79 = 80, T__80 = 81, T__81 = 82, 
                 T__82 = 83, T__83 = 84, T__84 = 85, T__85 = 86, T__86 = 87, 
                 T__87 = 88, T__88 = 89, T__89 = 90, T__90 = 91, T__91 = 92, 
                 T__92 = 93, T__93 = 94, T__94 = 95, T__95 = 96, T__96 = 97, 
                 T__97 = 98, T__98 = 99, T__99 = 100, T__100 = 101, T__101 = 102, 
                 T__102 = 103, T__103 = 104, T__104 = 105, T__105 = 106, 
                 T__106 = 107, T__107 = 108, T__108 = 109, T__109 = 110, 
                 T__110 = 111, T__111 = 112, T__112 = 113, T__113 = 114, 
                 T__114 = 115, T__115 = 116, T__116 = 117, T__117 = 118, 
                 T__118 = 119, T__119 = 120, T__120 = 121, T__121 = 122, 
                 T__122 = 123, T__123 = 124, T__124 = 125, T__125 = 126, 
                 T__126 = 127, T__127 = 128, T__128 = 129, T__129 = 130, 
                 T__130 = 131, T__131 = 132, T__132 = 133, T__133 = 134, 
                 T__134 = 135, T__135 = 136, T__136 = 137, T__137 = 138, 
                 T__138 = 139, T__139 = 140, T__140 = 141, T__141 = 142, 
                 T__142 = 143, T__143 = 144, T__144 = 145, T__145 = 146, 
                 T__146 = 147, T__147 = 148, T__148 = 149, T__149 = 150, 
                 T__150 = 151, T__151 = 152, T__152 = 153, T__153 = 154, 
                 T__154 = 155, T__155 = 156, T__156 = 157, T__157 = 158, 
                 T__158 = 159, T__159 = 160, T__160 = 161, T__161 = 162, 
                 T__162 = 163, T__163 = 164, T__164 = 165, T__165 = 166, 
                 T__166 = 167, T__167 = 168, T__168 = 169, T__169 = 170, 
                 T__170 = 171, T__171 = 172, T__172 = 173, T__173 = 174, 
                 T__174 = 175, T__175 = 176, T__176 = 177, T__177 = 178, 
                 T__178 = 179, T__179 = 180, T__180 = 181, T__181 = 182, 
                 T__182 = 183, T__183 = 184, T__184 = 185, T__185 = 186, 
                 T__186 = 187, T__187 = 188, T__188 = 189, T__189 = 190, 
                 T__190 = 191, T__191 = 192, T__192 = 193, T__193 = 194, 
                 T__194 = 195, T__195 = 196, T__196 = 197, T__197 = 198, 
                 T__198 = 199, T__199 = 200, T__200 = 201, T__201 = 202, 
                 T__202 = 203, T__203 = 204, T__204 = 205, T__205 = 206, 
                 T__206 = 207, T__207 = 208, T__208 = 209, T__209 = 210, 
                 T__210 = 211, T__211 = 212, T__212 = 213, T__213 = 214, 
                 T__214 = 215, T__215 = 216, T__216 = 217, T__217 = 218, 
                 T__218 = 219, T__219 = 220, T__220 = 221, T__221 = 222, 
                 T__222 = 223, T__223 = 224, T__224 = 225, T__225 = 226, 
                 T__226 = 227, T__227 = 228, T__228 = 229, T__229 = 230, 
                 T__230 = 231, T__231 = 232, T__232 = 233, T__233 = 234, 
                 T__234 = 235, T__235 = 236, T__236 = 237, T__237 = 238, 
                 T__238 = 239, T__239 = 240, T__240 = 241, T__241 = 242, 
                 T__242 = 243, T__243 = 244, T__244 = 245, T__245 = 246, 
                 T__246 = 247, T__247 = 248, T__248 = 249, T__249 = 250, 
                 T__250 = 251, T__251 = 252, T__252 = 253, T__253 = 254, 
                 T__254 = 255, T__255 = 256, T__256 = 257, T__257 = 258, 
                 T__258 = 259, T__259 = 260, T__260 = 261, T__261 = 262, 
                 T__262 = 263, T__263 = 264, T__264 = 265, T__265 = 266, 
                 T__266 = 267, T__267 = 268, T__268 = 269, T__269 = 270, 
                 T__270 = 271, T__271 = 272, T__272 = 273, T__273 = 274, 
                 T__274 = 275, T__275 = 276, T__276 = 277, T__277 = 278, 
                 T__278 = 279, T__279 = 280, T__280 = 281, T__281 = 282, 
                 T__282 = 283, T__283 = 284, T__284 = 285, T__285 = 286, 
                 T__286 = 287, T__287 = 288, T__288 = 289, T__289 = 290, 
                 T__290 = 291, T__291 = 292, T__292 = 293, T__293 = 294, 
                 T__294 = 295, T__295 = 296, T__296 = 297, T__297 = 298, 
                 T__298 = 299, T__299 = 300, T__300 = 301, T__301 = 302, 
                 T__302 = 303, T__303 = 304, T__304 = 305, T__305 = 306, 
                 T__306 = 307, T__307 = 308, T__308 = 309, T__309 = 310, 
                 T__310 = 311, T__311 = 312, T__312 = 313, T__313 = 314, 
                 T__314 = 315, T__315 = 316, T__316 = 317, T__317 = 318, 
                 T__318 = 319, T__319 = 320, T__320 = 321, T__321 = 322, 
                 T__322 = 323, T__323 = 324, T__324 = 325, T__325 = 326, 
                 T__326 = 327, T__327 = 328, T__328 = 329, T__329 = 330, 
                 T__330 = 331, T__331 = 332, T__332 = 333, T__333 = 334, 
                 T__334 = 335, T__335 = 336, T__336 = 337, T__337 = 338, 
                 T__338 = 339, T__339 = 340, T__340 = 341, T__341 = 342, 
                 T__342 = 343, T__343 = 344, T__344 = 345, T__345 = 346, 
                 T__346 = 347, T__347 = 348, T__348 = 349, T__349 = 350, 
                 T__350 = 351, T__351 = 352, T__352 = 353, T__353 = 354, 
                 T__354 = 355, T__355 = 356, T__356 = 357, T__357 = 358, 
                 T__358 = 359, T__359 = 360, T__360 = 361, T__361 = 362, 
                 T__362 = 363, T__363 = 364, T__364 = 365, T__365 = 366, 
                 T__366 = 367, T__367 = 368, T__368 = 369, T__369 = 370, 
                 T__370 = 371, T__371 = 372, T__372 = 373, T__373 = 374, 
                 T__374 = 375, T__375 = 376, T__376 = 377, T__377 = 378, 
                 T__378 = 379, T__379 = 380, T__380 = 381, T__381 = 382, 
                 T__382 = 383, T__383 = 384, T__384 = 385, T__385 = 386, 
                 T__386 = 387, T__387 = 388, T__388 = 389, T__389 = 390, 
                 T__390 = 391, T__391 = 392, T__392 = 393, T__393 = 394, 
                 T__394 = 395, T__395 = 396, T__396 = 397, T__397 = 398, 
                 T__398 = 399, T__399 = 400, T__400 = 401, T__401 = 402, 
                 T__402 = 403, T__403 = 404, T__404 = 405, T__405 = 406, 
                 T__406 = 407, T__407 = 408, T__408 = 409, T__409 = 410, 
                 T__410 = 411, T__411 = 412, T__412 = 413, T__413 = 414, 
                 T__414 = 415, T__415 = 416, T__416 = 417, T__417 = 418, 
                 T__418 = 419, T__419 = 420, T__420 = 421, T__421 = 422, 
                 T__422 = 423, T__423 = 424, T__424 = 425, T__425 = 426, 
                 T__426 = 427, T__427 = 428, T__428 = 429, T__429 = 430, 
                 T__430 = 431, T__431 = 432, T__432 = 433, T__433 = 434, 
                 T__434 = 435, T__435 = 436, T__436 = 437, T__437 = 438, 
                 T__438 = 439, T__439 = 440, T__440 = 441, T__441 = 442, 
                 T__442 = 443, T__443 = 444, T__444 = 445, T__445 = 446, 
                 T__446 = 447, T__447 = 448, T__448 = 449, T__449 = 450, 
                 T__450 = 451, T__451 = 452, T__452 = 453, T__453 = 454, 
                 T__454 = 455, T__455 = 456, T__456 = 457, T__457 = 458, 
                 T__458 = 459, T__459 = 460, T__460 = 461, T__461 = 462, 
                 T__462 = 463, T__463 = 464, T__464 = 465, T__465 = 466, 
                 T__466 = 467, T__467 = 468, T__468 = 469, T__469 = 470, 
                 T__470 = 471, T__471 = 472, T__472 = 473, T__473 = 474, 
                 T__474 = 475, T__475 = 476, T__476 = 477, T__477 = 478, 
                 T__478 = 479, T__479 = 480, T__480 = 481, T__481 = 482, 
                 T__482 = 483, T__483 = 484, T__484 = 485, T__485 = 486, 
                 T__486 = 487, T__487 = 488, T__488 = 489, T__489 = 490, 
                 T__490 = 491, T__491 = 492, T__492 = 493, T__493 = 494, 
                 T__494 = 495, T__495 = 496, T__496 = 497, T__497 = 498, 
                 T__498 = 499, T__499 = 500, T__500 = 501, T__501 = 502, 
                 T__502 = 503, T__503 = 504, T__504 = 505, T__505 = 506, 
                 T__506 = 507, T__507 = 508, T__508 = 509, T__509 = 510, 
                 T__510 = 511, T__511 = 512, T__512 = 513, T__513 = 514, 
                 T__514 = 515, T__515 = 516, T__516 = 517, T__517 = 518, 
                 T__518 = 519, T__519 = 520, T__520 = 521, T__521 = 522, 
                 T__522 = 523, T__523 = 524, T__524 = 525, T__525 = 526, 
                 T__526 = 527, T__527 = 528, T__528 = 529, T__529 = 530, 
                 T__530 = 531, T__531 = 532, T__532 = 533, T__533 = 534, 
                 T__534 = 535, T__535 = 536, T__536 = 537, T__537 = 538, 
                 T__538 = 539, T__539 = 540, T__540 = 541, T__541 = 542, 
                 T__542 = 543, T__543 = 544, T__544 = 545, T__545 = 546, 
                 T__546 = 547, T__547 = 548, T__548 = 549, T__549 = 550, 
                 T__550 = 551, T__551 = 552, T__552 = 553, T__553 = 554, 
                 T__554 = 555, T__555 = 556, T__556 = 557, T__557 = 558, 
                 T__558 = 559, T__559 = 560, T__560 = 561, T__561 = 562, 
                 T__562 = 563, T__563 = 564, T__564 = 565, T__565 = 566, 
                 T__566 = 567, T__567 = 568, T__568 = 569, T__569 = 570, 
                 T__570 = 571, T__571 = 572, T__572 = 573, T__573 = 574, 
                 T__574 = 575, T__575 = 576, T__576 = 577, T__577 = 578, 
                 T__578 = 579, T__579 = 580, T__580 = 581, T__581 = 582, 
                 T__582 = 583, T__583 = 584, T__584 = 585, T__585 = 586, 
                 T__586 = 587, T__587 = 588, T__588 = 589, T__589 = 590, 
                 T__590 = 591, T__591 = 592, T__592 = 593, T__593 = 594, 
                 T__594 = 595, T__595 = 596, T__596 = 597, T__597 = 598, 
                 T__598 = 599, T__599 = 600, T__600 = 601, T__601 = 602, 
                 T__602 = 603, T__603 = 604, T__604 = 605, T__605 = 606, 
                 T__606 = 607, T__607 = 608, T__608 = 609, T__609 = 610, 
                 T__610 = 611, T__611 = 612, T__612 = 613, T__613 = 614, 
                 T__614 = 615, T__615 = 616, T__616 = 617, T__617 = 618, 
                 T__618 = 619, T__619 = 620, T__620 = 621, T__621 = 622, 
                 T__622 = 623, T__623 = 624, T__624 = 625, T__625 = 626, 
                 T__626 = 627, T__627 = 628, T__628 = 629, T__629 = 630, 
                 T__630 = 631, T__631 = 632, T__632 = 633, T__633 = 634, 
                 T__634 = 635, T__635 = 636, T__636 = 637, T__637 = 638, 
                 T__638 = 639, T__639 = 640, T__640 = 641, T__641 = 642, 
                 T__642 = 643, T__643 = 644, T__644 = 645, T__645 = 646, 
                 T__646 = 647, T__647 = 648, T__648 = 649, T__649 = 650, 
                 T__650 = 651, T__651 = 652, T__652 = 653, T__653 = 654, 
                 T__654 = 655, T__655 = 656, T__656 = 657, T__657 = 658, 
                 T__658 = 659, T__659 = 660, T__660 = 661, T__661 = 662, 
                 T__662 = 663, T__663 = 664, T__664 = 665, T__665 = 666, 
                 IDENTIFIER = 667, STRING_LITERAL = 668, DECIMAL_LITERAL = 669, 
                 WS = 670
	}

	public
	static let RULE_goal = 0, RULE_absolute = 1, RULE_acLoad = 2, RULE_acLoadDisplay = 3, 
            RULE_acLoadFactorCapacitance = 4, RULE_acLoadFactorTime = 5, 
            RULE_addDisplay = 6, RULE_ampere = 7, RULE_and = 8, RULE_angleValue = 9, 
            RULE_annotate = 10, RULE_approvedDate = 11, RULE_approvedDateDisplay = 12, 
            RULE_arc = 13, RULE_ascii = 14, RULE_associatedInterconnectNameDisplay = 15, 
            RULE_attachmentPoint = 16, RULE_author = 17, RULE_backgroundColor = 18, 
            RULE_baselineJustify = 19, RULE_becomes = 20, RULE_behaviorView = 21, 
            RULE_bidirectional = 22, RULE_bidirectionalPort = 23, RULE_bidirectionalPortAttributes = 24, 
            RULE_bitOrder = 25, RULE_blue = 26, RULE_boldStyle = 27, RULE_eboolean = 28, 
            RULE_booleanConstant = 29, RULE_booleanConstantRef = 30, RULE_booleanExpression = 31, 
            RULE_booleanMap = 32, RULE_booleanParameter = 33, RULE_booleanParameterAssign = 34, 
            RULE_booleanParameterRef = 35, RULE_booleanToken = 36, RULE_booleanValue = 37, 
            RULE_borderPattern = 38, RULE_borderPatternVisible = 39, RULE_borderWidth = 40, 
            RULE_bottomJustify = 41, RULE_calculated = 42, RULE_candela = 43, 
            RULE_capacitanceValue = 44, RULE_caplineJustify = 45, RULE_cell = 46, 
            RULE_cellHeader = 47, RULE_cellNameDisplay = 48, RULE_cellPropertyDisplay = 49, 
            RULE_cellPropertyDisplayOverride = 50, RULE_cellPropertyOverride = 51, 
            RULE_cellRef = 52, RULE_celsius = 53, RULE_centerJustify = 54, 
            RULE_characterEncoding = 55, RULE_checkDate = 56, RULE_checkDateDisplay = 57, 
            RULE_circle = 58, RULE_cluster = 59, RULE_clusterConfiguration = 60, 
            RULE_clusterConfigurationNameCaseSensitive = 61, RULE_clusterConfigurationNameDef = 62, 
            RULE_clusterConfigurationNameRef = 63, RULE_clusterConfigurationRef = 64, 
            RULE_clusterHeader = 65, RULE_clusterNameCaseSensitive = 66, 
            RULE_clusterNameDef = 67, RULE_clusterNameRef = 68, RULE_clusterPropertyDisplay = 69, 
            RULE_clusterPropertyDisplayOverride = 70, RULE_clusterPropertyOverride = 71, 
            RULE_clusterRef = 72, RULE_color = 73, RULE_comment = 74, RULE_commentGraphics = 75, 
            RULE_companyName = 76, RULE_companyNameDisplay = 77, RULE_complementedName = 78, 
            RULE_complementedNamePart = 79, RULE_complexGeometry = 80, RULE_complexName = 81, 
            RULE_compound = 82, RULE_condition = 83, RULE_conditionDisplay = 84, 
            RULE_connectedSignalIndexGenerator = 85, RULE_connectedSignalIndexGeneratorDisplay = 86, 
            RULE_connectivityBus = 87, RULE_connectivityBusJoined = 88, 
            RULE_connectivityBusSlice = 89, RULE_connectivityFrameStructure = 90, 
            RULE_connectivityFrameStructureNameDef = 91, RULE_connectivityNet = 92, 
            RULE_connectivityNetJoined = 93, RULE_connectivityRipper = 94, 
            RULE_connectivityRipperNameDef = 95, RULE_connectivityRipperNameRef = 96, 
            RULE_connectivityRipperRef = 97, RULE_connectivityStructure = 98, 
            RULE_connectivitySubBus = 99, RULE_connectivitySubNet = 100, 
            RULE_connectivityTagGenerator = 101, RULE_connectivityTagGeneratorDisplay = 102, 
            RULE_connectivityUnits = 103, RULE_connectivityView = 104, RULE_connectivityViewHeader = 105, 
            RULE_constantNameDef = 106, RULE_constantNameRef = 107, RULE_constantValues = 108, 
            RULE_contract = 109, RULE_contractDisplay = 110, RULE_copyright = 111, 
            RULE_copyrightDisplay = 112, RULE_cornerType = 113, RULE_coulomb = 114, 
            RULE_criticality = 115, RULE_criticalityDisplay = 116, RULE_currentMap = 117, 
            RULE_currentValue = 118, RULE_curve = 119, RULE_dataOrigin = 120, 
            RULE_date = 121, RULE_dayNumber = 122, RULE_dcFanInLoad = 123, 
            RULE_dcFanInLoadDisplay = 124, RULE_dcFanOutLoad = 125, RULE_dcFanOutLoadDisplay = 126, 
            RULE_dcMaxFanIn = 127, RULE_dcMaxFanInDisplay = 128, RULE_dcMaxFanOut = 129, 
            RULE_dcMaxFanOutDisplay = 130, RULE_decimalToString = 131, RULE_defaultClusterConfiguration = 132, 
            RULE_defaultConnection = 133, RULE_degree = 134, RULE_delay = 135, 
            RULE_denominator = 136, RULE_derivation = 137, RULE_derivedFrom = 138, 
            RULE_design = 139, RULE_designator = 140, RULE_designatorDisplay = 141, 
            RULE_designHeader = 142, RULE_designHierarchy = 143, RULE_designHierarchyHeader = 144, 
            RULE_designHierarchyNameCaseSensitive = 145, RULE_designHierarchyNameDef = 146, 
            RULE_designNameCaseSensitive = 147, RULE_designNameDef = 148, 
            RULE_designUnits = 149, RULE_diagram = 150, RULE_diagramNameDef = 151, 
            RULE_directionalPortAttributeOverride = 152, RULE_display = 153, 
            RULE_displayAttributes = 154, RULE_displayName = 155, RULE_displayNameOverride = 156, 
            RULE_distanceValue = 157, RULE_dividend = 158, RULE_divisor = 159, 
            RULE_documentation = 160, RULE_documentationHeader = 161, RULE_documentationNameCaseSensitive = 162, 
            RULE_documentationNameDef = 163, RULE_documentationUnits = 164, 
            RULE_dominates = 165, RULE_dot = 166, RULE_drawingDescription = 167, 
            RULE_drawingDescriptionDisplay = 168, RULE_drawingIdentification = 169, 
            RULE_drawingIdentificationDisplay = 170, RULE_drawingSize = 171, 
            RULE_drawingSizeDisplay = 172, RULE_duration = 173, RULE_e = 174, 
            RULE_edif = 175, RULE_edifHeader = 176, RULE_edifLevel = 177, 
            RULE_edifLevelValue = 178, RULE_edifNameDef = 179, RULE_edifVersion = 180, 
            RULE_endPoint = 181, RULE_endType = 182, RULE_engineeringDate = 183, 
            RULE_engineeringDateDisplay = 184, RULE_event = 185, RULE_exponent = 186, 
            RULE_extend = 187, RULE_extendForFrameMemberDef = 188, RULE_extendFrameDef = 189, 
            RULE_extendInstanceDef = 190, RULE_extendInstanceMemberDef = 191, 
            RULE_extendInterconnectDef = 192, RULE_extendPageDef = 193, 
            RULE_extendPortDef = 194, RULE_extendPortMemberDef = 195, RULE_extendSignalDef = 196, 
            RULE_extendSignalGroupDef = 197, RULE_extendSignalMemberDef = 198, 
            RULE_external = 199, RULE_fahrenheit = 200, RULE_efalse = 201, 
            RULE_farad = 202, RULE_figure = 203, RULE_figureGroup = 204, 
            RULE_figureGroupNameCaseSensitive = 205, RULE_figureGroupNameDef = 206, 
            RULE_figureGroupNameRef = 207, RULE_figureGroupOverride = 208, 
            RULE_fillPattern = 209, RULE_fillPatternVisible = 210, RULE_firstIntegerExpression = 211, 
            RULE_firstStringExpression = 212, RULE_fixed = 213, RULE_font = 214, 
            RULE_fontCapitalHeight = 215, RULE_fontDefinitions = 216, RULE_fontDescent = 217, 
            RULE_fontFamily = 218, RULE_fontHeight = 219, RULE_fontNameDef = 220, 
            RULE_fontNameRef = 221, RULE_fontProportions = 222, RULE_fontRef = 223, 
            RULE_fonts = 224, RULE_fontWidth = 225, RULE_forbiddenEvent = 226, 
            RULE_forFrame = 227, RULE_forFrameAnnotate = 228, RULE_forFrameIndex = 229, 
            RULE_forFrameIndexDisplay = 230, RULE_forFrameIndexNameCaseSensitive = 231, 
            RULE_forFrameIndexRef = 232, RULE_forFrameMemberRef = 233, RULE_forFrameRef = 234, 
            RULE_frameConfiguration = 235, RULE_frameNameCaseSensitive = 236, 
            RULE_frameNameDef = 237, RULE_frameNameRef = 238, RULE_frameRef = 239, 
            RULE_frequencyValue = 240, RULE_fromBottom = 241, RULE_fromInteger = 242, 
            RULE_fromLeft = 243, RULE_fromRight = 244, RULE_fromTop = 245, 
            RULE_generated = 246, RULE_geometryMacro = 247, RULE_geometryMacroHeader = 248, 
            RULE_geometryMacroRef = 249, RULE_geometryMacroUnits = 250, 
            RULE_globalPort = 251, RULE_globalPortBundle = 252, RULE_globalPortDefinitions = 253, 
            RULE_globalPortList = 254, RULE_globalPortNameCaseSensitive = 255, 
            RULE_globalPortNameDef = 256, RULE_globalPortNameDisplay = 257, 
            RULE_globalPortNameRef = 258, RULE_globalPortPropertyDisplay = 259, 
            RULE_globalPortRef = 260, RULE_globalPortScope = 261, RULE_green = 262, 
            RULE_henry = 263, RULE_hertz = 264, RULE_horizontalJustification = 265, 
            RULE_hotspot = 266, RULE_hotspotConnectDirection = 267, RULE_hotspotGrid = 268, 
            RULE_hotspotNameCaseSensitive = 269, RULE_hotspotNameDef = 270, 
            RULE_hotspotNameDisplay = 271, RULE_hotspotNameRef = 272, RULE_hourNumber = 273, 
            RULE_ieeeDesignation = 274, RULE_ieeeSection = 275, RULE_ieeeStandard = 276, 
            RULE_ifFrame = 277, RULE_ifFrameAnnotate = 278, RULE_ifFrameRef = 279, 
            RULE_ifFrameSet = 280, RULE_ignore = 281, RULE_implementationNameCaseSensitive = 282, 
            RULE_implementationNameDef = 283, RULE_implementationNameDisplay = 284, 
            RULE_implementationNameRef = 285, RULE_indexEndDisplay = 286, 
            RULE_indexNameDef = 287, RULE_indexNameDisplay = 288, RULE_indexNameRef = 289, 
            RULE_indexStart = 290, RULE_indexStartDisplay = 291, RULE_indexStep = 292, 
            RULE_indexStepDisplay = 293, RULE_indexValue = 294, RULE_input = 295, 
            RULE_inputPort = 296, RULE_inputPortAttributes = 297, RULE_instance = 298, 
            RULE_instanceConfiguration = 299, RULE_instanceIndexValue = 300, 
            RULE_instanceMemberRef = 301, RULE_instanceNameCaseSensitive = 302, 
            RULE_instanceNameDef = 303, RULE_instanceNameDisplay = 304, 
            RULE_instanceNameGenerator = 305, RULE_instanceNameGeneratorDisplay = 306, 
            RULE_instanceNameRef = 307, RULE_instancePortAttributeDisplay = 308, 
            RULE_instancePortAttributes = 309, RULE_instancePropertyDisplay = 310, 
            RULE_instancePropertyOverride = 311, RULE_instanceRef = 312, 
            RULE_instanceWidth = 313, RULE_instanceWidthDisplay = 314, RULE_integer = 315, 
            RULE_integerConstant = 316, RULE_integerConstantRef = 317, RULE_integerEqual = 318, 
            RULE_integerExpression = 319, RULE_integerParameter = 320, RULE_integerParameterAssign = 321, 
            RULE_integerParameterRef = 322, RULE_integerProduct = 323, RULE_integerQuotient = 324, 
            RULE_integerRemainder = 325, RULE_integerSubtract = 326, RULE_integerSum = 327, 
            RULE_integerValue = 328, RULE_interconnectAnnotate = 329, RULE_interconnectAttachedText = 330, 
            RULE_interconnectDelay = 331, RULE_interconnectDelayDisplay = 332, 
            RULE_interconnectDelayNameDef = 333, RULE_interconnectDelayNameRef = 334, 
            RULE_interconnectHeader = 335, RULE_interconnectNameCaseSensitive = 336, 
            RULE_interconnectNameDef = 337, RULE_interconnectNameDisplay = 338, 
            RULE_interconnectNameRef = 339, RULE_interconnectPropertyDisplay = 340, 
            RULE_interconnectRef = 341, RULE_interconnectSet = 342, RULE_einterface = 343, 
            RULE_interfaceJoined = 344, RULE_interfaceUnits = 345, RULE_iso8859 = 346, 
            RULE_iso8859Part = 347, RULE_isolated = 348, RULE_issue = 349, 
            RULE_italicStyle = 350, RULE_jisx0201 = 351, RULE_jisx0208 = 352, 
            RULE_joinedAsSignal = 353, RULE_joule = 354, RULE_k0KeywordLevel = 355, 
            RULE_k1KeywordAlias = 356, RULE_k1KeywordLevel = 357, RULE_k1KeywordNameDef = 358, 
            RULE_k1KeywordNameRef = 359, RULE_k2Actual = 360, RULE_k2Build = 361, 
            RULE_k2Formal = 362, RULE_k2FormalNameDef = 363, RULE_k2FormalNameRef = 364, 
            RULE_k2Generate = 365, RULE_k2KeywordDefine = 366, RULE_k2KeywordLevel = 367, 
            RULE_k2KeywordParameters = 368, RULE_k2Literal = 369, RULE_k2Optional = 370, 
            RULE_k2Required = 371, RULE_k3Build = 372, RULE_k3Collector = 373, 
            RULE_k3ForEach = 374, RULE_k3Formal = 375, RULE_k3FormalList = 376, 
            RULE_k3Generate = 377, RULE_k3KeywordDefine = 378, RULE_k3KeywordLevel = 379, 
            RULE_k3KeywordParameters = 380, RULE_kelvin = 381, RULE_keywordMap = 382, 
            RULE_kilogram = 383, RULE_leaf = 384, RULE_leafOccurrenceAnnotate = 385, 
            RULE_leftJustify = 386, RULE_lengthValue = 387, RULE_lessThan = 388, 
            RULE_lessThanOrEqual = 389, RULE_library = 390, RULE_libraryHeader = 391, 
            RULE_libraryNameCaseSensitive = 392, RULE_libraryNameDef = 393, 
            RULE_libraryNameRef = 394, RULE_libraryObjectNameCaseSensitive = 395, 
            RULE_libraryObjectNameDef = 396, RULE_libraryObjectNameRef = 397, 
            RULE_libraryRef = 398, RULE_loadDelay = 399, RULE_localPortGroup = 400, 
            RULE_localPortGroupNameCaseSensitive = 401, RULE_localPortGroupNameDef = 402, 
            RULE_localPortGroupNameRef = 403, RULE_localPortGroupRef = 404, 
            RULE_logicalConnectivity = 405, RULE_logicDefinitions = 406, 
            RULE_logicList = 407, RULE_logicMapInput = 408, RULE_logicMapOutput = 409, 
            RULE_logicModelUnits = 410, RULE_logicModelView = 411, RULE_logicNameDef = 412, 
            RULE_logicNameRef = 413, RULE_logicOneOf = 414, RULE_logicRef = 415, 
            RULE_logicValue = 416, RULE_lsbToMsb = 417, RULE_mantissa = 418, 
            RULE_mark = 419, RULE_maskLayoutUnits = 420, RULE_maskLayoutView = 421, 
            RULE_measured = 422, RULE_meter = 423, RULE_middleJustify = 424, 
            RULE_minimalWidth = 425, RULE_minimumStringLength = 426, RULE_miNoMax = 427, 
            RULE_miNoMaxValue = 428, RULE_minuend = 429, RULE_minuteNumber = 430, 
            RULE_mixedDirection = 431, RULE_mnm = 432, RULE_mole = 433, 
            RULE_monthNumber = 434, RULE_msbToLsb = 435, RULE_mustJoin = 436, 
            RULE_nameAlias = 437, RULE_nameCaseSensitivity = 438, RULE_nameDef = 439, 
            RULE_nameDimension = 440, RULE_nameDimensionStructure = 441, 
            RULE_nameInformation = 442, RULE_namePartSeparator = 443, RULE_nameRef = 444, 
            RULE_nameStructure = 445, RULE_narrowPort = 446, RULE_narrowWire = 447, 
            RULE_noHotspotGrid = 448, RULE_nominalHotspotGrid = 449, RULE_nonPermutable = 450, 
            RULE_not = 451, RULE_notInherited = 452, RULE_number = 453, 
            RULE_numberExpression = 454, RULE_numberOfBasicUnits = 455, 
            RULE_numberOfNewUnits = 456, RULE_numberParameter = 457, RULE_numberParameterAssign = 458, 
            RULE_numberParameterRef = 459, RULE_numberPoint = 460, RULE_numberValue = 461, 
            RULE_numerator = 462, RULE_occurrenceAnnotate = 463, RULE_occurrenceHierarchyAnnotate = 464, 
            RULE_offsetEvent = 465, RULE_ohm = 466, RULE_openShape = 467, 
            RULE_or = 468, RULE_origin = 469, RULE_originalBoundingBox = 470, 
            RULE_originalDrawingDate = 471, RULE_originalDrawingDateDisplay = 472, 
            RULE_originalName = 473, RULE_otherwiseFrame = 474, RULE_otherwiseFrameAnnotate = 475, 
            RULE_otherwiseFrameRef = 476, RULE_output = 477, RULE_outputPort = 478, 
            RULE_outputPortAttributes = 479, RULE_owner = 480, RULE_page = 481, 
            RULE_pageAnnotate = 482, RULE_pageBorder = 483, RULE_pageBorderTemplate = 484, 
            RULE_pageBorderTemplateRef = 485, RULE_pageCommentGraphics = 486, 
            RULE_pageHeader = 487, RULE_pageIdentification = 488, RULE_pageIdentificationDisplay = 489, 
            RULE_pageNameCaseSensitive = 490, RULE_pageNameDef = 491, RULE_pageNameRef = 492, 
            RULE_pagePropertyDisplay = 493, RULE_pageRef = 494, RULE_pageSize = 495, 
            RULE_pageTitle = 496, RULE_pageTitleBlock = 497, RULE_pageTitleBlockAttributeDisplay = 498, 
            RULE_pageTitleBlockAttributes = 499, RULE_pageTitleBlockTemplate = 500, 
            RULE_pageTitleBlockTemplateRef = 501, RULE_pageTitleDisplay = 502, 
            RULE_parameterDisplay = 503, RULE_parameterNameCaseSensitive = 504, 
            RULE_parameterNameDef = 505, RULE_parameterNameDisplay = 506, 
            RULE_parameterNameRef = 507, RULE_path = 508, RULE_pathDelay = 509, 
            RULE_pathWidth = 510, RULE_pcbLayoutUnits = 511, RULE_pcbLayoutView = 512, 
            RULE_permutable = 513, RULE_physicalDefaults = 514, RULE_physicalScaling = 515, 
            RULE_pixelPattern = 516, RULE_pixelRow = 517, RULE_point = 518, 
            RULE_pointList = 519, RULE_pointValue = 520, RULE_polygon = 521, 
            RULE_port = 522, RULE_portAnnotate = 523, RULE_portAttributeDisplay = 524, 
            RULE_portBundle = 525, RULE_portDelay = 526, RULE_portDelayDisplay = 527, 
            RULE_portDelayNameDef = 528, RULE_portDelayNameRef = 529, RULE_portDelayOverride = 530, 
            RULE_portDirection = 531, RULE_portDirectionIndicator = 532, 
            RULE_portIndexValue = 533, RULE_portInstanceRef = 534, RULE_portJoined = 535, 
            RULE_portList = 536, RULE_portLoadDelay = 537, RULE_portLoadDelayDisplay = 538, 
            RULE_portLoadDelayNameDef = 539, RULE_portLoadDelayNameRef = 540, 
            RULE_portLoadDelayOverride = 541, RULE_portMemberRef = 542, 
            RULE_portNameCaseSensitive = 543, RULE_portNameDef = 544, RULE_portNameDisplay = 545, 
            RULE_portNameGenerator = 546, RULE_portNameGeneratorDisplay = 547, 
            RULE_portNameRef = 548, RULE_portPropertyDisplay = 549, RULE_portPropertyDisplayOverride = 550, 
            RULE_portPropertyOverride = 551, RULE_portRef = 552, RULE_portSet = 553, 
            RULE_portWidth = 554, RULE_presentLogicValue = 555, RULE_previousLogicValue = 556, 
            RULE_previousVersion = 557, RULE_primaryName = 558, RULE_program = 559, 
            RULE_property = 560, RULE_propertyDisplay = 561, RULE_propertyDisplayOverride = 562, 
            RULE_propertyInheritanceControl = 563, RULE_propertyNameCaseSensitive = 564, 
            RULE_propertyNameDef = 565, RULE_propertyNameDisplay = 566, 
            RULE_propertyNameRef = 567, RULE_propertyOverride = 568, RULE_proportionalFont = 569, 
            RULE_pt = 570, RULE_pt1 = 571, RULE_pt2 = 572, RULE_radian = 573, 
            RULE_reason = 574, RULE_rectangle = 575, RULE_red = 576, RULE_removeDisplay = 577, 
            RULE_repetitionCount = 578, RULE_repetitionCountDisplay = 579, 
            RULE_replaceDisplay = 580, RULE_required = 581, RULE_resolves = 582, 
            RULE_revision = 583, RULE_revisionDisplay = 584, RULE_rightJustify = 585, 
            RULE_ripperHotspot = 586, RULE_ripperHotspotRef = 587, RULE_rotation = 588, 
            RULE_round = 589, RULE_rowSize = 590, RULE_scaledInteger = 591, 
            RULE_scaleX = 592, RULE_scaleY = 593, RULE_schematicBus = 594, 
            RULE_schematicBusDetails = 595, RULE_schematicBusGraphics = 596, 
            RULE_schematicBusJoined = 597, RULE_schematicBusSlice = 598, 
            RULE_schematicComplexFigure = 599, RULE_schematicFigureMacro = 600, 
            RULE_schematicFigureMacroRef = 601, RULE_schematicForFrameBorder = 602, 
            RULE_schematicForFrameBorderTemplate = 603, RULE_schematicForFrameBorderTemplateRef = 604, 
            RULE_schematicForFrameImplementation = 605, RULE_schematicForFrameImplementationHeader = 606, 
            RULE_schematicFrameImplementationDetails = 607, RULE_schematicGlobalPortAttributes = 608, 
            RULE_schematicGlobalPortImplementation = 609, RULE_schematicGlobalPortImplementationRef = 610, 
            RULE_schematicGlobalPortTemplate = 611, RULE_schematicGlobalPortTemplateRef = 612, 
            RULE_schematicIfFrameBorder = 613, RULE_schematicIfFrameBorderTemplate = 614, 
            RULE_schematicIfFrameBorderTemplateRef = 615, RULE_schematicIfFrameImplementation = 616, 
            RULE_schematicIfFrameImplementationHeader = 617, RULE_schematicImplementation = 618, 
            RULE_schematicInstanceImplementation = 619, RULE_schematicInstanceImplementationRef = 620, 
            RULE_schematicInterconnectAttributeDisplay = 621, RULE_schematicInterconnectHeader = 622, 
            RULE_schematicInterconnectTerminatorImplementation = 623, RULE_schematicInterconnectTerminatorImplementationRef = 624, 
            RULE_schematicInterconnectTerminatorTemplate = 625, RULE_schematicInterconnectTerminatorTemplateRef = 626, 
            RULE_schematicJunctionImplementation = 627, RULE_schematicJunctionImplementationRef = 628, 
            RULE_schematicJunctionTemplate = 629, RULE_schematicJunctionTemplateRef = 630, 
            RULE_schematicMasterPortImplementation = 631, RULE_schematicMasterPortImplementationRef = 632, 
            RULE_schematicMasterPortTemplate = 633, RULE_schematicMasterPortTemplateRef = 634, 
            RULE_schematicMetric = 635, RULE_schematicNet = 636, RULE_schematicNetDetails = 637, 
            RULE_schematicNetGraphics = 638, RULE_schematicNetJoined = 639, 
            RULE_schematicOffPageConnectorImplementation = 640, RULE_schematicOffPageConnectorImplementationRef = 641, 
            RULE_schematicOffPageConnectorTemplate = 642, RULE_schematicOffPageConnectorTemplateRef = 643, 
            RULE_schematicOnPageConnectorImplementation = 644, RULE_schematicOnPageConnectorImplementationRef = 645, 
            RULE_schematicOnPageConnectorTemplate = 646, RULE_schematicOnPageConnectorTemplateRef = 647, 
            RULE_schematicOtherwiseFrameBorder = 648, RULE_schematicOtherwiseFrameBorderTemplate = 649, 
            RULE_schematicOtherwiseFrameBorderTemplateRef = 650, RULE_schematicOtherwiseFrameImplementation = 651, 
            RULE_schematicOtherwiseFrameImplementationHeader = 652, RULE_schematicPortAcPower = 653, 
            RULE_schematicPortAcPowerRecommendedFrequency = 654, RULE_schematicPortAcPowerRecommendedVoltageRms = 655, 
            RULE_schematicPortAnalog = 656, RULE_schematicPortAttributes = 657, 
            RULE_schematicPortChassisGround = 658, RULE_schematicPortClock = 659, 
            RULE_schematicPortDcPower = 660, RULE_schematicPortDcPowerRecommendedVoltage = 661, 
            RULE_schematicPortEarthGround = 662, RULE_schematicPortGround = 663, 
            RULE_schematicPortNonLogical = 664, RULE_schematicPortOpenCollector = 665, 
            RULE_schematicPortOpenEmitter = 666, RULE_schematicPortPower = 667, 
            RULE_schematicPortStyle = 668, RULE_schematicPortThreeState = 669, 
            RULE_schematicRequiredDefaults = 670, RULE_schematicRipperImplementation = 671, 
            RULE_schematicRipperImplementationRef = 672, RULE_schematicRipperTemplate = 673, 
            RULE_schematicRipperTemplateRef = 674, RULE_schematicSubBus = 675, 
            RULE_schematicSubBusSet = 676, RULE_schematicSubInterconnectHeader = 677, 
            RULE_schematicSubNet = 678, RULE_schematicSubNetSet = 679, RULE_schematicSymbol = 680, 
            RULE_schematicSymbolBorder = 681, RULE_schematicSymbolBorderTemplate = 682, 
            RULE_schematicSymbolBorderTemplateRef = 683, RULE_schematicSymbolHeader = 684, 
            RULE_schematicSymbolPortImplementation = 685, RULE_schematicSymbolPortImplementationRef = 686, 
            RULE_schematicSymbolPortTemplate = 687, RULE_schematicSymbolPortTemplateRef = 688, 
            RULE_schematicSymbolRef = 689, RULE_schematicTemplateHeader = 690, 
            RULE_schematicUnits = 691, RULE_schematicView = 692, RULE_schematicViewHeader = 693, 
            RULE_schematicWireAffinity = 694, RULE_schematicWireStyle = 695, 
            RULE_second = 696, RULE_secondIntegerExpression = 697, RULE_secondNumber = 698, 
            RULE_secondStringExpression = 699, RULE_section = 700, RULE_sectionNameDef = 701, 
            RULE_sectionTitle = 702, RULE_sequence = 703, RULE_setAngle = 704, 
            RULE_setCapacitance = 705, RULE_setCurrent = 706, RULE_setDistance = 707, 
            RULE_setFrequency = 708, RULE_setTime = 709, RULE_setVoltage = 710, 
            RULE_shape = 711, RULE_siemens = 712, RULE_signal = 713, RULE_signalAnnotate = 714, 
            RULE_signalGroup = 715, RULE_signalGroupAnnotate = 716, RULE_signalGroupNameCaseSensitive = 717, 
            RULE_signalGroupNameDef = 718, RULE_signalGroupNameRef = 719, 
            RULE_signalGroupRef = 720, RULE_signalIndexValue = 721, RULE_signalJoined = 722, 
            RULE_signalList = 723, RULE_signalMemberRef = 724, RULE_signalNameCaseSensitive = 725, 
            RULE_signalNameDef = 726, RULE_signalNameRef = 727, RULE_signalRef = 728, 
            RULE_signalWidth = 729, RULE_simpleName = 730, RULE_startPoint = 731, 
            RULE_status = 732, RULE_step = 733, RULE_string = 734, RULE_stringConcatenate = 735, 
            RULE_stringConstant = 736, RULE_stringConstantRef = 737, RULE_stringEqual = 738, 
            RULE_stringExpression = 739, RULE_stringLength = 740, RULE_stringParameter = 741, 
            RULE_stringParameterAssign = 742, RULE_stringParameterRef = 743, 
            RULE_stringPrefix = 744, RULE_stringSuffix = 745, RULE_stringValue = 746, 
            RULE_strong = 747, RULE_subIssue = 748, RULE_substring = 749, 
            RULE_substringLength = 750, RULE_substringOffset = 751, RULE_subtrahend = 752, 
            RULE_symbolicLayoutUnits = 753, RULE_symbolicLayoutView = 754, 
            RULE_symbolPortImplementationNameDef = 755, RULE_symbolPortImplementationNameRef = 756, 
            RULE_technology = 757, RULE_textHeight = 758, RULE_throughPoint = 759, 
            RULE_time = 760, RULE_timeDelay = 761, RULE_timeInterval = 762, 
            RULE_timeStamp = 763, RULE_timeValue = 764, RULE_timing = 765, 
            RULE_timingDisplay = 766, RULE_timingNameDef = 767, RULE_timingNameRef = 768, 
            RULE_toInteger = 769, RULE_topJustify = 770, RULE_totalPages = 771, 
            RULE_totalPagesDisplay = 772, RULE_transform = 773, RULE_transition = 774, 
            RULE_etrue = 775, RULE_truncate = 776, RULE_typedValue = 777, 
            RULE_typeface = 778, RULE_typefaceSuffix = 779, RULE_unconfigured = 780, 
            RULE_unconstrained = 781, RULE_undefined = 782, RULE_unit = 783, 
            RULE_unitDefinitions = 784, RULE_unitExponent = 785, RULE_unitNameDef = 786, 
            RULE_unitNameRef = 787, RULE_unitRef = 788, RULE_unrestricted = 789, 
            RULE_unspecified = 790, RULE_unspecifiedDirectionPort = 791, 
            RULE_untyped = 792, RULE_unused = 793, RULE_usableArea = 794, 
            RULE_userData = 795, RULE_userDataTag = 796, RULE_version = 797, 
            RULE_verticalJustification = 798, RULE_viewGroup = 799, RULE_viewGroupHeader = 800, 
            RULE_viewGroupNameCaseSensitive = 801, RULE_viewGroupNameDef = 802, 
            RULE_viewGroupNameRef = 803, RULE_viewGroupRef = 804, RULE_viewNameCaseSensitive = 805, 
            RULE_viewNameDef = 806, RULE_viewNameDisplay = 807, RULE_viewNameRef = 808, 
            RULE_viewPropertyDisplay = 809, RULE_viewPropertyOverride = 810, 
            RULE_viewRef = 811, RULE_visible = 812, RULE_volt = 813, RULE_voltageMap = 814, 
            RULE_voltageValue = 815, RULE_watt = 816, RULE_weak = 817, RULE_weakJoined = 818, 
            RULE_weber = 819, RULE_widePort = 820, RULE_wideWire = 821, 
            RULE_written = 822, RULE_xCoordinate = 823, RULE_xNumberValue = 824, 
            RULE_xor = 825, RULE_yCoordinate = 826, RULE_year = 827, RULE_yearNumber = 828, 
            RULE_yNumberValue = 829, RULE_integerToken = 830, RULE_stringToken = 831

	public
	static let ruleNames: [String] = [
		"goal", "absolute", "acLoad", "acLoadDisplay", "acLoadFactorCapacitance", 
		"acLoadFactorTime", "addDisplay", "ampere", "and", "angleValue", "annotate", 
		"approvedDate", "approvedDateDisplay", "arc", "ascii", "associatedInterconnectNameDisplay", 
		"attachmentPoint", "author", "backgroundColor", "baselineJustify", "becomes", 
		"behaviorView", "bidirectional", "bidirectionalPort", "bidirectionalPortAttributes", 
		"bitOrder", "blue", "boldStyle", "eboolean", "booleanConstant", "booleanConstantRef", 
		"booleanExpression", "booleanMap", "booleanParameter", "booleanParameterAssign", 
		"booleanParameterRef", "booleanToken", "booleanValue", "borderPattern", 
		"borderPatternVisible", "borderWidth", "bottomJustify", "calculated", 
		"candela", "capacitanceValue", "caplineJustify", "cell", "cellHeader", 
		"cellNameDisplay", "cellPropertyDisplay", "cellPropertyDisplayOverride", 
		"cellPropertyOverride", "cellRef", "celsius", "centerJustify", "characterEncoding", 
		"checkDate", "checkDateDisplay", "circle", "cluster", "clusterConfiguration", 
		"clusterConfigurationNameCaseSensitive", "clusterConfigurationNameDef", 
		"clusterConfigurationNameRef", "clusterConfigurationRef", "clusterHeader", 
		"clusterNameCaseSensitive", "clusterNameDef", "clusterNameRef", "clusterPropertyDisplay", 
		"clusterPropertyDisplayOverride", "clusterPropertyOverride", "clusterRef", 
		"color", "comment", "commentGraphics", "companyName", "companyNameDisplay", 
		"complementedName", "complementedNamePart", "complexGeometry", "complexName", 
		"compound", "condition", "conditionDisplay", "connectedSignalIndexGenerator", 
		"connectedSignalIndexGeneratorDisplay", "connectivityBus", "connectivityBusJoined", 
		"connectivityBusSlice", "connectivityFrameStructure", "connectivityFrameStructureNameDef", 
		"connectivityNet", "connectivityNetJoined", "connectivityRipper", "connectivityRipperNameDef", 
		"connectivityRipperNameRef", "connectivityRipperRef", "connectivityStructure", 
		"connectivitySubBus", "connectivitySubNet", "connectivityTagGenerator", 
		"connectivityTagGeneratorDisplay", "connectivityUnits", "connectivityView", 
		"connectivityViewHeader", "constantNameDef", "constantNameRef", "constantValues", 
		"contract", "contractDisplay", "copyright", "copyrightDisplay", "cornerType", 
		"coulomb", "criticality", "criticalityDisplay", "currentMap", "currentValue", 
		"curve", "dataOrigin", "date", "dayNumber", "dcFanInLoad", "dcFanInLoadDisplay", 
		"dcFanOutLoad", "dcFanOutLoadDisplay", "dcMaxFanIn", "dcMaxFanInDisplay", 
		"dcMaxFanOut", "dcMaxFanOutDisplay", "decimalToString", "defaultClusterConfiguration", 
		"defaultConnection", "degree", "delay", "denominator", "derivation", "derivedFrom", 
		"design", "designator", "designatorDisplay", "designHeader", "designHierarchy", 
		"designHierarchyHeader", "designHierarchyNameCaseSensitive", "designHierarchyNameDef", 
		"designNameCaseSensitive", "designNameDef", "designUnits", "diagram", 
		"diagramNameDef", "directionalPortAttributeOverride", "display", "displayAttributes", 
		"displayName", "displayNameOverride", "distanceValue", "dividend", "divisor", 
		"documentation", "documentationHeader", "documentationNameCaseSensitive", 
		"documentationNameDef", "documentationUnits", "dominates", "dot", "drawingDescription", 
		"drawingDescriptionDisplay", "drawingIdentification", "drawingIdentificationDisplay", 
		"drawingSize", "drawingSizeDisplay", "duration", "e", "edif", "edifHeader", 
		"edifLevel", "edifLevelValue", "edifNameDef", "edifVersion", "endPoint", 
		"endType", "engineeringDate", "engineeringDateDisplay", "event", "exponent", 
		"extend", "extendForFrameMemberDef", "extendFrameDef", "extendInstanceDef", 
		"extendInstanceMemberDef", "extendInterconnectDef", "extendPageDef", "extendPortDef", 
		"extendPortMemberDef", "extendSignalDef", "extendSignalGroupDef", "extendSignalMemberDef", 
		"external", "fahrenheit", "efalse", "farad", "figure", "figureGroup", 
		"figureGroupNameCaseSensitive", "figureGroupNameDef", "figureGroupNameRef", 
		"figureGroupOverride", "fillPattern", "fillPatternVisible", "firstIntegerExpression", 
		"firstStringExpression", "fixed", "font", "fontCapitalHeight", "fontDefinitions", 
		"fontDescent", "fontFamily", "fontHeight", "fontNameDef", "fontNameRef", 
		"fontProportions", "fontRef", "fonts", "fontWidth", "forbiddenEvent", 
		"forFrame", "forFrameAnnotate", "forFrameIndex", "forFrameIndexDisplay", 
		"forFrameIndexNameCaseSensitive", "forFrameIndexRef", "forFrameMemberRef", 
		"forFrameRef", "frameConfiguration", "frameNameCaseSensitive", "frameNameDef", 
		"frameNameRef", "frameRef", "frequencyValue", "fromBottom", "fromInteger", 
		"fromLeft", "fromRight", "fromTop", "generated", "geometryMacro", "geometryMacroHeader", 
		"geometryMacroRef", "geometryMacroUnits", "globalPort", "globalPortBundle", 
		"globalPortDefinitions", "globalPortList", "globalPortNameCaseSensitive", 
		"globalPortNameDef", "globalPortNameDisplay", "globalPortNameRef", "globalPortPropertyDisplay", 
		"globalPortRef", "globalPortScope", "green", "henry", "hertz", "horizontalJustification", 
		"hotspot", "hotspotConnectDirection", "hotspotGrid", "hotspotNameCaseSensitive", 
		"hotspotNameDef", "hotspotNameDisplay", "hotspotNameRef", "hourNumber", 
		"ieeeDesignation", "ieeeSection", "ieeeStandard", "ifFrame", "ifFrameAnnotate", 
		"ifFrameRef", "ifFrameSet", "ignore", "implementationNameCaseSensitive", 
		"implementationNameDef", "implementationNameDisplay", "implementationNameRef", 
		"indexEndDisplay", "indexNameDef", "indexNameDisplay", "indexNameRef", 
		"indexStart", "indexStartDisplay", "indexStep", "indexStepDisplay", "indexValue", 
		"input", "inputPort", "inputPortAttributes", "instance", "instanceConfiguration", 
		"instanceIndexValue", "instanceMemberRef", "instanceNameCaseSensitive", 
		"instanceNameDef", "instanceNameDisplay", "instanceNameGenerator", "instanceNameGeneratorDisplay", 
		"instanceNameRef", "instancePortAttributeDisplay", "instancePortAttributes", 
		"instancePropertyDisplay", "instancePropertyOverride", "instanceRef", 
		"instanceWidth", "instanceWidthDisplay", "integer", "integerConstant", 
		"integerConstantRef", "integerEqual", "integerExpression", "integerParameter", 
		"integerParameterAssign", "integerParameterRef", "integerProduct", "integerQuotient", 
		"integerRemainder", "integerSubtract", "integerSum", "integerValue", "interconnectAnnotate", 
		"interconnectAttachedText", "interconnectDelay", "interconnectDelayDisplay", 
		"interconnectDelayNameDef", "interconnectDelayNameRef", "interconnectHeader", 
		"interconnectNameCaseSensitive", "interconnectNameDef", "interconnectNameDisplay", 
		"interconnectNameRef", "interconnectPropertyDisplay", "interconnectRef", 
		"interconnectSet", "einterface", "interfaceJoined", "interfaceUnits", 
		"iso8859", "iso8859Part", "isolated", "issue", "italicStyle", "jisx0201", 
		"jisx0208", "joinedAsSignal", "joule", "k0KeywordLevel", "k1KeywordAlias", 
		"k1KeywordLevel", "k1KeywordNameDef", "k1KeywordNameRef", "k2Actual", 
		"k2Build", "k2Formal", "k2FormalNameDef", "k2FormalNameRef", "k2Generate", 
		"k2KeywordDefine", "k2KeywordLevel", "k2KeywordParameters", "k2Literal", 
		"k2Optional", "k2Required", "k3Build", "k3Collector", "k3ForEach", "k3Formal", 
		"k3FormalList", "k3Generate", "k3KeywordDefine", "k3KeywordLevel", "k3KeywordParameters", 
		"kelvin", "keywordMap", "kilogram", "leaf", "leafOccurrenceAnnotate", 
		"leftJustify", "lengthValue", "lessThan", "lessThanOrEqual", "library", 
		"libraryHeader", "libraryNameCaseSensitive", "libraryNameDef", "libraryNameRef", 
		"libraryObjectNameCaseSensitive", "libraryObjectNameDef", "libraryObjectNameRef", 
		"libraryRef", "loadDelay", "localPortGroup", "localPortGroupNameCaseSensitive", 
		"localPortGroupNameDef", "localPortGroupNameRef", "localPortGroupRef", 
		"logicalConnectivity", "logicDefinitions", "logicList", "logicMapInput", 
		"logicMapOutput", "logicModelUnits", "logicModelView", "logicNameDef", 
		"logicNameRef", "logicOneOf", "logicRef", "logicValue", "lsbToMsb", "mantissa", 
		"mark", "maskLayoutUnits", "maskLayoutView", "measured", "meter", "middleJustify", 
		"minimalWidth", "minimumStringLength", "miNoMax", "miNoMaxValue", "minuend", 
		"minuteNumber", "mixedDirection", "mnm", "mole", "monthNumber", "msbToLsb", 
		"mustJoin", "nameAlias", "nameCaseSensitivity", "nameDef", "nameDimension", 
		"nameDimensionStructure", "nameInformation", "namePartSeparator", "nameRef", 
		"nameStructure", "narrowPort", "narrowWire", "noHotspotGrid", "nominalHotspotGrid", 
		"nonPermutable", "not", "notInherited", "number", "numberExpression", 
		"numberOfBasicUnits", "numberOfNewUnits", "numberParameter", "numberParameterAssign", 
		"numberParameterRef", "numberPoint", "numberValue", "numerator", "occurrenceAnnotate", 
		"occurrenceHierarchyAnnotate", "offsetEvent", "ohm", "openShape", "or", 
		"origin", "originalBoundingBox", "originalDrawingDate", "originalDrawingDateDisplay", 
		"originalName", "otherwiseFrame", "otherwiseFrameAnnotate", "otherwiseFrameRef", 
		"output", "outputPort", "outputPortAttributes", "owner", "page", "pageAnnotate", 
		"pageBorder", "pageBorderTemplate", "pageBorderTemplateRef", "pageCommentGraphics", 
		"pageHeader", "pageIdentification", "pageIdentificationDisplay", "pageNameCaseSensitive", 
		"pageNameDef", "pageNameRef", "pagePropertyDisplay", "pageRef", "pageSize", 
		"pageTitle", "pageTitleBlock", "pageTitleBlockAttributeDisplay", "pageTitleBlockAttributes", 
		"pageTitleBlockTemplate", "pageTitleBlockTemplateRef", "pageTitleDisplay", 
		"parameterDisplay", "parameterNameCaseSensitive", "parameterNameDef", 
		"parameterNameDisplay", "parameterNameRef", "path", "pathDelay", "pathWidth", 
		"pcbLayoutUnits", "pcbLayoutView", "permutable", "physicalDefaults", "physicalScaling", 
		"pixelPattern", "pixelRow", "point", "pointList", "pointValue", "polygon", 
		"port", "portAnnotate", "portAttributeDisplay", "portBundle", "portDelay", 
		"portDelayDisplay", "portDelayNameDef", "portDelayNameRef", "portDelayOverride", 
		"portDirection", "portDirectionIndicator", "portIndexValue", "portInstanceRef", 
		"portJoined", "portList", "portLoadDelay", "portLoadDelayDisplay", "portLoadDelayNameDef", 
		"portLoadDelayNameRef", "portLoadDelayOverride", "portMemberRef", "portNameCaseSensitive", 
		"portNameDef", "portNameDisplay", "portNameGenerator", "portNameGeneratorDisplay", 
		"portNameRef", "portPropertyDisplay", "portPropertyDisplayOverride", "portPropertyOverride", 
		"portRef", "portSet", "portWidth", "presentLogicValue", "previousLogicValue", 
		"previousVersion", "primaryName", "program", "property", "propertyDisplay", 
		"propertyDisplayOverride", "propertyInheritanceControl", "propertyNameCaseSensitive", 
		"propertyNameDef", "propertyNameDisplay", "propertyNameRef", "propertyOverride", 
		"proportionalFont", "pt", "pt1", "pt2", "radian", "reason", "rectangle", 
		"red", "removeDisplay", "repetitionCount", "repetitionCountDisplay", "replaceDisplay", 
		"required", "resolves", "revision", "revisionDisplay", "rightJustify", 
		"ripperHotspot", "ripperHotspotRef", "rotation", "round", "rowSize", "scaledInteger", 
		"scaleX", "scaleY", "schematicBus", "schematicBusDetails", "schematicBusGraphics", 
		"schematicBusJoined", "schematicBusSlice", "schematicComplexFigure", "schematicFigureMacro", 
		"schematicFigureMacroRef", "schematicForFrameBorder", "schematicForFrameBorderTemplate", 
		"schematicForFrameBorderTemplateRef", "schematicForFrameImplementation", 
		"schematicForFrameImplementationHeader", "schematicFrameImplementationDetails", 
		"schematicGlobalPortAttributes", "schematicGlobalPortImplementation", 
		"schematicGlobalPortImplementationRef", "schematicGlobalPortTemplate", 
		"schematicGlobalPortTemplateRef", "schematicIfFrameBorder", "schematicIfFrameBorderTemplate", 
		"schematicIfFrameBorderTemplateRef", "schematicIfFrameImplementation", 
		"schematicIfFrameImplementationHeader", "schematicImplementation", "schematicInstanceImplementation", 
		"schematicInstanceImplementationRef", "schematicInterconnectAttributeDisplay", 
		"schematicInterconnectHeader", "schematicInterconnectTerminatorImplementation", 
		"schematicInterconnectTerminatorImplementationRef", "schematicInterconnectTerminatorTemplate", 
		"schematicInterconnectTerminatorTemplateRef", "schematicJunctionImplementation", 
		"schematicJunctionImplementationRef", "schematicJunctionTemplate", "schematicJunctionTemplateRef", 
		"schematicMasterPortImplementation", "schematicMasterPortImplementationRef", 
		"schematicMasterPortTemplate", "schematicMasterPortTemplateRef", "schematicMetric", 
		"schematicNet", "schematicNetDetails", "schematicNetGraphics", "schematicNetJoined", 
		"schematicOffPageConnectorImplementation", "schematicOffPageConnectorImplementationRef", 
		"schematicOffPageConnectorTemplate", "schematicOffPageConnectorTemplateRef", 
		"schematicOnPageConnectorImplementation", "schematicOnPageConnectorImplementationRef", 
		"schematicOnPageConnectorTemplate", "schematicOnPageConnectorTemplateRef", 
		"schematicOtherwiseFrameBorder", "schematicOtherwiseFrameBorderTemplate", 
		"schematicOtherwiseFrameBorderTemplateRef", "schematicOtherwiseFrameImplementation", 
		"schematicOtherwiseFrameImplementationHeader", "schematicPortAcPower", 
		"schematicPortAcPowerRecommendedFrequency", "schematicPortAcPowerRecommendedVoltageRms", 
		"schematicPortAnalog", "schematicPortAttributes", "schematicPortChassisGround", 
		"schematicPortClock", "schematicPortDcPower", "schematicPortDcPowerRecommendedVoltage", 
		"schematicPortEarthGround", "schematicPortGround", "schematicPortNonLogical", 
		"schematicPortOpenCollector", "schematicPortOpenEmitter", "schematicPortPower", 
		"schematicPortStyle", "schematicPortThreeState", "schematicRequiredDefaults", 
		"schematicRipperImplementation", "schematicRipperImplementationRef", "schematicRipperTemplate", 
		"schematicRipperTemplateRef", "schematicSubBus", "schematicSubBusSet", 
		"schematicSubInterconnectHeader", "schematicSubNet", "schematicSubNetSet", 
		"schematicSymbol", "schematicSymbolBorder", "schematicSymbolBorderTemplate", 
		"schematicSymbolBorderTemplateRef", "schematicSymbolHeader", "schematicSymbolPortImplementation", 
		"schematicSymbolPortImplementationRef", "schematicSymbolPortTemplate", 
		"schematicSymbolPortTemplateRef", "schematicSymbolRef", "schematicTemplateHeader", 
		"schematicUnits", "schematicView", "schematicViewHeader", "schematicWireAffinity", 
		"schematicWireStyle", "second", "secondIntegerExpression", "secondNumber", 
		"secondStringExpression", "section", "sectionNameDef", "sectionTitle", 
		"sequence", "setAngle", "setCapacitance", "setCurrent", "setDistance", 
		"setFrequency", "setTime", "setVoltage", "shape", "siemens", "signal", 
		"signalAnnotate", "signalGroup", "signalGroupAnnotate", "signalGroupNameCaseSensitive", 
		"signalGroupNameDef", "signalGroupNameRef", "signalGroupRef", "signalIndexValue", 
		"signalJoined", "signalList", "signalMemberRef", "signalNameCaseSensitive", 
		"signalNameDef", "signalNameRef", "signalRef", "signalWidth", "simpleName", 
		"startPoint", "status", "step", "string", "stringConcatenate", "stringConstant", 
		"stringConstantRef", "stringEqual", "stringExpression", "stringLength", 
		"stringParameter", "stringParameterAssign", "stringParameterRef", "stringPrefix", 
		"stringSuffix", "stringValue", "strong", "subIssue", "substring", "substringLength", 
		"substringOffset", "subtrahend", "symbolicLayoutUnits", "symbolicLayoutView", 
		"symbolPortImplementationNameDef", "symbolPortImplementationNameRef", 
		"technology", "textHeight", "throughPoint", "time", "timeDelay", "timeInterval", 
		"timeStamp", "timeValue", "timing", "timingDisplay", "timingNameDef", 
		"timingNameRef", "toInteger", "topJustify", "totalPages", "totalPagesDisplay", 
		"transform", "transition", "etrue", "truncate", "typedValue", "typeface", 
		"typefaceSuffix", "unconfigured", "unconstrained", "undefined", "unit", 
		"unitDefinitions", "unitExponent", "unitNameDef", "unitNameRef", "unitRef", 
		"unrestricted", "unspecified", "unspecifiedDirectionPort", "untyped", 
		"unused", "usableArea", "userData", "userDataTag", "version", "verticalJustification", 
		"viewGroup", "viewGroupHeader", "viewGroupNameCaseSensitive", "viewGroupNameDef", 
		"viewGroupNameRef", "viewGroupRef", "viewNameCaseSensitive", "viewNameDef", 
		"viewNameDisplay", "viewNameRef", "viewPropertyDisplay", "viewPropertyOverride", 
		"viewRef", "visible", "volt", "voltageMap", "voltageValue", "watt", "weak", 
		"weakJoined", "weber", "widePort", "wideWire", "written", "xCoordinate", 
		"xNumberValue", "xor", "yCoordinate", "year", "yearNumber", "yNumberValue", 
		"integerToken", "stringToken"
	]

	private static let _LITERAL_NAMES: [String?] = [
		nil, "'(absolute'", "')'", "'(acLoad'", "'(acLoadDisplay'", "'(addDisplay'", 
		"'(ampere'", "'(and'", "'(annotate'", "'(approvedDate'", "'(approvedDateDisplay'", 
		"'(arc'", "'(ascii'", "'(associatedInterconnectNameDisplay'", "'(author'", 
		"'(backgroundColor'", "'(baselineJustify'", "'(becomes'", "'(behaviorView'", 
		"'(bidirectional'", "'(bidirectionalPort'", "'(bidirectionalPortAttributes'", 
		"'(bitOrder'", "'(boldStyle'", "'(boolean'", "'(booleanConstant'", "'(booleanConstantRef'", 
		"'(booleanMap'", "'(booleanParameter'", "'(booleanParameterAssign'", "'(booleanParameterRef'", 
		"'(borderPattern'", "'(borderPatternVisible'", "'(borderWidth'", "'(bottomJustify'", 
		"'(calculated'", "'(candela'", "'(caplineJustify'", "'(cell'", "'(cellHeader'", 
		"'(cellNameDisplay'", "'(cellPropertyDisplay'", "'(cellPropertyDisplayOverride'", 
		"'(cellPropertyOverride'", "'(cellRef'", "'(celsius'", "'(centerJustify'", 
		"'(characterEncoding'", "'(checkDate'", "'(checkDateDisplay'", "'(circle'", 
		"'(cluster'", "'(clusterConfiguration'", "'(clusterConfigurationNameCaseSensitive'", 
		"'(clusterConfigurationRef'", "'(clusterHeader'", "'(clusterNameCaseSensitive'", 
		"'(clusterPropertyDisplay'", "'(clusterPropertyDisplayOverride'", "'(clusterPropertyOverride'", 
		"'(clusterRef'", "'(color'", "'(comment'", "'(commentGraphics'", "'(companyName'", 
		"'(companyNameDisplay'", "'(complementedName'", "'(complementedNamePart'", 
		"'(complexGeometry'", "'(complexName'", "'(compound'", "'(condition'", 
		"'(conditionDisplay'", "'(connectedSignalIndexGenerator'", "'(connectedSignalIndexGeneratorDisplay'", 
		"'(connectivityBus'", "'(connectivityBusJoined'", "'(connectivityBusSlice'", 
		"'(connectivityFrameStructure'", "'(connectivityNet'", "'(connectivityNetJoined'", 
		"'(connectivityRipper'", "'(connectivityRipperRef'", "'(connectivityStructure'", 
		"'(connectivitySubBus'", "'(connectivitySubNet'", "'(connectivityTagGenerator'", 
		"'(connectivityTagGeneratorDisplay'", "'(connectivityUnits'", "'(connectivityView'", 
		"'(connectivityViewHeader'", "'(constantValues'", "'(contract'", "'(contractDisplay'", 
		"'(copyright'", "'(copyrightDisplay'", "'(cornerType'", "'(coulomb'", 
		"'(criticality'", "'(criticalityDisplay'", "'(currentMap'", "'(curve'", 
		"'(dataOrigin'", "'(date'", "'(dcFanInLoad'", "'(dcFanInLoadDisplay'", 
		"'(dcFanOutLoad'", "'(dcFanOutLoadDisplay'", "'(dcMaxFanIn'", "'(dcMaxFanInDisplay'", 
		"'(dcMaxFanOut'", "'(dcMaxFanOutDisplay'", "'(decimalToString'", "'(defaultClusterConfiguration'", 
		"'(defaultConnection'", "'(degree'", "'(delay'", "'(derivedFrom'", "'(design'", 
		"'(designator'", "'(designatorDisplay'", "'(designHeader'", "'(designHierarchy'", 
		"'(designHierarchyHeader'", "'(designHierarchyNameCaseSensitive'", "'(designNameCaseSensitive'", 
		"'(designUnits'", "'(diagram'", "'(directionalPortAttributeOverride'", 
		"'(display'", "'(displayAttributes'", "'(displayName'", "'(displayNameOverride'", 
		"'(documentation'", "'(documentationHeader'", "'(documentationNameCaseSensitive'", 
		"'(documentationUnits'", "'(dominates'", "'(dot'", "'(drawingDescription'", 
		"'(drawingDescriptionDisplay'", "'(drawingIdentification'", "'(drawingIdentificationDisplay'", 
		"'(drawingSize'", "'(drawingSizeDisplay'", "'(duration'", "'(e'", "'(edif'", 
		"'(edifHeader'", "'(edifLevel'", "'(edifVersion'", "'(endType'", "'(engineeringDate'", 
		"'(engineeringDateDisplay'", "'(event'", "'(extend'", "'(external'", "'(fahrenheit'", 
		"'(false'", "'(farad'", "'(figure'", "'(figureGroup'", "'(figureGroupNameCaseSensitive'", 
		"'(figureGroupOverride'", "'(fillPattern'", "'(fillPatternVisible'", "'(fixed'", 
		"'(font'", "'(fontCapitalHeight'", "'(fontDefinitions'", "'(fontDescent'", 
		"'(fontHeight'", "'(fontProportions'", "'(fontRef'", "'(fonts'", "'(fontWidth'", 
		"'(forbiddenEvent'", "'(forFrame'", "'(forFrameAnnotate'", "'(forFrameIndex'", 
		"'(forFrameIndexDisplay'", "'(forFrameIndexNameCaseSensitive'", "'(forFrameIndexRef'", 
		"'(forFrameMemberRef'", "'(forFrameRef'", "'(frameConfiguration'", "'(frameNameCaseSensitive'", 
		"'(frameRef'", "'(fromBottom'", "'(fromLeft'", "'(fromRight'", "'(fromTop'", 
		"'(generated'", "'(geometryMacro'", "'(geometryMacroHeader'", "'(geometryMacroRef'", 
		"'(geometryMacroUnits'", "'(globalPort'", "'(globalPortBundle'", "'(globalPortDefinitions'", 
		"'(globalPortList'", "'(globalPortNameCaseSensitive'", "'(globalPortNameDisplay'", 
		"'(globalPortPropertyDisplay'", "'(globalPortRef'", "'(globalPortScope'", 
		"'(henry'", "'(hertz'", "'(horizontalJustification'", "'(hotspot'", "'(hotspotConnectDirection'", 
		"'(hotspotGrid'", "'(hotspotNameCaseSensitive'", "'(hotspotNameDisplay'", 
		"'(ieeeSection'", "'(ieeeStandard'", "'(ifFrame'", "'(ifFrameAnnotate'", 
		"'(ifFrameRef'", "'(ifFrameSet'", "'(ignore'", "'(implementationNameCaseSensitive'", 
		"'(implementationNameDisplay'", "'(indexEndDisplay'", "'(indexNameDisplay'", 
		"'(indexStart'", "'(indexStartDisplay'", "'(indexStep'", "'(indexStepDisplay'", 
		"'(indexValue'", "'(input'", "'(inputPort'", "'(inputPortAttributes'", 
		"'(instance'", "'(instanceConfiguration'", "'(instanceIndexValue'", "'(instanceMemberRef'", 
		"'(instanceNameCaseSensitive'", "'(instanceNameDisplay'", "'(instanceNameGenerator'", 
		"'(instanceNameGeneratorDisplay'", "'(instancePortAttributeDisplay'", 
		"'(instancePortAttributes'", "'(instancePropertyDisplay'", "'(instancePropertyOverride'", 
		"'(instanceRef'", "'(instanceWidth'", "'(instanceWidthDisplay'", "'(integer'", 
		"'(integerConstant'", "'(integerConstantRef'", "'(integerEqual'", "'(integerParameter'", 
		"'(integerParameterAssign'", "'(integerParameterRef'", "'(integerProduct'", 
		"'(integerQuotient'", "'(integerRemainder'", "'(integerSubtract'", "'(integerSum'", 
		"'(interconnectAnnotate'", "'(interconnectAttachedText'", "'(interconnectDelay'", 
		"'(interconnectDelayDisplay'", "'(interconnectHeader'", "'(interconnectNameCaseSensitive'", 
		"'(interconnectNameDisplay'", "'(interconnectPropertyDisplay'", "'(interconnectRef'", 
		"'(interconnectSet'", "'(interface'", "'(interfaceJoined'", "'(interfaceUnits'", 
		"'(iso8859'", "'(isolated'", "'(italicStyle'", "'(jisx0201'", "'(jisx0208'", 
		"'(joinedAsSignal'", "'(joule'", "'(k0KeywordLevel'", "'(k1KeywordAlias'", 
		"'(k1KeywordLevel'", "'(k2Actual'", "'(k2Build'", "'(k2Formal'", "'(k2Generate'", 
		"'(k2KeywordDefine'", "'(k2KeywordLevel'", "'(k2KeywordParameters'", "'(k2Literal'", 
		"'(k2Optional'", "'(k2Required'", "'(k3Build'", "'(k3Collector'", "'(k3ForEach'", 
		"'(k3Formal'", "'(k3FormalList'", "'(k3Generate'", "'(k3KeywordDefine'", 
		"'(k3KeywordLevel'", "'(k3KeywordParameters'", "'(kelvin'", "'(keywordMap'", 
		"'(kilogram'", "'(leaf'", "'(leafOccurrenceAnnotate'", "'(leftJustify'", 
		"'(lessThan'", "'(lessThanOrEqual'", "'(library'", "'(libraryHeader'", 
		"'(libraryNameCaseSensitive'", "'(libraryObjectNameCaseSensitive'", "'(libraryRef'", 
		"'(loadDelay'", "'(localPortGroup'", "'(localPortGroupNameCaseSensitive'", 
		"'(localPortGroupRef'", "'(logicalConnectivity'", "'(logicDefinitions'", 
		"'(logicList'", "'(logicMapInput'", "'(logicMapOutput'", "'(logicModelUnits'", 
		"'(logicModelView'", "'(logicOneOf'", "'(logicRef'", "'(logicValue'", 
		"'(lsbToMsb'", "'(maskLayoutUnits'", "'(maskLayoutView'", "'(measured'", 
		"'(meter'", "'(middleJustify'", "'(minimalWidth'", "'(minimumStringLength'", 
		"'(miNoMax'", "'(mixedDirection'", "'(mnm'", "'(mole'", "'(msbToLsb'", 
		"'(mustJoin'", "'(nameAlias'", "'(nameCaseSensitivity'", "'(nameDimension'", 
		"'(nameDimensionStructure'", "'(nameInformation'", "'(namePartSeparator'", 
		"'(nameStructure'", "'(narrowPort'", "'(narrowWire'", "'(noHotspotGrid'", 
		"'(nominalHotspotGrid'", "'(nonPermutable'", "'(not'", "'(notInherited'", 
		"'(number'", "'(numberParameter'", "'(numberParameterAssign'", "'(numberParameterRef'", 
		"'(numberPoint'", "'(occurrenceAnnotate'", "'(occurrenceHierarchyAnnotate'", 
		"'(offsetEvent'", "'(ohm'", "'(openShape'", "'(or'", "'(origin'", "'(originalBoundingBox'", 
		"'(originalDrawingDate'", "'(originalDrawingDateDisplay'", "'(otherwiseFrame'", 
		"'(otherwiseFrameAnnotate'", "'(otherwiseFrameRef'", "'(output'", "'(outputPort'", 
		"'(outputPortAttributes'", "'(owner'", "'(page'", "'(pageAnnotate'", "'(pageBorder'", 
		"'(pageBorderTemplate'", "'(pageBorderTemplateRef'", "'(pageCommentGraphics'", 
		"'(pageHeader'", "'(pageIdentification'", "'(pageIdentificationDisplay'", 
		"'(pageNameCaseSensitive'", "'(pagePropertyDisplay'", "'(pageRef'", "'(pageSize'", 
		"'(pageTitle'", "'(pageTitleBlock'", "'(pageTitleBlockAttributeDisplay'", 
		"'(pageTitleBlockAttributes'", "'(pageTitleBlockTemplate'", "'(pageTitleBlockTemplateRef'", 
		"'(pageTitleDisplay'", "'(parameterDisplay'", "'(parameterNameCaseSensitive'", 
		"'(parameterNameDisplay'", "'(path'", "'(pathDelay'", "'(pathWidth'", 
		"'(pcbLayoutUnits'", "'(pcbLayoutView'", "'(permutable'", "'(physicalDefaults'", 
		"'(physicalScaling'", "'(pixelPattern'", "'(pixelRow'", "'(point'", "'(pointList'", 
		"'(polygon'", "'(port'", "'(portAnnotate'", "'(portAttributeDisplay'", 
		"'(portBundle'", "'(portDelay'", "'(portDelayDisplay'", "'(portDelayOverride'", 
		"'(portIndexValue'", "'(portInstanceRef'", "'(portJoined'", "'(portList'", 
		"'(portLoadDelay'", "'(portLoadDelayDisplay'", "'(portLoadDelayOverride'", 
		"'(portMemberRef'", "'(portNameCaseSensitive'", "'(portNameDisplay'", 
		"'(portNameGenerator'", "'(portNameGeneratorDisplay'", "'(portPropertyDisplay'", 
		"'(portPropertyDisplayOverride'", "'(portPropertyOverride'", "'(portRef'", 
		"'(portSet'", "'(portWidth'", "'(previousVersion'", "'(primaryName'", 
		"'(program'", "'(property'", "'(propertyDisplay'", "'(propertyDisplayOverride'", 
		"'(propertyInheritanceControl'", "'(propertyNameCaseSensitive'", "'(propertyNameDisplay'", 
		"'(propertyOverride'", "'(proportionalFont'", "'(pt'", "'(radian'", "'(reason'", 
		"'(rectangle'", "'(removeDisplay'", "'(repetitionCount'", "'(repetitionCountDisplay'", 
		"'(replaceDisplay'", "'(required'", "'(resolves'", "'(revision'", "'(revisionDisplay'", 
		"'(rightJustify'", "'(ripperHotspot'", "'(ripperHotspotRef'", "'(rotation'", 
		"'(round'", "'(scaleX'", "'(scaleY'", "'(schematicBus'", "'(schematicBusDetails'", 
		"'(schematicBusGraphics'", "'(schematicBusJoined'", "'(schematicBusSlice'", 
		"'(schematicComplexFigure'", "'(schematicFigureMacro'", "'(schematicFigureMacroRef'", 
		"'(schematicForFrameBorder'", "'(schematicForFrameBorderTemplate'", "'(schematicForFrameBorderTemplateRef'", 
		"'(schematicForFrameImplementation'", "'(schematicForFrameImplementationHeader'", 
		"'(schematicFrameImplementationDetails'", "'(schematicGlobalPortAttributes'", 
		"'(schematicGlobalPortImplementation'", "'(schematicGlobalPortImplementationRef'", 
		"'(schematicGlobalPortTemplate'", "'(schematicGlobalPortTemplateRef'", 
		"'(schematicIfFrameBorder'", "'(schematicIfFrameBorderTemplate'", "'(schematicIfFrameBorderTemplateRef'", 
		"'(schematicIfFrameImplementation'", "'(schematicIfFrameImplementationHeader'", 
		"'(schematicImplementation'", "'(schematicInstanceImplementation'", "'(schematicInstanceImplementationRef'", 
		"'(schematicInterconnectAttributeDisplay'", "'(schematicInterconnectHeader'", 
		"'(schematicInterconnectTerminatorImplementation'", "'(schematicInterconnectTerminatorImplementationRef'", 
		"'(schematicInterconnectTerminatorTemplate'", "'(schematicInterconnectTerminatorTemplateRef'", 
		"'(schematicJunctionImplementation'", "'(schematicJunctionImplementationRef'", 
		"'(schematicJunctionTemplate'", "'(schematicJunctionTemplateRef'", "'(schematicMasterPortImplementation'", 
		"'(schematicMasterPortImplementationRef'", "'(schematicMasterPortTemplate'", 
		"'(schematicMasterPortTemplateRef'", "'(schematicMetric'", "'(schematicNet'", 
		"'(schematicNetDetails'", "'(schematicNetGraphics'", "'(schematicNetJoined'", 
		"'(schematicOffPageConnectorImplementation'", "'(schematicOffPageConnectorImplementationRef'", 
		"'(schematicOffPageConnectorTemplate'", "'(schematicOffPageConnectorTemplateRef'", 
		"'(schematicOnPageConnectorImplementation'", "'(schematicOnPageConnectorImplementationRef'", 
		"'(schematicOnPageConnectorTemplate'", "'(schematicOnPageConnectorTemplateRef'", 
		"'(schematicOtherwiseFrameBorder'", "'(schematicOtherwiseFrameBorderTemplate'", 
		"'(schematicOtherwiseFrameBorderTemplateRef'", "'(schematicOtherwiseFrameImplementation'", 
		"'(schematicOtherwiseFrameImplementationHeader'", "'(schematicPortAcPower'", 
		"'(schematicPortAcPowerRecommendedFrequency'", "'(schematicPortAcPowerRecommendedVoltageRms'", 
		"'(schematicPortAnalog'", "'(schematicPortAttributes'", "'(schematicPortChassisGround'", 
		"'(schematicPortClock'", "'(schematicPortDcPower'", "'(schematicPortDcPowerRecommendedVoltage'", 
		"'(schematicPortEarthGround'", "'(schematicPortGround'", "'(schematicPortNonLogical'", 
		"'(schematicPortOpenCollector'", "'(schematicPortOpenEmitter'", "'(schematicPortPower'", 
		"'(schematicPortStyle'", "'(schematicPortThreeState'", "'(schematicRequiredDefaults'", 
		"'(schematicRipperImplementation'", "'(schematicRipperImplementationRef'", 
		"'(schematicRipperTemplate'", "'(schematicRipperTemplateRef'", "'(schematicSubBus'", 
		"'(schematicSubBusSet'", "'(schematicSubInterconnectHeader'", "'(schematicSubNet'", 
		"'(schematicSubNetSet'", "'(schematicSymbol'", "'(schematicSymbolBorder'", 
		"'(schematicSymbolBorderTemplate'", "'(schematicSymbolBorderTemplateRef'", 
		"'(schematicSymbolHeader'", "'(schematicSymbolPortImplementation'", "'(schematicSymbolPortImplementationRef'", 
		"'(schematicSymbolPortTemplate'", "'(schematicSymbolPortTemplateRef'", 
		"'(schematicSymbolRef'", "'(schematicTemplateHeader'", "'(schematicUnits'", 
		"'(schematicView'", "'(schematicViewHeader'", "'(schematicWireAffinity'", 
		"'(schematicWireStyle'", "'(second'", "'(section'", "'(sectionTitle'", 
		"'(sequence'", "'(setAngle'", "'(setCapacitance'", "'(setCurrent'", "'(setDistance'", 
		"'(setFrequency'", "'(setTime'", "'(setVoltage'", "'(shape'", "'(siemens'", 
		"'(signal'", "'(signalAnnotate'", "'(signalGroup'", "'(signalGroupAnnotate'", 
		"'(signalGroupNameCaseSensitive'", "'(signalGroupRef'", "'(signalIndexValue'", 
		"'(signalJoined'", "'(signalList'", "'(signalMemberRef'", "'(signalNameCaseSensitive'", 
		"'(signalRef'", "'(signalWidth'", "'(status'", "'(step'", "'(string'", 
		"'(stringConcatenate'", "'(stringConstant'", "'(stringConstantRef'", "'(stringEqual'", 
		"'(stringLength'", "'(stringParameter'", "'(stringParameterAssign'", "'(stringParameterRef'", 
		"'(stringPrefix'", "'(stringSuffix'", "'(strong'", "'(substring'", "'(symbolicLayoutUnits'", 
		"'(symbolicLayoutView'", "'(technology'", "'(textHeight'", "'(time'", 
		"'(timeInterval'", "'(timeStamp'", "'(timing'", "'(timingDisplay'", "'(topJustify'", 
		"'(totalPages'", "'(totalPagesDisplay'", "'(transform'", "'(transition'", 
		"'(true'", "'(truncate'", "'(typeface'", "'(typefaceSuffix'", "'(unconfigured'", 
		"'(unconstrained'", "'(undefined'", "'(unit'", "'(unitDefinitions'", "'(unitRef'", 
		"'(unrestricted'", "'(unspecified'", "'(unspecifiedDirectionPort'", "'(untyped'", 
		"'(unused'", "'(usableArea'", "'(userData'", "'(version'", "'(verticalJustification'", 
		"'(viewGroup'", "'(viewGroupHeader'", "'(viewGroupNameCaseSensitive'", 
		"'(viewGroupRef'", "'(viewNameCaseSensitive'", "'(viewNameDisplay'", "'(viewPropertyDisplay'", 
		"'(viewPropertyOverride'", "'(viewRef'", "'(visible'", "'(volt'", "'(voltageMap'", 
		"'(watt'", "'(weak'", "'(weakJoined'", "'(weber'", "'(widePort'", "'(wideWire'", 
		"'(written'", "'(xor'", "'(year'"
	]
	private static let _SYMBOLIC_NAMES: [String?] = [
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, "IDENTIFIER", "STRING_LITERAL", 
		"DECIMAL_LITERAL", "WS"
	]
	public
	static let VOCABULARY = Vocabulary(_LITERAL_NAMES, _SYMBOLIC_NAMES)

	override open
	func getGrammarFileName() -> String { return "EDIF300.g4" }

	override open
	func getRuleNames() -> [String] { return EDIF300Parser.ruleNames }

	override open
	func getSerializedATN() -> String { return EDIF300Parser._serializedATN }

	override open
	func getATN() -> ATN { return EDIF300Parser._ATN }

	override open
	func getVocabulary() -> Vocabulary {
	    return EDIF300Parser.VOCABULARY
	}

	override public
	init(_ input:TokenStream) throws {
	    RuntimeMetaData.checkVersion("4.7.1", RuntimeMetaData.VERSION)
		try super.init(input)
		_interp = ParserATNSimulator(self,EDIF300Parser._ATN,EDIF300Parser._decisionToDFA, EDIF300Parser._sharedContextCache)
	}

	public class GoalContext: ParserRuleContext {
			open
			func edif() -> EdifContext? {
				return getRuleContext(EdifContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_goal
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGoal(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGoal(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGoal(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGoal(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func goal() throws -> GoalContext {
		var _localctx: GoalContext = GoalContext(_ctx, getState())
		try enterRule(_localctx, 0, EDIF300Parser.RULE_goal)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1664)
		 	try edif()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AbsoluteContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_absolute
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAbsolute(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAbsolute(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAbsolute(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAbsolute(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func absolute() throws -> AbsoluteContext {
		var _localctx: AbsoluteContext = AbsoluteContext(_ctx, getState())
		try enterRule(_localctx, 2, EDIF300Parser.RULE_absolute)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1666)
		 	try match(EDIF300Parser.Tokens.T__0.rawValue)
		 	setState(1667)
		 	try integerExpression()
		 	setState(1668)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AcLoadContext: ParserRuleContext {
			open
			func capacitanceValue() -> CapacitanceValueContext? {
				return getRuleContext(CapacitanceValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_acLoad
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAcLoad(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAcLoad(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAcLoad(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAcLoad(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func acLoad() throws -> AcLoadContext {
		var _localctx: AcLoadContext = AcLoadContext(_ctx, getState())
		try enterRule(_localctx, 4, EDIF300Parser.RULE_acLoad)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1670)
		 	try match(EDIF300Parser.Tokens.T__2.rawValue)
		 	setState(1671)
		 	try capacitanceValue()
		 	setState(1672)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AcLoadDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_acLoadDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAcLoadDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAcLoadDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAcLoadDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAcLoadDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func acLoadDisplay() throws -> AcLoadDisplayContext {
		var _localctx: AcLoadDisplayContext = AcLoadDisplayContext(_ctx, getState())
		try enterRule(_localctx, 6, EDIF300Parser.RULE_acLoadDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1674)
		 	try match(EDIF300Parser.Tokens.T__3.rawValue)
		 	setState(1678)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(1675)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(1676)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(1677)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1680)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AcLoadFactorCapacitanceContext: ParserRuleContext {
			open
			func capacitanceValue() -> CapacitanceValueContext? {
				return getRuleContext(CapacitanceValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_acLoadFactorCapacitance
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAcLoadFactorCapacitance(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAcLoadFactorCapacitance(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAcLoadFactorCapacitance(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAcLoadFactorCapacitance(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func acLoadFactorCapacitance() throws -> AcLoadFactorCapacitanceContext {
		var _localctx: AcLoadFactorCapacitanceContext = AcLoadFactorCapacitanceContext(_ctx, getState())
		try enterRule(_localctx, 8, EDIF300Parser.RULE_acLoadFactorCapacitance)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1682)
		 	try capacitanceValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AcLoadFactorTimeContext: ParserRuleContext {
			open
			func timeValue() -> TimeValueContext? {
				return getRuleContext(TimeValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_acLoadFactorTime
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAcLoadFactorTime(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAcLoadFactorTime(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAcLoadFactorTime(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAcLoadFactorTime(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func acLoadFactorTime() throws -> AcLoadFactorTimeContext {
		var _localctx: AcLoadFactorTimeContext = AcLoadFactorTimeContext(_ctx, getState())
		try enterRule(_localctx, 10, EDIF300Parser.RULE_acLoadFactorTime)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1684)
		 	try timeValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AddDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_addDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAddDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAddDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAddDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAddDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func addDisplay() throws -> AddDisplayContext {
		var _localctx: AddDisplayContext = AddDisplayContext(_ctx, getState())
		try enterRule(_localctx, 12, EDIF300Parser.RULE_addDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1686)
		 	try match(EDIF300Parser.Tokens.T__4.rawValue)
		 	setState(1690)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1687)
		 		try display()


		 		setState(1692)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1693)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AmpereContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ampere
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAmpere(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAmpere(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAmpere(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAmpere(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ampere() throws -> AmpereContext {
		var _localctx: AmpereContext = AmpereContext(_ctx, getState())
		try enterRule(_localctx, 14, EDIF300Parser.RULE_ampere)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1695)
		 	try match(EDIF300Parser.Tokens.T__5.rawValue)
		 	setState(1696)
		 	try unitExponent()
		 	setState(1697)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AndContext: ParserRuleContext {
			open
			func booleanExpression() -> [BooleanExpressionContext] {
				return getRuleContexts(BooleanExpressionContext.self)
			}
			open
			func booleanExpression(_ i: Int) -> BooleanExpressionContext? {
				return getRuleContext(BooleanExpressionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_and
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAnd(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAnd(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAnd(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAnd(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func and() throws -> AndContext {
		var _localctx: AndContext = AndContext(_ctx, getState())
		try enterRule(_localctx, 16, EDIF300Parser.RULE_and)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1699)
		 	try match(EDIF300Parser.Tokens.T__6.rawValue)
		 	setState(1703)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__6.rawValue,EDIF300Parser.Tokens.T__25.rawValue,EDIF300Parser.Tokens.T__29.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__157.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__250.rawValue,EDIF300Parser.Tokens.T__307.rawValue,EDIF300Parser.Tokens.T__308.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 251)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__354.rawValue || _la == EDIF300Parser.Tokens.T__366.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__603.rawValue,EDIF300Parser.Tokens.T__626.rawValue,EDIF300Parser.Tokens.T__664.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 604)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(1700)
		 		try booleanExpression()


		 		setState(1705)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1706)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AngleValueContext: ParserRuleContext {
			open
			func numberValue() -> NumberValueContext? {
				return getRuleContext(NumberValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_angleValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAngleValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAngleValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAngleValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAngleValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func angleValue() throws -> AngleValueContext {
		var _localctx: AngleValueContext = AngleValueContext(_ctx, getState())
		try enterRule(_localctx, 18, EDIF300Parser.RULE_angleValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1708)
		 	try numberValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AnnotateContext: ParserRuleContext {
			open
			func stringValue() -> StringValueContext? {
				return getRuleContext(StringValueContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_annotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func annotate() throws -> AnnotateContext {
		var _localctx: AnnotateContext = AnnotateContext(_ctx, getState())
		try enterRule(_localctx, 20, EDIF300Parser.RULE_annotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1710)
		 	try match(EDIF300Parser.Tokens.T__7.rawValue)
		 	setState(1711)
		 	try stringValue()
		 	setState(1715)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1712)
		 		try display()


		 		setState(1717)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1718)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ApprovedDateContext: ParserRuleContext {
			open
			func date() -> DateContext? {
				return getRuleContext(DateContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_approvedDate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterApprovedDate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitApprovedDate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitApprovedDate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitApprovedDate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func approvedDate() throws -> ApprovedDateContext {
		var _localctx: ApprovedDateContext = ApprovedDateContext(_ctx, getState())
		try enterRule(_localctx, 22, EDIF300Parser.RULE_approvedDate)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1720)
		 	try match(EDIF300Parser.Tokens.T__8.rawValue)
		 	setState(1721)
		 	try date()
		 	setState(1722)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ApprovedDateDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_approvedDateDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterApprovedDateDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitApprovedDateDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitApprovedDateDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitApprovedDateDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func approvedDateDisplay() throws -> ApprovedDateDisplayContext {
		var _localctx: ApprovedDateDisplayContext = ApprovedDateDisplayContext(_ctx, getState())
		try enterRule(_localctx, 24, EDIF300Parser.RULE_approvedDateDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1724)
		 	try match(EDIF300Parser.Tokens.T__9.rawValue)
		 	setState(1728)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(1725)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(1726)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(1727)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1730)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ArcContext: ParserRuleContext {
			open
			func startPoint() -> StartPointContext? {
				return getRuleContext(StartPointContext.self, 0)
			}
			open
			func throughPoint() -> ThroughPointContext? {
				return getRuleContext(ThroughPointContext.self, 0)
			}
			open
			func endPoint() -> EndPointContext? {
				return getRuleContext(EndPointContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_arc
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterArc(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitArc(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitArc(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitArc(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func arc() throws -> ArcContext {
		var _localctx: ArcContext = ArcContext(_ctx, getState())
		try enterRule(_localctx, 26, EDIF300Parser.RULE_arc)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1732)
		 	try match(EDIF300Parser.Tokens.T__10.rawValue)
		 	setState(1733)
		 	try startPoint()
		 	setState(1734)
		 	try throughPoint()
		 	setState(1735)
		 	try endPoint()
		 	setState(1736)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AsciiContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ascii
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAscii(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAscii(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAscii(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAscii(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ascii() throws -> AsciiContext {
		var _localctx: AsciiContext = AsciiContext(_ctx, getState())
		try enterRule(_localctx, 28, EDIF300Parser.RULE_ascii)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1738)
		 	try match(EDIF300Parser.Tokens.T__11.rawValue)
		 	setState(1739)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AssociatedInterconnectNameDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_associatedInterconnectNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAssociatedInterconnectNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAssociatedInterconnectNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAssociatedInterconnectNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAssociatedInterconnectNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func associatedInterconnectNameDisplay() throws -> AssociatedInterconnectNameDisplayContext {
		var _localctx: AssociatedInterconnectNameDisplayContext = AssociatedInterconnectNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 30, EDIF300Parser.RULE_associatedInterconnectNameDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1741)
		 	try match(EDIF300Parser.Tokens.T__12.rawValue)
		 	setState(1745)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(1742)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(1743)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(1744)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1747)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AttachmentPointContext: ParserRuleContext {
			open
			func pointValue() -> PointValueContext? {
				return getRuleContext(PointValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_attachmentPoint
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAttachmentPoint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAttachmentPoint(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAttachmentPoint(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAttachmentPoint(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func attachmentPoint() throws -> AttachmentPointContext {
		var _localctx: AttachmentPointContext = AttachmentPointContext(_ctx, getState())
		try enterRule(_localctx, 32, EDIF300Parser.RULE_attachmentPoint)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1749)
		 	try pointValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AuthorContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_author
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterAuthor(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitAuthor(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitAuthor(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitAuthor(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func author() throws -> AuthorContext {
		var _localctx: AuthorContext = AuthorContext(_ctx, getState())
		try enterRule(_localctx, 34, EDIF300Parser.RULE_author)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1751)
		 	try match(EDIF300Parser.Tokens.T__13.rawValue)
		 	setState(1752)
		 	try stringToken()
		 	setState(1753)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BackgroundColorContext: ParserRuleContext {
			open
			func color() -> ColorContext? {
				return getRuleContext(ColorContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_backgroundColor
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBackgroundColor(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBackgroundColor(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBackgroundColor(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBackgroundColor(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func backgroundColor() throws -> BackgroundColorContext {
		var _localctx: BackgroundColorContext = BackgroundColorContext(_ctx, getState())
		try enterRule(_localctx, 36, EDIF300Parser.RULE_backgroundColor)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1755)
		 	try match(EDIF300Parser.Tokens.T__14.rawValue)
		 	setState(1756)
		 	try color()
		 	setState(1757)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BaselineJustifyContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_baselineJustify
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBaselineJustify(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBaselineJustify(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBaselineJustify(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBaselineJustify(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func baselineJustify() throws -> BaselineJustifyContext {
		var _localctx: BaselineJustifyContext = BaselineJustifyContext(_ctx, getState())
		try enterRule(_localctx, 38, EDIF300Parser.RULE_baselineJustify)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1759)
		 	try match(EDIF300Parser.Tokens.T__15.rawValue)
		 	setState(1760)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BecomesContext: ParserRuleContext {
			open
			func logicNameRef() -> LogicNameRefContext? {
				return getRuleContext(LogicNameRefContext.self, 0)
			}
			open
			func logicList() -> LogicListContext? {
				return getRuleContext(LogicListContext.self, 0)
			}
			open
			func logicOneOf() -> LogicOneOfContext? {
				return getRuleContext(LogicOneOfContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_becomes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBecomes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBecomes(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBecomes(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBecomes(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func becomes() throws -> BecomesContext {
		var _localctx: BecomesContext = BecomesContext(_ctx, getState())
		try enterRule(_localctx, 40, EDIF300Parser.RULE_becomes)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1762)
		 	try match(EDIF300Parser.Tokens.T__16.rawValue)
		 	setState(1766)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IDENTIFIER:
		 		setState(1763)
		 		try logicNameRef()

		 		break

		 	case .T__320:
		 		setState(1764)
		 		try logicList()

		 		break

		 	case .T__325:
		 		setState(1765)
		 		try logicOneOf()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1768)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BehaviorViewContext: ParserRuleContext {
			open
			func viewNameDef() -> ViewNameDefContext? {
				return getRuleContext(ViewNameDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_behaviorView
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBehaviorView(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBehaviorView(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBehaviorView(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBehaviorView(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func behaviorView() throws -> BehaviorViewContext {
		var _localctx: BehaviorViewContext = BehaviorViewContext(_ctx, getState())
		try enterRule(_localctx, 42, EDIF300Parser.RULE_behaviorView)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1770)
		 	try match(EDIF300Parser.Tokens.T__17.rawValue)
		 	setState(1771)
		 	try viewNameDef()
		 	setState(1777)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1775)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(1772)
		 			try comment()

		 			break

		 		case .T__346:
		 			setState(1773)
		 			try nameInformation()

		 			break

		 		case .T__642:
		 			setState(1774)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(1779)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1780)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BidirectionalContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_bidirectional
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBidirectional(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBidirectional(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBidirectional(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBidirectional(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func bidirectional() throws -> BidirectionalContext {
		var _localctx: BidirectionalContext = BidirectionalContext(_ctx, getState())
		try enterRule(_localctx, 44, EDIF300Parser.RULE_bidirectional)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1782)
		 	try match(EDIF300Parser.Tokens.T__18.rawValue)
		 	setState(1783)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BidirectionalPortContext: ParserRuleContext {
			open
			func bidirectionalPortAttributes() -> BidirectionalPortAttributesContext? {
				return getRuleContext(BidirectionalPortAttributesContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_bidirectionalPort
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBidirectionalPort(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBidirectionalPort(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBidirectionalPort(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBidirectionalPort(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func bidirectionalPort() throws -> BidirectionalPortContext {
		var _localctx: BidirectionalPortContext = BidirectionalPortContext(_ctx, getState())
		try enterRule(_localctx, 46, EDIF300Parser.RULE_bidirectionalPort)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1785)
		 	try match(EDIF300Parser.Tokens.T__19.rawValue)
		 	setState(1787)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__20.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1786)
		 		try bidirectionalPortAttributes()

		 	}

		 	setState(1789)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BidirectionalPortAttributesContext: ParserRuleContext {
			open
			func dcFanInLoad() -> [DcFanInLoadContext] {
				return getRuleContexts(DcFanInLoadContext.self)
			}
			open
			func dcFanInLoad(_ i: Int) -> DcFanInLoadContext? {
				return getRuleContext(DcFanInLoadContext.self, i)
			}
			open
			func dcFanOutLoad() -> [DcFanOutLoadContext] {
				return getRuleContexts(DcFanOutLoadContext.self)
			}
			open
			func dcFanOutLoad(_ i: Int) -> DcFanOutLoadContext? {
				return getRuleContext(DcFanOutLoadContext.self, i)
			}
			open
			func dcMaxFanIn() -> [DcMaxFanInContext] {
				return getRuleContexts(DcMaxFanInContext.self)
			}
			open
			func dcMaxFanIn(_ i: Int) -> DcMaxFanInContext? {
				return getRuleContext(DcMaxFanInContext.self, i)
			}
			open
			func dcMaxFanOut() -> [DcMaxFanOutContext] {
				return getRuleContexts(DcMaxFanOutContext.self)
			}
			open
			func dcMaxFanOut(_ i: Int) -> DcMaxFanOutContext? {
				return getRuleContext(DcMaxFanOutContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_bidirectionalPortAttributes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBidirectionalPortAttributes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBidirectionalPortAttributes(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBidirectionalPortAttributes(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBidirectionalPortAttributes(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func bidirectionalPortAttributes() throws -> BidirectionalPortAttributesContext {
		var _localctx: BidirectionalPortAttributesContext = BidirectionalPortAttributesContext(_ctx, getState())
		try enterRule(_localctx, 48, EDIF300Parser.RULE_bidirectionalPortAttributes)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1791)
		 	try match(EDIF300Parser.Tokens.T__20.rawValue)
		 	setState(1798)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__103.rawValue,EDIF300Parser.Tokens.T__105.rawValue,EDIF300Parser.Tokens.T__107.rawValue,EDIF300Parser.Tokens.T__109.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 104)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(1796)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__103:
		 			setState(1792)
		 			try dcFanInLoad()

		 			break

		 		case .T__105:
		 			setState(1793)
		 			try dcFanOutLoad()

		 			break

		 		case .T__107:
		 			setState(1794)
		 			try dcMaxFanIn()

		 			break

		 		case .T__109:
		 			setState(1795)
		 			try dcMaxFanOut()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(1800)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1801)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BitOrderContext: ParserRuleContext {
			open
			func lsbToMsb() -> LsbToMsbContext? {
				return getRuleContext(LsbToMsbContext.self, 0)
			}
			open
			func msbToLsb() -> MsbToLsbContext? {
				return getRuleContext(MsbToLsbContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_bitOrder
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBitOrder(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBitOrder(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBitOrder(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBitOrder(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func bitOrder() throws -> BitOrderContext {
		var _localctx: BitOrderContext = BitOrderContext(_ctx, getState())
		try enterRule(_localctx, 50, EDIF300Parser.RULE_bitOrder)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1803)
		 	try match(EDIF300Parser.Tokens.T__21.rawValue)
		 	setState(1806)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__328:
		 		setState(1804)
		 		try lsbToMsb()

		 		break

		 	case .T__340:
		 		setState(1805)
		 		try msbToLsb()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1808)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BlueContext: ParserRuleContext {
			open
			func scaledInteger() -> ScaledIntegerContext? {
				return getRuleContext(ScaledIntegerContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_blue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBlue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBlue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBlue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBlue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func blue() throws -> BlueContext {
		var _localctx: BlueContext = BlueContext(_ctx, getState())
		try enterRule(_localctx, 52, EDIF300Parser.RULE_blue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1810)
		 	try scaledInteger()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BoldStyleContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_boldStyle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBoldStyle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBoldStyle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBoldStyle(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBoldStyle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func boldStyle() throws -> BoldStyleContext {
		var _localctx: BoldStyleContext = BoldStyleContext(_ctx, getState())
		try enterRule(_localctx, 54, EDIF300Parser.RULE_boldStyle)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1812)
		 	try match(EDIF300Parser.Tokens.T__22.rawValue)
		 	setState(1813)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EbooleanContext: ParserRuleContext {
			open
			func booleanExpression() -> BooleanExpressionContext? {
				return getRuleContext(BooleanExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_eboolean
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEboolean(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEboolean(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEboolean(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEboolean(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func eboolean() throws -> EbooleanContext {
		var _localctx: EbooleanContext = EbooleanContext(_ctx, getState())
		try enterRule(_localctx, 56, EDIF300Parser.RULE_eboolean)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1815)
		 	try match(EDIF300Parser.Tokens.T__23.rawValue)
		 	setState(1816)
		 	try booleanExpression()
		 	setState(1817)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BooleanConstantContext: ParserRuleContext {
			open
			func constantNameDef() -> ConstantNameDefContext? {
				return getRuleContext(ConstantNameDefContext.self, 0)
			}
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_booleanConstant
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBooleanConstant(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBooleanConstant(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBooleanConstant(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBooleanConstant(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func booleanConstant() throws -> BooleanConstantContext {
		var _localctx: BooleanConstantContext = BooleanConstantContext(_ctx, getState())
		try enterRule(_localctx, 58, EDIF300Parser.RULE_booleanConstant)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1819)
		 	try match(EDIF300Parser.Tokens.T__24.rawValue)
		 	setState(1820)
		 	try constantNameDef()
		 	setState(1821)
		 	try booleanToken()
		 	setState(1822)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BooleanConstantRefContext: ParserRuleContext {
			open
			func constantNameRef() -> ConstantNameRefContext? {
				return getRuleContext(ConstantNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_booleanConstantRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBooleanConstantRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBooleanConstantRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBooleanConstantRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBooleanConstantRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func booleanConstantRef() throws -> BooleanConstantRefContext {
		var _localctx: BooleanConstantRefContext = BooleanConstantRefContext(_ctx, getState())
		try enterRule(_localctx, 60, EDIF300Parser.RULE_booleanConstantRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1824)
		 	try match(EDIF300Parser.Tokens.T__25.rawValue)
		 	setState(1825)
		 	try constantNameRef()
		 	setState(1826)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BooleanExpressionContext: ParserRuleContext {
			open
			func and() -> AndContext? {
				return getRuleContext(AndContext.self, 0)
			}
			open
			func booleanParameterRef() -> BooleanParameterRefContext? {
				return getRuleContext(BooleanParameterRefContext.self, 0)
			}
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
			open
			func stringEqual() -> StringEqualContext? {
				return getRuleContext(StringEqualContext.self, 0)
			}
			open
			func integerEqual() -> IntegerEqualContext? {
				return getRuleContext(IntegerEqualContext.self, 0)
			}
			open
			func lessThan() -> LessThanContext? {
				return getRuleContext(LessThanContext.self, 0)
			}
			open
			func lessThanOrEqual() -> LessThanOrEqualContext? {
				return getRuleContext(LessThanOrEqualContext.self, 0)
			}
			open
			func not() -> NotContext? {
				return getRuleContext(NotContext.self, 0)
			}
			open
			func or() -> OrContext? {
				return getRuleContext(OrContext.self, 0)
			}
			open
			func xor() -> XorContext? {
				return getRuleContext(XorContext.self, 0)
			}
			open
			func booleanConstantRef() -> BooleanConstantRefContext? {
				return getRuleContext(BooleanConstantRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_booleanExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBooleanExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBooleanExpression(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBooleanExpression(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBooleanExpression(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func booleanExpression() throws -> BooleanExpressionContext {
		var _localctx: BooleanExpressionContext = BooleanExpressionContext(_ctx, getState())
		try enterRule(_localctx, 62, EDIF300Parser.RULE_booleanExpression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1839)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__6:
		 		setState(1828)
		 		try and()

		 		break

		 	case .T__29:
		 		setState(1829)
		 		try booleanParameterRef()

		 		break
		 	case .T__157:fallthrough
		 	case .T__626:
		 		setState(1830)
		 		try booleanToken()

		 		break

		 	case .T__603:
		 		setState(1831)
		 		try stringEqual()

		 		break

		 	case .T__250:
		 		setState(1832)
		 		try integerEqual()

		 		break

		 	case .T__307:
		 		setState(1833)
		 		try lessThan()

		 		break

		 	case .T__308:
		 		setState(1834)
		 		try lessThanOrEqual()

		 		break

		 	case .T__354:
		 		setState(1835)
		 		try not()

		 		break

		 	case .T__366:
		 		setState(1836)
		 		try or()

		 		break

		 	case .T__664:
		 		setState(1837)
		 		try xor()

		 		break

		 	case .T__25:
		 		setState(1838)
		 		try booleanConstantRef()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BooleanMapContext: ParserRuleContext {
			open
			func booleanValue() -> BooleanValueContext? {
				return getRuleContext(BooleanValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_booleanMap
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBooleanMap(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBooleanMap(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBooleanMap(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBooleanMap(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func booleanMap() throws -> BooleanMapContext {
		var _localctx: BooleanMapContext = BooleanMapContext(_ctx, getState())
		try enterRule(_localctx, 64, EDIF300Parser.RULE_booleanMap)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1841)
		 	try match(EDIF300Parser.Tokens.T__26.rawValue)
		 	setState(1842)
		 	try booleanValue()
		 	setState(1843)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BooleanParameterContext: ParserRuleContext {
			open
			func parameterNameDef() -> ParameterNameDefContext? {
				return getRuleContext(ParameterNameDefContext.self, 0)
			}
			open
			func eboolean() -> [EbooleanContext] {
				return getRuleContexts(EbooleanContext.self)
			}
			open
			func eboolean(_ i: Int) -> EbooleanContext? {
				return getRuleContext(EbooleanContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_booleanParameter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBooleanParameter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBooleanParameter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBooleanParameter(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBooleanParameter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func booleanParameter() throws -> BooleanParameterContext {
		var _localctx: BooleanParameterContext = BooleanParameterContext(_ctx, getState())
		try enterRule(_localctx, 66, EDIF300Parser.RULE_booleanParameter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1845)
		 	try match(EDIF300Parser.Tokens.T__27.rawValue)
		 	setState(1846)
		 	try parameterNameDef()
		 	setState(1851)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__23.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1849)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__23:
		 			setState(1847)
		 			try eboolean()

		 			break

		 		case .T__346:
		 			setState(1848)
		 			try nameInformation()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(1853)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1854)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BooleanParameterAssignContext: ParserRuleContext {
			open
			func parameterNameRef() -> ParameterNameRefContext? {
				return getRuleContext(ParameterNameRefContext.self, 0)
			}
			open
			func booleanExpression() -> BooleanExpressionContext? {
				return getRuleContext(BooleanExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_booleanParameterAssign
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBooleanParameterAssign(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBooleanParameterAssign(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBooleanParameterAssign(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBooleanParameterAssign(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func booleanParameterAssign() throws -> BooleanParameterAssignContext {
		var _localctx: BooleanParameterAssignContext = BooleanParameterAssignContext(_ctx, getState())
		try enterRule(_localctx, 68, EDIF300Parser.RULE_booleanParameterAssign)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1856)
		 	try match(EDIF300Parser.Tokens.T__28.rawValue)
		 	setState(1857)
		 	try parameterNameRef()
		 	setState(1858)
		 	try booleanExpression()
		 	setState(1859)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BooleanParameterRefContext: ParserRuleContext {
			open
			func parameterNameRef() -> ParameterNameRefContext? {
				return getRuleContext(ParameterNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_booleanParameterRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBooleanParameterRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBooleanParameterRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBooleanParameterRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBooleanParameterRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func booleanParameterRef() throws -> BooleanParameterRefContext {
		var _localctx: BooleanParameterRefContext = BooleanParameterRefContext(_ctx, getState())
		try enterRule(_localctx, 70, EDIF300Parser.RULE_booleanParameterRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1861)
		 	try match(EDIF300Parser.Tokens.T__29.rawValue)
		 	setState(1862)
		 	try parameterNameRef()
		 	setState(1863)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BooleanTokenContext: ParserRuleContext {
			open
			func efalse() -> EfalseContext? {
				return getRuleContext(EfalseContext.self, 0)
			}
			open
			func etrue() -> EtrueContext? {
				return getRuleContext(EtrueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_booleanToken
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBooleanToken(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBooleanToken(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBooleanToken(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBooleanToken(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func booleanToken() throws -> BooleanTokenContext {
		var _localctx: BooleanTokenContext = BooleanTokenContext(_ctx, getState())
		try enterRule(_localctx, 72, EDIF300Parser.RULE_booleanToken)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1867)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__157:
		 		setState(1865)
		 		try efalse()

		 		break

		 	case .T__626:
		 		setState(1866)
		 		try etrue()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BooleanValueContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_booleanValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBooleanValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBooleanValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBooleanValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBooleanValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func booleanValue() throws -> BooleanValueContext {
		var _localctx: BooleanValueContext = BooleanValueContext(_ctx, getState())
		try enterRule(_localctx, 74, EDIF300Parser.RULE_booleanValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1869)
		 	try booleanToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BorderPatternContext: ParserRuleContext {
			open
			func pixelPattern() -> PixelPatternContext? {
				return getRuleContext(PixelPatternContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_borderPattern
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBorderPattern(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBorderPattern(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBorderPattern(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBorderPattern(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func borderPattern() throws -> BorderPatternContext {
		var _localctx: BorderPatternContext = BorderPatternContext(_ctx, getState())
		try enterRule(_localctx, 76, EDIF300Parser.RULE_borderPattern)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1871)
		 	try match(EDIF300Parser.Tokens.T__30.rawValue)
		 	setState(1872)
		 	try pixelPattern()
		 	setState(1873)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BorderPatternVisibleContext: ParserRuleContext {
			open
			func booleanValue() -> BooleanValueContext? {
				return getRuleContext(BooleanValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_borderPatternVisible
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBorderPatternVisible(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBorderPatternVisible(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBorderPatternVisible(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBorderPatternVisible(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func borderPatternVisible() throws -> BorderPatternVisibleContext {
		var _localctx: BorderPatternVisibleContext = BorderPatternVisibleContext(_ctx, getState())
		try enterRule(_localctx, 78, EDIF300Parser.RULE_borderPatternVisible)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1875)
		 	try match(EDIF300Parser.Tokens.T__31.rawValue)
		 	setState(1876)
		 	try booleanValue()
		 	setState(1877)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BorderWidthContext: ParserRuleContext {
			open
			func lengthValue() -> LengthValueContext? {
				return getRuleContext(LengthValueContext.self, 0)
			}
			open
			func minimalWidth() -> MinimalWidthContext? {
				return getRuleContext(MinimalWidthContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_borderWidth
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBorderWidth(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBorderWidth(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBorderWidth(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBorderWidth(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func borderWidth() throws -> BorderWidthContext {
		var _localctx: BorderWidthContext = BorderWidthContext(_ctx, getState())
		try enterRule(_localctx, 80, EDIF300Parser.RULE_borderWidth)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1879)
		 	try match(EDIF300Parser.Tokens.T__32.rawValue)
		 	setState(1882)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DECIMAL_LITERAL:
		 		setState(1880)
		 		try lengthValue()

		 		break

		 	case .T__334:
		 		setState(1881)
		 		try minimalWidth()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1884)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BottomJustifyContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_bottomJustify
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterBottomJustify(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitBottomJustify(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitBottomJustify(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitBottomJustify(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func bottomJustify() throws -> BottomJustifyContext {
		var _localctx: BottomJustifyContext = BottomJustifyContext(_ctx, getState())
		try enterRule(_localctx, 82, EDIF300Parser.RULE_bottomJustify)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1886)
		 	try match(EDIF300Parser.Tokens.T__33.rawValue)
		 	setState(1887)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CalculatedContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_calculated
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCalculated(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCalculated(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCalculated(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCalculated(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func calculated() throws -> CalculatedContext {
		var _localctx: CalculatedContext = CalculatedContext(_ctx, getState())
		try enterRule(_localctx, 84, EDIF300Parser.RULE_calculated)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1889)
		 	try match(EDIF300Parser.Tokens.T__34.rawValue)
		 	setState(1890)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CandelaContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_candela
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCandela(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCandela(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCandela(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCandela(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func candela() throws -> CandelaContext {
		var _localctx: CandelaContext = CandelaContext(_ctx, getState())
		try enterRule(_localctx, 86, EDIF300Parser.RULE_candela)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1892)
		 	try match(EDIF300Parser.Tokens.T__35.rawValue)
		 	setState(1893)
		 	try unitExponent()
		 	setState(1894)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CapacitanceValueContext: ParserRuleContext {
			open
			func miNoMaxValue() -> MiNoMaxValueContext? {
				return getRuleContext(MiNoMaxValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_capacitanceValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCapacitanceValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCapacitanceValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCapacitanceValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCapacitanceValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func capacitanceValue() throws -> CapacitanceValueContext {
		var _localctx: CapacitanceValueContext = CapacitanceValueContext(_ctx, getState())
		try enterRule(_localctx, 88, EDIF300Parser.RULE_capacitanceValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1896)
		 	try miNoMaxValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CaplineJustifyContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_caplineJustify
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCaplineJustify(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCaplineJustify(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCaplineJustify(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCaplineJustify(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func caplineJustify() throws -> CaplineJustifyContext {
		var _localctx: CaplineJustifyContext = CaplineJustifyContext(_ctx, getState())
		try enterRule(_localctx, 90, EDIF300Parser.RULE_caplineJustify)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1898)
		 	try match(EDIF300Parser.Tokens.T__36.rawValue)
		 	setState(1899)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CellContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func cellHeader() -> CellHeaderContext? {
				return getRuleContext(CellHeaderContext.self, 0)
			}
			open
			func cluster() -> [ClusterContext] {
				return getRuleContexts(ClusterContext.self)
			}
			open
			func cluster(_ i: Int) -> ClusterContext? {
				return getRuleContext(ClusterContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
			open
			func viewGroup() -> [ViewGroupContext] {
				return getRuleContexts(ViewGroupContext.self)
			}
			open
			func viewGroup(_ i: Int) -> ViewGroupContext? {
				return getRuleContext(ViewGroupContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_cell
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCell(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCell(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCell(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCell(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cell() throws -> CellContext {
		var _localctx: CellContext = CellContext(_ctx, getState())
		try enterRule(_localctx, 92, EDIF300Parser.RULE_cell)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1901)
		 	try match(EDIF300Parser.Tokens.T__37.rawValue)
		 	setState(1902)
		 	try libraryObjectNameDef()
		 	setState(1903)
		 	try cellHeader()
		 	setState(1910)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__50.rawValue || _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue || _la == EDIF300Parser.Tokens.T__645.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1908)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__50:
		 			setState(1904)
		 			try cluster()

		 			break

		 		case .T__61:
		 			setState(1905)
		 			try comment()

		 			break

		 		case .T__642:
		 			setState(1906)
		 			try userData()

		 			break

		 		case .T__645:
		 			setState(1907)
		 			try viewGroup()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(1912)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1913)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CellHeaderContext: ParserRuleContext {
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_cellHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCellHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCellHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCellHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCellHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cellHeader() throws -> CellHeaderContext {
		var _localctx: CellHeaderContext = CellHeaderContext(_ctx, getState())
		try enterRule(_localctx, 94, EDIF300Parser.RULE_cellHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1915)
		 	try match(EDIF300Parser.Tokens.T__38.rawValue)
		 	setState(1922)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1920)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__132:
		 			setState(1916)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(1917)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(1918)
		 			try property()

		 			break

		 		case .T__597:
		 			setState(1919)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(1924)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1925)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CellNameDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func displayNameOverride() -> [DisplayNameOverrideContext] {
				return getRuleContexts(DisplayNameOverrideContext.self)
			}
			open
			func displayNameOverride(_ i: Int) -> DisplayNameOverrideContext? {
				return getRuleContext(DisplayNameOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_cellNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCellNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCellNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCellNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCellNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cellNameDisplay() throws -> CellNameDisplayContext {
		var _localctx: CellNameDisplayContext = CellNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 96, EDIF300Parser.RULE_cellNameDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1927)
		 	try match(EDIF300Parser.Tokens.T__39.rawValue)
		 	setState(1932)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue || _la == EDIF300Parser.Tokens.T__131.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1930)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(1928)
		 			try display()

		 			break

		 		case .T__131:
		 			setState(1929)
		 			try displayNameOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(1934)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1935)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CellPropertyDisplayContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func propertyNameDisplay() -> [PropertyNameDisplayContext] {
				return getRuleContexts(PropertyNameDisplayContext.self)
			}
			open
			func propertyNameDisplay(_ i: Int) -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_cellPropertyDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCellPropertyDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCellPropertyDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCellPropertyDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCellPropertyDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cellPropertyDisplay() throws -> CellPropertyDisplayContext {
		var _localctx: CellPropertyDisplayContext = CellPropertyDisplayContext(_ctx, getState())
		try enterRule(_localctx, 98, EDIF300Parser.RULE_cellPropertyDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1937)
		 	try match(EDIF300Parser.Tokens.T__40.rawValue)
		 	setState(1938)
		 	try propertyNameRef()
		 	setState(1943)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1941)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(1939)
		 			try display()

		 			break

		 		case .T__447:
		 			setState(1940)
		 			try propertyNameDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(1945)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1946)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CellPropertyDisplayOverrideContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
			open
			func propertyNameDisplay() -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_cellPropertyDisplayOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCellPropertyDisplayOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCellPropertyDisplayOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCellPropertyDisplayOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCellPropertyDisplayOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cellPropertyDisplayOverride() throws -> CellPropertyDisplayOverrideContext {
		var _localctx: CellPropertyDisplayOverrideContext = CellPropertyDisplayOverrideContext(_ctx, getState())
		try enterRule(_localctx, 100, EDIF300Parser.RULE_cellPropertyDisplayOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1948)
		 	try match(EDIF300Parser.Tokens.T__41.rawValue)
		 	setState(1949)
		 	try propertyNameRef()
		 	setState(1953)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(1950)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(1951)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(1952)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1956)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1955)
		 		try propertyNameDisplay()

		 	}

		 	setState(1958)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CellPropertyOverrideContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func typedValue() -> TypedValueContext? {
				return getRuleContext(TypedValueContext.self, 0)
			}
			open
			func untyped() -> UntypedContext? {
				return getRuleContext(UntypedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func fixed() -> [FixedContext] {
				return getRuleContexts(FixedContext.self)
			}
			open
			func fixed(_ i: Int) -> FixedContext? {
				return getRuleContext(FixedContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_cellPropertyOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCellPropertyOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCellPropertyOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCellPropertyOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCellPropertyOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cellPropertyOverride() throws -> CellPropertyOverrideContext {
		var _localctx: CellPropertyOverrideContext = CellPropertyOverrideContext(_ctx, getState())
		try enterRule(_localctx, 102, EDIF300Parser.RULE_cellPropertyOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1960)
		 	try match(EDIF300Parser.Tokens.T__42.rawValue)
		 	setState(1961)
		 	try propertyNameRef()
		 	setState(1964)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__23:fallthrough
		 	case .T__247:fallthrough
		 	case .T__336:fallthrough
		 	case .T__356:fallthrough
		 	case .T__411:fallthrough
		 	case .T__599:
		 		setState(1962)
		 		try typedValue()

		 		break

		 	case .T__639:
		 		setState(1963)
		 		try untyped()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1971)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__165.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1969)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(1966)
		 			try comment()

		 			break

		 		case .T__165:
		 			setState(1967)
		 			try fixed()

		 			break

		 		case .T__448:
		 			setState(1968)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(1973)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1974)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CellRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_cellRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCellRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCellRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCellRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCellRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cellRef() throws -> CellRefContext {
		var _localctx: CellRefContext = CellRefContext(_ctx, getState())
		try enterRule(_localctx, 104, EDIF300Parser.RULE_cellRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1976)
		 	try match(EDIF300Parser.Tokens.T__43.rawValue)
		 	setState(1977)
		 	try libraryObjectNameRef()
		 	setState(1979)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1978)
		 		try libraryRef()

		 	}

		 	setState(1981)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CelsiusContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_celsius
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCelsius(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCelsius(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCelsius(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCelsius(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func celsius() throws -> CelsiusContext {
		var _localctx: CelsiusContext = CelsiusContext(_ctx, getState())
		try enterRule(_localctx, 106, EDIF300Parser.RULE_celsius)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1983)
		 	try match(EDIF300Parser.Tokens.T__44.rawValue)
		 	setState(1984)
		 	try unitExponent()
		 	setState(1985)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CenterJustifyContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_centerJustify
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCenterJustify(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCenterJustify(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCenterJustify(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCenterJustify(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func centerJustify() throws -> CenterJustifyContext {
		var _localctx: CenterJustifyContext = CenterJustifyContext(_ctx, getState())
		try enterRule(_localctx, 108, EDIF300Parser.RULE_centerJustify)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1987)
		 	try match(EDIF300Parser.Tokens.T__45.rawValue)
		 	setState(1988)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CharacterEncodingContext: ParserRuleContext {
			open
			func ascii() -> AsciiContext? {
				return getRuleContext(AsciiContext.self, 0)
			}
			open
			func iso8859() -> Iso8859Context? {
				return getRuleContext(Iso8859Context.self, 0)
			}
			open
			func jisx0201() -> Jisx0201Context? {
				return getRuleContext(Jisx0201Context.self, 0)
			}
			open
			func jisx0208() -> Jisx0208Context? {
				return getRuleContext(Jisx0208Context.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_characterEncoding
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCharacterEncoding(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCharacterEncoding(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCharacterEncoding(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCharacterEncoding(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func characterEncoding() throws -> CharacterEncodingContext {
		var _localctx: CharacterEncodingContext = CharacterEncodingContext(_ctx, getState())
		try enterRule(_localctx, 110, EDIF300Parser.RULE_characterEncoding)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1990)
		 	try match(EDIF300Parser.Tokens.T__46.rawValue)
		 	setState(1995)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__11:
		 		setState(1991)
		 		try ascii()

		 		break

		 	case .T__272:
		 		setState(1992)
		 		try iso8859()

		 		break

		 	case .T__275:
		 		setState(1993)
		 		try jisx0201()

		 		break

		 	case .T__276:
		 		setState(1994)
		 		try jisx0208()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1997)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CheckDateContext: ParserRuleContext {
			open
			func date() -> DateContext? {
				return getRuleContext(DateContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_checkDate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCheckDate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCheckDate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCheckDate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCheckDate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func checkDate() throws -> CheckDateContext {
		var _localctx: CheckDateContext = CheckDateContext(_ctx, getState())
		try enterRule(_localctx, 112, EDIF300Parser.RULE_checkDate)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1999)
		 	try match(EDIF300Parser.Tokens.T__47.rawValue)
		 	setState(2000)
		 	try date()
		 	setState(2001)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CheckDateDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_checkDateDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCheckDateDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCheckDateDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCheckDateDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCheckDateDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func checkDateDisplay() throws -> CheckDateDisplayContext {
		var _localctx: CheckDateDisplayContext = CheckDateDisplayContext(_ctx, getState())
		try enterRule(_localctx, 114, EDIF300Parser.RULE_checkDateDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2003)
		 	try match(EDIF300Parser.Tokens.T__48.rawValue)
		 	setState(2007)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2004)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2005)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2006)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2009)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CircleContext: ParserRuleContext {
			open
			func pt1() -> Pt1Context? {
				return getRuleContext(Pt1Context.self, 0)
			}
			open
			func pt2() -> Pt2Context? {
				return getRuleContext(Pt2Context.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_circle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCircle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCircle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCircle(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCircle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func circle() throws -> CircleContext {
		var _localctx: CircleContext = CircleContext(_ctx, getState())
		try enterRule(_localctx, 116, EDIF300Parser.RULE_circle)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2011)
		 	try match(EDIF300Parser.Tokens.T__49.rawValue)
		 	setState(2012)
		 	try pt1()
		 	setState(2013)
		 	try pt2()
		 	setState(2014)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterContext: ParserRuleContext {
			open
			func clusterNameDef() -> ClusterNameDefContext? {
				return getRuleContext(ClusterNameDefContext.self, 0)
			}
			open
			func einterface() -> EinterfaceContext? {
				return getRuleContext(EinterfaceContext.self, 0)
			}
			open
			func clusterHeader() -> ClusterHeaderContext? {
				return getRuleContext(ClusterHeaderContext.self, 0)
			}
			open
			func schematicSymbol() -> [SchematicSymbolContext] {
				return getRuleContexts(SchematicSymbolContext.self)
			}
			open
			func schematicSymbol(_ i: Int) -> SchematicSymbolContext? {
				return getRuleContext(SchematicSymbolContext.self, i)
			}
			open
			func schematicView() -> [SchematicViewContext] {
				return getRuleContexts(SchematicViewContext.self)
			}
			open
			func schematicView(_ i: Int) -> SchematicViewContext? {
				return getRuleContext(SchematicViewContext.self, i)
			}
			open
			func behaviorView() -> [BehaviorViewContext] {
				return getRuleContexts(BehaviorViewContext.self)
			}
			open
			func behaviorView(_ i: Int) -> BehaviorViewContext? {
				return getRuleContext(BehaviorViewContext.self, i)
			}
			open
			func clusterConfiguration() -> [ClusterConfigurationContext] {
				return getRuleContexts(ClusterConfigurationContext.self)
			}
			open
			func clusterConfiguration(_ i: Int) -> ClusterConfigurationContext? {
				return getRuleContext(ClusterConfigurationContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func connectivityView() -> [ConnectivityViewContext] {
				return getRuleContexts(ConnectivityViewContext.self)
			}
			open
			func connectivityView(_ i: Int) -> ConnectivityViewContext? {
				return getRuleContext(ConnectivityViewContext.self, i)
			}
			open
			func defaultClusterConfiguration() -> [DefaultClusterConfigurationContext] {
				return getRuleContexts(DefaultClusterConfigurationContext.self)
			}
			open
			func defaultClusterConfiguration(_ i: Int) -> DefaultClusterConfigurationContext? {
				return getRuleContext(DefaultClusterConfigurationContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
			open
			func logicModelView() -> [LogicModelViewContext] {
				return getRuleContexts(LogicModelViewContext.self)
			}
			open
			func logicModelView(_ i: Int) -> LogicModelViewContext? {
				return getRuleContext(LogicModelViewContext.self, i)
			}
			open
			func maskLayoutView() -> [MaskLayoutViewContext] {
				return getRuleContexts(MaskLayoutViewContext.self)
			}
			open
			func maskLayoutView(_ i: Int) -> MaskLayoutViewContext? {
				return getRuleContext(MaskLayoutViewContext.self, i)
			}
			open
			func pcbLayoutView() -> [PcbLayoutViewContext] {
				return getRuleContexts(PcbLayoutViewContext.self)
			}
			open
			func pcbLayoutView(_ i: Int) -> PcbLayoutViewContext? {
				return getRuleContext(PcbLayoutViewContext.self, i)
			}
			open
			func symbolicLayoutView() -> [SymbolicLayoutViewContext] {
				return getRuleContexts(SymbolicLayoutViewContext.self)
			}
			open
			func symbolicLayoutView(_ i: Int) -> SymbolicLayoutViewContext? {
				return getRuleContext(SymbolicLayoutViewContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_cluster
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCluster(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCluster(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCluster(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCluster(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cluster() throws -> ClusterContext {
		var _localctx: ClusterContext = ClusterContext(_ctx, getState())
		try enterRule(_localctx, 118, EDIF300Parser.RULE_cluster)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2016)
		 	try match(EDIF300Parser.Tokens.T__50.rawValue)
		 	setState(2017)
		 	try clusterNameDef()
		 	setState(2018)
		 	try einterface()
		 	setState(2019)
		 	try clusterHeader()
		 	setState(2034)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__17.rawValue,EDIF300Parser.Tokens.T__51.rawValue,EDIF300Parser.Tokens.T__61.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__88.rawValue || _la == EDIF300Parser.Tokens.T__112.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__324.rawValue || _la == EDIF300Parser.Tokens.T__330.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__405.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__555.rawValue,EDIF300Parser.Tokens.T__567.rawValue,EDIF300Parser.Tokens.T__613.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 556)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2032)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__555:
		 			setState(2020)
		 			try schematicSymbol()

		 			break

		 		case .T__567:
		 			setState(2021)
		 			try schematicView()

		 			break

		 		case .T__17:
		 			setState(2022)
		 			try behaviorView()

		 			break

		 		case .T__51:
		 			setState(2023)
		 			try clusterConfiguration()

		 			break

		 		case .T__61:
		 			setState(2024)
		 			try comment()

		 			break

		 		case .T__88:
		 			setState(2025)
		 			try connectivityView()

		 			break

		 		case .T__112:
		 			setState(2026)
		 			try defaultClusterConfiguration()

		 			break

		 		case .T__642:
		 			setState(2027)
		 			try userData()

		 			break

		 		case .T__324:
		 			setState(2028)
		 			try logicModelView()

		 			break

		 		case .T__330:
		 			setState(2029)
		 			try maskLayoutView()

		 			break

		 		case .T__405:
		 			setState(2030)
		 			try pcbLayoutView()

		 			break

		 		case .T__613:
		 			setState(2031)
		 			try symbolicLayoutView()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2036)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2037)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterConfigurationContext: ParserRuleContext {
			open
			func clusterConfigurationNameDef() -> ClusterConfigurationNameDefContext? {
				return getRuleContext(ClusterConfigurationNameDefContext.self, 0)
			}
			open
			func viewRef() -> ViewRefContext? {
				return getRuleContext(ViewRefContext.self, 0)
			}
			open
			func leaf() -> LeafContext? {
				return getRuleContext(LeafContext.self, 0)
			}
			open
			func unconfigured() -> UnconfiguredContext? {
				return getRuleContext(UnconfiguredContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func frameConfiguration() -> [FrameConfigurationContext] {
				return getRuleContexts(FrameConfigurationContext.self)
			}
			open
			func frameConfiguration(_ i: Int) -> FrameConfigurationContext? {
				return getRuleContext(FrameConfigurationContext.self, i)
			}
			open
			func globalPortScope() -> [GlobalPortScopeContext] {
				return getRuleContexts(GlobalPortScopeContext.self)
			}
			open
			func globalPortScope(_ i: Int) -> GlobalPortScopeContext? {
				return getRuleContext(GlobalPortScopeContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func instanceConfiguration() -> [InstanceConfigurationContext] {
				return getRuleContexts(InstanceConfigurationContext.self)
			}
			open
			func instanceConfiguration(_ i: Int) -> InstanceConfigurationContext? {
				return getRuleContext(InstanceConfigurationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterConfiguration
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterConfiguration(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterConfiguration(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterConfiguration(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterConfiguration(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterConfiguration() throws -> ClusterConfigurationContext {
		var _localctx: ClusterConfigurationContext = ClusterConfigurationContext(_ctx, getState())
		try enterRule(_localctx, 120, EDIF300Parser.RULE_clusterConfiguration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2039)
		 	try match(EDIF300Parser.Tokens.T__51.rawValue)
		 	setState(2040)
		 	try clusterConfigurationNameDef()
		 	setState(2044)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__653:
		 		setState(2041)
		 		try viewRef()

		 		break

		 	case .T__304:
		 		setState(2042)
		 		try leaf()

		 		break

		 	case .T__630:
		 		setState(2043)
		 		try unconfigured()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2055)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__184.rawValue,EDIF300Parser.Tokens.T__204.rawValue,EDIF300Parser.Tokens.T__233.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 185)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2053)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(2046)
		 			try comment()

		 			break

		 		case .T__184:
		 			setState(2047)
		 			try frameConfiguration()

		 			break

		 		case .T__204:
		 			setState(2048)
		 			try globalPortScope()

		 			break

		 		case .T__346:
		 			setState(2049)
		 			try nameInformation()

		 			break

		 		case .T__233:
		 			setState(2050)
		 			try instanceConfiguration()

		 			break

		 		case .T__442:
		 			setState(2051)
		 			try property()

		 			break

		 		case .T__642:
		 			setState(2052)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2057)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2058)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterConfigurationNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterConfigurationNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterConfigurationNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterConfigurationNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterConfigurationNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterConfigurationNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterConfigurationNameCaseSensitive() throws -> ClusterConfigurationNameCaseSensitiveContext {
		var _localctx: ClusterConfigurationNameCaseSensitiveContext = ClusterConfigurationNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 122, EDIF300Parser.RULE_clusterConfigurationNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2060)
		 	try match(EDIF300Parser.Tokens.T__52.rawValue)
		 	setState(2061)
		 	try booleanToken()
		 	setState(2062)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterConfigurationNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterConfigurationNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterConfigurationNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterConfigurationNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterConfigurationNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterConfigurationNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterConfigurationNameDef() throws -> ClusterConfigurationNameDefContext {
		var _localctx: ClusterConfigurationNameDefContext = ClusterConfigurationNameDefContext(_ctx, getState())
		try enterRule(_localctx, 124, EDIF300Parser.RULE_clusterConfigurationNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2064)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterConfigurationNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterConfigurationNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterConfigurationNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterConfigurationNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterConfigurationNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterConfigurationNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterConfigurationNameRef() throws -> ClusterConfigurationNameRefContext {
		var _localctx: ClusterConfigurationNameRefContext = ClusterConfigurationNameRefContext(_ctx, getState())
		try enterRule(_localctx, 126, EDIF300Parser.RULE_clusterConfigurationNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2066)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterConfigurationRefContext: ParserRuleContext {
			open
			func clusterConfigurationNameRef() -> ClusterConfigurationNameRefContext? {
				return getRuleContext(ClusterConfigurationNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterConfigurationRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterConfigurationRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterConfigurationRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterConfigurationRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterConfigurationRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterConfigurationRef() throws -> ClusterConfigurationRefContext {
		var _localctx: ClusterConfigurationRefContext = ClusterConfigurationRefContext(_ctx, getState())
		try enterRule(_localctx, 128, EDIF300Parser.RULE_clusterConfigurationRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2068)
		 	try match(EDIF300Parser.Tokens.T__53.rawValue)
		 	setState(2069)
		 	try clusterConfigurationNameRef()
		 	setState(2070)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterHeaderContext: ParserRuleContext {
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterHeader() throws -> ClusterHeaderContext {
		var _localctx: ClusterHeaderContext = ClusterHeaderContext(_ctx, getState())
		try enterRule(_localctx, 130, EDIF300Parser.RULE_clusterHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2072)
		 	try match(EDIF300Parser.Tokens.T__54.rawValue)
		 	setState(2079)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2077)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__132:
		 			setState(2073)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(2074)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(2075)
		 			try property()

		 			break

		 		case .T__597:
		 			setState(2076)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2081)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2082)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterNameCaseSensitive() throws -> ClusterNameCaseSensitiveContext {
		var _localctx: ClusterNameCaseSensitiveContext = ClusterNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 132, EDIF300Parser.RULE_clusterNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2084)
		 	try match(EDIF300Parser.Tokens.T__55.rawValue)
		 	setState(2085)
		 	try booleanToken()
		 	setState(2086)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterNameDef() throws -> ClusterNameDefContext {
		var _localctx: ClusterNameDefContext = ClusterNameDefContext(_ctx, getState())
		try enterRule(_localctx, 134, EDIF300Parser.RULE_clusterNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2088)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterNameRef() throws -> ClusterNameRefContext {
		var _localctx: ClusterNameRefContext = ClusterNameRefContext(_ctx, getState())
		try enterRule(_localctx, 136, EDIF300Parser.RULE_clusterNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2090)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterPropertyDisplayContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func propertyNameDisplay() -> [PropertyNameDisplayContext] {
				return getRuleContexts(PropertyNameDisplayContext.self)
			}
			open
			func propertyNameDisplay(_ i: Int) -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterPropertyDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterPropertyDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterPropertyDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterPropertyDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterPropertyDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterPropertyDisplay() throws -> ClusterPropertyDisplayContext {
		var _localctx: ClusterPropertyDisplayContext = ClusterPropertyDisplayContext(_ctx, getState())
		try enterRule(_localctx, 138, EDIF300Parser.RULE_clusterPropertyDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2092)
		 	try match(EDIF300Parser.Tokens.T__56.rawValue)
		 	setState(2093)
		 	try propertyNameRef()
		 	setState(2098)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2096)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(2094)
		 			try display()

		 			break

		 		case .T__447:
		 			setState(2095)
		 			try propertyNameDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2100)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2101)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterPropertyDisplayOverrideContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
			open
			func propertyNameDisplay() -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterPropertyDisplayOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterPropertyDisplayOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterPropertyDisplayOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterPropertyDisplayOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterPropertyDisplayOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterPropertyDisplayOverride() throws -> ClusterPropertyDisplayOverrideContext {
		var _localctx: ClusterPropertyDisplayOverrideContext = ClusterPropertyDisplayOverrideContext(_ctx, getState())
		try enterRule(_localctx, 140, EDIF300Parser.RULE_clusterPropertyDisplayOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2103)
		 	try match(EDIF300Parser.Tokens.T__57.rawValue)
		 	setState(2104)
		 	try propertyNameRef()
		 	setState(2108)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2105)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2106)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2107)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2111)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2110)
		 		try propertyNameDisplay()

		 	}

		 	setState(2113)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterPropertyOverrideContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func typedValue() -> TypedValueContext? {
				return getRuleContext(TypedValueContext.self, 0)
			}
			open
			func untyped() -> UntypedContext? {
				return getRuleContext(UntypedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func fixed() -> [FixedContext] {
				return getRuleContexts(FixedContext.self)
			}
			open
			func fixed(_ i: Int) -> FixedContext? {
				return getRuleContext(FixedContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterPropertyOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterPropertyOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterPropertyOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterPropertyOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterPropertyOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterPropertyOverride() throws -> ClusterPropertyOverrideContext {
		var _localctx: ClusterPropertyOverrideContext = ClusterPropertyOverrideContext(_ctx, getState())
		try enterRule(_localctx, 142, EDIF300Parser.RULE_clusterPropertyOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2115)
		 	try match(EDIF300Parser.Tokens.T__58.rawValue)
		 	setState(2116)
		 	try propertyNameRef()
		 	setState(2119)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__23:fallthrough
		 	case .T__247:fallthrough
		 	case .T__336:fallthrough
		 	case .T__356:fallthrough
		 	case .T__411:fallthrough
		 	case .T__599:
		 		setState(2117)
		 		try typedValue()

		 		break

		 	case .T__639:
		 		setState(2118)
		 		try untyped()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2126)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__165.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2124)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(2121)
		 			try comment()

		 			break

		 		case .T__165:
		 			setState(2122)
		 			try fixed()

		 			break

		 		case .T__448:
		 			setState(2123)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2128)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2129)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ClusterRefContext: ParserRuleContext {
			open
			func clusterNameRef() -> ClusterNameRefContext? {
				return getRuleContext(ClusterNameRefContext.self, 0)
			}
			open
			func cellRef() -> CellRefContext? {
				return getRuleContext(CellRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_clusterRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterClusterRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitClusterRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitClusterRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitClusterRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func clusterRef() throws -> ClusterRefContext {
		var _localctx: ClusterRefContext = ClusterRefContext(_ctx, getState())
		try enterRule(_localctx, 144, EDIF300Parser.RULE_clusterRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2131)
		 	try match(EDIF300Parser.Tokens.T__59.rawValue)
		 	setState(2132)
		 	try clusterNameRef()
		 	setState(2134)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__43.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2133)
		 		try cellRef()

		 	}

		 	setState(2136)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ColorContext: ParserRuleContext {
			open
			func red() -> RedContext? {
				return getRuleContext(RedContext.self, 0)
			}
			open
			func green() -> GreenContext? {
				return getRuleContext(GreenContext.self, 0)
			}
			open
			func blue() -> BlueContext? {
				return getRuleContext(BlueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_color
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterColor(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitColor(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitColor(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitColor(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func color() throws -> ColorContext {
		var _localctx: ColorContext = ColorContext(_ctx, getState())
		try enterRule(_localctx, 146, EDIF300Parser.RULE_color)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2138)
		 	try match(EDIF300Parser.Tokens.T__60.rawValue)
		 	setState(2139)
		 	try red()
		 	setState(2140)
		 	try green()
		 	setState(2141)
		 	try blue()
		 	setState(2142)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CommentContext: ParserRuleContext {
			open
			func stringToken() -> [StringTokenContext] {
				return getRuleContexts(StringTokenContext.self)
			}
			open
			func stringToken(_ i: Int) -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_comment
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterComment(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitComment(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitComment(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitComment(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func comment() throws -> CommentContext {
		var _localctx: CommentContext = CommentContext(_ctx, getState())
		try enterRule(_localctx, 148, EDIF300Parser.RULE_comment)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2144)
		 	try match(EDIF300Parser.Tokens.T__61.rawValue)
		 	setState(2148)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.STRING_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2145)
		 		try stringToken()


		 		setState(2150)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2151)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CommentGraphicsContext: ParserRuleContext {
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func originalBoundingBox() -> [OriginalBoundingBoxContext] {
				return getRuleContexts(OriginalBoundingBoxContext.self)
			}
			open
			func originalBoundingBox(_ i: Int) -> OriginalBoundingBoxContext? {
				return getRuleContext(OriginalBoundingBoxContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_commentGraphics
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCommentGraphics(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCommentGraphics(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCommentGraphics(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCommentGraphics(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func commentGraphics() throws -> CommentGraphicsContext {
		var _localctx: CommentGraphicsContext = CommentGraphicsContext(_ctx, getState())
		try enterRule(_localctx, 150, EDIF300Parser.RULE_commentGraphics)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2153)
		 	try match(EDIF300Parser.Tokens.T__62.rawValue)
		 	setState(2162)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__368.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__443.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2160)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(2154)
		 			try annotate()

		 			break

		 		case .T__61:
		 			setState(2155)
		 			try comment()

		 			break

		 		case .T__159:
		 			setState(2156)
		 			try figure()

		 			break

		 		case .T__368:
		 			setState(2157)
		 			try originalBoundingBox()

		 			break

		 		case .T__443:
		 			setState(2158)
		 			try propertyDisplay()

		 			break

		 		case .T__642:
		 			setState(2159)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2164)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2165)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CompanyNameContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_companyName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCompanyName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCompanyName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCompanyName(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCompanyName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func companyName() throws -> CompanyNameContext {
		var _localctx: CompanyNameContext = CompanyNameContext(_ctx, getState())
		try enterRule(_localctx, 152, EDIF300Parser.RULE_companyName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2167)
		 	try match(EDIF300Parser.Tokens.T__63.rawValue)
		 	setState(2168)
		 	try stringToken()
		 	setState(2169)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CompanyNameDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_companyNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCompanyNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCompanyNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCompanyNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCompanyNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func companyNameDisplay() throws -> CompanyNameDisplayContext {
		var _localctx: CompanyNameDisplayContext = CompanyNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 154, EDIF300Parser.RULE_companyNameDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2171)
		 	try match(EDIF300Parser.Tokens.T__64.rawValue)
		 	setState(2175)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2172)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2173)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2174)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2177)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ComplementedNameContext: ParserRuleContext {
			open
			func complementedNamePart() -> [ComplementedNamePartContext] {
				return getRuleContexts(ComplementedNamePartContext.self)
			}
			open
			func complementedNamePart(_ i: Int) -> ComplementedNamePartContext? {
				return getRuleContext(ComplementedNamePartContext.self, i)
			}
			open
			func nameDimension() -> [NameDimensionContext] {
				return getRuleContexts(NameDimensionContext.self)
			}
			open
			func nameDimension(_ i: Int) -> NameDimensionContext? {
				return getRuleContext(NameDimensionContext.self, i)
			}
			open
			func namePartSeparator() -> [NamePartSeparatorContext] {
				return getRuleContexts(NamePartSeparatorContext.self)
			}
			open
			func namePartSeparator(_ i: Int) -> NamePartSeparatorContext? {
				return getRuleContext(NamePartSeparatorContext.self, i)
			}
			open
			func simpleName() -> [SimpleNameContext] {
				return getRuleContexts(SimpleNameContext.self)
			}
			open
			func simpleName(_ i: Int) -> SimpleNameContext? {
				return getRuleContext(SimpleNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_complementedName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterComplementedName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitComplementedName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitComplementedName(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitComplementedName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func complementedName() throws -> ComplementedNameContext {
		var _localctx: ComplementedNameContext = ComplementedNameContext(_ctx, getState())
		try enterRule(_localctx, 156, EDIF300Parser.RULE_complementedName)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2179)
		 	try match(EDIF300Parser.Tokens.T__65.rawValue)
		 	setState(2186)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__66.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__344.rawValue || _la == EDIF300Parser.Tokens.T__347.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.STRING_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2184)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__66:
		 			setState(2180)
		 			try complementedNamePart()

		 			break

		 		case .T__344:
		 			setState(2181)
		 			try nameDimension()

		 			break

		 		case .T__347:
		 			setState(2182)
		 			try namePartSeparator()

		 			break

		 		case .STRING_LITERAL:
		 			setState(2183)
		 			try simpleName()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2188)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2189)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ComplementedNamePartContext: ParserRuleContext {
			open
			func complementedNamePart() -> [ComplementedNamePartContext] {
				return getRuleContexts(ComplementedNamePartContext.self)
			}
			open
			func complementedNamePart(_ i: Int) -> ComplementedNamePartContext? {
				return getRuleContext(ComplementedNamePartContext.self, i)
			}
			open
			func namePartSeparator() -> [NamePartSeparatorContext] {
				return getRuleContexts(NamePartSeparatorContext.self)
			}
			open
			func namePartSeparator(_ i: Int) -> NamePartSeparatorContext? {
				return getRuleContext(NamePartSeparatorContext.self, i)
			}
			open
			func simpleName() -> [SimpleNameContext] {
				return getRuleContexts(SimpleNameContext.self)
			}
			open
			func simpleName(_ i: Int) -> SimpleNameContext? {
				return getRuleContext(SimpleNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_complementedNamePart
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterComplementedNamePart(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitComplementedNamePart(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitComplementedNamePart(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitComplementedNamePart(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func complementedNamePart() throws -> ComplementedNamePartContext {
		var _localctx: ComplementedNamePartContext = ComplementedNamePartContext(_ctx, getState())
		try enterRule(_localctx, 158, EDIF300Parser.RULE_complementedNamePart)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2191)
		 	try match(EDIF300Parser.Tokens.T__66.rawValue)
		 	setState(2197)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__66.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__347.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.STRING_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2195)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__66:
		 			setState(2192)
		 			try complementedNamePart()

		 			break

		 		case .T__347:
		 			setState(2193)
		 			try namePartSeparator()

		 			break

		 		case .STRING_LITERAL:
		 			setState(2194)
		 			try simpleName()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2199)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2200)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ComplexGeometryContext: ParserRuleContext {
			open
			func geometryMacroRef() -> GeometryMacroRefContext? {
				return getRuleContext(GeometryMacroRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_complexGeometry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterComplexGeometry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitComplexGeometry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitComplexGeometry(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitComplexGeometry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func complexGeometry() throws -> ComplexGeometryContext {
		var _localctx: ComplexGeometryContext = ComplexGeometryContext(_ctx, getState())
		try enterRule(_localctx, 160, EDIF300Parser.RULE_complexGeometry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2202)
		 	try match(EDIF300Parser.Tokens.T__67.rawValue)
		 	setState(2203)
		 	try geometryMacroRef()
		 	setState(2204)
		 	try transform()
		 	setState(2205)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ComplexNameContext: ParserRuleContext {
			open
			func complementedNamePart() -> [ComplementedNamePartContext] {
				return getRuleContexts(ComplementedNamePartContext.self)
			}
			open
			func complementedNamePart(_ i: Int) -> ComplementedNamePartContext? {
				return getRuleContext(ComplementedNamePartContext.self, i)
			}
			open
			func nameDimension() -> [NameDimensionContext] {
				return getRuleContexts(NameDimensionContext.self)
			}
			open
			func nameDimension(_ i: Int) -> NameDimensionContext? {
				return getRuleContext(NameDimensionContext.self, i)
			}
			open
			func namePartSeparator() -> [NamePartSeparatorContext] {
				return getRuleContexts(NamePartSeparatorContext.self)
			}
			open
			func namePartSeparator(_ i: Int) -> NamePartSeparatorContext? {
				return getRuleContext(NamePartSeparatorContext.self, i)
			}
			open
			func simpleName() -> [SimpleNameContext] {
				return getRuleContexts(SimpleNameContext.self)
			}
			open
			func simpleName(_ i: Int) -> SimpleNameContext? {
				return getRuleContext(SimpleNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_complexName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterComplexName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitComplexName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitComplexName(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitComplexName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func complexName() throws -> ComplexNameContext {
		var _localctx: ComplexNameContext = ComplexNameContext(_ctx, getState())
		try enterRule(_localctx, 162, EDIF300Parser.RULE_complexName)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2207)
		 	try match(EDIF300Parser.Tokens.T__68.rawValue)
		 	setState(2214)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__66.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__344.rawValue || _la == EDIF300Parser.Tokens.T__347.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.STRING_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2212)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__66:
		 			setState(2208)
		 			try complementedNamePart()

		 			break

		 		case .T__344:
		 			setState(2209)
		 			try nameDimension()

		 			break

		 		case .T__347:
		 			setState(2210)
		 			try namePartSeparator()

		 			break

		 		case .STRING_LITERAL:
		 			setState(2211)
		 			try simpleName()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2216)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2217)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CompoundContext: ParserRuleContext {
			open
			func logicNameRef() -> [LogicNameRefContext] {
				return getRuleContexts(LogicNameRefContext.self)
			}
			open
			func logicNameRef(_ i: Int) -> LogicNameRefContext? {
				return getRuleContext(LogicNameRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_compound
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCompound(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCompound(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCompound(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCompound(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func compound() throws -> CompoundContext {
		var _localctx: CompoundContext = CompoundContext(_ctx, getState())
		try enterRule(_localctx, 164, EDIF300Parser.RULE_compound)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2219)
		 	try match(EDIF300Parser.Tokens.T__69.rawValue)
		 	setState(2223)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2220)
		 		try logicNameRef()


		 		setState(2225)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2226)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConditionContext: ParserRuleContext {
			open
			func booleanExpression() -> BooleanExpressionContext? {
				return getRuleContext(BooleanExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_condition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCondition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCondition(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCondition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func condition() throws -> ConditionContext {
		var _localctx: ConditionContext = ConditionContext(_ctx, getState())
		try enterRule(_localctx, 166, EDIF300Parser.RULE_condition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2228)
		 	try match(EDIF300Parser.Tokens.T__70.rawValue)
		 	setState(2229)
		 	try booleanExpression()
		 	setState(2230)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConditionDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_conditionDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConditionDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConditionDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConditionDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConditionDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func conditionDisplay() throws -> ConditionDisplayContext {
		var _localctx: ConditionDisplayContext = ConditionDisplayContext(_ctx, getState())
		try enterRule(_localctx, 168, EDIF300Parser.RULE_conditionDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2232)
		 	try match(EDIF300Parser.Tokens.T__71.rawValue)
		 	setState(2236)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2233)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2234)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2235)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2238)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectedSignalIndexGeneratorContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectedSignalIndexGenerator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectedSignalIndexGenerator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectedSignalIndexGenerator(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectedSignalIndexGenerator(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectedSignalIndexGenerator(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectedSignalIndexGenerator() throws -> ConnectedSignalIndexGeneratorContext {
		var _localctx: ConnectedSignalIndexGeneratorContext = ConnectedSignalIndexGeneratorContext(_ctx, getState())
		try enterRule(_localctx, 170, EDIF300Parser.RULE_connectedSignalIndexGenerator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2240)
		 	try match(EDIF300Parser.Tokens.T__72.rawValue)
		 	setState(2241)
		 	try integerExpression()
		 	setState(2242)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectedSignalIndexGeneratorDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectedSignalIndexGeneratorDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectedSignalIndexGeneratorDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectedSignalIndexGeneratorDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectedSignalIndexGeneratorDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectedSignalIndexGeneratorDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectedSignalIndexGeneratorDisplay() throws -> ConnectedSignalIndexGeneratorDisplayContext {
		var _localctx: ConnectedSignalIndexGeneratorDisplayContext = ConnectedSignalIndexGeneratorDisplayContext(_ctx, getState())
		try enterRule(_localctx, 172, EDIF300Parser.RULE_connectedSignalIndexGeneratorDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2244)
		 	try match(EDIF300Parser.Tokens.T__73.rawValue)
		 	setState(2248)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2245)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2246)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2247)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2250)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityBusContext: ParserRuleContext {
			open
			func interconnectNameDef() -> InterconnectNameDefContext? {
				return getRuleContext(InterconnectNameDefContext.self, 0)
			}
			open
			func signalGroupRef() -> SignalGroupRefContext? {
				return getRuleContext(SignalGroupRefContext.self, 0)
			}
			open
			func interconnectHeader() -> InterconnectHeaderContext? {
				return getRuleContext(InterconnectHeaderContext.self, 0)
			}
			open
			func connectivityBusJoined() -> ConnectivityBusJoinedContext? {
				return getRuleContext(ConnectivityBusJoinedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func connectivityBusSlice() -> [ConnectivityBusSliceContext] {
				return getRuleContexts(ConnectivityBusSliceContext.self)
			}
			open
			func connectivityBusSlice(_ i: Int) -> ConnectivityBusSliceContext? {
				return getRuleContext(ConnectivityBusSliceContext.self, i)
			}
			open
			func connectivitySubBus() -> [ConnectivitySubBusContext] {
				return getRuleContexts(ConnectivitySubBusContext.self)
			}
			open
			func connectivitySubBus(_ i: Int) -> ConnectivitySubBusContext? {
				return getRuleContext(ConnectivitySubBusContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityBus
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityBus(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityBus(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityBus(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityBus(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityBus() throws -> ConnectivityBusContext {
		var _localctx: ConnectivityBusContext = ConnectivityBusContext(_ctx, getState())
		try enterRule(_localctx, 174, EDIF300Parser.RULE_connectivityBus)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2252)
		 	try match(EDIF300Parser.Tokens.T__74.rawValue)
		 	setState(2253)
		 	try interconnectNameDef()
		 	setState(2254)
		 	try signalGroupRef()
		 	setState(2255)
		 	try interconnectHeader()
		 	setState(2256)
		 	try connectivityBusJoined()
		 	setState(2263)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__61.rawValue,EDIF300Parser.Tokens.T__76.rawValue,EDIF300Parser.Tokens.T__83.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 62)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2261)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(2257)
		 			try comment()

		 			break

		 		case .T__76:
		 			setState(2258)
		 			try connectivityBusSlice()

		 			break

		 		case .T__83:
		 			setState(2259)
		 			try connectivitySubBus()

		 			break

		 		case .T__642:
		 			setState(2260)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2265)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2266)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityBusJoinedContext: ParserRuleContext {
			open
			func portJoined() -> PortJoinedContext? {
				return getRuleContext(PortJoinedContext.self, 0)
			}
			open
			func connectivityRipperRef() -> [ConnectivityRipperRefContext] {
				return getRuleContexts(ConnectivityRipperRefContext.self)
			}
			open
			func connectivityRipperRef(_ i: Int) -> ConnectivityRipperRefContext? {
				return getRuleContext(ConnectivityRipperRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityBusJoined
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityBusJoined(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityBusJoined(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityBusJoined(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityBusJoined(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityBusJoined() throws -> ConnectivityBusJoinedContext {
		var _localctx: ConnectivityBusJoinedContext = ConnectivityBusJoinedContext(_ctx, getState())
		try enterRule(_localctx, 176, EDIF300Parser.RULE_connectivityBusJoined)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2268)
		 	try match(EDIF300Parser.Tokens.T__75.rawValue)
		 	setState(2269)
		 	try portJoined()
		 	setState(2273)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__81.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2270)
		 		try connectivityRipperRef()


		 		setState(2275)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2276)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityBusSliceContext: ParserRuleContext {
			open
			func interconnectNameDef() -> InterconnectNameDefContext? {
				return getRuleContext(InterconnectNameDefContext.self, 0)
			}
			open
			func signalGroupRef() -> SignalGroupRefContext? {
				return getRuleContext(SignalGroupRefContext.self, 0)
			}
			open
			func interconnectHeader() -> InterconnectHeaderContext? {
				return getRuleContext(InterconnectHeaderContext.self, 0)
			}
			open
			func connectivityBusJoined() -> ConnectivityBusJoinedContext? {
				return getRuleContext(ConnectivityBusJoinedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func connectivityBusSlice() -> [ConnectivityBusSliceContext] {
				return getRuleContexts(ConnectivityBusSliceContext.self)
			}
			open
			func connectivityBusSlice(_ i: Int) -> ConnectivityBusSliceContext? {
				return getRuleContext(ConnectivityBusSliceContext.self, i)
			}
			open
			func connectivitySubBus() -> [ConnectivitySubBusContext] {
				return getRuleContexts(ConnectivitySubBusContext.self)
			}
			open
			func connectivitySubBus(_ i: Int) -> ConnectivitySubBusContext? {
				return getRuleContext(ConnectivitySubBusContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityBusSlice
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityBusSlice(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityBusSlice(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityBusSlice(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityBusSlice(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityBusSlice() throws -> ConnectivityBusSliceContext {
		var _localctx: ConnectivityBusSliceContext = ConnectivityBusSliceContext(_ctx, getState())
		try enterRule(_localctx, 178, EDIF300Parser.RULE_connectivityBusSlice)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2278)
		 	try match(EDIF300Parser.Tokens.T__76.rawValue)
		 	setState(2279)
		 	try interconnectNameDef()
		 	setState(2280)
		 	try signalGroupRef()
		 	setState(2281)
		 	try interconnectHeader()
		 	setState(2282)
		 	try connectivityBusJoined()
		 	setState(2289)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__61.rawValue,EDIF300Parser.Tokens.T__76.rawValue,EDIF300Parser.Tokens.T__83.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 62)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2287)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(2283)
		 			try comment()

		 			break

		 		case .T__76:
		 			setState(2284)
		 			try connectivityBusSlice()

		 			break

		 		case .T__83:
		 			setState(2285)
		 			try connectivitySubBus()

		 			break

		 		case .T__642:
		 			setState(2286)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2291)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2292)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityFrameStructureContext: ParserRuleContext {
			open
			func connectivityFrameStructureNameDef() -> ConnectivityFrameStructureNameDefContext? {
				return getRuleContext(ConnectivityFrameStructureNameDefContext.self, 0)
			}
			open
			func frameRef() -> FrameRefContext? {
				return getRuleContext(FrameRefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func connectivityBus() -> [ConnectivityBusContext] {
				return getRuleContexts(ConnectivityBusContext.self)
			}
			open
			func connectivityBus(_ i: Int) -> ConnectivityBusContext? {
				return getRuleContext(ConnectivityBusContext.self, i)
			}
			open
			func connectivityFrameStructure() -> [ConnectivityFrameStructureContext] {
				return getRuleContexts(ConnectivityFrameStructureContext.self)
			}
			open
			func connectivityFrameStructure(_ i: Int) -> ConnectivityFrameStructureContext? {
				return getRuleContext(ConnectivityFrameStructureContext.self, i)
			}
			open
			func connectivityNet() -> [ConnectivityNetContext] {
				return getRuleContexts(ConnectivityNetContext.self)
			}
			open
			func connectivityNet(_ i: Int) -> ConnectivityNetContext? {
				return getRuleContext(ConnectivityNetContext.self, i)
			}
			open
			func connectivityRipper() -> [ConnectivityRipperContext] {
				return getRuleContexts(ConnectivityRipperContext.self)
			}
			open
			func connectivityRipper(_ i: Int) -> ConnectivityRipperContext? {
				return getRuleContext(ConnectivityRipperContext.self, i)
			}
			open
			func timing() -> [TimingContext] {
				return getRuleContexts(TimingContext.self)
			}
			open
			func timing(_ i: Int) -> TimingContext? {
				return getRuleContext(TimingContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityFrameStructure
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityFrameStructure(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityFrameStructure(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityFrameStructure(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityFrameStructure(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityFrameStructure() throws -> ConnectivityFrameStructureContext {
		var _localctx: ConnectivityFrameStructureContext = ConnectivityFrameStructureContext(_ctx, getState())
		try enterRule(_localctx, 180, EDIF300Parser.RULE_connectivityFrameStructure)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2294)
		 	try match(EDIF300Parser.Tokens.T__77.rawValue)
		 	setState(2295)
		 	try connectivityFrameStructureNameDef()
		 	setState(2296)
		 	try frameRef()
		 	setState(2306)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__61.rawValue,EDIF300Parser.Tokens.T__74.rawValue,EDIF300Parser.Tokens.T__77.rawValue,EDIF300Parser.Tokens.T__78.rawValue,EDIF300Parser.Tokens.T__80.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 62)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__619.rawValue || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2304)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(2297)
		 			try comment()

		 			break

		 		case .T__74:
		 			setState(2298)
		 			try connectivityBus()

		 			break

		 		case .T__77:
		 			setState(2299)
		 			try connectivityFrameStructure()

		 			break

		 		case .T__78:
		 			setState(2300)
		 			try connectivityNet()

		 			break

		 		case .T__80:
		 			setState(2301)
		 			try connectivityRipper()

		 			break

		 		case .T__619:
		 			setState(2302)
		 			try timing()

		 			break

		 		case .T__642:
		 			setState(2303)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2308)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2309)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityFrameStructureNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityFrameStructureNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityFrameStructureNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityFrameStructureNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityFrameStructureNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityFrameStructureNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityFrameStructureNameDef() throws -> ConnectivityFrameStructureNameDefContext {
		var _localctx: ConnectivityFrameStructureNameDefContext = ConnectivityFrameStructureNameDefContext(_ctx, getState())
		try enterRule(_localctx, 182, EDIF300Parser.RULE_connectivityFrameStructureNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2311)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityNetContext: ParserRuleContext {
			open
			func interconnectNameDef() -> InterconnectNameDefContext? {
				return getRuleContext(InterconnectNameDefContext.self, 0)
			}
			open
			func signalRef() -> SignalRefContext? {
				return getRuleContext(SignalRefContext.self, 0)
			}
			open
			func interconnectHeader() -> InterconnectHeaderContext? {
				return getRuleContext(InterconnectHeaderContext.self, 0)
			}
			open
			func connectivityNetJoined() -> ConnectivityNetJoinedContext? {
				return getRuleContext(ConnectivityNetJoinedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func connectivitySubNet() -> [ConnectivitySubNetContext] {
				return getRuleContexts(ConnectivitySubNetContext.self)
			}
			open
			func connectivitySubNet(_ i: Int) -> ConnectivitySubNetContext? {
				return getRuleContext(ConnectivitySubNetContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityNet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityNet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityNet(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityNet(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityNet(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityNet() throws -> ConnectivityNetContext {
		var _localctx: ConnectivityNetContext = ConnectivityNetContext(_ctx, getState())
		try enterRule(_localctx, 184, EDIF300Parser.RULE_connectivityNet)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2313)
		 	try match(EDIF300Parser.Tokens.T__78.rawValue)
		 	setState(2314)
		 	try interconnectNameDef()
		 	setState(2315)
		 	try signalRef()
		 	setState(2316)
		 	try interconnectHeader()
		 	setState(2317)
		 	try connectivityNetJoined()
		 	setState(2323)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue || _la == EDIF300Parser.Tokens.T__84.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2321)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(2318)
		 			try comment()

		 			break

		 		case .T__84:
		 			setState(2319)
		 			try connectivitySubNet()

		 			break

		 		case .T__642:
		 			setState(2320)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2325)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2326)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityNetJoinedContext: ParserRuleContext {
			open
			func portJoined() -> PortJoinedContext? {
				return getRuleContext(PortJoinedContext.self, 0)
			}
			open
			func joinedAsSignal() -> JoinedAsSignalContext? {
				return getRuleContext(JoinedAsSignalContext.self, 0)
			}
			open
			func connectivityRipperRef() -> [ConnectivityRipperRefContext] {
				return getRuleContexts(ConnectivityRipperRefContext.self)
			}
			open
			func connectivityRipperRef(_ i: Int) -> ConnectivityRipperRefContext? {
				return getRuleContext(ConnectivityRipperRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityNetJoined
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityNetJoined(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityNetJoined(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityNetJoined(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityNetJoined(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityNetJoined() throws -> ConnectivityNetJoinedContext {
		var _localctx: ConnectivityNetJoinedContext = ConnectivityNetJoinedContext(_ctx, getState())
		try enterRule(_localctx, 186, EDIF300Parser.RULE_connectivityNetJoined)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2328)
		 	try match(EDIF300Parser.Tokens.T__79.rawValue)
		 	setState(2331)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__423:
		 		setState(2329)
		 		try portJoined()

		 		break

		 	case .T__277:
		 		setState(2330)
		 		try joinedAsSignal()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2336)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__81.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2333)
		 		try connectivityRipperRef()


		 		setState(2338)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2339)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityRipperContext: ParserRuleContext {
			open
			func connectivityRipperNameDef() -> ConnectivityRipperNameDefContext? {
				return getRuleContext(ConnectivityRipperNameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityRipper
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityRipper(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityRipper(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityRipper(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityRipper(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityRipper() throws -> ConnectivityRipperContext {
		var _localctx: ConnectivityRipperContext = ConnectivityRipperContext(_ctx, getState())
		try enterRule(_localctx, 188, EDIF300Parser.RULE_connectivityRipper)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2341)
		 	try match(EDIF300Parser.Tokens.T__80.rawValue)
		 	setState(2342)
		 	try connectivityRipperNameDef()
		 	setState(2343)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityRipperNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityRipperNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityRipperNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityRipperNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityRipperNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityRipperNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityRipperNameDef() throws -> ConnectivityRipperNameDefContext {
		var _localctx: ConnectivityRipperNameDefContext = ConnectivityRipperNameDefContext(_ctx, getState())
		try enterRule(_localctx, 190, EDIF300Parser.RULE_connectivityRipperNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2345)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityRipperNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityRipperNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityRipperNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityRipperNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityRipperNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityRipperNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityRipperNameRef() throws -> ConnectivityRipperNameRefContext {
		var _localctx: ConnectivityRipperNameRefContext = ConnectivityRipperNameRefContext(_ctx, getState())
		try enterRule(_localctx, 192, EDIF300Parser.RULE_connectivityRipperNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2347)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityRipperRefContext: ParserRuleContext {
			open
			func connectivityRipperNameRef() -> ConnectivityRipperNameRefContext? {
				return getRuleContext(ConnectivityRipperNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityRipperRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityRipperRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityRipperRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityRipperRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityRipperRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityRipperRef() throws -> ConnectivityRipperRefContext {
		var _localctx: ConnectivityRipperRefContext = ConnectivityRipperRefContext(_ctx, getState())
		try enterRule(_localctx, 194, EDIF300Parser.RULE_connectivityRipperRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2349)
		 	try match(EDIF300Parser.Tokens.T__81.rawValue)
		 	setState(2350)
		 	try connectivityRipperNameRef()
		 	setState(2351)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityStructureContext: ParserRuleContext {
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func connectivityBus() -> [ConnectivityBusContext] {
				return getRuleContexts(ConnectivityBusContext.self)
			}
			open
			func connectivityBus(_ i: Int) -> ConnectivityBusContext? {
				return getRuleContext(ConnectivityBusContext.self, i)
			}
			open
			func connectivityFrameStructure() -> [ConnectivityFrameStructureContext] {
				return getRuleContexts(ConnectivityFrameStructureContext.self)
			}
			open
			func connectivityFrameStructure(_ i: Int) -> ConnectivityFrameStructureContext? {
				return getRuleContext(ConnectivityFrameStructureContext.self, i)
			}
			open
			func connectivityNet() -> [ConnectivityNetContext] {
				return getRuleContexts(ConnectivityNetContext.self)
			}
			open
			func connectivityNet(_ i: Int) -> ConnectivityNetContext? {
				return getRuleContext(ConnectivityNetContext.self, i)
			}
			open
			func connectivityRipper() -> [ConnectivityRipperContext] {
				return getRuleContexts(ConnectivityRipperContext.self)
			}
			open
			func connectivityRipper(_ i: Int) -> ConnectivityRipperContext? {
				return getRuleContext(ConnectivityRipperContext.self, i)
			}
			open
			func localPortGroup() -> [LocalPortGroupContext] {
				return getRuleContexts(LocalPortGroupContext.self)
			}
			open
			func localPortGroup(_ i: Int) -> LocalPortGroupContext? {
				return getRuleContext(LocalPortGroupContext.self, i)
			}
			open
			func timing() -> [TimingContext] {
				return getRuleContexts(TimingContext.self)
			}
			open
			func timing(_ i: Int) -> TimingContext? {
				return getRuleContext(TimingContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityStructure
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityStructure(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityStructure(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityStructure(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityStructure(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityStructure() throws -> ConnectivityStructureContext {
		var _localctx: ConnectivityStructureContext = ConnectivityStructureContext(_ctx, getState())
		try enterRule(_localctx, 196, EDIF300Parser.RULE_connectivityStructure)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2353)
		 	try match(EDIF300Parser.Tokens.T__82.rawValue)
		 	setState(2364)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__61.rawValue,EDIF300Parser.Tokens.T__74.rawValue,EDIF300Parser.Tokens.T__77.rawValue,EDIF300Parser.Tokens.T__78.rawValue,EDIF300Parser.Tokens.T__80.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 62)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__315.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__619.rawValue || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2362)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(2354)
		 			try comment()

		 			break

		 		case .T__74:
		 			setState(2355)
		 			try connectivityBus()

		 			break

		 		case .T__77:
		 			setState(2356)
		 			try connectivityFrameStructure()

		 			break

		 		case .T__78:
		 			setState(2357)
		 			try connectivityNet()

		 			break

		 		case .T__80:
		 			setState(2358)
		 			try connectivityRipper()

		 			break

		 		case .T__315:
		 			setState(2359)
		 			try localPortGroup()

		 			break

		 		case .T__619:
		 			setState(2360)
		 			try timing()

		 			break

		 		case .T__642:
		 			setState(2361)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2366)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2367)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivitySubBusContext: ParserRuleContext {
			open
			func interconnectNameDef() -> InterconnectNameDefContext? {
				return getRuleContext(InterconnectNameDefContext.self, 0)
			}
			open
			func interconnectHeader() -> InterconnectHeaderContext? {
				return getRuleContext(InterconnectHeaderContext.self, 0)
			}
			open
			func connectivityBusJoined() -> ConnectivityBusJoinedContext? {
				return getRuleContext(ConnectivityBusJoinedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func connectivityBusSlice() -> [ConnectivityBusSliceContext] {
				return getRuleContexts(ConnectivityBusSliceContext.self)
			}
			open
			func connectivityBusSlice(_ i: Int) -> ConnectivityBusSliceContext? {
				return getRuleContext(ConnectivityBusSliceContext.self, i)
			}
			open
			func connectivitySubBus() -> [ConnectivitySubBusContext] {
				return getRuleContexts(ConnectivitySubBusContext.self)
			}
			open
			func connectivitySubBus(_ i: Int) -> ConnectivitySubBusContext? {
				return getRuleContext(ConnectivitySubBusContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivitySubBus
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivitySubBus(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivitySubBus(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivitySubBus(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivitySubBus(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivitySubBus() throws -> ConnectivitySubBusContext {
		var _localctx: ConnectivitySubBusContext = ConnectivitySubBusContext(_ctx, getState())
		try enterRule(_localctx, 198, EDIF300Parser.RULE_connectivitySubBus)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2369)
		 	try match(EDIF300Parser.Tokens.T__83.rawValue)
		 	setState(2370)
		 	try interconnectNameDef()
		 	setState(2371)
		 	try interconnectHeader()
		 	setState(2372)
		 	try connectivityBusJoined()
		 	setState(2379)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__61.rawValue,EDIF300Parser.Tokens.T__76.rawValue,EDIF300Parser.Tokens.T__83.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 62)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2377)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(2373)
		 			try comment()

		 			break

		 		case .T__76:
		 			setState(2374)
		 			try connectivityBusSlice()

		 			break

		 		case .T__83:
		 			setState(2375)
		 			try connectivitySubBus()

		 			break

		 		case .T__642:
		 			setState(2376)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2381)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2382)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivitySubNetContext: ParserRuleContext {
			open
			func interconnectNameDef() -> InterconnectNameDefContext? {
				return getRuleContext(InterconnectNameDefContext.self, 0)
			}
			open
			func interconnectHeader() -> InterconnectHeaderContext? {
				return getRuleContext(InterconnectHeaderContext.self, 0)
			}
			open
			func connectivityNetJoined() -> ConnectivityNetJoinedContext? {
				return getRuleContext(ConnectivityNetJoinedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func connectivitySubNet() -> [ConnectivitySubNetContext] {
				return getRuleContexts(ConnectivitySubNetContext.self)
			}
			open
			func connectivitySubNet(_ i: Int) -> ConnectivitySubNetContext? {
				return getRuleContext(ConnectivitySubNetContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivitySubNet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivitySubNet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivitySubNet(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivitySubNet(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivitySubNet(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivitySubNet() throws -> ConnectivitySubNetContext {
		var _localctx: ConnectivitySubNetContext = ConnectivitySubNetContext(_ctx, getState())
		try enterRule(_localctx, 200, EDIF300Parser.RULE_connectivitySubNet)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2384)
		 	try match(EDIF300Parser.Tokens.T__84.rawValue)
		 	setState(2385)
		 	try interconnectNameDef()
		 	setState(2386)
		 	try interconnectHeader()
		 	setState(2387)
		 	try connectivityNetJoined()
		 	setState(2393)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue || _la == EDIF300Parser.Tokens.T__84.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2391)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(2388)
		 			try comment()

		 			break

		 		case .T__84:
		 			setState(2389)
		 			try connectivitySubNet()

		 			break

		 		case .T__642:
		 			setState(2390)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2395)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2396)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityTagGeneratorContext: ParserRuleContext {
			open
			func stringExpression() -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityTagGenerator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityTagGenerator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityTagGenerator(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityTagGenerator(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityTagGenerator(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityTagGenerator() throws -> ConnectivityTagGeneratorContext {
		var _localctx: ConnectivityTagGeneratorContext = ConnectivityTagGeneratorContext(_ctx, getState())
		try enterRule(_localctx, 202, EDIF300Parser.RULE_connectivityTagGenerator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2398)
		 	try match(EDIF300Parser.Tokens.T__85.rawValue)
		 	setState(2399)
		 	try stringExpression()
		 	setState(2400)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityTagGeneratorDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityTagGeneratorDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityTagGeneratorDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityTagGeneratorDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityTagGeneratorDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityTagGeneratorDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityTagGeneratorDisplay() throws -> ConnectivityTagGeneratorDisplayContext {
		var _localctx: ConnectivityTagGeneratorDisplayContext = ConnectivityTagGeneratorDisplayContext(_ctx, getState())
		try enterRule(_localctx, 204, EDIF300Parser.RULE_connectivityTagGeneratorDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2402)
		 	try match(EDIF300Parser.Tokens.T__86.rawValue)
		 	setState(2406)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2403)
		 		try display()


		 		setState(2408)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2409)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityUnitsContext: ParserRuleContext {
			open
			func setCapacitance() -> SetCapacitanceContext? {
				return getRuleContext(SetCapacitanceContext.self, 0)
			}
			open
			func setTime() -> SetTimeContext? {
				return getRuleContext(SetTimeContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityUnits() throws -> ConnectivityUnitsContext {
		var _localctx: ConnectivityUnitsContext = ConnectivityUnitsContext(_ctx, getState())
		try enterRule(_localctx, 206, EDIF300Parser.RULE_connectivityUnits)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2411)
		 	try match(EDIF300Parser.Tokens.T__87.rawValue)
		 	setState(2414)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__576:
		 	 	setState(2412)
		 	 	try setCapacitance()

		 		break

		 	case .T__580:
		 	 	setState(2413)
		 	 	try setTime()

		 		break

		 	case .T__1:
		 		break
		 	default:
		 		break
		 	}
		 	setState(2416)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityViewContext: ParserRuleContext {
			open
			func viewNameDef() -> ViewNameDefContext? {
				return getRuleContext(ViewNameDefContext.self, 0)
			}
			open
			func connectivityViewHeader() -> ConnectivityViewHeaderContext? {
				return getRuleContext(ConnectivityViewHeaderContext.self, 0)
			}
			open
			func logicalConnectivity() -> LogicalConnectivityContext? {
				return getRuleContext(LogicalConnectivityContext.self, 0)
			}
			open
			func connectivityStructure() -> ConnectivityStructureContext? {
				return getRuleContext(ConnectivityStructureContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityView
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityView(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityView(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityView(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityView(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityView() throws -> ConnectivityViewContext {
		var _localctx: ConnectivityViewContext = ConnectivityViewContext(_ctx, getState())
		try enterRule(_localctx, 208, EDIF300Parser.RULE_connectivityView)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2418)
		 	try match(EDIF300Parser.Tokens.T__88.rawValue)
		 	setState(2419)
		 	try viewNameDef()
		 	setState(2420)
		 	try connectivityViewHeader()
		 	setState(2421)
		 	try logicalConnectivity()
		 	setState(2422)
		 	try connectivityStructure()
		 	setState(2427)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2425)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(2423)
		 			try comment()

		 			break

		 		case .T__642:
		 			setState(2424)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2429)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2430)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectivityViewHeaderContext: ParserRuleContext {
			open
			func connectivityUnits() -> ConnectivityUnitsContext? {
				return getRuleContext(ConnectivityUnitsContext.self, 0)
			}
			open
			func derivedFrom() -> [DerivedFromContext] {
				return getRuleContexts(DerivedFromContext.self)
			}
			open
			func derivedFrom(_ i: Int) -> DerivedFromContext? {
				return getRuleContext(DerivedFromContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func previousVersion() -> [PreviousVersionContext] {
				return getRuleContexts(PreviousVersionContext.self)
			}
			open
			func previousVersion(_ i: Int) -> PreviousVersionContext? {
				return getRuleContext(PreviousVersionContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_connectivityViewHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConnectivityViewHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConnectivityViewHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConnectivityViewHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConnectivityViewHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func connectivityViewHeader() throws -> ConnectivityViewHeaderContext {
		var _localctx: ConnectivityViewHeaderContext = ConnectivityViewHeaderContext(_ctx, getState())
		try enterRule(_localctx, 210, EDIF300Parser.RULE_connectivityViewHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2432)
		 	try match(EDIF300Parser.Tokens.T__89.rawValue)
		 	setState(2433)
		 	try connectivityUnits()
		 	setState(2442)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__116.rawValue || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__439.rawValue || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2440)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__116:
		 			setState(2434)
		 			try derivedFrom()

		 			break

		 		case .T__132:
		 			setState(2435)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(2436)
		 			try nameInformation()

		 			break

		 		case .T__439:
		 			setState(2437)
		 			try previousVersion()

		 			break

		 		case .T__442:
		 			setState(2438)
		 			try property()

		 			break

		 		case .T__597:
		 			setState(2439)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2444)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2445)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConstantNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_constantNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConstantNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConstantNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConstantNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConstantNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func constantNameDef() throws -> ConstantNameDefContext {
		var _localctx: ConstantNameDefContext = ConstantNameDefContext(_ctx, getState())
		try enterRule(_localctx, 212, EDIF300Parser.RULE_constantNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2447)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConstantNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_constantNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConstantNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConstantNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConstantNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConstantNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func constantNameRef() throws -> ConstantNameRefContext {
		var _localctx: ConstantNameRefContext = ConstantNameRefContext(_ctx, getState())
		try enterRule(_localctx, 214, EDIF300Parser.RULE_constantNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2449)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConstantValuesContext: ParserRuleContext {
			open
			func booleanConstant() -> [BooleanConstantContext] {
				return getRuleContexts(BooleanConstantContext.self)
			}
			open
			func booleanConstant(_ i: Int) -> BooleanConstantContext? {
				return getRuleContext(BooleanConstantContext.self, i)
			}
			open
			func integerConstant() -> [IntegerConstantContext] {
				return getRuleContexts(IntegerConstantContext.self)
			}
			open
			func integerConstant(_ i: Int) -> IntegerConstantContext? {
				return getRuleContext(IntegerConstantContext.self, i)
			}
			open
			func stringConstant() -> [StringConstantContext] {
				return getRuleContexts(StringConstantContext.self)
			}
			open
			func stringConstant(_ i: Int) -> StringConstantContext? {
				return getRuleContext(StringConstantContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_constantValues
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterConstantValues(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitConstantValues(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitConstantValues(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitConstantValues(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func constantValues() throws -> ConstantValuesContext {
		var _localctx: ConstantValuesContext = ConstantValuesContext(_ctx, getState())
		try enterRule(_localctx, 216, EDIF300Parser.RULE_constantValues)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2451)
		 	try match(EDIF300Parser.Tokens.T__90.rawValue)
		 	setState(2457)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__24.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__248.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__601.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2455)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__24:
		 			setState(2452)
		 			try booleanConstant()

		 			break

		 		case .T__248:
		 			setState(2453)
		 			try integerConstant()

		 			break

		 		case .T__601:
		 			setState(2454)
		 			try stringConstant()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2459)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2460)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ContractContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_contract
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterContract(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitContract(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitContract(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitContract(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func contract() throws -> ContractContext {
		var _localctx: ContractContext = ContractContext(_ctx, getState())
		try enterRule(_localctx, 218, EDIF300Parser.RULE_contract)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2462)
		 	try match(EDIF300Parser.Tokens.T__91.rawValue)
		 	setState(2463)
		 	try stringToken()
		 	setState(2464)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ContractDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_contractDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterContractDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitContractDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitContractDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitContractDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func contractDisplay() throws -> ContractDisplayContext {
		var _localctx: ContractDisplayContext = ContractDisplayContext(_ctx, getState())
		try enterRule(_localctx, 220, EDIF300Parser.RULE_contractDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2466)
		 	try match(EDIF300Parser.Tokens.T__92.rawValue)
		 	setState(2470)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2467)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2468)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2469)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2472)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CopyrightContext: ParserRuleContext {
			open
			func year() -> YearContext? {
				return getRuleContext(YearContext.self, 0)
			}
			open
			func stringToken() -> [StringTokenContext] {
				return getRuleContexts(StringTokenContext.self)
			}
			open
			func stringToken(_ i: Int) -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_copyright
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCopyright(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCopyright(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCopyright(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCopyright(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func copyright() throws -> CopyrightContext {
		var _localctx: CopyrightContext = CopyrightContext(_ctx, getState())
		try enterRule(_localctx, 222, EDIF300Parser.RULE_copyright)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2474)
		 	try match(EDIF300Parser.Tokens.T__93.rawValue)
		 	setState(2475)
		 	try year()
		 	setState(2479)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.STRING_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2476)
		 		try stringToken()


		 		setState(2481)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2482)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CopyrightDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_copyrightDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCopyrightDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCopyrightDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCopyrightDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCopyrightDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func copyrightDisplay() throws -> CopyrightDisplayContext {
		var _localctx: CopyrightDisplayContext = CopyrightDisplayContext(_ctx, getState())
		try enterRule(_localctx, 224, EDIF300Parser.RULE_copyrightDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2484)
		 	try match(EDIF300Parser.Tokens.T__94.rawValue)
		 	setState(2488)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2485)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2486)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2487)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2490)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CornerTypeContext: ParserRuleContext {
			open
			func truncate() -> TruncateContext? {
				return getRuleContext(TruncateContext.self, 0)
			}
			open
			func round() -> RoundContext? {
				return getRuleContext(RoundContext.self, 0)
			}
			open
			func extend() -> ExtendContext? {
				return getRuleContext(ExtendContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_cornerType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCornerType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCornerType(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCornerType(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCornerType(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func cornerType() throws -> CornerTypeContext {
		var _localctx: CornerTypeContext = CornerTypeContext(_ctx, getState())
		try enterRule(_localctx, 226, EDIF300Parser.RULE_cornerType)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2492)
		 	try match(EDIF300Parser.Tokens.T__95.rawValue)
		 	setState(2496)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__627:
		 		setState(2493)
		 		try truncate()

		 		break

		 	case .T__466:
		 		setState(2494)
		 		try round()

		 		break

		 	case .T__154:
		 		setState(2495)
		 		try extend()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2498)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CoulombContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_coulomb
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCoulomb(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCoulomb(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCoulomb(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCoulomb(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func coulomb() throws -> CoulombContext {
		var _localctx: CoulombContext = CoulombContext(_ctx, getState())
		try enterRule(_localctx, 228, EDIF300Parser.RULE_coulomb)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2500)
		 	try match(EDIF300Parser.Tokens.T__96.rawValue)
		 	setState(2501)
		 	try unitExponent()
		 	setState(2502)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CriticalityContext: ParserRuleContext {
			open
			func integerValue() -> IntegerValueContext? {
				return getRuleContext(IntegerValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_criticality
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCriticality(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCriticality(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCriticality(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCriticality(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func criticality() throws -> CriticalityContext {
		var _localctx: CriticalityContext = CriticalityContext(_ctx, getState())
		try enterRule(_localctx, 230, EDIF300Parser.RULE_criticality)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2504)
		 	try match(EDIF300Parser.Tokens.T__97.rawValue)
		 	setState(2505)
		 	try integerValue()
		 	setState(2506)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CriticalityDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_criticalityDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCriticalityDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCriticalityDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCriticalityDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCriticalityDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func criticalityDisplay() throws -> CriticalityDisplayContext {
		var _localctx: CriticalityDisplayContext = CriticalityDisplayContext(_ctx, getState())
		try enterRule(_localctx, 232, EDIF300Parser.RULE_criticalityDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2508)
		 	try match(EDIF300Parser.Tokens.T__98.rawValue)
		 	setState(2512)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2509)
		 		try display()


		 		setState(2514)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2515)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CurrentMapContext: ParserRuleContext {
			open
			func currentValue() -> CurrentValueContext? {
				return getRuleContext(CurrentValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_currentMap
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCurrentMap(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCurrentMap(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCurrentMap(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCurrentMap(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func currentMap() throws -> CurrentMapContext {
		var _localctx: CurrentMapContext = CurrentMapContext(_ctx, getState())
		try enterRule(_localctx, 234, EDIF300Parser.RULE_currentMap)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2517)
		 	try match(EDIF300Parser.Tokens.T__99.rawValue)
		 	setState(2518)
		 	try currentValue()
		 	setState(2519)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CurrentValueContext: ParserRuleContext {
			open
			func miNoMaxValue() -> MiNoMaxValueContext? {
				return getRuleContext(MiNoMaxValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_currentValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCurrentValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCurrentValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCurrentValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCurrentValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func currentValue() throws -> CurrentValueContext {
		var _localctx: CurrentValueContext = CurrentValueContext(_ctx, getState())
		try enterRule(_localctx, 236, EDIF300Parser.RULE_currentValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2521)
		 	try miNoMaxValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CurveContext: ParserRuleContext {
			open
			func arc() -> [ArcContext] {
				return getRuleContexts(ArcContext.self)
			}
			open
			func arc(_ i: Int) -> ArcContext? {
				return getRuleContext(ArcContext.self, i)
			}
			open
			func pointValue() -> [PointValueContext] {
				return getRuleContexts(PointValueContext.self)
			}
			open
			func pointValue(_ i: Int) -> PointValueContext? {
				return getRuleContext(PointValueContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_curve
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterCurve(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitCurve(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitCurve(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitCurve(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func curve() throws -> CurveContext {
		var _localctx: CurveContext = CurveContext(_ctx, getState())
		try enterRule(_localctx, 238, EDIF300Parser.RULE_curve)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2523)
		 	try match(EDIF300Parser.Tokens.T__100.rawValue)
		 	setState(2528)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__10.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__450.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2526)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__10:
		 			setState(2524)
		 			try arc()

		 			break

		 		case .T__450:
		 			setState(2525)
		 			try pointValue()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2530)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2531)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataOriginContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
			open
			func version() -> VersionContext? {
				return getRuleContext(VersionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dataOrigin
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDataOrigin(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDataOrigin(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDataOrigin(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDataOrigin(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dataOrigin() throws -> DataOriginContext {
		var _localctx: DataOriginContext = DataOriginContext(_ctx, getState())
		try enterRule(_localctx, 240, EDIF300Parser.RULE_dataOrigin)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2533)
		 	try match(EDIF300Parser.Tokens.T__101.rawValue)
		 	setState(2534)
		 	try stringToken()
		 	setState(2536)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__643.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2535)
		 		try version()

		 	}

		 	setState(2538)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DateContext: ParserRuleContext {
			open
			func yearNumber() -> YearNumberContext? {
				return getRuleContext(YearNumberContext.self, 0)
			}
			open
			func monthNumber() -> MonthNumberContext? {
				return getRuleContext(MonthNumberContext.self, 0)
			}
			open
			func dayNumber() -> DayNumberContext? {
				return getRuleContext(DayNumberContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_date
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func date() throws -> DateContext {
		var _localctx: DateContext = DateContext(_ctx, getState())
		try enterRule(_localctx, 242, EDIF300Parser.RULE_date)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2540)
		 	try match(EDIF300Parser.Tokens.T__102.rawValue)
		 	setState(2541)
		 	try yearNumber()
		 	setState(2542)
		 	try monthNumber()
		 	setState(2543)
		 	try dayNumber()
		 	setState(2544)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DayNumberContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dayNumber
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDayNumber(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDayNumber(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDayNumber(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDayNumber(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dayNumber() throws -> DayNumberContext {
		var _localctx: DayNumberContext = DayNumberContext(_ctx, getState())
		try enterRule(_localctx, 244, EDIF300Parser.RULE_dayNumber)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2546)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DcFanInLoadContext: ParserRuleContext {
			open
			func numberValue() -> NumberValueContext? {
				return getRuleContext(NumberValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dcFanInLoad
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDcFanInLoad(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDcFanInLoad(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDcFanInLoad(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDcFanInLoad(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dcFanInLoad() throws -> DcFanInLoadContext {
		var _localctx: DcFanInLoadContext = DcFanInLoadContext(_ctx, getState())
		try enterRule(_localctx, 246, EDIF300Parser.RULE_dcFanInLoad)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2548)
		 	try match(EDIF300Parser.Tokens.T__103.rawValue)
		 	setState(2549)
		 	try numberValue()
		 	setState(2550)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DcFanInLoadDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dcFanInLoadDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDcFanInLoadDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDcFanInLoadDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDcFanInLoadDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDcFanInLoadDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dcFanInLoadDisplay() throws -> DcFanInLoadDisplayContext {
		var _localctx: DcFanInLoadDisplayContext = DcFanInLoadDisplayContext(_ctx, getState())
		try enterRule(_localctx, 248, EDIF300Parser.RULE_dcFanInLoadDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2552)
		 	try match(EDIF300Parser.Tokens.T__104.rawValue)
		 	setState(2556)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2553)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2554)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2555)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2558)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DcFanOutLoadContext: ParserRuleContext {
			open
			func numberValue() -> NumberValueContext? {
				return getRuleContext(NumberValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dcFanOutLoad
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDcFanOutLoad(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDcFanOutLoad(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDcFanOutLoad(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDcFanOutLoad(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dcFanOutLoad() throws -> DcFanOutLoadContext {
		var _localctx: DcFanOutLoadContext = DcFanOutLoadContext(_ctx, getState())
		try enterRule(_localctx, 250, EDIF300Parser.RULE_dcFanOutLoad)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2560)
		 	try match(EDIF300Parser.Tokens.T__105.rawValue)
		 	setState(2561)
		 	try numberValue()
		 	setState(2562)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DcFanOutLoadDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dcFanOutLoadDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDcFanOutLoadDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDcFanOutLoadDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDcFanOutLoadDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDcFanOutLoadDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dcFanOutLoadDisplay() throws -> DcFanOutLoadDisplayContext {
		var _localctx: DcFanOutLoadDisplayContext = DcFanOutLoadDisplayContext(_ctx, getState())
		try enterRule(_localctx, 252, EDIF300Parser.RULE_dcFanOutLoadDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2564)
		 	try match(EDIF300Parser.Tokens.T__106.rawValue)
		 	setState(2568)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2565)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2566)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2567)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2570)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DcMaxFanInContext: ParserRuleContext {
			open
			func numberValue() -> NumberValueContext? {
				return getRuleContext(NumberValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dcMaxFanIn
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDcMaxFanIn(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDcMaxFanIn(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDcMaxFanIn(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDcMaxFanIn(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dcMaxFanIn() throws -> DcMaxFanInContext {
		var _localctx: DcMaxFanInContext = DcMaxFanInContext(_ctx, getState())
		try enterRule(_localctx, 254, EDIF300Parser.RULE_dcMaxFanIn)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2572)
		 	try match(EDIF300Parser.Tokens.T__107.rawValue)
		 	setState(2573)
		 	try numberValue()
		 	setState(2574)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DcMaxFanInDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dcMaxFanInDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDcMaxFanInDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDcMaxFanInDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDcMaxFanInDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDcMaxFanInDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dcMaxFanInDisplay() throws -> DcMaxFanInDisplayContext {
		var _localctx: DcMaxFanInDisplayContext = DcMaxFanInDisplayContext(_ctx, getState())
		try enterRule(_localctx, 256, EDIF300Parser.RULE_dcMaxFanInDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2576)
		 	try match(EDIF300Parser.Tokens.T__108.rawValue)
		 	setState(2580)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2577)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2578)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2579)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2582)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DcMaxFanOutContext: ParserRuleContext {
			open
			func numberValue() -> NumberValueContext? {
				return getRuleContext(NumberValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dcMaxFanOut
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDcMaxFanOut(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDcMaxFanOut(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDcMaxFanOut(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDcMaxFanOut(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dcMaxFanOut() throws -> DcMaxFanOutContext {
		var _localctx: DcMaxFanOutContext = DcMaxFanOutContext(_ctx, getState())
		try enterRule(_localctx, 258, EDIF300Parser.RULE_dcMaxFanOut)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2584)
		 	try match(EDIF300Parser.Tokens.T__109.rawValue)
		 	setState(2585)
		 	try numberValue()
		 	setState(2586)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DcMaxFanOutDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dcMaxFanOutDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDcMaxFanOutDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDcMaxFanOutDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDcMaxFanOutDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDcMaxFanOutDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dcMaxFanOutDisplay() throws -> DcMaxFanOutDisplayContext {
		var _localctx: DcMaxFanOutDisplayContext = DcMaxFanOutDisplayContext(_ctx, getState())
		try enterRule(_localctx, 260, EDIF300Parser.RULE_dcMaxFanOutDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2588)
		 	try match(EDIF300Parser.Tokens.T__110.rawValue)
		 	setState(2592)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2589)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2590)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2591)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2594)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DecimalToStringContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
			open
			func minimumStringLength() -> MinimumStringLengthContext? {
				return getRuleContext(MinimumStringLengthContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_decimalToString
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDecimalToString(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDecimalToString(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDecimalToString(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDecimalToString(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func decimalToString() throws -> DecimalToStringContext {
		var _localctx: DecimalToStringContext = DecimalToStringContext(_ctx, getState())
		try enterRule(_localctx, 262, EDIF300Parser.RULE_decimalToString)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2596)
		 	try match(EDIF300Parser.Tokens.T__111.rawValue)
		 	setState(2597)
		 	try integerExpression()
		 	setState(2599)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__335.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2598)
		 		try minimumStringLength()

		 	}

		 	setState(2601)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DefaultClusterConfigurationContext: ParserRuleContext {
			open
			func clusterConfigurationNameRef() -> ClusterConfigurationNameRefContext? {
				return getRuleContext(ClusterConfigurationNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_defaultClusterConfiguration
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDefaultClusterConfiguration(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDefaultClusterConfiguration(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDefaultClusterConfiguration(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDefaultClusterConfiguration(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func defaultClusterConfiguration() throws -> DefaultClusterConfigurationContext {
		var _localctx: DefaultClusterConfigurationContext = DefaultClusterConfigurationContext(_ctx, getState())
		try enterRule(_localctx, 264, EDIF300Parser.RULE_defaultClusterConfiguration)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2603)
		 	try match(EDIF300Parser.Tokens.T__112.rawValue)
		 	setState(2604)
		 	try clusterConfigurationNameRef()
		 	setState(2605)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DefaultConnectionContext: ParserRuleContext {
			open
			func globalPortRef() -> GlobalPortRefContext? {
				return getRuleContext(GlobalPortRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_defaultConnection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDefaultConnection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDefaultConnection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDefaultConnection(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDefaultConnection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func defaultConnection() throws -> DefaultConnectionContext {
		var _localctx: DefaultConnectionContext = DefaultConnectionContext(_ctx, getState())
		try enterRule(_localctx, 266, EDIF300Parser.RULE_defaultConnection)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2607)
		 	try match(EDIF300Parser.Tokens.T__113.rawValue)
		 	setState(2608)
		 	try globalPortRef()
		 	setState(2609)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DegreeContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_degree
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDegree(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDegree(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDegree(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDegree(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func degree() throws -> DegreeContext {
		var _localctx: DegreeContext = DegreeContext(_ctx, getState())
		try enterRule(_localctx, 268, EDIF300Parser.RULE_degree)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2611)
		 	try match(EDIF300Parser.Tokens.T__114.rawValue)
		 	setState(2612)
		 	try unitExponent()
		 	setState(2613)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DelayContext: ParserRuleContext {
			open
			func timeDelay() -> TimeDelayContext? {
				return getRuleContext(TimeDelayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_delay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDelay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDelay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDelay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDelay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func delay() throws -> DelayContext {
		var _localctx: DelayContext = DelayContext(_ctx, getState())
		try enterRule(_localctx, 270, EDIF300Parser.RULE_delay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2615)
		 	try match(EDIF300Parser.Tokens.T__115.rawValue)
		 	setState(2616)
		 	try timeDelay()
		 	setState(2617)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DenominatorContext: ParserRuleContext {
			open
			func integerValue() -> IntegerValueContext? {
				return getRuleContext(IntegerValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_denominator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDenominator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDenominator(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDenominator(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDenominator(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func denominator() throws -> DenominatorContext {
		var _localctx: DenominatorContext = DenominatorContext(_ctx, getState())
		try enterRule(_localctx, 272, EDIF300Parser.RULE_denominator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2619)
		 	try integerValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DerivationContext: ParserRuleContext {
			open
			func calculated() -> CalculatedContext? {
				return getRuleContext(CalculatedContext.self, 0)
			}
			open
			func measured() -> MeasuredContext? {
				return getRuleContext(MeasuredContext.self, 0)
			}
			open
			func required() -> RequiredContext? {
				return getRuleContext(RequiredContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_derivation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDerivation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDerivation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDerivation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDerivation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func derivation() throws -> DerivationContext {
		var _localctx: DerivationContext = DerivationContext(_ctx, getState())
		try enterRule(_localctx, 274, EDIF300Parser.RULE_derivation)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2624)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__34:
		 		setState(2621)
		 		try calculated()

		 		break

		 	case .T__331:
		 		setState(2622)
		 		try measured()

		 		break

		 	case .T__458:
		 		setState(2623)
		 		try required()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DerivedFromContext: ParserRuleContext {
			open
			func viewRef() -> ViewRefContext? {
				return getRuleContext(ViewRefContext.self, 0)
			}
			open
			func reason() -> ReasonContext? {
				return getRuleContext(ReasonContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_derivedFrom
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDerivedFrom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDerivedFrom(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDerivedFrom(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDerivedFrom(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func derivedFrom() throws -> DerivedFromContext {
		var _localctx: DerivedFromContext = DerivedFromContext(_ctx, getState())
		try enterRule(_localctx, 276, EDIF300Parser.RULE_derivedFrom)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2626)
		 	try match(EDIF300Parser.Tokens.T__116.rawValue)
		 	setState(2627)
		 	try viewRef()
		 	setState(2629)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__452.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2628)
		 		try reason()

		 	}

		 	setState(2631)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DesignContext: ParserRuleContext {
			open
			func designNameDef() -> DesignNameDefContext? {
				return getRuleContext(DesignNameDefContext.self, 0)
			}
			open
			func cellRef() -> CellRefContext? {
				return getRuleContext(CellRefContext.self, 0)
			}
			open
			func designHeader() -> DesignHeaderContext? {
				return getRuleContext(DesignHeaderContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func designHierarchy() -> [DesignHierarchyContext] {
				return getRuleContexts(DesignHierarchyContext.self)
			}
			open
			func designHierarchy(_ i: Int) -> DesignHierarchyContext? {
				return getRuleContext(DesignHierarchyContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_design
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDesign(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDesign(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDesign(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDesign(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func design() throws -> DesignContext {
		var _localctx: DesignContext = DesignContext(_ctx, getState())
		try enterRule(_localctx, 278, EDIF300Parser.RULE_design)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2633)
		 	try match(EDIF300Parser.Tokens.T__117.rawValue)
		 	setState(2634)
		 	try designNameDef()
		 	setState(2635)
		 	try cellRef()
		 	setState(2636)
		 	try designHeader()
		 	setState(2642)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue || _la == EDIF300Parser.Tokens.T__121.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2640)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(2637)
		 			try comment()

		 			break

		 		case .T__121:
		 			setState(2638)
		 			try designHierarchy()

		 			break

		 		case .T__642:
		 			setState(2639)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2644)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2645)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DesignatorContext: ParserRuleContext {
			open
			func stringValue() -> StringValueContext? {
				return getRuleContext(StringValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_designator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDesignator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDesignator(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDesignator(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDesignator(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func designator() throws -> DesignatorContext {
		var _localctx: DesignatorContext = DesignatorContext(_ctx, getState())
		try enterRule(_localctx, 280, EDIF300Parser.RULE_designator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2647)
		 	try match(EDIF300Parser.Tokens.T__118.rawValue)
		 	setState(2648)
		 	try stringValue()
		 	setState(2649)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DesignatorDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_designatorDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDesignatorDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDesignatorDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDesignatorDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDesignatorDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func designatorDisplay() throws -> DesignatorDisplayContext {
		var _localctx: DesignatorDisplayContext = DesignatorDisplayContext(_ctx, getState())
		try enterRule(_localctx, 282, EDIF300Parser.RULE_designatorDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2651)
		 	try match(EDIF300Parser.Tokens.T__119.rawValue)
		 	setState(2655)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2652)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2653)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2654)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2657)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DesignHeaderContext: ParserRuleContext {
			open
			func designUnits() -> DesignUnitsContext? {
				return getRuleContext(DesignUnitsContext.self, 0)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_designHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDesignHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDesignHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDesignHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDesignHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func designHeader() throws -> DesignHeaderContext {
		var _localctx: DesignHeaderContext = DesignHeaderContext(_ctx, getState())
		try enterRule(_localctx, 284, EDIF300Parser.RULE_designHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2659)
		 	try match(EDIF300Parser.Tokens.T__120.rawValue)
		 	setState(2660)
		 	try designUnits()
		 	setState(2667)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2665)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__132:
		 			setState(2661)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(2662)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(2663)
		 			try property()

		 			break

		 		case .T__597:
		 			setState(2664)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2669)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2670)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DesignHierarchyContext: ParserRuleContext {
			open
			func designHierarchyNameDef() -> DesignHierarchyNameDefContext? {
				return getRuleContext(DesignHierarchyNameDefContext.self, 0)
			}
			open
			func clusterRef() -> ClusterRefContext? {
				return getRuleContext(ClusterRefContext.self, 0)
			}
			open
			func clusterConfigurationRef() -> ClusterConfigurationRefContext? {
				return getRuleContext(ClusterConfigurationRefContext.self, 0)
			}
			open
			func designHierarchyHeader() -> DesignHierarchyHeaderContext? {
				return getRuleContext(DesignHierarchyHeaderContext.self, 0)
			}
			open
			func occurrenceHierarchyAnnotate() -> OccurrenceHierarchyAnnotateContext? {
				return getRuleContext(OccurrenceHierarchyAnnotateContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_designHierarchy
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDesignHierarchy(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDesignHierarchy(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDesignHierarchy(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDesignHierarchy(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func designHierarchy() throws -> DesignHierarchyContext {
		var _localctx: DesignHierarchyContext = DesignHierarchyContext(_ctx, getState())
		try enterRule(_localctx, 286, EDIF300Parser.RULE_designHierarchy)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2672)
		 	try match(EDIF300Parser.Tokens.T__121.rawValue)
		 	setState(2673)
		 	try designHierarchyNameDef()
		 	setState(2674)
		 	try clusterRef()
		 	setState(2675)
		 	try clusterConfigurationRef()
		 	setState(2676)
		 	try designHierarchyHeader()
		 	setState(2678)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__362.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2677)
		 		try occurrenceHierarchyAnnotate()

		 	}

		 	setState(2680)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DesignHierarchyHeaderContext: ParserRuleContext {
			open
			func booleanParameterAssign() -> [BooleanParameterAssignContext] {
				return getRuleContexts(BooleanParameterAssignContext.self)
			}
			open
			func booleanParameterAssign(_ i: Int) -> BooleanParameterAssignContext? {
				return getRuleContext(BooleanParameterAssignContext.self, i)
			}
			open
			func integerParameterAssign() -> [IntegerParameterAssignContext] {
				return getRuleContexts(IntegerParameterAssignContext.self)
			}
			open
			func integerParameterAssign(_ i: Int) -> IntegerParameterAssignContext? {
				return getRuleContext(IntegerParameterAssignContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func numberParameterAssign() -> [NumberParameterAssignContext] {
				return getRuleContexts(NumberParameterAssignContext.self)
			}
			open
			func numberParameterAssign(_ i: Int) -> NumberParameterAssignContext? {
				return getRuleContext(NumberParameterAssignContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func stringParameterAssign() -> [StringParameterAssignContext] {
				return getRuleContexts(StringParameterAssignContext.self)
			}
			open
			func stringParameterAssign(_ i: Int) -> StringParameterAssignContext? {
				return getRuleContext(StringParameterAssignContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_designHierarchyHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDesignHierarchyHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDesignHierarchyHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDesignHierarchyHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDesignHierarchyHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func designHierarchyHeader() throws -> DesignHierarchyHeaderContext {
		var _localctx: DesignHierarchyHeaderContext = DesignHierarchyHeaderContext(_ctx, getState())
		try enterRule(_localctx, 288, EDIF300Parser.RULE_designHierarchyHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2682)
		 	try match(EDIF300Parser.Tokens.T__122.rawValue)
		 	setState(2691)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__28.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__252.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue || _la == EDIF300Parser.Tokens.T__358.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__606.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2689)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__28:
		 			setState(2683)
		 			try booleanParameterAssign()

		 			break

		 		case .T__252:
		 			setState(2684)
		 			try integerParameterAssign()

		 			break

		 		case .T__346:
		 			setState(2685)
		 			try nameInformation()

		 			break

		 		case .T__358:
		 			setState(2686)
		 			try numberParameterAssign()

		 			break

		 		case .T__442:
		 			setState(2687)
		 			try property()

		 			break

		 		case .T__606:
		 			setState(2688)
		 			try stringParameterAssign()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2693)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2694)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DesignHierarchyNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_designHierarchyNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDesignHierarchyNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDesignHierarchyNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDesignHierarchyNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDesignHierarchyNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func designHierarchyNameCaseSensitive() throws -> DesignHierarchyNameCaseSensitiveContext {
		var _localctx: DesignHierarchyNameCaseSensitiveContext = DesignHierarchyNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 290, EDIF300Parser.RULE_designHierarchyNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2696)
		 	try match(EDIF300Parser.Tokens.T__123.rawValue)
		 	setState(2697)
		 	try booleanToken()
		 	setState(2698)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DesignHierarchyNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_designHierarchyNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDesignHierarchyNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDesignHierarchyNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDesignHierarchyNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDesignHierarchyNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func designHierarchyNameDef() throws -> DesignHierarchyNameDefContext {
		var _localctx: DesignHierarchyNameDefContext = DesignHierarchyNameDefContext(_ctx, getState())
		try enterRule(_localctx, 292, EDIF300Parser.RULE_designHierarchyNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2700)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DesignNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_designNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDesignNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDesignNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDesignNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDesignNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func designNameCaseSensitive() throws -> DesignNameCaseSensitiveContext {
		var _localctx: DesignNameCaseSensitiveContext = DesignNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 294, EDIF300Parser.RULE_designNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2702)
		 	try match(EDIF300Parser.Tokens.T__124.rawValue)
		 	setState(2703)
		 	try booleanToken()
		 	setState(2704)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DesignNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_designNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDesignNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDesignNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDesignNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDesignNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func designNameDef() throws -> DesignNameDefContext {
		var _localctx: DesignNameDefContext = DesignNameDefContext(_ctx, getState())
		try enterRule(_localctx, 296, EDIF300Parser.RULE_designNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2706)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DesignUnitsContext: ParserRuleContext {
			open
			func setCapacitance() -> [SetCapacitanceContext] {
				return getRuleContexts(SetCapacitanceContext.self)
			}
			open
			func setCapacitance(_ i: Int) -> SetCapacitanceContext? {
				return getRuleContext(SetCapacitanceContext.self, i)
			}
			open
			func setTime() -> [SetTimeContext] {
				return getRuleContexts(SetTimeContext.self)
			}
			open
			func setTime(_ i: Int) -> SetTimeContext? {
				return getRuleContext(SetTimeContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_designUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDesignUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDesignUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDesignUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDesignUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func designUnits() throws -> DesignUnitsContext {
		var _localctx: DesignUnitsContext = DesignUnitsContext(_ctx, getState())
		try enterRule(_localctx, 298, EDIF300Parser.RULE_designUnits)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2708)
		 	try match(EDIF300Parser.Tokens.T__125.rawValue)
		 	setState(2713)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__576.rawValue || _la == EDIF300Parser.Tokens.T__580.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2711)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__576:
		 			setState(2709)
		 			try setCapacitance()

		 			break

		 		case .T__580:
		 			setState(2710)
		 			try setTime()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2715)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2716)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DiagramContext: ParserRuleContext {
			open
			func diagramNameDef() -> DiagramNameDefContext? {
				return getRuleContext(DiagramNameDefContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_diagram
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDiagram(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDiagram(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDiagram(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDiagram(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func diagram() throws -> DiagramContext {
		var _localctx: DiagramContext = DiagramContext(_ctx, getState())
		try enterRule(_localctx, 300, EDIF300Parser.RULE_diagram)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2718)
		 	try match(EDIF300Parser.Tokens.T__126.rawValue)
		 	setState(2719)
		 	try diagramNameDef()
		 	setState(2726)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2724)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(2720)
		 			try annotate()

		 			break

		 		case .T__61:
		 			setState(2721)
		 			try comment()

		 			break

		 		case .T__159:
		 			setState(2722)
		 			try figure()

		 			break

		 		case .T__642:
		 			setState(2723)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2728)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2729)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DiagramNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_diagramNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDiagramNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDiagramNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDiagramNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDiagramNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func diagramNameDef() throws -> DiagramNameDefContext {
		var _localctx: DiagramNameDefContext = DiagramNameDefContext(_ctx, getState())
		try enterRule(_localctx, 302, EDIF300Parser.RULE_diagramNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2731)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DirectionalPortAttributeOverrideContext: ParserRuleContext {
			open
			func inputPortAttributes() -> InputPortAttributesContext? {
				return getRuleContext(InputPortAttributesContext.self, 0)
			}
			open
			func outputPortAttributes() -> OutputPortAttributesContext? {
				return getRuleContext(OutputPortAttributesContext.self, 0)
			}
			open
			func bidirectionalPortAttributes() -> BidirectionalPortAttributesContext? {
				return getRuleContext(BidirectionalPortAttributesContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_directionalPortAttributeOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDirectionalPortAttributeOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDirectionalPortAttributeOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDirectionalPortAttributeOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDirectionalPortAttributeOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func directionalPortAttributeOverride() throws -> DirectionalPortAttributeOverrideContext {
		var _localctx: DirectionalPortAttributeOverrideContext = DirectionalPortAttributeOverrideContext(_ctx, getState())
		try enterRule(_localctx, 304, EDIF300Parser.RULE_directionalPortAttributeOverride)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2733)
		 	try match(EDIF300Parser.Tokens.T__127.rawValue)
		 	setState(2737)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__231:
		 		setState(2734)
		 		try inputPortAttributes()

		 		break

		 	case .T__376:
		 		setState(2735)
		 		try outputPortAttributes()

		 		break

		 	case .T__20:
		 		setState(2736)
		 		try bidirectionalPortAttributes()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2739)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DisplayContext: ParserRuleContext {
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func figureGroupNameRef() -> [FigureGroupNameRefContext] {
				return getRuleContexts(FigureGroupNameRefContext.self)
			}
			open
			func figureGroupNameRef(_ i: Int) -> FigureGroupNameRefContext? {
				return getRuleContext(FigureGroupNameRefContext.self, i)
			}
			open
			func figureGroupOverride() -> [FigureGroupOverrideContext] {
				return getRuleContexts(FigureGroupOverrideContext.self)
			}
			open
			func figureGroupOverride(_ i: Int) -> FigureGroupOverrideContext? {
				return getRuleContext(FigureGroupOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_display
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func display() throws -> DisplayContext {
		var _localctx: DisplayContext = DisplayContext(_ctx, getState())
		try enterRule(_localctx, 306, EDIF300Parser.RULE_display)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2741)
		 	try match(EDIF300Parser.Tokens.T__128.rawValue)
		 	setState(2746)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__162.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2744)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .IDENTIFIER:
		 			setState(2742)
		 			try figureGroupNameRef()

		 			break

		 		case .T__162:
		 			setState(2743)
		 			try figureGroupOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2748)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2749)
		 	try transform()
		 	setState(2750)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DisplayAttributesContext: ParserRuleContext {
			open
			func borderPattern() -> [BorderPatternContext] {
				return getRuleContexts(BorderPatternContext.self)
			}
			open
			func borderPattern(_ i: Int) -> BorderPatternContext? {
				return getRuleContext(BorderPatternContext.self, i)
			}
			open
			func borderPatternVisible() -> [BorderPatternVisibleContext] {
				return getRuleContexts(BorderPatternVisibleContext.self)
			}
			open
			func borderPatternVisible(_ i: Int) -> BorderPatternVisibleContext? {
				return getRuleContext(BorderPatternVisibleContext.self, i)
			}
			open
			func borderWidth() -> [BorderWidthContext] {
				return getRuleContexts(BorderWidthContext.self)
			}
			open
			func borderWidth(_ i: Int) -> BorderWidthContext? {
				return getRuleContext(BorderWidthContext.self, i)
			}
			open
			func color() -> [ColorContext] {
				return getRuleContexts(ColorContext.self)
			}
			open
			func color(_ i: Int) -> ColorContext? {
				return getRuleContext(ColorContext.self, i)
			}
			open
			func fillPattern() -> [FillPatternContext] {
				return getRuleContexts(FillPatternContext.self)
			}
			open
			func fillPattern(_ i: Int) -> FillPatternContext? {
				return getRuleContext(FillPatternContext.self, i)
			}
			open
			func fillPatternVisible() -> [FillPatternVisibleContext] {
				return getRuleContexts(FillPatternVisibleContext.self)
			}
			open
			func fillPatternVisible(_ i: Int) -> FillPatternVisibleContext? {
				return getRuleContext(FillPatternVisibleContext.self, i)
			}
			open
			func fontRef() -> [FontRefContext] {
				return getRuleContexts(FontRefContext.self)
			}
			open
			func fontRef(_ i: Int) -> FontRefContext? {
				return getRuleContext(FontRefContext.self, i)
			}
			open
			func horizontalJustification() -> [HorizontalJustificationContext] {
				return getRuleContexts(HorizontalJustificationContext.self)
			}
			open
			func horizontalJustification(_ i: Int) -> HorizontalJustificationContext? {
				return getRuleContext(HorizontalJustificationContext.self, i)
			}
			open
			func textHeight() -> [TextHeightContext] {
				return getRuleContexts(TextHeightContext.self)
			}
			open
			func textHeight(_ i: Int) -> TextHeightContext? {
				return getRuleContext(TextHeightContext.self, i)
			}
			open
			func verticalJustification() -> [VerticalJustificationContext] {
				return getRuleContexts(VerticalJustificationContext.self)
			}
			open
			func verticalJustification(_ i: Int) -> VerticalJustificationContext? {
				return getRuleContext(VerticalJustificationContext.self, i)
			}
			open
			func visible() -> [VisibleContext] {
				return getRuleContexts(VisibleContext.self)
			}
			open
			func visible(_ i: Int) -> VisibleContext? {
				return getRuleContext(VisibleContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_displayAttributes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDisplayAttributes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDisplayAttributes(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDisplayAttributes(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDisplayAttributes(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func displayAttributes() throws -> DisplayAttributesContext {
		var _localctx: DisplayAttributesContext = DisplayAttributesContext(_ctx, getState())
		try enterRule(_localctx, 308, EDIF300Parser.RULE_displayAttributes)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2752)
		 	try match(EDIF300Parser.Tokens.T__129.rawValue)
		 	setState(2766)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__30.rawValue,EDIF300Parser.Tokens.T__31.rawValue,EDIF300Parser.Tokens.T__32.rawValue,EDIF300Parser.Tokens.T__60.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__163.rawValue,EDIF300Parser.Tokens.T__164.rawValue,EDIF300Parser.Tokens.T__172.rawValue,EDIF300Parser.Tokens.T__207.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 164)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__615.rawValue,EDIF300Parser.Tokens.T__644.rawValue,EDIF300Parser.Tokens.T__654.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 616)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2764)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__30:
		 			setState(2753)
		 			try borderPattern()

		 			break

		 		case .T__31:
		 			setState(2754)
		 			try borderPatternVisible()

		 			break

		 		case .T__32:
		 			setState(2755)
		 			try borderWidth()

		 			break

		 		case .T__60:
		 			setState(2756)
		 			try color()

		 			break

		 		case .T__163:
		 			setState(2757)
		 			try fillPattern()

		 			break

		 		case .T__164:
		 			setState(2758)
		 			try fillPatternVisible()

		 			break

		 		case .T__172:
		 			setState(2759)
		 			try fontRef()

		 			break

		 		case .T__207:
		 			setState(2760)
		 			try horizontalJustification()

		 			break

		 		case .T__615:
		 			setState(2761)
		 			try textHeight()

		 			break

		 		case .T__644:
		 			setState(2762)
		 			try verticalJustification()

		 			break

		 		case .T__654:
		 			setState(2763)
		 			try visible()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2768)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2769)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DisplayNameContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_displayName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDisplayName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDisplayName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDisplayName(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDisplayName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func displayName() throws -> DisplayNameContext {
		var _localctx: DisplayNameContext = DisplayNameContext(_ctx, getState())
		try enterRule(_localctx, 310, EDIF300Parser.RULE_displayName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2771)
		 	try match(EDIF300Parser.Tokens.T__130.rawValue)
		 	setState(2772)
		 	try stringToken()
		 	setState(2773)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DisplayNameOverrideContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_displayNameOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDisplayNameOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDisplayNameOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDisplayNameOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDisplayNameOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func displayNameOverride() throws -> DisplayNameOverrideContext {
		var _localctx: DisplayNameOverrideContext = DisplayNameOverrideContext(_ctx, getState())
		try enterRule(_localctx, 312, EDIF300Parser.RULE_displayNameOverride)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2775)
		 	try match(EDIF300Parser.Tokens.T__131.rawValue)
		 	setState(2776)
		 	try stringToken()
		 	setState(2780)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2777)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2778)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2779)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2782)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DistanceValueContext: ParserRuleContext {
			open
			func integerValue() -> IntegerValueContext? {
				return getRuleContext(IntegerValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_distanceValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDistanceValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDistanceValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDistanceValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDistanceValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func distanceValue() throws -> DistanceValueContext {
		var _localctx: DistanceValueContext = DistanceValueContext(_ctx, getState())
		try enterRule(_localctx, 314, EDIF300Parser.RULE_distanceValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2784)
		 	try integerValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DividendContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dividend
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDividend(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDividend(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDividend(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDividend(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dividend() throws -> DividendContext {
		var _localctx: DividendContext = DividendContext(_ctx, getState())
		try enterRule(_localctx, 316, EDIF300Parser.RULE_dividend)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2786)
		 	try integerExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DivisorContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_divisor
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDivisor(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDivisor(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDivisor(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDivisor(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func divisor() throws -> DivisorContext {
		var _localctx: DivisorContext = DivisorContext(_ctx, getState())
		try enterRule(_localctx, 318, EDIF300Parser.RULE_divisor)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2788)
		 	try integerExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DocumentationContext: ParserRuleContext {
			open
			func documentationNameDef() -> DocumentationNameDefContext? {
				return getRuleContext(DocumentationNameDefContext.self, 0)
			}
			open
			func documentationHeader() -> DocumentationHeaderContext? {
				return getRuleContext(DocumentationHeaderContext.self, 0)
			}
			open
			func section() -> [SectionContext] {
				return getRuleContexts(SectionContext.self)
			}
			open
			func section(_ i: Int) -> SectionContext? {
				return getRuleContext(SectionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_documentation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDocumentation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDocumentation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDocumentation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDocumentation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func documentation() throws -> DocumentationContext {
		var _localctx: DocumentationContext = DocumentationContext(_ctx, getState())
		try enterRule(_localctx, 320, EDIF300Parser.RULE_documentation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2790)
		 	try match(EDIF300Parser.Tokens.T__132.rawValue)
		 	setState(2791)
		 	try documentationNameDef()
		 	setState(2792)
		 	try documentationHeader()
		 	setState(2796)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__572.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2793)
		 		try section()


		 		setState(2798)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2799)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DocumentationHeaderContext: ParserRuleContext {
			open
			func documentationUnits() -> DocumentationUnitsContext? {
				return getRuleContext(DocumentationUnitsContext.self, 0)
			}
			open
			func backgroundColor() -> [BackgroundColorContext] {
				return getRuleContexts(BackgroundColorContext.self)
			}
			open
			func backgroundColor(_ i: Int) -> BackgroundColorContext? {
				return getRuleContext(BackgroundColorContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_documentationHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDocumentationHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDocumentationHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDocumentationHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDocumentationHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func documentationHeader() throws -> DocumentationHeaderContext {
		var _localctx: DocumentationHeaderContext = DocumentationHeaderContext(_ctx, getState())
		try enterRule(_localctx, 322, EDIF300Parser.RULE_documentationHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2801)
		 	try match(EDIF300Parser.Tokens.T__133.rawValue)
		 	setState(2802)
		 	try documentationUnits()
		 	setState(2808)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__14.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2806)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__14:
		 			setState(2803)
		 			try backgroundColor()

		 			break

		 		case .T__346:
		 			setState(2804)
		 			try nameInformation()

		 			break

		 		case .T__597:
		 			setState(2805)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2810)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2811)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DocumentationNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_documentationNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDocumentationNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDocumentationNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDocumentationNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDocumentationNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func documentationNameCaseSensitive() throws -> DocumentationNameCaseSensitiveContext {
		var _localctx: DocumentationNameCaseSensitiveContext = DocumentationNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 324, EDIF300Parser.RULE_documentationNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2813)
		 	try match(EDIF300Parser.Tokens.T__134.rawValue)
		 	setState(2814)
		 	try booleanToken()
		 	setState(2815)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DocumentationNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_documentationNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDocumentationNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDocumentationNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDocumentationNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDocumentationNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func documentationNameDef() throws -> DocumentationNameDefContext {
		var _localctx: DocumentationNameDefContext = DocumentationNameDefContext(_ctx, getState())
		try enterRule(_localctx, 326, EDIF300Parser.RULE_documentationNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2817)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DocumentationUnitsContext: ParserRuleContext {
			open
			func setAngle() -> [SetAngleContext] {
				return getRuleContexts(SetAngleContext.self)
			}
			open
			func setAngle(_ i: Int) -> SetAngleContext? {
				return getRuleContext(SetAngleContext.self, i)
			}
			open
			func setDistance() -> [SetDistanceContext] {
				return getRuleContexts(SetDistanceContext.self)
			}
			open
			func setDistance(_ i: Int) -> SetDistanceContext? {
				return getRuleContext(SetDistanceContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_documentationUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDocumentationUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDocumentationUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDocumentationUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDocumentationUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func documentationUnits() throws -> DocumentationUnitsContext {
		var _localctx: DocumentationUnitsContext = DocumentationUnitsContext(_ctx, getState())
		try enterRule(_localctx, 328, EDIF300Parser.RULE_documentationUnits)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2819)
		 	try match(EDIF300Parser.Tokens.T__135.rawValue)
		 	setState(2824)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__575.rawValue || _la == EDIF300Parser.Tokens.T__578.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2822)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__575:
		 			setState(2820)
		 			try setAngle()

		 			break

		 		case .T__578:
		 			setState(2821)
		 			try setDistance()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2826)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2827)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DominatesContext: ParserRuleContext {
			open
			func logicNameRef() -> [LogicNameRefContext] {
				return getRuleContexts(LogicNameRefContext.self)
			}
			open
			func logicNameRef(_ i: Int) -> LogicNameRefContext? {
				return getRuleContext(LogicNameRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dominates
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDominates(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDominates(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDominates(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDominates(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dominates() throws -> DominatesContext {
		var _localctx: DominatesContext = DominatesContext(_ctx, getState())
		try enterRule(_localctx, 330, EDIF300Parser.RULE_dominates)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2829)
		 	try match(EDIF300Parser.Tokens.T__136.rawValue)
		 	setState(2833)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2830)
		 		try logicNameRef()


		 		setState(2835)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2836)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DotContext: ParserRuleContext {
			open
			func pointValue() -> PointValueContext? {
				return getRuleContext(PointValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_dot
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDot(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDot(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDot(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDot(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func dot() throws -> DotContext {
		var _localctx: DotContext = DotContext(_ctx, getState())
		try enterRule(_localctx, 332, EDIF300Parser.RULE_dot)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2838)
		 	try match(EDIF300Parser.Tokens.T__137.rawValue)
		 	setState(2839)
		 	try pointValue()
		 	setState(2840)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DrawingDescriptionContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_drawingDescription
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDrawingDescription(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDrawingDescription(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDrawingDescription(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDrawingDescription(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func drawingDescription() throws -> DrawingDescriptionContext {
		var _localctx: DrawingDescriptionContext = DrawingDescriptionContext(_ctx, getState())
		try enterRule(_localctx, 334, EDIF300Parser.RULE_drawingDescription)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2842)
		 	try match(EDIF300Parser.Tokens.T__138.rawValue)
		 	setState(2843)
		 	try stringToken()
		 	setState(2844)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DrawingDescriptionDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_drawingDescriptionDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDrawingDescriptionDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDrawingDescriptionDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDrawingDescriptionDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDrawingDescriptionDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func drawingDescriptionDisplay() throws -> DrawingDescriptionDisplayContext {
		var _localctx: DrawingDescriptionDisplayContext = DrawingDescriptionDisplayContext(_ctx, getState())
		try enterRule(_localctx, 336, EDIF300Parser.RULE_drawingDescriptionDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2846)
		 	try match(EDIF300Parser.Tokens.T__139.rawValue)
		 	setState(2850)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2847)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2848)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2849)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2852)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DrawingIdentificationContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_drawingIdentification
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDrawingIdentification(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDrawingIdentification(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDrawingIdentification(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDrawingIdentification(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func drawingIdentification() throws -> DrawingIdentificationContext {
		var _localctx: DrawingIdentificationContext = DrawingIdentificationContext(_ctx, getState())
		try enterRule(_localctx, 338, EDIF300Parser.RULE_drawingIdentification)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2854)
		 	try match(EDIF300Parser.Tokens.T__140.rawValue)
		 	setState(2855)
		 	try stringToken()
		 	setState(2856)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DrawingIdentificationDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_drawingIdentificationDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDrawingIdentificationDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDrawingIdentificationDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDrawingIdentificationDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDrawingIdentificationDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func drawingIdentificationDisplay() throws -> DrawingIdentificationDisplayContext {
		var _localctx: DrawingIdentificationDisplayContext = DrawingIdentificationDisplayContext(_ctx, getState())
		try enterRule(_localctx, 340, EDIF300Parser.RULE_drawingIdentificationDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2858)
		 	try match(EDIF300Parser.Tokens.T__141.rawValue)
		 	setState(2862)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2859)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2860)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2861)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2864)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DrawingSizeContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_drawingSize
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDrawingSize(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDrawingSize(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDrawingSize(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDrawingSize(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func drawingSize() throws -> DrawingSizeContext {
		var _localctx: DrawingSizeContext = DrawingSizeContext(_ctx, getState())
		try enterRule(_localctx, 342, EDIF300Parser.RULE_drawingSize)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2866)
		 	try match(EDIF300Parser.Tokens.T__142.rawValue)
		 	setState(2867)
		 	try stringToken()
		 	setState(2868)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DrawingSizeDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_drawingSizeDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDrawingSizeDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDrawingSizeDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDrawingSizeDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDrawingSizeDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func drawingSizeDisplay() throws -> DrawingSizeDisplayContext {
		var _localctx: DrawingSizeDisplayContext = DrawingSizeDisplayContext(_ctx, getState())
		try enterRule(_localctx, 344, EDIF300Parser.RULE_drawingSizeDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2870)
		 	try match(EDIF300Parser.Tokens.T__143.rawValue)
		 	setState(2874)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2871)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2872)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2873)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2876)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DurationContext: ParserRuleContext {
			open
			func timeValue() -> TimeValueContext? {
				return getRuleContext(TimeValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_duration
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterDuration(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitDuration(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitDuration(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitDuration(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func duration() throws -> DurationContext {
		var _localctx: DurationContext = DurationContext(_ctx, getState())
		try enterRule(_localctx, 346, EDIF300Parser.RULE_duration)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2878)
		 	try match(EDIF300Parser.Tokens.T__144.rawValue)
		 	setState(2879)
		 	try timeValue()
		 	setState(2880)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EContext: ParserRuleContext {
			open
			func mantissa() -> MantissaContext? {
				return getRuleContext(MantissaContext.self, 0)
			}
			open
			func exponent() -> ExponentContext? {
				return getRuleContext(ExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_e
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterE(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitE(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitE(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitE(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func e() throws -> EContext {
		var _localctx: EContext = EContext(_ctx, getState())
		try enterRule(_localctx, 348, EDIF300Parser.RULE_e)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2882)
		 	try match(EDIF300Parser.Tokens.T__145.rawValue)
		 	setState(2883)
		 	try mantissa()
		 	setState(2884)
		 	try exponent()
		 	setState(2885)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EdifContext: ParserRuleContext {
			open
			func edifNameDef() -> EdifNameDefContext? {
				return getRuleContext(EdifNameDefContext.self, 0)
			}
			open
			func edifVersion() -> EdifVersionContext? {
				return getRuleContext(EdifVersionContext.self, 0)
			}
			open
			func edifHeader() -> EdifHeaderContext? {
				return getRuleContext(EdifHeaderContext.self, 0)
			}
			open
			func library() -> [LibraryContext] {
				return getRuleContexts(LibraryContext.self)
			}
			open
			func library(_ i: Int) -> LibraryContext? {
				return getRuleContext(LibraryContext.self, i)
			}
			open
			func design() -> [DesignContext] {
				return getRuleContexts(DesignContext.self)
			}
			open
			func design(_ i: Int) -> DesignContext? {
				return getRuleContext(DesignContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func external() -> [ExternalContext] {
				return getRuleContexts(ExternalContext.self)
			}
			open
			func external(_ i: Int) -> ExternalContext? {
				return getRuleContext(ExternalContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_edif
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEdif(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEdif(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEdif(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEdif(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func edif() throws -> EdifContext {
		var _localctx: EdifContext = EdifContext(_ctx, getState())
		try enterRule(_localctx, 350, EDIF300Parser.RULE_edif)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2887)
		 	try match(EDIF300Parser.Tokens.T__146.rawValue)
		 	setState(2888)
		 	try edifNameDef()
		 	setState(2889)
		 	try edifVersion()
		 	setState(2890)
		 	try edifHeader()
		 	setState(2898)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__117.rawValue || _la == EDIF300Parser.Tokens.T__155.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__309.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2896)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__309:
		 			setState(2891)
		 			try library()

		 			break

		 		case .T__117:
		 			setState(2892)
		 			try design()

		 			break

		 		case .T__61:
		 			setState(2893)
		 			try comment()

		 			break

		 		case .T__155:
		 			setState(2894)
		 			try external()

		 			break

		 		case .T__642:
		 			setState(2895)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2900)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2901)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EdifHeaderContext: ParserRuleContext {
			open
			func edifLevel() -> EdifLevelContext? {
				return getRuleContext(EdifLevelContext.self, 0)
			}
			open
			func keywordMap() -> KeywordMapContext? {
				return getRuleContext(KeywordMapContext.self, 0)
			}
			open
			func unitDefinitions() -> UnitDefinitionsContext? {
				return getRuleContext(UnitDefinitionsContext.self, 0)
			}
			open
			func fontDefinitions() -> FontDefinitionsContext? {
				return getRuleContext(FontDefinitionsContext.self, 0)
			}
			open
			func physicalDefaults() -> PhysicalDefaultsContext? {
				return getRuleContext(PhysicalDefaultsContext.self, 0)
			}
			open
			func characterEncoding() -> [CharacterEncodingContext] {
				return getRuleContexts(CharacterEncodingContext.self)
			}
			open
			func characterEncoding(_ i: Int) -> CharacterEncodingContext? {
				return getRuleContext(CharacterEncodingContext.self, i)
			}
			open
			func constantValues() -> [ConstantValuesContext] {
				return getRuleContexts(ConstantValuesContext.self)
			}
			open
			func constantValues(_ i: Int) -> ConstantValuesContext? {
				return getRuleContext(ConstantValuesContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func globalPortDefinitions() -> [GlobalPortDefinitionsContext] {
				return getRuleContexts(GlobalPortDefinitionsContext.self)
			}
			open
			func globalPortDefinitions(_ i: Int) -> GlobalPortDefinitionsContext? {
				return getRuleContext(GlobalPortDefinitionsContext.self, i)
			}
			open
			func nameCaseSensitivity() -> [NameCaseSensitivityContext] {
				return getRuleContexts(NameCaseSensitivityContext.self)
			}
			open
			func nameCaseSensitivity(_ i: Int) -> NameCaseSensitivityContext? {
				return getRuleContext(NameCaseSensitivityContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func physicalScaling() -> [PhysicalScalingContext] {
				return getRuleContexts(PhysicalScalingContext.self)
			}
			open
			func physicalScaling(_ i: Int) -> PhysicalScalingContext? {
				return getRuleContext(PhysicalScalingContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_edifHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEdifHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEdifHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEdifHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEdifHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func edifHeader() throws -> EdifHeaderContext {
		var _localctx: EdifHeaderContext = EdifHeaderContext(_ctx, getState())
		try enterRule(_localctx, 352, EDIF300Parser.RULE_edifHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2903)
		 	try match(EDIF300Parser.Tokens.T__147.rawValue)
		 	setState(2904)
		 	try edifLevel()
		 	setState(2905)
		 	try keywordMap()
		 	setState(2906)
		 	try unitDefinitions()
		 	setState(2907)
		 	try fontDefinitions()
		 	setState(2908)
		 	try physicalDefaults()
		 	setState(2920)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__46.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__90.rawValue || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__198.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__343.rawValue || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__408.rawValue || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2918)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__46:
		 			setState(2909)
		 			try characterEncoding()

		 			break

		 		case .T__90:
		 			setState(2910)
		 			try constantValues()

		 			break

		 		case .T__132:
		 			setState(2911)
		 			try documentation()

		 			break

		 		case .T__198:
		 			setState(2912)
		 			try globalPortDefinitions()

		 			break

		 		case .T__343:
		 			setState(2913)
		 			try nameCaseSensitivity()

		 			break

		 		case .T__346:
		 			setState(2914)
		 			try nameInformation()

		 			break

		 		case .T__408:
		 			setState(2915)
		 			try physicalScaling()

		 			break

		 		case .T__442:
		 			setState(2916)
		 			try property()

		 			break

		 		case .T__597:
		 			setState(2917)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2922)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2923)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EdifLevelContext: ParserRuleContext {
			open
			func edifLevelValue() -> EdifLevelValueContext? {
				return getRuleContext(EdifLevelValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_edifLevel
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEdifLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEdifLevel(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEdifLevel(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEdifLevel(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func edifLevel() throws -> EdifLevelContext {
		var _localctx: EdifLevelContext = EdifLevelContext(_ctx, getState())
		try enterRule(_localctx, 354, EDIF300Parser.RULE_edifLevel)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2925)
		 	try match(EDIF300Parser.Tokens.T__148.rawValue)
		 	setState(2926)
		 	try edifLevelValue()
		 	setState(2927)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EdifLevelValueContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_edifLevelValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEdifLevelValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEdifLevelValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEdifLevelValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEdifLevelValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func edifLevelValue() throws -> EdifLevelValueContext {
		var _localctx: EdifLevelValueContext = EdifLevelValueContext(_ctx, getState())
		try enterRule(_localctx, 356, EDIF300Parser.RULE_edifLevelValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2929)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EdifNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_edifNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEdifNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEdifNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEdifNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEdifNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func edifNameDef() throws -> EdifNameDefContext {
		var _localctx: EdifNameDefContext = EdifNameDefContext(_ctx, getState())
		try enterRule(_localctx, 358, EDIF300Parser.RULE_edifNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2931)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EdifVersionContext: ParserRuleContext {
			open
			func mark() -> MarkContext? {
				return getRuleContext(MarkContext.self, 0)
			}
			open
			func issue() -> IssueContext? {
				return getRuleContext(IssueContext.self, 0)
			}
			open
			func subIssue() -> SubIssueContext? {
				return getRuleContext(SubIssueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_edifVersion
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEdifVersion(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEdifVersion(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEdifVersion(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEdifVersion(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func edifVersion() throws -> EdifVersionContext {
		var _localctx: EdifVersionContext = EdifVersionContext(_ctx, getState())
		try enterRule(_localctx, 360, EDIF300Parser.RULE_edifVersion)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2933)
		 	try match(EDIF300Parser.Tokens.T__149.rawValue)
		 	setState(2934)
		 	try mark()
		 	setState(2935)
		 	try issue()
		 	setState(2936)
		 	try subIssue()
		 	setState(2937)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EndPointContext: ParserRuleContext {
			open
			func pointValue() -> PointValueContext? {
				return getRuleContext(PointValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_endPoint
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEndPoint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEndPoint(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEndPoint(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEndPoint(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func endPoint() throws -> EndPointContext {
		var _localctx: EndPointContext = EndPointContext(_ctx, getState())
		try enterRule(_localctx, 362, EDIF300Parser.RULE_endPoint)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2939)
		 	try pointValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EndTypeContext: ParserRuleContext {
			open
			func truncate() -> TruncateContext? {
				return getRuleContext(TruncateContext.self, 0)
			}
			open
			func round() -> RoundContext? {
				return getRuleContext(RoundContext.self, 0)
			}
			open
			func extend() -> ExtendContext? {
				return getRuleContext(ExtendContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_endType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEndType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEndType(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEndType(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEndType(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func endType() throws -> EndTypeContext {
		var _localctx: EndTypeContext = EndTypeContext(_ctx, getState())
		try enterRule(_localctx, 364, EDIF300Parser.RULE_endType)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2941)
		 	try match(EDIF300Parser.Tokens.T__150.rawValue)
		 	setState(2945)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__627:
		 		setState(2942)
		 		try truncate()

		 		break

		 	case .T__466:
		 		setState(2943)
		 		try round()

		 		break

		 	case .T__154:
		 		setState(2944)
		 		try extend()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2947)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EngineeringDateContext: ParserRuleContext {
			open
			func date() -> DateContext? {
				return getRuleContext(DateContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_engineeringDate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEngineeringDate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEngineeringDate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEngineeringDate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEngineeringDate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func engineeringDate() throws -> EngineeringDateContext {
		var _localctx: EngineeringDateContext = EngineeringDateContext(_ctx, getState())
		try enterRule(_localctx, 366, EDIF300Parser.RULE_engineeringDate)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2949)
		 	try match(EDIF300Parser.Tokens.T__151.rawValue)
		 	setState(2950)
		 	try date()
		 	setState(2951)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EngineeringDateDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_engineeringDateDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEngineeringDateDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEngineeringDateDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEngineeringDateDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEngineeringDateDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func engineeringDateDisplay() throws -> EngineeringDateDisplayContext {
		var _localctx: EngineeringDateDisplayContext = EngineeringDateDisplayContext(_ctx, getState())
		try enterRule(_localctx, 368, EDIF300Parser.RULE_engineeringDateDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2953)
		 	try match(EDIF300Parser.Tokens.T__152.rawValue)
		 	setState(2957)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(2954)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(2955)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(2956)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2959)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EventContext: ParserRuleContext {
			open
			func portRef() -> PortRefContext? {
				return getRuleContext(PortRefContext.self, 0)
			}
			open
			func portList() -> PortListContext? {
				return getRuleContext(PortListContext.self, 0)
			}
			open
			func portSet() -> PortSetContext? {
				return getRuleContext(PortSetContext.self, 0)
			}
			open
			func interconnectRef() -> InterconnectRefContext? {
				return getRuleContext(InterconnectRefContext.self, 0)
			}
			open
			func interconnectSet() -> InterconnectSetContext? {
				return getRuleContext(InterconnectSetContext.self, 0)
			}
			open
			func becomes() -> [BecomesContext] {
				return getRuleContexts(BecomesContext.self)
			}
			open
			func becomes(_ i: Int) -> BecomesContext? {
				return getRuleContext(BecomesContext.self, i)
			}
			open
			func transition() -> [TransitionContext] {
				return getRuleContexts(TransitionContext.self)
			}
			open
			func transition(_ i: Int) -> TransitionContext? {
				return getRuleContext(TransitionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_event
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEvent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEvent(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEvent(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEvent(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func event() throws -> EventContext {
		var _localctx: EventContext = EventContext(_ctx, getState())
		try enterRule(_localctx, 370, EDIF300Parser.RULE_event)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2961)
		 	try match(EDIF300Parser.Tokens.T__153.rawValue)
		 	setState(2967)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__436:
		 		setState(2962)
		 		try portRef()

		 		break

		 	case .T__424:
		 		setState(2963)
		 		try portList()

		 		break

		 	case .T__437:
		 		setState(2964)
		 		try portSet()

		 		break

		 	case .T__267:
		 		setState(2965)
		 		try interconnectRef()

		 		break

		 	case .T__268:
		 		setState(2966)
		 		try interconnectSet()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2973)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__16.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__625.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2971)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__16:
		 			setState(2969)
		 			try becomes()

		 			break

		 		case .T__625:
		 			setState(2970)
		 			try transition()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(2975)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2976)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExponentContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_exponent
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExponent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExponent(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExponent(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExponent(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func exponent() throws -> ExponentContext {
		var _localctx: ExponentContext = ExponentContext(_ctx, getState())
		try enterRule(_localctx, 372, EDIF300Parser.RULE_exponent)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2978)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extend
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtend(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtend(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtend(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtend(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extend() throws -> ExtendContext {
		var _localctx: ExtendContext = ExtendContext(_ctx, getState())
		try enterRule(_localctx, 374, EDIF300Parser.RULE_extend)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2980)
		 	try match(EDIF300Parser.Tokens.T__154.rawValue)
		 	setState(2981)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendForFrameMemberDefContext: ParserRuleContext {
			open
			func forFrameMemberRef() -> ForFrameMemberRefContext? {
				return getRuleContext(ForFrameMemberRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extendForFrameMemberDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtendForFrameMemberDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtendForFrameMemberDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtendForFrameMemberDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtendForFrameMemberDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extendForFrameMemberDef() throws -> ExtendForFrameMemberDefContext {
		var _localctx: ExtendForFrameMemberDefContext = ExtendForFrameMemberDefContext(_ctx, getState())
		try enterRule(_localctx, 376, EDIF300Parser.RULE_extendForFrameMemberDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2983)
		 	try forFrameMemberRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendFrameDefContext: ParserRuleContext {
			open
			func frameNameRef() -> FrameNameRefContext? {
				return getRuleContext(FrameNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extendFrameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtendFrameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtendFrameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtendFrameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtendFrameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extendFrameDef() throws -> ExtendFrameDefContext {
		var _localctx: ExtendFrameDefContext = ExtendFrameDefContext(_ctx, getState())
		try enterRule(_localctx, 378, EDIF300Parser.RULE_extendFrameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2985)
		 	try frameNameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendInstanceDefContext: ParserRuleContext {
			open
			func instanceNameRef() -> InstanceNameRefContext? {
				return getRuleContext(InstanceNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extendInstanceDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtendInstanceDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtendInstanceDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtendInstanceDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtendInstanceDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extendInstanceDef() throws -> ExtendInstanceDefContext {
		var _localctx: ExtendInstanceDefContext = ExtendInstanceDefContext(_ctx, getState())
		try enterRule(_localctx, 380, EDIF300Parser.RULE_extendInstanceDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2987)
		 	try instanceNameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendInstanceMemberDefContext: ParserRuleContext {
			open
			func instanceMemberRef() -> InstanceMemberRefContext? {
				return getRuleContext(InstanceMemberRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extendInstanceMemberDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtendInstanceMemberDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtendInstanceMemberDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtendInstanceMemberDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtendInstanceMemberDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extendInstanceMemberDef() throws -> ExtendInstanceMemberDefContext {
		var _localctx: ExtendInstanceMemberDefContext = ExtendInstanceMemberDefContext(_ctx, getState())
		try enterRule(_localctx, 382, EDIF300Parser.RULE_extendInstanceMemberDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2989)
		 	try instanceMemberRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendInterconnectDefContext: ParserRuleContext {
			open
			func interconnectNameRef() -> InterconnectNameRefContext? {
				return getRuleContext(InterconnectNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extendInterconnectDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtendInterconnectDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtendInterconnectDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtendInterconnectDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtendInterconnectDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extendInterconnectDef() throws -> ExtendInterconnectDefContext {
		var _localctx: ExtendInterconnectDefContext = ExtendInterconnectDefContext(_ctx, getState())
		try enterRule(_localctx, 384, EDIF300Parser.RULE_extendInterconnectDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2991)
		 	try interconnectNameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendPageDefContext: ParserRuleContext {
			open
			func pageNameRef() -> PageNameRefContext? {
				return getRuleContext(PageNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extendPageDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtendPageDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtendPageDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtendPageDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtendPageDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extendPageDef() throws -> ExtendPageDefContext {
		var _localctx: ExtendPageDefContext = ExtendPageDefContext(_ctx, getState())
		try enterRule(_localctx, 386, EDIF300Parser.RULE_extendPageDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2993)
		 	try pageNameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendPortDefContext: ParserRuleContext {
			open
			func portNameRef() -> PortNameRefContext? {
				return getRuleContext(PortNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extendPortDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtendPortDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtendPortDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtendPortDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtendPortDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extendPortDef() throws -> ExtendPortDefContext {
		var _localctx: ExtendPortDefContext = ExtendPortDefContext(_ctx, getState())
		try enterRule(_localctx, 388, EDIF300Parser.RULE_extendPortDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2995)
		 	try portNameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendPortMemberDefContext: ParserRuleContext {
			open
			func portMemberRef() -> PortMemberRefContext? {
				return getRuleContext(PortMemberRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extendPortMemberDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtendPortMemberDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtendPortMemberDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtendPortMemberDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtendPortMemberDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extendPortMemberDef() throws -> ExtendPortMemberDefContext {
		var _localctx: ExtendPortMemberDefContext = ExtendPortMemberDefContext(_ctx, getState())
		try enterRule(_localctx, 390, EDIF300Parser.RULE_extendPortMemberDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2997)
		 	try portMemberRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendSignalDefContext: ParserRuleContext {
			open
			func signalNameRef() -> SignalNameRefContext? {
				return getRuleContext(SignalNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extendSignalDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtendSignalDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtendSignalDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtendSignalDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtendSignalDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extendSignalDef() throws -> ExtendSignalDefContext {
		var _localctx: ExtendSignalDefContext = ExtendSignalDefContext(_ctx, getState())
		try enterRule(_localctx, 392, EDIF300Parser.RULE_extendSignalDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2999)
		 	try signalNameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendSignalGroupDefContext: ParserRuleContext {
			open
			func signalGroupNameRef() -> SignalGroupNameRefContext? {
				return getRuleContext(SignalGroupNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extendSignalGroupDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtendSignalGroupDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtendSignalGroupDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtendSignalGroupDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtendSignalGroupDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extendSignalGroupDef() throws -> ExtendSignalGroupDefContext {
		var _localctx: ExtendSignalGroupDefContext = ExtendSignalGroupDefContext(_ctx, getState())
		try enterRule(_localctx, 394, EDIF300Parser.RULE_extendSignalGroupDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3001)
		 	try signalGroupNameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExtendSignalMemberDefContext: ParserRuleContext {
			open
			func signalMemberRef() -> SignalMemberRefContext? {
				return getRuleContext(SignalMemberRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_extendSignalMemberDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExtendSignalMemberDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExtendSignalMemberDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExtendSignalMemberDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExtendSignalMemberDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func extendSignalMemberDef() throws -> ExtendSignalMemberDefContext {
		var _localctx: ExtendSignalMemberDefContext = ExtendSignalMemberDefContext(_ctx, getState())
		try enterRule(_localctx, 396, EDIF300Parser.RULE_extendSignalMemberDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3003)
		 	try signalMemberRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExternalContext: ParserRuleContext {
			open
			func libraryNameDef() -> LibraryNameDefContext? {
				return getRuleContext(LibraryNameDefContext.self, 0)
			}
			open
			func libraryHeader() -> LibraryHeaderContext? {
				return getRuleContext(LibraryHeaderContext.self, 0)
			}
			open
			func cell() -> [CellContext] {
				return getRuleContexts(CellContext.self)
			}
			open
			func cell(_ i: Int) -> CellContext? {
				return getRuleContext(CellContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func geometryMacro() -> [GeometryMacroContext] {
				return getRuleContexts(GeometryMacroContext.self)
			}
			open
			func geometryMacro(_ i: Int) -> GeometryMacroContext? {
				return getRuleContext(GeometryMacroContext.self, i)
			}
			open
			func pageBorderTemplate() -> [PageBorderTemplateContext] {
				return getRuleContexts(PageBorderTemplateContext.self)
			}
			open
			func pageBorderTemplate(_ i: Int) -> PageBorderTemplateContext? {
				return getRuleContext(PageBorderTemplateContext.self, i)
			}
			open
			func pageTitleBlockTemplate() -> [PageTitleBlockTemplateContext] {
				return getRuleContexts(PageTitleBlockTemplateContext.self)
			}
			open
			func pageTitleBlockTemplate(_ i: Int) -> PageTitleBlockTemplateContext? {
				return getRuleContext(PageTitleBlockTemplateContext.self, i)
			}
			open
			func schematicFigureMacro() -> [SchematicFigureMacroContext] {
				return getRuleContexts(SchematicFigureMacroContext.self)
			}
			open
			func schematicFigureMacro(_ i: Int) -> SchematicFigureMacroContext? {
				return getRuleContext(SchematicFigureMacroContext.self, i)
			}
			open
			func schematicForFrameBorderTemplate() -> [SchematicForFrameBorderTemplateContext] {
				return getRuleContexts(SchematicForFrameBorderTemplateContext.self)
			}
			open
			func schematicForFrameBorderTemplate(_ i: Int) -> SchematicForFrameBorderTemplateContext? {
				return getRuleContext(SchematicForFrameBorderTemplateContext.self, i)
			}
			open
			func schematicGlobalPortTemplate() -> [SchematicGlobalPortTemplateContext] {
				return getRuleContexts(SchematicGlobalPortTemplateContext.self)
			}
			open
			func schematicGlobalPortTemplate(_ i: Int) -> SchematicGlobalPortTemplateContext? {
				return getRuleContext(SchematicGlobalPortTemplateContext.self, i)
			}
			open
			func schematicIfFrameBorderTemplate() -> [SchematicIfFrameBorderTemplateContext] {
				return getRuleContexts(SchematicIfFrameBorderTemplateContext.self)
			}
			open
			func schematicIfFrameBorderTemplate(_ i: Int) -> SchematicIfFrameBorderTemplateContext? {
				return getRuleContext(SchematicIfFrameBorderTemplateContext.self, i)
			}
			open
			func schematicInterconnectTerminatorTemplate() -> [SchematicInterconnectTerminatorTemplateContext] {
				return getRuleContexts(SchematicInterconnectTerminatorTemplateContext.self)
			}
			open
			func schematicInterconnectTerminatorTemplate(_ i: Int) -> SchematicInterconnectTerminatorTemplateContext? {
				return getRuleContext(SchematicInterconnectTerminatorTemplateContext.self, i)
			}
			open
			func schematicJunctionTemplate() -> [SchematicJunctionTemplateContext] {
				return getRuleContexts(SchematicJunctionTemplateContext.self)
			}
			open
			func schematicJunctionTemplate(_ i: Int) -> SchematicJunctionTemplateContext? {
				return getRuleContext(SchematicJunctionTemplateContext.self, i)
			}
			open
			func schematicMasterPortTemplate() -> [SchematicMasterPortTemplateContext] {
				return getRuleContexts(SchematicMasterPortTemplateContext.self)
			}
			open
			func schematicMasterPortTemplate(_ i: Int) -> SchematicMasterPortTemplateContext? {
				return getRuleContext(SchematicMasterPortTemplateContext.self, i)
			}
			open
			func schematicOffPageConnectorTemplate() -> [SchematicOffPageConnectorTemplateContext] {
				return getRuleContexts(SchematicOffPageConnectorTemplateContext.self)
			}
			open
			func schematicOffPageConnectorTemplate(_ i: Int) -> SchematicOffPageConnectorTemplateContext? {
				return getRuleContext(SchematicOffPageConnectorTemplateContext.self, i)
			}
			open
			func schematicOnPageConnectorTemplate() -> [SchematicOnPageConnectorTemplateContext] {
				return getRuleContexts(SchematicOnPageConnectorTemplateContext.self)
			}
			open
			func schematicOnPageConnectorTemplate(_ i: Int) -> SchematicOnPageConnectorTemplateContext? {
				return getRuleContext(SchematicOnPageConnectorTemplateContext.self, i)
			}
			open
			func schematicOtherwiseFrameBorderTemplate() -> [SchematicOtherwiseFrameBorderTemplateContext] {
				return getRuleContexts(SchematicOtherwiseFrameBorderTemplateContext.self)
			}
			open
			func schematicOtherwiseFrameBorderTemplate(_ i: Int) -> SchematicOtherwiseFrameBorderTemplateContext? {
				return getRuleContext(SchematicOtherwiseFrameBorderTemplateContext.self, i)
			}
			open
			func schematicRipperTemplate() -> [SchematicRipperTemplateContext] {
				return getRuleContexts(SchematicRipperTemplateContext.self)
			}
			open
			func schematicRipperTemplate(_ i: Int) -> SchematicRipperTemplateContext? {
				return getRuleContext(SchematicRipperTemplateContext.self, i)
			}
			open
			func schematicSymbolBorderTemplate() -> [SchematicSymbolBorderTemplateContext] {
				return getRuleContexts(SchematicSymbolBorderTemplateContext.self)
			}
			open
			func schematicSymbolBorderTemplate(_ i: Int) -> SchematicSymbolBorderTemplateContext? {
				return getRuleContext(SchematicSymbolBorderTemplateContext.self, i)
			}
			open
			func schematicSymbolPortTemplate() -> [SchematicSymbolPortTemplateContext] {
				return getRuleContexts(SchematicSymbolPortTemplateContext.self)
			}
			open
			func schematicSymbolPortTemplate(_ i: Int) -> SchematicSymbolPortTemplateContext? {
				return getRuleContext(SchematicSymbolPortTemplateContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_external
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterExternal(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitExternal(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitExternal(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitExternal(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func external() throws -> ExternalContext {
		var _localctx: ExternalContext = ExternalContext(_ctx, getState())
		try enterRule(_localctx, 398, EDIF300Parser.RULE_external)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3005)
		 	try match(EDIF300Parser.Tokens.T__155.rawValue)
		 	setState(3006)
		 	try libraryNameDef()
		 	setState(3007)
		 	try libraryHeader()
		 	setState(3029)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__37.rawValue || _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__192.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__381.rawValue || _la == EDIF300Parser.Tokens.T__395.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__475.rawValue,EDIF300Parser.Tokens.T__478.rawValue,EDIF300Parser.Tokens.T__486.rawValue,EDIF300Parser.Tokens.T__489.rawValue,EDIF300Parser.Tokens.T__500.rawValue,EDIF300Parser.Tokens.T__504.rawValue,EDIF300Parser.Tokens.T__508.rawValue,EDIF300Parser.Tokens.T__517.rawValue,EDIF300Parser.Tokens.T__521.rawValue,EDIF300Parser.Tokens.T__524.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 476)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__548.rawValue,EDIF300Parser.Tokens.T__557.rawValue,EDIF300Parser.Tokens.T__562.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 549)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3027)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__37:
		 			setState(3008)
		 			try cell()

		 			break

		 		case .T__61:
		 			setState(3009)
		 			try comment()

		 			break

		 		case .T__192:
		 			setState(3010)
		 			try geometryMacro()

		 			break

		 		case .T__381:
		 			setState(3011)
		 			try pageBorderTemplate()

		 			break

		 		case .T__395:
		 			setState(3012)
		 			try pageTitleBlockTemplate()

		 			break

		 		case .T__475:
		 			setState(3013)
		 			try schematicFigureMacro()

		 			break

		 		case .T__478:
		 			setState(3014)
		 			try schematicForFrameBorderTemplate()

		 			break

		 		case .T__486:
		 			setState(3015)
		 			try schematicGlobalPortTemplate()

		 			break

		 		case .T__489:
		 			setState(3016)
		 			try schematicIfFrameBorderTemplate()

		 			break

		 		case .T__500:
		 			setState(3017)
		 			try schematicInterconnectTerminatorTemplate()

		 			break

		 		case .T__504:
		 			setState(3018)
		 			try schematicJunctionTemplate()

		 			break

		 		case .T__508:
		 			setState(3019)
		 			try schematicMasterPortTemplate()

		 			break

		 		case .T__517:
		 			setState(3020)
		 			try schematicOffPageConnectorTemplate()

		 			break

		 		case .T__521:
		 			setState(3021)
		 			try schematicOnPageConnectorTemplate()

		 			break

		 		case .T__524:
		 			setState(3022)
		 			try schematicOtherwiseFrameBorderTemplate()

		 			break

		 		case .T__548:
		 			setState(3023)
		 			try schematicRipperTemplate()

		 			break

		 		case .T__557:
		 			setState(3024)
		 			try schematicSymbolBorderTemplate()

		 			break

		 		case .T__562:
		 			setState(3025)
		 			try schematicSymbolPortTemplate()

		 			break

		 		case .T__642:
		 			setState(3026)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3031)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3032)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FahrenheitContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fahrenheit
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFahrenheit(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFahrenheit(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFahrenheit(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFahrenheit(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fahrenheit() throws -> FahrenheitContext {
		var _localctx: FahrenheitContext = FahrenheitContext(_ctx, getState())
		try enterRule(_localctx, 400, EDIF300Parser.RULE_fahrenheit)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3034)
		 	try match(EDIF300Parser.Tokens.T__156.rawValue)
		 	setState(3035)
		 	try unitExponent()
		 	setState(3036)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EfalseContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_efalse
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEfalse(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEfalse(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEfalse(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEfalse(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func efalse() throws -> EfalseContext {
		var _localctx: EfalseContext = EfalseContext(_ctx, getState())
		try enterRule(_localctx, 402, EDIF300Parser.RULE_efalse)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3038)
		 	try match(EDIF300Parser.Tokens.T__157.rawValue)
		 	setState(3039)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FaradContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_farad
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFarad(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFarad(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFarad(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFarad(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func farad() throws -> FaradContext {
		var _localctx: FaradContext = FaradContext(_ctx, getState())
		try enterRule(_localctx, 404, EDIF300Parser.RULE_farad)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3041)
		 	try match(EDIF300Parser.Tokens.T__158.rawValue)
		 	setState(3042)
		 	try unitExponent()
		 	setState(3043)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FigureContext: ParserRuleContext {
			open
			func figureGroupNameRef() -> FigureGroupNameRefContext? {
				return getRuleContext(FigureGroupNameRefContext.self, 0)
			}
			open
			func figureGroupOverride() -> FigureGroupOverrideContext? {
				return getRuleContext(FigureGroupOverrideContext.self, 0)
			}
			open
			func circle() -> [CircleContext] {
				return getRuleContexts(CircleContext.self)
			}
			open
			func circle(_ i: Int) -> CircleContext? {
				return getRuleContext(CircleContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func complexGeometry() -> [ComplexGeometryContext] {
				return getRuleContexts(ComplexGeometryContext.self)
			}
			open
			func complexGeometry(_ i: Int) -> ComplexGeometryContext? {
				return getRuleContext(ComplexGeometryContext.self, i)
			}
			open
			func dot() -> [DotContext] {
				return getRuleContexts(DotContext.self)
			}
			open
			func dot(_ i: Int) -> DotContext? {
				return getRuleContext(DotContext.self, i)
			}
			open
			func openShape() -> [OpenShapeContext] {
				return getRuleContexts(OpenShapeContext.self)
			}
			open
			func openShape(_ i: Int) -> OpenShapeContext? {
				return getRuleContext(OpenShapeContext.self, i)
			}
			open
			func path() -> [PathContext] {
				return getRuleContexts(PathContext.self)
			}
			open
			func path(_ i: Int) -> PathContext? {
				return getRuleContext(PathContext.self, i)
			}
			open
			func polygon() -> [PolygonContext] {
				return getRuleContexts(PolygonContext.self)
			}
			open
			func polygon(_ i: Int) -> PolygonContext? {
				return getRuleContext(PolygonContext.self, i)
			}
			open
			func rectangle() -> [RectangleContext] {
				return getRuleContexts(RectangleContext.self)
			}
			open
			func rectangle(_ i: Int) -> RectangleContext? {
				return getRuleContext(RectangleContext.self, i)
			}
			open
			func shape() -> [ShapeContext] {
				return getRuleContexts(ShapeContext.self)
			}
			open
			func shape(_ i: Int) -> ShapeContext? {
				return getRuleContext(ShapeContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_figure
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFigure(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFigure(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFigure(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFigure(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func figure() throws -> FigureContext {
		var _localctx: FigureContext = FigureContext(_ctx, getState())
		try enterRule(_localctx, 406, EDIF300Parser.RULE_figure)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3045)
		 	try match(EDIF300Parser.Tokens.T__159.rawValue)
		 	setState(3048)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IDENTIFIER:
		 		setState(3046)
		 		try figureGroupNameRef()

		 		break

		 	case .T__162:
		 		setState(3047)
		 		try figureGroupOverride()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3062)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__49.rawValue,EDIF300Parser.Tokens.T__61.rawValue,EDIF300Parser.Tokens.T__67.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 50)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__137.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__365.rawValue,EDIF300Parser.Tokens.T__401.rawValue,EDIF300Parser.Tokens.T__413.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 366)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__453.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__582.rawValue || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3060)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__49:
		 			setState(3050)
		 			try circle()

		 			break

		 		case .T__61:
		 			setState(3051)
		 			try comment()

		 			break

		 		case .T__67:
		 			setState(3052)
		 			try complexGeometry()

		 			break

		 		case .T__137:
		 			setState(3053)
		 			try dot()

		 			break

		 		case .T__365:
		 			setState(3054)
		 			try openShape()

		 			break

		 		case .T__401:
		 			setState(3055)
		 			try path()

		 			break

		 		case .T__413:
		 			setState(3056)
		 			try polygon()

		 			break

		 		case .T__453:
		 			setState(3057)
		 			try rectangle()

		 			break

		 		case .T__582:
		 			setState(3058)
		 			try shape()

		 			break

		 		case .T__642:
		 			setState(3059)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3064)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3065)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FigureGroupContext: ParserRuleContext {
			open
			func figureGroupNameDef() -> FigureGroupNameDefContext? {
				return getRuleContext(FigureGroupNameDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func cornerType() -> [CornerTypeContext] {
				return getRuleContexts(CornerTypeContext.self)
			}
			open
			func cornerType(_ i: Int) -> CornerTypeContext? {
				return getRuleContext(CornerTypeContext.self, i)
			}
			open
			func displayAttributes() -> [DisplayAttributesContext] {
				return getRuleContexts(DisplayAttributesContext.self)
			}
			open
			func displayAttributes(_ i: Int) -> DisplayAttributesContext? {
				return getRuleContext(DisplayAttributesContext.self, i)
			}
			open
			func endType() -> [EndTypeContext] {
				return getRuleContexts(EndTypeContext.self)
			}
			open
			func endType(_ i: Int) -> EndTypeContext? {
				return getRuleContext(EndTypeContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func pathWidth() -> [PathWidthContext] {
				return getRuleContexts(PathWidthContext.self)
			}
			open
			func pathWidth(_ i: Int) -> PathWidthContext? {
				return getRuleContext(PathWidthContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_figureGroup
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFigureGroup(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFigureGroup(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFigureGroup(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFigureGroup(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func figureGroup() throws -> FigureGroupContext {
		var _localctx: FigureGroupContext = FigureGroupContext(_ctx, getState())
		try enterRule(_localctx, 408, EDIF300Parser.RULE_figureGroup)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3067)
		 	try match(EDIF300Parser.Tokens.T__160.rawValue)
		 	setState(3068)
		 	try figureGroupNameDef()
		 	setState(3079)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__95.rawValue,EDIF300Parser.Tokens.T__129.rawValue,EDIF300Parser.Tokens.T__150.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 96)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue || _la == EDIF300Parser.Tokens.T__403.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3077)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(3069)
		 			try comment()

		 			break

		 		case .T__95:
		 			setState(3070)
		 			try cornerType()

		 			break

		 		case .T__129:
		 			setState(3071)
		 			try displayAttributes()

		 			break

		 		case .T__150:
		 			setState(3072)
		 			try endType()

		 			break

		 		case .T__346:
		 			setState(3073)
		 			try nameInformation()

		 			break

		 		case .T__403:
		 			setState(3074)
		 			try pathWidth()

		 			break

		 		case .T__442:
		 			setState(3075)
		 			try property()

		 			break

		 		case .T__642:
		 			setState(3076)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3081)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3082)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FigureGroupNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_figureGroupNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFigureGroupNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFigureGroupNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFigureGroupNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFigureGroupNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func figureGroupNameCaseSensitive() throws -> FigureGroupNameCaseSensitiveContext {
		var _localctx: FigureGroupNameCaseSensitiveContext = FigureGroupNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 410, EDIF300Parser.RULE_figureGroupNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3084)
		 	try match(EDIF300Parser.Tokens.T__161.rawValue)
		 	setState(3085)
		 	try booleanToken()
		 	setState(3086)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FigureGroupNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_figureGroupNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFigureGroupNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFigureGroupNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFigureGroupNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFigureGroupNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func figureGroupNameDef() throws -> FigureGroupNameDefContext {
		var _localctx: FigureGroupNameDefContext = FigureGroupNameDefContext(_ctx, getState())
		try enterRule(_localctx, 412, EDIF300Parser.RULE_figureGroupNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3088)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FigureGroupNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_figureGroupNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFigureGroupNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFigureGroupNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFigureGroupNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFigureGroupNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func figureGroupNameRef() throws -> FigureGroupNameRefContext {
		var _localctx: FigureGroupNameRefContext = FigureGroupNameRefContext(_ctx, getState())
		try enterRule(_localctx, 414, EDIF300Parser.RULE_figureGroupNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3090)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FigureGroupOverrideContext: ParserRuleContext {
			open
			func figureGroupNameRef() -> FigureGroupNameRefContext? {
				return getRuleContext(FigureGroupNameRefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func cornerType() -> [CornerTypeContext] {
				return getRuleContexts(CornerTypeContext.self)
			}
			open
			func cornerType(_ i: Int) -> CornerTypeContext? {
				return getRuleContext(CornerTypeContext.self, i)
			}
			open
			func displayAttributes() -> [DisplayAttributesContext] {
				return getRuleContexts(DisplayAttributesContext.self)
			}
			open
			func displayAttributes(_ i: Int) -> DisplayAttributesContext? {
				return getRuleContext(DisplayAttributesContext.self, i)
			}
			open
			func endType() -> [EndTypeContext] {
				return getRuleContexts(EndTypeContext.self)
			}
			open
			func endType(_ i: Int) -> EndTypeContext? {
				return getRuleContext(EndTypeContext.self, i)
			}
			open
			func pathWidth() -> [PathWidthContext] {
				return getRuleContexts(PathWidthContext.self)
			}
			open
			func pathWidth(_ i: Int) -> PathWidthContext? {
				return getRuleContext(PathWidthContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_figureGroupOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFigureGroupOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFigureGroupOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFigureGroupOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFigureGroupOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func figureGroupOverride() throws -> FigureGroupOverrideContext {
		var _localctx: FigureGroupOverrideContext = FigureGroupOverrideContext(_ctx, getState())
		try enterRule(_localctx, 416, EDIF300Parser.RULE_figureGroupOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3092)
		 	try match(EDIF300Parser.Tokens.T__162.rawValue)
		 	setState(3093)
		 	try figureGroupNameRef()
		 	setState(3102)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__95.rawValue,EDIF300Parser.Tokens.T__129.rawValue,EDIF300Parser.Tokens.T__150.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 96)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__403.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3100)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(3094)
		 			try comment()

		 			break

		 		case .T__95:
		 			setState(3095)
		 			try cornerType()

		 			break

		 		case .T__129:
		 			setState(3096)
		 			try displayAttributes()

		 			break

		 		case .T__150:
		 			setState(3097)
		 			try endType()

		 			break

		 		case .T__403:
		 			setState(3098)
		 			try pathWidth()

		 			break

		 		case .T__448:
		 			setState(3099)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3104)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3105)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FillPatternContext: ParserRuleContext {
			open
			func pixelPattern() -> PixelPatternContext? {
				return getRuleContext(PixelPatternContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fillPattern
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFillPattern(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFillPattern(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFillPattern(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFillPattern(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fillPattern() throws -> FillPatternContext {
		var _localctx: FillPatternContext = FillPatternContext(_ctx, getState())
		try enterRule(_localctx, 418, EDIF300Parser.RULE_fillPattern)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3107)
		 	try match(EDIF300Parser.Tokens.T__163.rawValue)
		 	setState(3108)
		 	try pixelPattern()
		 	setState(3109)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FillPatternVisibleContext: ParserRuleContext {
			open
			func booleanValue() -> BooleanValueContext? {
				return getRuleContext(BooleanValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fillPatternVisible
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFillPatternVisible(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFillPatternVisible(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFillPatternVisible(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFillPatternVisible(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fillPatternVisible() throws -> FillPatternVisibleContext {
		var _localctx: FillPatternVisibleContext = FillPatternVisibleContext(_ctx, getState())
		try enterRule(_localctx, 420, EDIF300Parser.RULE_fillPatternVisible)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3111)
		 	try match(EDIF300Parser.Tokens.T__164.rawValue)
		 	setState(3112)
		 	try booleanValue()
		 	setState(3113)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FirstIntegerExpressionContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_firstIntegerExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFirstIntegerExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFirstIntegerExpression(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFirstIntegerExpression(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFirstIntegerExpression(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func firstIntegerExpression() throws -> FirstIntegerExpressionContext {
		var _localctx: FirstIntegerExpressionContext = FirstIntegerExpressionContext(_ctx, getState())
		try enterRule(_localctx, 422, EDIF300Parser.RULE_firstIntegerExpression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3115)
		 	try integerExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FirstStringExpressionContext: ParserRuleContext {
			open
			func stringExpression() -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_firstStringExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFirstStringExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFirstStringExpression(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFirstStringExpression(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFirstStringExpression(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func firstStringExpression() throws -> FirstStringExpressionContext {
		var _localctx: FirstStringExpressionContext = FirstStringExpressionContext(_ctx, getState())
		try enterRule(_localctx, 424, EDIF300Parser.RULE_firstStringExpression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3117)
		 	try stringExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FixedContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fixed
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFixed(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFixed(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFixed(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFixed(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fixed() throws -> FixedContext {
		var _localctx: FixedContext = FixedContext(_ctx, getState())
		try enterRule(_localctx, 426, EDIF300Parser.RULE_fixed)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3119)
		 	try match(EDIF300Parser.Tokens.T__165.rawValue)
		 	setState(3120)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontContext: ParserRuleContext {
			open
			func fontNameDef() -> FontNameDefContext? {
				return getRuleContext(FontNameDefContext.self, 0)
			}
			open
			func typeface() -> TypefaceContext? {
				return getRuleContext(TypefaceContext.self, 0)
			}
			open
			func fontProportions() -> FontProportionsContext? {
				return getRuleContext(FontProportionsContext.self, 0)
			}
			open
			func boldStyle() -> [BoldStyleContext] {
				return getRuleContexts(BoldStyleContext.self)
			}
			open
			func boldStyle(_ i: Int) -> BoldStyleContext? {
				return getRuleContext(BoldStyleContext.self, i)
			}
			open
			func italicStyle() -> [ItalicStyleContext] {
				return getRuleContexts(ItalicStyleContext.self)
			}
			open
			func italicStyle(_ i: Int) -> ItalicStyleContext? {
				return getRuleContext(ItalicStyleContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func proportionalFont() -> [ProportionalFontContext] {
				return getRuleContexts(ProportionalFontContext.self)
			}
			open
			func proportionalFont(_ i: Int) -> ProportionalFontContext? {
				return getRuleContext(ProportionalFontContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_font
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFont(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFont(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFont(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFont(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func font() throws -> FontContext {
		var _localctx: FontContext = FontContext(_ctx, getState())
		try enterRule(_localctx, 428, EDIF300Parser.RULE_font)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3122)
		 	try match(EDIF300Parser.Tokens.T__166.rawValue)
		 	setState(3123)
		 	try fontNameDef()
		 	setState(3124)
		 	try typeface()
		 	setState(3125)
		 	try fontProportions()
		 	setState(3133)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__22.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__274.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue || _la == EDIF300Parser.Tokens.T__449.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3131)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__22:
		 			setState(3126)
		 			try boldStyle()

		 			break

		 		case .T__274:
		 			setState(3127)
		 			try italicStyle()

		 			break

		 		case .T__442:
		 			setState(3128)
		 			try property()

		 			break

		 		case .T__449:
		 			setState(3129)
		 			try proportionalFont()

		 			break

		 		case .T__642:
		 			setState(3130)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3135)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3136)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontCapitalHeightContext: ParserRuleContext {
			open
			func lengthValue() -> LengthValueContext? {
				return getRuleContext(LengthValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fontCapitalHeight
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFontCapitalHeight(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFontCapitalHeight(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFontCapitalHeight(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFontCapitalHeight(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fontCapitalHeight() throws -> FontCapitalHeightContext {
		var _localctx: FontCapitalHeightContext = FontCapitalHeightContext(_ctx, getState())
		try enterRule(_localctx, 430, EDIF300Parser.RULE_fontCapitalHeight)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3138)
		 	try match(EDIF300Parser.Tokens.T__167.rawValue)
		 	setState(3139)
		 	try lengthValue()
		 	setState(3140)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontDefinitionsContext: ParserRuleContext {
			open
			func fonts() -> FontsContext? {
				return getRuleContext(FontsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fontDefinitions
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFontDefinitions(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFontDefinitions(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFontDefinitions(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFontDefinitions(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fontDefinitions() throws -> FontDefinitionsContext {
		var _localctx: FontDefinitionsContext = FontDefinitionsContext(_ctx, getState())
		try enterRule(_localctx, 432, EDIF300Parser.RULE_fontDefinitions)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3142)
		 	try match(EDIF300Parser.Tokens.T__168.rawValue)
		 	setState(3144)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__173.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3143)
		 		try fonts()

		 	}

		 	setState(3146)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontDescentContext: ParserRuleContext {
			open
			func lengthValue() -> LengthValueContext? {
				return getRuleContext(LengthValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fontDescent
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFontDescent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFontDescent(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFontDescent(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFontDescent(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fontDescent() throws -> FontDescentContext {
		var _localctx: FontDescentContext = FontDescentContext(_ctx, getState())
		try enterRule(_localctx, 434, EDIF300Parser.RULE_fontDescent)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3148)
		 	try match(EDIF300Parser.Tokens.T__169.rawValue)
		 	setState(3149)
		 	try lengthValue()
		 	setState(3150)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontFamilyContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fontFamily
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFontFamily(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFontFamily(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFontFamily(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFontFamily(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fontFamily() throws -> FontFamilyContext {
		var _localctx: FontFamilyContext = FontFamilyContext(_ctx, getState())
		try enterRule(_localctx, 436, EDIF300Parser.RULE_fontFamily)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3152)
		 	try stringToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontHeightContext: ParserRuleContext {
			open
			func lengthValue() -> LengthValueContext? {
				return getRuleContext(LengthValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fontHeight
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFontHeight(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFontHeight(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFontHeight(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFontHeight(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fontHeight() throws -> FontHeightContext {
		var _localctx: FontHeightContext = FontHeightContext(_ctx, getState())
		try enterRule(_localctx, 438, EDIF300Parser.RULE_fontHeight)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3154)
		 	try match(EDIF300Parser.Tokens.T__170.rawValue)
		 	setState(3155)
		 	try lengthValue()
		 	setState(3156)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fontNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFontNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFontNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFontNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFontNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fontNameDef() throws -> FontNameDefContext {
		var _localctx: FontNameDefContext = FontNameDefContext(_ctx, getState())
		try enterRule(_localctx, 440, EDIF300Parser.RULE_fontNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3158)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fontNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFontNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFontNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFontNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFontNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fontNameRef() throws -> FontNameRefContext {
		var _localctx: FontNameRefContext = FontNameRefContext(_ctx, getState())
		try enterRule(_localctx, 442, EDIF300Parser.RULE_fontNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3160)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontProportionsContext: ParserRuleContext {
			open
			func fontHeight() -> FontHeightContext? {
				return getRuleContext(FontHeightContext.self, 0)
			}
			open
			func fontDescent() -> FontDescentContext? {
				return getRuleContext(FontDescentContext.self, 0)
			}
			open
			func fontCapitalHeight() -> FontCapitalHeightContext? {
				return getRuleContext(FontCapitalHeightContext.self, 0)
			}
			open
			func fontWidth() -> FontWidthContext? {
				return getRuleContext(FontWidthContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fontProportions
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFontProportions(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFontProportions(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFontProportions(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFontProportions(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fontProportions() throws -> FontProportionsContext {
		var _localctx: FontProportionsContext = FontProportionsContext(_ctx, getState())
		try enterRule(_localctx, 444, EDIF300Parser.RULE_fontProportions)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3162)
		 	try match(EDIF300Parser.Tokens.T__171.rawValue)
		 	setState(3163)
		 	try fontHeight()
		 	setState(3164)
		 	try fontDescent()
		 	setState(3165)
		 	try fontCapitalHeight()
		 	setState(3166)
		 	try fontWidth()
		 	setState(3167)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontRefContext: ParserRuleContext {
			open
			func fontNameRef() -> FontNameRefContext? {
				return getRuleContext(FontNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fontRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFontRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFontRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFontRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFontRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fontRef() throws -> FontRefContext {
		var _localctx: FontRefContext = FontRefContext(_ctx, getState())
		try enterRule(_localctx, 446, EDIF300Parser.RULE_fontRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3169)
		 	try match(EDIF300Parser.Tokens.T__172.rawValue)
		 	setState(3170)
		 	try fontNameRef()
		 	setState(3171)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontsContext: ParserRuleContext {
			open
			func setDistance() -> SetDistanceContext? {
				return getRuleContext(SetDistanceContext.self, 0)
			}
			open
			func font() -> [FontContext] {
				return getRuleContexts(FontContext.self)
			}
			open
			func font(_ i: Int) -> FontContext? {
				return getRuleContext(FontContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fonts
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFonts(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFonts(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFonts(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFonts(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fonts() throws -> FontsContext {
		var _localctx: FontsContext = FontsContext(_ctx, getState())
		try enterRule(_localctx, 448, EDIF300Parser.RULE_fonts)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3173)
		 	try match(EDIF300Parser.Tokens.T__173.rawValue)
		 	setState(3174)
		 	try setDistance()
		 	setState(3178)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__166.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3175)
		 		try font()


		 		setState(3180)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3181)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FontWidthContext: ParserRuleContext {
			open
			func lengthValue() -> LengthValueContext? {
				return getRuleContext(LengthValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fontWidth
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFontWidth(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFontWidth(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFontWidth(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFontWidth(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fontWidth() throws -> FontWidthContext {
		var _localctx: FontWidthContext = FontWidthContext(_ctx, getState())
		try enterRule(_localctx, 450, EDIF300Parser.RULE_fontWidth)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3183)
		 	try match(EDIF300Parser.Tokens.T__174.rawValue)
		 	setState(3184)
		 	try lengthValue()
		 	setState(3185)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ForbiddenEventContext: ParserRuleContext {
			open
			func timeInterval() -> TimeIntervalContext? {
				return getRuleContext(TimeIntervalContext.self, 0)
			}
			open
			func event() -> [EventContext] {
				return getRuleContexts(EventContext.self)
			}
			open
			func event(_ i: Int) -> EventContext? {
				return getRuleContext(EventContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_forbiddenEvent
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterForbiddenEvent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitForbiddenEvent(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitForbiddenEvent(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitForbiddenEvent(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func forbiddenEvent() throws -> ForbiddenEventContext {
		var _localctx: ForbiddenEventContext = ForbiddenEventContext(_ctx, getState())
		try enterRule(_localctx, 452, EDIF300Parser.RULE_forbiddenEvent)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3187)
		 	try match(EDIF300Parser.Tokens.T__175.rawValue)
		 	setState(3188)
		 	try timeInterval()
		 	setState(3192)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__153.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3189)
		 		try event()


		 		setState(3194)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3195)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ForFrameContext: ParserRuleContext {
			open
			func frameNameDef() -> FrameNameDefContext? {
				return getRuleContext(FrameNameDefContext.self, 0)
			}
			open
			func repetitionCount() -> RepetitionCountContext? {
				return getRuleContext(RepetitionCountContext.self, 0)
			}
			open
			func forFrameIndex() -> ForFrameIndexContext? {
				return getRuleContext(ForFrameIndexContext.self, 0)
			}
			open
			func logicalConnectivity() -> LogicalConnectivityContext? {
				return getRuleContext(LogicalConnectivityContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_forFrame
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterForFrame(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitForFrame(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitForFrame(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitForFrame(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func forFrame() throws -> ForFrameContext {
		var _localctx: ForFrameContext = ForFrameContext(_ctx, getState())
		try enterRule(_localctx, 454, EDIF300Parser.RULE_forFrame)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3197)
		 	try match(EDIF300Parser.Tokens.T__176.rawValue)
		 	setState(3198)
		 	try frameNameDef()
		 	setState(3199)
		 	try repetitionCount()
		 	setState(3200)
		 	try forFrameIndex()
		 	setState(3201)
		 	try logicalConnectivity()
		 	setState(3209)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3207)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(3202)
		 			try comment()

		 			break

		 		case .T__132:
		 			setState(3203)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(3204)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(3205)
		 			try property()

		 			break

		 		case .T__642:
		 			setState(3206)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3211)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3212)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ForFrameAnnotateContext: ParserRuleContext {
			open
			func extendForFrameMemberDef() -> ExtendForFrameMemberDefContext? {
				return getRuleContext(ExtendForFrameMemberDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func forFrameAnnotate() -> [ForFrameAnnotateContext] {
				return getRuleContexts(ForFrameAnnotateContext.self)
			}
			open
			func forFrameAnnotate(_ i: Int) -> ForFrameAnnotateContext? {
				return getRuleContext(ForFrameAnnotateContext.self, i)
			}
			open
			func ifFrameAnnotate() -> [IfFrameAnnotateContext] {
				return getRuleContexts(IfFrameAnnotateContext.self)
			}
			open
			func ifFrameAnnotate(_ i: Int) -> IfFrameAnnotateContext? {
				return getRuleContext(IfFrameAnnotateContext.self, i)
			}
			open
			func interconnectAnnotate() -> [InterconnectAnnotateContext] {
				return getRuleContexts(InterconnectAnnotateContext.self)
			}
			open
			func interconnectAnnotate(_ i: Int) -> InterconnectAnnotateContext? {
				return getRuleContext(InterconnectAnnotateContext.self, i)
			}
			open
			func leafOccurrenceAnnotate() -> [LeafOccurrenceAnnotateContext] {
				return getRuleContexts(LeafOccurrenceAnnotateContext.self)
			}
			open
			func leafOccurrenceAnnotate(_ i: Int) -> LeafOccurrenceAnnotateContext? {
				return getRuleContext(LeafOccurrenceAnnotateContext.self, i)
			}
			open
			func occurrenceAnnotate() -> [OccurrenceAnnotateContext] {
				return getRuleContexts(OccurrenceAnnotateContext.self)
			}
			open
			func occurrenceAnnotate(_ i: Int) -> OccurrenceAnnotateContext? {
				return getRuleContext(OccurrenceAnnotateContext.self, i)
			}
			open
			func otherwiseFrameAnnotate() -> [OtherwiseFrameAnnotateContext] {
				return getRuleContexts(OtherwiseFrameAnnotateContext.self)
			}
			open
			func otherwiseFrameAnnotate(_ i: Int) -> OtherwiseFrameAnnotateContext? {
				return getRuleContext(OtherwiseFrameAnnotateContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_forFrameAnnotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterForFrameAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitForFrameAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitForFrameAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitForFrameAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func forFrameAnnotate() throws -> ForFrameAnnotateContext {
		var _localctx: ForFrameAnnotateContext = ForFrameAnnotateContext(_ctx, getState())
		try enterRule(_localctx, 456, EDIF300Parser.RULE_forFrameAnnotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3214)
		 	try match(EDIF300Parser.Tokens.T__177.rawValue)
		 	setState(3215)
		 	try extendForFrameMemberDef()
		 	setState(3225)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__177.rawValue || _la == EDIF300Parser.Tokens.T__216.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__259.rawValue || _la == EDIF300Parser.Tokens.T__305.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__361.rawValue || _la == EDIF300Parser.Tokens.T__372.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3223)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(3216)
		 			try comment()

		 			break

		 		case .T__177:
		 			setState(3217)
		 			try forFrameAnnotate()

		 			break

		 		case .T__216:
		 			setState(3218)
		 			try ifFrameAnnotate()

		 			break

		 		case .T__259:
		 			setState(3219)
		 			try interconnectAnnotate()

		 			break

		 		case .T__305:
		 			setState(3220)
		 			try leafOccurrenceAnnotate()

		 			break

		 		case .T__361:
		 			setState(3221)
		 			try occurrenceAnnotate()

		 			break

		 		case .T__372:
		 			setState(3222)
		 			try otherwiseFrameAnnotate()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3227)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3228)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ForFrameIndexContext: ParserRuleContext {
			open
			func indexNameDef() -> IndexNameDefContext? {
				return getRuleContext(IndexNameDefContext.self, 0)
			}
			open
			func indexStart() -> [IndexStartContext] {
				return getRuleContexts(IndexStartContext.self)
			}
			open
			func indexStart(_ i: Int) -> IndexStartContext? {
				return getRuleContext(IndexStartContext.self, i)
			}
			open
			func indexStep() -> [IndexStepContext] {
				return getRuleContexts(IndexStepContext.self)
			}
			open
			func indexStep(_ i: Int) -> IndexStepContext? {
				return getRuleContext(IndexStepContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_forFrameIndex
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterForFrameIndex(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitForFrameIndex(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitForFrameIndex(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitForFrameIndex(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func forFrameIndex() throws -> ForFrameIndexContext {
		var _localctx: ForFrameIndexContext = ForFrameIndexContext(_ctx, getState())
		try enterRule(_localctx, 458, EDIF300Parser.RULE_forFrameIndex)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3230)
		 	try match(EDIF300Parser.Tokens.T__178.rawValue)
		 	setState(3231)
		 	try indexNameDef()
		 	setState(3237)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__224.rawValue || _la == EDIF300Parser.Tokens.T__226.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3235)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__224:
		 			setState(3232)
		 			try indexStart()

		 			break

		 		case .T__226:
		 			setState(3233)
		 			try indexStep()

		 			break

		 		case .T__346:
		 			setState(3234)
		 			try nameInformation()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3239)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3240)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ForFrameIndexDisplayContext: ParserRuleContext {
			open
			func indexEndDisplay() -> [IndexEndDisplayContext] {
				return getRuleContexts(IndexEndDisplayContext.self)
			}
			open
			func indexEndDisplay(_ i: Int) -> IndexEndDisplayContext? {
				return getRuleContext(IndexEndDisplayContext.self, i)
			}
			open
			func indexNameDisplay() -> [IndexNameDisplayContext] {
				return getRuleContexts(IndexNameDisplayContext.self)
			}
			open
			func indexNameDisplay(_ i: Int) -> IndexNameDisplayContext? {
				return getRuleContext(IndexNameDisplayContext.self, i)
			}
			open
			func indexStartDisplay() -> [IndexStartDisplayContext] {
				return getRuleContexts(IndexStartDisplayContext.self)
			}
			open
			func indexStartDisplay(_ i: Int) -> IndexStartDisplayContext? {
				return getRuleContext(IndexStartDisplayContext.self, i)
			}
			open
			func indexStepDisplay() -> [IndexStepDisplayContext] {
				return getRuleContexts(IndexStepDisplayContext.self)
			}
			open
			func indexStepDisplay(_ i: Int) -> IndexStepDisplayContext? {
				return getRuleContext(IndexStepDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_forFrameIndexDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterForFrameIndexDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitForFrameIndexDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitForFrameIndexDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitForFrameIndexDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func forFrameIndexDisplay() throws -> ForFrameIndexDisplayContext {
		var _localctx: ForFrameIndexDisplayContext = ForFrameIndexDisplayContext(_ctx, getState())
		try enterRule(_localctx, 460, EDIF300Parser.RULE_forFrameIndexDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3242)
		 	try match(EDIF300Parser.Tokens.T__179.rawValue)
		 	setState(3249)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__222.rawValue,EDIF300Parser.Tokens.T__223.rawValue,EDIF300Parser.Tokens.T__225.rawValue,EDIF300Parser.Tokens.T__227.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 223)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(3247)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__222:
		 			setState(3243)
		 			try indexEndDisplay()

		 			break

		 		case .T__223:
		 			setState(3244)
		 			try indexNameDisplay()

		 			break

		 		case .T__225:
		 			setState(3245)
		 			try indexStartDisplay()

		 			break

		 		case .T__227:
		 			setState(3246)
		 			try indexStepDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3251)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3252)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ForFrameIndexNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_forFrameIndexNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterForFrameIndexNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitForFrameIndexNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitForFrameIndexNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitForFrameIndexNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func forFrameIndexNameCaseSensitive() throws -> ForFrameIndexNameCaseSensitiveContext {
		var _localctx: ForFrameIndexNameCaseSensitiveContext = ForFrameIndexNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 462, EDIF300Parser.RULE_forFrameIndexNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3254)
		 	try match(EDIF300Parser.Tokens.T__180.rawValue)
		 	setState(3255)
		 	try booleanToken()
		 	setState(3256)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ForFrameIndexRefContext: ParserRuleContext {
			open
			func indexNameRef() -> IndexNameRefContext? {
				return getRuleContext(IndexNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_forFrameIndexRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterForFrameIndexRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitForFrameIndexRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitForFrameIndexRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitForFrameIndexRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func forFrameIndexRef() throws -> ForFrameIndexRefContext {
		var _localctx: ForFrameIndexRefContext = ForFrameIndexRefContext(_ctx, getState())
		try enterRule(_localctx, 464, EDIF300Parser.RULE_forFrameIndexRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3258)
		 	try match(EDIF300Parser.Tokens.T__181.rawValue)
		 	setState(3259)
		 	try indexNameRef()
		 	setState(3260)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ForFrameMemberRefContext: ParserRuleContext {
			open
			func frameNameRef() -> FrameNameRefContext? {
				return getRuleContext(FrameNameRefContext.self, 0)
			}
			open
			func indexValue() -> IndexValueContext? {
				return getRuleContext(IndexValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_forFrameMemberRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterForFrameMemberRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitForFrameMemberRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitForFrameMemberRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitForFrameMemberRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func forFrameMemberRef() throws -> ForFrameMemberRefContext {
		var _localctx: ForFrameMemberRefContext = ForFrameMemberRefContext(_ctx, getState())
		try enterRule(_localctx, 466, EDIF300Parser.RULE_forFrameMemberRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3262)
		 	try match(EDIF300Parser.Tokens.T__182.rawValue)
		 	setState(3263)
		 	try frameNameRef()
		 	setState(3264)
		 	try indexValue()
		 	setState(3265)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ForFrameRefContext: ParserRuleContext {
			open
			func frameNameRef() -> FrameNameRefContext? {
				return getRuleContext(FrameNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_forFrameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterForFrameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitForFrameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitForFrameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitForFrameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func forFrameRef() throws -> ForFrameRefContext {
		var _localctx: ForFrameRefContext = ForFrameRefContext(_ctx, getState())
		try enterRule(_localctx, 468, EDIF300Parser.RULE_forFrameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3267)
		 	try match(EDIF300Parser.Tokens.T__183.rawValue)
		 	setState(3268)
		 	try frameNameRef()
		 	setState(3269)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FrameConfigurationContext: ParserRuleContext {
			open
			func frameNameRef() -> FrameNameRefContext? {
				return getRuleContext(FrameNameRefContext.self, 0)
			}
			open
			func frameConfiguration() -> [FrameConfigurationContext] {
				return getRuleContexts(FrameConfigurationContext.self)
			}
			open
			func frameConfiguration(_ i: Int) -> FrameConfigurationContext? {
				return getRuleContext(FrameConfigurationContext.self, i)
			}
			open
			func instanceConfiguration() -> [InstanceConfigurationContext] {
				return getRuleContexts(InstanceConfigurationContext.self)
			}
			open
			func instanceConfiguration(_ i: Int) -> InstanceConfigurationContext? {
				return getRuleContext(InstanceConfigurationContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_frameConfiguration
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFrameConfiguration(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFrameConfiguration(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFrameConfiguration(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFrameConfiguration(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func frameConfiguration() throws -> FrameConfigurationContext {
		var _localctx: FrameConfigurationContext = FrameConfigurationContext(_ctx, getState())
		try enterRule(_localctx, 470, EDIF300Parser.RULE_frameConfiguration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3271)
		 	try match(EDIF300Parser.Tokens.T__184.rawValue)
		 	setState(3272)
		 	try frameNameRef()
		 	setState(3277)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__184.rawValue || _la == EDIF300Parser.Tokens.T__233.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3275)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__184:
		 			setState(3273)
		 			try frameConfiguration()

		 			break

		 		case .T__233:
		 			setState(3274)
		 			try instanceConfiguration()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3279)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3280)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FrameNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_frameNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFrameNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFrameNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFrameNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFrameNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func frameNameCaseSensitive() throws -> FrameNameCaseSensitiveContext {
		var _localctx: FrameNameCaseSensitiveContext = FrameNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 472, EDIF300Parser.RULE_frameNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3282)
		 	try match(EDIF300Parser.Tokens.T__185.rawValue)
		 	setState(3283)
		 	try booleanToken()
		 	setState(3284)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FrameNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_frameNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFrameNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFrameNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFrameNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFrameNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func frameNameDef() throws -> FrameNameDefContext {
		var _localctx: FrameNameDefContext = FrameNameDefContext(_ctx, getState())
		try enterRule(_localctx, 474, EDIF300Parser.RULE_frameNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3286)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FrameNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_frameNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFrameNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFrameNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFrameNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFrameNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func frameNameRef() throws -> FrameNameRefContext {
		var _localctx: FrameNameRefContext = FrameNameRefContext(_ctx, getState())
		try enterRule(_localctx, 476, EDIF300Parser.RULE_frameNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3288)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FrameRefContext: ParserRuleContext {
			open
			func frameNameRef() -> FrameNameRefContext? {
				return getRuleContext(FrameNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_frameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFrameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFrameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFrameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFrameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func frameRef() throws -> FrameRefContext {
		var _localctx: FrameRefContext = FrameRefContext(_ctx, getState())
		try enterRule(_localctx, 478, EDIF300Parser.RULE_frameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3290)
		 	try match(EDIF300Parser.Tokens.T__186.rawValue)
		 	setState(3291)
		 	try frameNameRef()
		 	setState(3292)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FrequencyValueContext: ParserRuleContext {
			open
			func miNoMaxValue() -> MiNoMaxValueContext? {
				return getRuleContext(MiNoMaxValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_frequencyValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFrequencyValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFrequencyValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFrequencyValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFrequencyValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func frequencyValue() throws -> FrequencyValueContext {
		var _localctx: FrequencyValueContext = FrequencyValueContext(_ctx, getState())
		try enterRule(_localctx, 480, EDIF300Parser.RULE_frequencyValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3294)
		 	try miNoMaxValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FromBottomContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fromBottom
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFromBottom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFromBottom(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFromBottom(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFromBottom(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fromBottom() throws -> FromBottomContext {
		var _localctx: FromBottomContext = FromBottomContext(_ctx, getState())
		try enterRule(_localctx, 482, EDIF300Parser.RULE_fromBottom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3296)
		 	try match(EDIF300Parser.Tokens.T__187.rawValue)
		 	setState(3297)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FromIntegerContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fromInteger
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFromInteger(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFromInteger(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFromInteger(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFromInteger(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fromInteger() throws -> FromIntegerContext {
		var _localctx: FromIntegerContext = FromIntegerContext(_ctx, getState())
		try enterRule(_localctx, 484, EDIF300Parser.RULE_fromInteger)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3299)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FromLeftContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fromLeft
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFromLeft(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFromLeft(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFromLeft(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFromLeft(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fromLeft() throws -> FromLeftContext {
		var _localctx: FromLeftContext = FromLeftContext(_ctx, getState())
		try enterRule(_localctx, 486, EDIF300Parser.RULE_fromLeft)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3301)
		 	try match(EDIF300Parser.Tokens.T__188.rawValue)
		 	setState(3302)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FromRightContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fromRight
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFromRight(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFromRight(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFromRight(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFromRight(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fromRight() throws -> FromRightContext {
		var _localctx: FromRightContext = FromRightContext(_ctx, getState())
		try enterRule(_localctx, 488, EDIF300Parser.RULE_fromRight)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3304)
		 	try match(EDIF300Parser.Tokens.T__189.rawValue)
		 	setState(3305)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FromTopContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_fromTop
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterFromTop(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitFromTop(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitFromTop(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitFromTop(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func fromTop() throws -> FromTopContext {
		var _localctx: FromTopContext = FromTopContext(_ctx, getState())
		try enterRule(_localctx, 490, EDIF300Parser.RULE_fromTop)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3307)
		 	try match(EDIF300Parser.Tokens.T__190.rawValue)
		 	setState(3308)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GeneratedContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_generated
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGenerated(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGenerated(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGenerated(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGenerated(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func generated() throws -> GeneratedContext {
		var _localctx: GeneratedContext = GeneratedContext(_ctx, getState())
		try enterRule(_localctx, 492, EDIF300Parser.RULE_generated)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3310)
		 	try match(EDIF300Parser.Tokens.T__191.rawValue)
		 	setState(3311)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GeometryMacroContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func geometryMacroHeader() -> GeometryMacroHeaderContext? {
				return getRuleContext(GeometryMacroHeaderContext.self, 0)
			}
			open
			func circle() -> [CircleContext] {
				return getRuleContexts(CircleContext.self)
			}
			open
			func circle(_ i: Int) -> CircleContext? {
				return getRuleContext(CircleContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func complexGeometry() -> [ComplexGeometryContext] {
				return getRuleContexts(ComplexGeometryContext.self)
			}
			open
			func complexGeometry(_ i: Int) -> ComplexGeometryContext? {
				return getRuleContext(ComplexGeometryContext.self, i)
			}
			open
			func dot() -> [DotContext] {
				return getRuleContexts(DotContext.self)
			}
			open
			func dot(_ i: Int) -> DotContext? {
				return getRuleContext(DotContext.self, i)
			}
			open
			func openShape() -> [OpenShapeContext] {
				return getRuleContexts(OpenShapeContext.self)
			}
			open
			func openShape(_ i: Int) -> OpenShapeContext? {
				return getRuleContext(OpenShapeContext.self, i)
			}
			open
			func path() -> [PathContext] {
				return getRuleContexts(PathContext.self)
			}
			open
			func path(_ i: Int) -> PathContext? {
				return getRuleContext(PathContext.self, i)
			}
			open
			func polygon() -> [PolygonContext] {
				return getRuleContexts(PolygonContext.self)
			}
			open
			func polygon(_ i: Int) -> PolygonContext? {
				return getRuleContext(PolygonContext.self, i)
			}
			open
			func rectangle() -> [RectangleContext] {
				return getRuleContexts(RectangleContext.self)
			}
			open
			func rectangle(_ i: Int) -> RectangleContext? {
				return getRuleContext(RectangleContext.self, i)
			}
			open
			func shape() -> [ShapeContext] {
				return getRuleContexts(ShapeContext.self)
			}
			open
			func shape(_ i: Int) -> ShapeContext? {
				return getRuleContext(ShapeContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_geometryMacro
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGeometryMacro(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGeometryMacro(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGeometryMacro(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGeometryMacro(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func geometryMacro() throws -> GeometryMacroContext {
		var _localctx: GeometryMacroContext = GeometryMacroContext(_ctx, getState())
		try enterRule(_localctx, 494, EDIF300Parser.RULE_geometryMacro)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3313)
		 	try match(EDIF300Parser.Tokens.T__192.rawValue)
		 	setState(3314)
		 	try libraryObjectNameDef()
		 	setState(3315)
		 	try geometryMacroHeader()
		 	setState(3328)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__49.rawValue,EDIF300Parser.Tokens.T__61.rawValue,EDIF300Parser.Tokens.T__67.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 50)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__137.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__365.rawValue,EDIF300Parser.Tokens.T__401.rawValue,EDIF300Parser.Tokens.T__413.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 366)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__453.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__582.rawValue || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3326)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__49:
		 			setState(3316)
		 			try circle()

		 			break

		 		case .T__61:
		 			setState(3317)
		 			try comment()

		 			break

		 		case .T__67:
		 			setState(3318)
		 			try complexGeometry()

		 			break

		 		case .T__137:
		 			setState(3319)
		 			try dot()

		 			break

		 		case .T__365:
		 			setState(3320)
		 			try openShape()

		 			break

		 		case .T__401:
		 			setState(3321)
		 			try path()

		 			break

		 		case .T__413:
		 			setState(3322)
		 			try polygon()

		 			break

		 		case .T__453:
		 			setState(3323)
		 			try rectangle()

		 			break

		 		case .T__582:
		 			setState(3324)
		 			try shape()

		 			break

		 		case .T__642:
		 			setState(3325)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3330)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3331)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GeometryMacroHeaderContext: ParserRuleContext {
			open
			func geometryMacroUnits() -> GeometryMacroUnitsContext? {
				return getRuleContext(GeometryMacroUnitsContext.self, 0)
			}
			open
			func backgroundColor() -> [BackgroundColorContext] {
				return getRuleContexts(BackgroundColorContext.self)
			}
			open
			func backgroundColor(_ i: Int) -> BackgroundColorContext? {
				return getRuleContext(BackgroundColorContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func originalBoundingBox() -> [OriginalBoundingBoxContext] {
				return getRuleContexts(OriginalBoundingBoxContext.self)
			}
			open
			func originalBoundingBox(_ i: Int) -> OriginalBoundingBoxContext? {
				return getRuleContext(OriginalBoundingBoxContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_geometryMacroHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGeometryMacroHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGeometryMacroHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGeometryMacroHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGeometryMacroHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func geometryMacroHeader() throws -> GeometryMacroHeaderContext {
		var _localctx: GeometryMacroHeaderContext = GeometryMacroHeaderContext(_ctx, getState())
		try enterRule(_localctx, 496, EDIF300Parser.RULE_geometryMacroHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3333)
		 	try match(EDIF300Parser.Tokens.T__193.rawValue)
		 	setState(3334)
		 	try geometryMacroUnits()
		 	setState(3343)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__14.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue || _la == EDIF300Parser.Tokens.T__368.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3341)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__14:
		 			setState(3335)
		 			try backgroundColor()

		 			break

		 		case .T__132:
		 			setState(3336)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(3337)
		 			try nameInformation()

		 			break

		 		case .T__368:
		 			setState(3338)
		 			try originalBoundingBox()

		 			break

		 		case .T__442:
		 			setState(3339)
		 			try property()

		 			break

		 		case .T__597:
		 			setState(3340)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3345)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3346)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GeometryMacroRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_geometryMacroRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGeometryMacroRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGeometryMacroRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGeometryMacroRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGeometryMacroRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func geometryMacroRef() throws -> GeometryMacroRefContext {
		var _localctx: GeometryMacroRefContext = GeometryMacroRefContext(_ctx, getState())
		try enterRule(_localctx, 498, EDIF300Parser.RULE_geometryMacroRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3348)
		 	try match(EDIF300Parser.Tokens.T__194.rawValue)
		 	setState(3349)
		 	try libraryObjectNameRef()
		 	setState(3351)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3350)
		 		try libraryRef()

		 	}

		 	setState(3353)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GeometryMacroUnitsContext: ParserRuleContext {
			open
			func setAngle() -> SetAngleContext? {
				return getRuleContext(SetAngleContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_geometryMacroUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGeometryMacroUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGeometryMacroUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGeometryMacroUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGeometryMacroUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func geometryMacroUnits() throws -> GeometryMacroUnitsContext {
		var _localctx: GeometryMacroUnitsContext = GeometryMacroUnitsContext(_ctx, getState())
		try enterRule(_localctx, 500, EDIF300Parser.RULE_geometryMacroUnits)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3355)
		 	try match(EDIF300Parser.Tokens.T__195.rawValue)
		 	setState(3357)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__575.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3356)
		 		try setAngle()

		 	}

		 	setState(3359)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalPortContext: ParserRuleContext {
			open
			func globalPortNameDef() -> GlobalPortNameDefContext? {
				return getRuleContext(GlobalPortNameDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func schematicGlobalPortAttributes() -> [SchematicGlobalPortAttributesContext] {
				return getRuleContexts(SchematicGlobalPortAttributesContext.self)
			}
			open
			func schematicGlobalPortAttributes(_ i: Int) -> SchematicGlobalPortAttributesContext? {
				return getRuleContext(SchematicGlobalPortAttributesContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_globalPort
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGlobalPort(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGlobalPort(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGlobalPort(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGlobalPort(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalPort() throws -> GlobalPortContext {
		var _localctx: GlobalPortContext = GlobalPortContext(_ctx, getState())
		try enterRule(_localctx, 502, EDIF300Parser.RULE_globalPort)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3361)
		 	try match(EDIF300Parser.Tokens.T__196.rawValue)
		 	setState(3362)
		 	try globalPortNameDef()
		 	setState(3370)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue || _la == EDIF300Parser.Tokens.T__483.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3368)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(3363)
		 			try comment()

		 			break

		 		case .T__346:
		 			setState(3364)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(3365)
		 			try property()

		 			break

		 		case .T__483:
		 			setState(3366)
		 			try schematicGlobalPortAttributes()

		 			break

		 		case .T__642:
		 			setState(3367)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3372)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3373)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalPortBundleContext: ParserRuleContext {
			open
			func globalPortNameDef() -> GlobalPortNameDefContext? {
				return getRuleContext(GlobalPortNameDefContext.self, 0)
			}
			open
			func globalPortList() -> GlobalPortListContext? {
				return getRuleContext(GlobalPortListContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_globalPortBundle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGlobalPortBundle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGlobalPortBundle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGlobalPortBundle(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGlobalPortBundle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalPortBundle() throws -> GlobalPortBundleContext {
		var _localctx: GlobalPortBundleContext = GlobalPortBundleContext(_ctx, getState())
		try enterRule(_localctx, 504, EDIF300Parser.RULE_globalPortBundle)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3375)
		 	try match(EDIF300Parser.Tokens.T__197.rawValue)
		 	setState(3376)
		 	try globalPortNameDef()
		 	setState(3377)
		 	try globalPortList()
		 	setState(3384)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3382)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(3378)
		 			try comment()

		 			break

		 		case .T__346:
		 			setState(3379)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(3380)
		 			try property()

		 			break

		 		case .T__642:
		 			setState(3381)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3386)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3387)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalPortDefinitionsContext: ParserRuleContext {
			open
			func globalPort() -> [GlobalPortContext] {
				return getRuleContexts(GlobalPortContext.self)
			}
			open
			func globalPort(_ i: Int) -> GlobalPortContext? {
				return getRuleContext(GlobalPortContext.self, i)
			}
			open
			func globalPortBundle() -> [GlobalPortBundleContext] {
				return getRuleContexts(GlobalPortBundleContext.self)
			}
			open
			func globalPortBundle(_ i: Int) -> GlobalPortBundleContext? {
				return getRuleContext(GlobalPortBundleContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_globalPortDefinitions
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGlobalPortDefinitions(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGlobalPortDefinitions(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGlobalPortDefinitions(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGlobalPortDefinitions(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalPortDefinitions() throws -> GlobalPortDefinitionsContext {
		var _localctx: GlobalPortDefinitionsContext = GlobalPortDefinitionsContext(_ctx, getState())
		try enterRule(_localctx, 506, EDIF300Parser.RULE_globalPortDefinitions)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3389)
		 	try match(EDIF300Parser.Tokens.T__198.rawValue)
		 	setState(3394)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__196.rawValue || _la == EDIF300Parser.Tokens.T__197.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3392)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__196:
		 			setState(3390)
		 			try globalPort()

		 			break

		 		case .T__197:
		 			setState(3391)
		 			try globalPortBundle()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3396)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3397)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalPortListContext: ParserRuleContext {
			open
			func globalPortRef() -> [GlobalPortRefContext] {
				return getRuleContexts(GlobalPortRefContext.self)
			}
			open
			func globalPortRef(_ i: Int) -> GlobalPortRefContext? {
				return getRuleContext(GlobalPortRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_globalPortList
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGlobalPortList(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGlobalPortList(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGlobalPortList(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGlobalPortList(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalPortList() throws -> GlobalPortListContext {
		var _localctx: GlobalPortListContext = GlobalPortListContext(_ctx, getState())
		try enterRule(_localctx, 508, EDIF300Parser.RULE_globalPortList)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3399)
		 	try match(EDIF300Parser.Tokens.T__199.rawValue)
		 	setState(3403)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__203.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3400)
		 		try globalPortRef()


		 		setState(3405)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3406)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalPortNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_globalPortNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGlobalPortNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGlobalPortNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGlobalPortNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGlobalPortNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalPortNameCaseSensitive() throws -> GlobalPortNameCaseSensitiveContext {
		var _localctx: GlobalPortNameCaseSensitiveContext = GlobalPortNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 510, EDIF300Parser.RULE_globalPortNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3408)
		 	try match(EDIF300Parser.Tokens.T__200.rawValue)
		 	setState(3409)
		 	try booleanToken()
		 	setState(3410)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalPortNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_globalPortNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGlobalPortNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGlobalPortNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGlobalPortNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGlobalPortNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalPortNameDef() throws -> GlobalPortNameDefContext {
		var _localctx: GlobalPortNameDefContext = GlobalPortNameDefContext(_ctx, getState())
		try enterRule(_localctx, 512, EDIF300Parser.RULE_globalPortNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3412)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalPortNameDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func displayNameOverride() -> [DisplayNameOverrideContext] {
				return getRuleContexts(DisplayNameOverrideContext.self)
			}
			open
			func displayNameOverride(_ i: Int) -> DisplayNameOverrideContext? {
				return getRuleContext(DisplayNameOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_globalPortNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGlobalPortNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGlobalPortNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGlobalPortNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGlobalPortNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalPortNameDisplay() throws -> GlobalPortNameDisplayContext {
		var _localctx: GlobalPortNameDisplayContext = GlobalPortNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 514, EDIF300Parser.RULE_globalPortNameDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3414)
		 	try match(EDIF300Parser.Tokens.T__201.rawValue)
		 	setState(3419)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue || _la == EDIF300Parser.Tokens.T__131.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3417)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(3415)
		 			try display()

		 			break

		 		case .T__131:
		 			setState(3416)
		 			try displayNameOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3421)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3422)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalPortNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_globalPortNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGlobalPortNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGlobalPortNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGlobalPortNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGlobalPortNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalPortNameRef() throws -> GlobalPortNameRefContext {
		var _localctx: GlobalPortNameRefContext = GlobalPortNameRefContext(_ctx, getState())
		try enterRule(_localctx, 516, EDIF300Parser.RULE_globalPortNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3424)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalPortPropertyDisplayContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func propertyNameDisplay() -> [PropertyNameDisplayContext] {
				return getRuleContexts(PropertyNameDisplayContext.self)
			}
			open
			func propertyNameDisplay(_ i: Int) -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_globalPortPropertyDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGlobalPortPropertyDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGlobalPortPropertyDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGlobalPortPropertyDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGlobalPortPropertyDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalPortPropertyDisplay() throws -> GlobalPortPropertyDisplayContext {
		var _localctx: GlobalPortPropertyDisplayContext = GlobalPortPropertyDisplayContext(_ctx, getState())
		try enterRule(_localctx, 518, EDIF300Parser.RULE_globalPortPropertyDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3426)
		 	try match(EDIF300Parser.Tokens.T__202.rawValue)
		 	setState(3427)
		 	try propertyNameRef()
		 	setState(3432)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3430)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(3428)
		 			try display()

		 			break

		 		case .T__447:
		 			setState(3429)
		 			try propertyNameDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3434)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3435)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalPortRefContext: ParserRuleContext {
			open
			func globalPortNameRef() -> GlobalPortNameRefContext? {
				return getRuleContext(GlobalPortNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_globalPortRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGlobalPortRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGlobalPortRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGlobalPortRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGlobalPortRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalPortRef() throws -> GlobalPortRefContext {
		var _localctx: GlobalPortRefContext = GlobalPortRefContext(_ctx, getState())
		try enterRule(_localctx, 520, EDIF300Parser.RULE_globalPortRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3437)
		 	try match(EDIF300Parser.Tokens.T__203.rawValue)
		 	setState(3438)
		 	try globalPortNameRef()
		 	setState(3439)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GlobalPortScopeContext: ParserRuleContext {
			open
			func globalPortNameRef() -> GlobalPortNameRefContext? {
				return getRuleContext(GlobalPortNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_globalPortScope
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGlobalPortScope(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGlobalPortScope(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGlobalPortScope(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGlobalPortScope(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func globalPortScope() throws -> GlobalPortScopeContext {
		var _localctx: GlobalPortScopeContext = GlobalPortScopeContext(_ctx, getState())
		try enterRule(_localctx, 522, EDIF300Parser.RULE_globalPortScope)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3441)
		 	try match(EDIF300Parser.Tokens.T__204.rawValue)
		 	setState(3442)
		 	try globalPortNameRef()
		 	setState(3443)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GreenContext: ParserRuleContext {
			open
			func scaledInteger() -> ScaledIntegerContext? {
				return getRuleContext(ScaledIntegerContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_green
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterGreen(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitGreen(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitGreen(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitGreen(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func green() throws -> GreenContext {
		var _localctx: GreenContext = GreenContext(_ctx, getState())
		try enterRule(_localctx, 524, EDIF300Parser.RULE_green)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3445)
		 	try scaledInteger()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HenryContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_henry
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterHenry(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitHenry(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitHenry(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitHenry(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func henry() throws -> HenryContext {
		var _localctx: HenryContext = HenryContext(_ctx, getState())
		try enterRule(_localctx, 526, EDIF300Parser.RULE_henry)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3447)
		 	try match(EDIF300Parser.Tokens.T__205.rawValue)
		 	setState(3448)
		 	try unitExponent()
		 	setState(3449)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HertzContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_hertz
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterHertz(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitHertz(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitHertz(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitHertz(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func hertz() throws -> HertzContext {
		var _localctx: HertzContext = HertzContext(_ctx, getState())
		try enterRule(_localctx, 528, EDIF300Parser.RULE_hertz)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3451)
		 	try match(EDIF300Parser.Tokens.T__206.rawValue)
		 	setState(3452)
		 	try unitExponent()
		 	setState(3453)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HorizontalJustificationContext: ParserRuleContext {
			open
			func leftJustify() -> LeftJustifyContext? {
				return getRuleContext(LeftJustifyContext.self, 0)
			}
			open
			func centerJustify() -> CenterJustifyContext? {
				return getRuleContext(CenterJustifyContext.self, 0)
			}
			open
			func rightJustify() -> RightJustifyContext? {
				return getRuleContext(RightJustifyContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_horizontalJustification
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterHorizontalJustification(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitHorizontalJustification(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitHorizontalJustification(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitHorizontalJustification(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func horizontalJustification() throws -> HorizontalJustificationContext {
		var _localctx: HorizontalJustificationContext = HorizontalJustificationContext(_ctx, getState())
		try enterRule(_localctx, 530, EDIF300Parser.RULE_horizontalJustification)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3455)
		 	try match(EDIF300Parser.Tokens.T__207.rawValue)
		 	setState(3459)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__306:
		 		setState(3456)
		 		try leftJustify()

		 		break

		 	case .T__45:
		 		setState(3457)
		 		try centerJustify()

		 		break

		 	case .T__462:
		 		setState(3458)
		 		try rightJustify()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3461)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HotspotContext: ParserRuleContext {
			open
			func pointValue() -> PointValueContext? {
				return getRuleContext(PointValueContext.self, 0)
			}
			open
			func hotspotConnectDirection() -> [HotspotConnectDirectionContext] {
				return getRuleContexts(HotspotConnectDirectionContext.self)
			}
			open
			func hotspotConnectDirection(_ i: Int) -> HotspotConnectDirectionContext? {
				return getRuleContext(HotspotConnectDirectionContext.self, i)
			}
			open
			func hotspotNameDisplay() -> [HotspotNameDisplayContext] {
				return getRuleContexts(HotspotNameDisplayContext.self)
			}
			open
			func hotspotNameDisplay(_ i: Int) -> HotspotNameDisplayContext? {
				return getRuleContext(HotspotNameDisplayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func schematicWireAffinity() -> [SchematicWireAffinityContext] {
				return getRuleContexts(SchematicWireAffinityContext.self)
			}
			open
			func schematicWireAffinity(_ i: Int) -> SchematicWireAffinityContext? {
				return getRuleContext(SchematicWireAffinityContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_hotspot
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterHotspot(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitHotspot(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitHotspot(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitHotspot(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func hotspot() throws -> HotspotContext {
		var _localctx: HotspotContext = HotspotContext(_ctx, getState())
		try enterRule(_localctx, 532, EDIF300Parser.RULE_hotspot)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3463)
		 	try match(EDIF300Parser.Tokens.T__208.rawValue)
		 	setState(3464)
		 	try pointValue()
		 	setState(3471)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__209.rawValue || _la == EDIF300Parser.Tokens.T__212.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__569.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3469)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__209:
		 			setState(3465)
		 			try hotspotConnectDirection()

		 			break

		 		case .T__212:
		 			setState(3466)
		 			try hotspotNameDisplay()

		 			break

		 		case .T__346:
		 			setState(3467)
		 			try nameInformation()

		 			break

		 		case .T__569:
		 			setState(3468)
		 			try schematicWireAffinity()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3473)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3474)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HotspotConnectDirectionContext: ParserRuleContext {
			open
			func fromBottom() -> [FromBottomContext] {
				return getRuleContexts(FromBottomContext.self)
			}
			open
			func fromBottom(_ i: Int) -> FromBottomContext? {
				return getRuleContext(FromBottomContext.self, i)
			}
			open
			func fromLeft() -> [FromLeftContext] {
				return getRuleContexts(FromLeftContext.self)
			}
			open
			func fromLeft(_ i: Int) -> FromLeftContext? {
				return getRuleContext(FromLeftContext.self, i)
			}
			open
			func fromRight() -> [FromRightContext] {
				return getRuleContexts(FromRightContext.self)
			}
			open
			func fromRight(_ i: Int) -> FromRightContext? {
				return getRuleContext(FromRightContext.self, i)
			}
			open
			func fromTop() -> [FromTopContext] {
				return getRuleContexts(FromTopContext.self)
			}
			open
			func fromTop(_ i: Int) -> FromTopContext? {
				return getRuleContext(FromTopContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_hotspotConnectDirection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterHotspotConnectDirection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitHotspotConnectDirection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitHotspotConnectDirection(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitHotspotConnectDirection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func hotspotConnectDirection() throws -> HotspotConnectDirectionContext {
		var _localctx: HotspotConnectDirectionContext = HotspotConnectDirectionContext(_ctx, getState())
		try enterRule(_localctx, 534, EDIF300Parser.RULE_hotspotConnectDirection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3476)
		 	try match(EDIF300Parser.Tokens.T__209.rawValue)
		 	setState(3483)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__187.rawValue,EDIF300Parser.Tokens.T__188.rawValue,EDIF300Parser.Tokens.T__189.rawValue,EDIF300Parser.Tokens.T__190.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 188)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(3481)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__187:
		 			setState(3477)
		 			try fromBottom()

		 			break

		 		case .T__188:
		 			setState(3478)
		 			try fromLeft()

		 			break

		 		case .T__189:
		 			setState(3479)
		 			try fromRight()

		 			break

		 		case .T__190:
		 			setState(3480)
		 			try fromTop()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3485)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3486)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HotspotGridContext: ParserRuleContext {
			open
			func lengthValue() -> LengthValueContext? {
				return getRuleContext(LengthValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_hotspotGrid
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterHotspotGrid(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitHotspotGrid(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitHotspotGrid(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitHotspotGrid(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func hotspotGrid() throws -> HotspotGridContext {
		var _localctx: HotspotGridContext = HotspotGridContext(_ctx, getState())
		try enterRule(_localctx, 536, EDIF300Parser.RULE_hotspotGrid)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3488)
		 	try match(EDIF300Parser.Tokens.T__210.rawValue)
		 	setState(3489)
		 	try lengthValue()
		 	setState(3490)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HotspotNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_hotspotNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterHotspotNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitHotspotNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitHotspotNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitHotspotNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func hotspotNameCaseSensitive() throws -> HotspotNameCaseSensitiveContext {
		var _localctx: HotspotNameCaseSensitiveContext = HotspotNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 538, EDIF300Parser.RULE_hotspotNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3492)
		 	try match(EDIF300Parser.Tokens.T__211.rawValue)
		 	setState(3493)
		 	try booleanToken()
		 	setState(3494)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HotspotNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_hotspotNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterHotspotNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitHotspotNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitHotspotNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitHotspotNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func hotspotNameDef() throws -> HotspotNameDefContext {
		var _localctx: HotspotNameDefContext = HotspotNameDefContext(_ctx, getState())
		try enterRule(_localctx, 540, EDIF300Parser.RULE_hotspotNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3496)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HotspotNameDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func displayNameOverride() -> [DisplayNameOverrideContext] {
				return getRuleContexts(DisplayNameOverrideContext.self)
			}
			open
			func displayNameOverride(_ i: Int) -> DisplayNameOverrideContext? {
				return getRuleContext(DisplayNameOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_hotspotNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterHotspotNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitHotspotNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitHotspotNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitHotspotNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func hotspotNameDisplay() throws -> HotspotNameDisplayContext {
		var _localctx: HotspotNameDisplayContext = HotspotNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 542, EDIF300Parser.RULE_hotspotNameDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3498)
		 	try match(EDIF300Parser.Tokens.T__212.rawValue)
		 	setState(3503)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue || _la == EDIF300Parser.Tokens.T__131.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3501)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(3499)
		 			try display()

		 			break

		 		case .T__131:
		 			setState(3500)
		 			try displayNameOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3505)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3506)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HotspotNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_hotspotNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterHotspotNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitHotspotNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitHotspotNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitHotspotNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func hotspotNameRef() throws -> HotspotNameRefContext {
		var _localctx: HotspotNameRefContext = HotspotNameRefContext(_ctx, getState())
		try enterRule(_localctx, 544, EDIF300Parser.RULE_hotspotNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3508)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HourNumberContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_hourNumber
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterHourNumber(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitHourNumber(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitHourNumber(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitHourNumber(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func hourNumber() throws -> HourNumberContext {
		var _localctx: HourNumberContext = HourNumberContext(_ctx, getState())
		try enterRule(_localctx, 546, EDIF300Parser.RULE_hourNumber)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3510)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IeeeDesignationContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ieeeDesignation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIeeeDesignation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIeeeDesignation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIeeeDesignation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIeeeDesignation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ieeeDesignation() throws -> IeeeDesignationContext {
		var _localctx: IeeeDesignationContext = IeeeDesignationContext(_ctx, getState())
		try enterRule(_localctx, 548, EDIF300Parser.RULE_ieeeDesignation)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3512)
		 	try stringToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IeeeSectionContext: ParserRuleContext {
			open
			func integerToken() -> [IntegerTokenContext] {
				return getRuleContexts(IntegerTokenContext.self)
			}
			open
			func integerToken(_ i: Int) -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ieeeSection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIeeeSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIeeeSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIeeeSection(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIeeeSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ieeeSection() throws -> IeeeSectionContext {
		var _localctx: IeeeSectionContext = IeeeSectionContext(_ctx, getState())
		try enterRule(_localctx, 550, EDIF300Parser.RULE_ieeeSection)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3514)
		 	try match(EDIF300Parser.Tokens.T__213.rawValue)
		 	setState(3518)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.DECIMAL_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3515)
		 		try integerToken()


		 		setState(3520)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3521)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IeeeStandardContext: ParserRuleContext {
			open
			func ieeeDesignation() -> IeeeDesignationContext? {
				return getRuleContext(IeeeDesignationContext.self, 0)
			}
			open
			func year() -> YearContext? {
				return getRuleContext(YearContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func ieeeSection() -> [IeeeSectionContext] {
				return getRuleContexts(IeeeSectionContext.self)
			}
			open
			func ieeeSection(_ i: Int) -> IeeeSectionContext? {
				return getRuleContext(IeeeSectionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ieeeStandard
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIeeeStandard(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIeeeStandard(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIeeeStandard(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIeeeStandard(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ieeeStandard() throws -> IeeeStandardContext {
		var _localctx: IeeeStandardContext = IeeeStandardContext(_ctx, getState())
		try enterRule(_localctx, 552, EDIF300Parser.RULE_ieeeStandard)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3523)
		 	try match(EDIF300Parser.Tokens.T__214.rawValue)
		 	setState(3524)
		 	try ieeeDesignation()
		 	setState(3525)
		 	try year()
		 	setState(3530)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__213.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3528)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(3526)
		 			try comment()

		 			break

		 		case .T__213:
		 			setState(3527)
		 			try ieeeSection()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3532)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3533)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IfFrameContext: ParserRuleContext {
			open
			func frameNameDef() -> FrameNameDefContext? {
				return getRuleContext(FrameNameDefContext.self, 0)
			}
			open
			func condition() -> ConditionContext? {
				return getRuleContext(ConditionContext.self, 0)
			}
			open
			func logicalConnectivity() -> LogicalConnectivityContext? {
				return getRuleContext(LogicalConnectivityContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ifFrame
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIfFrame(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIfFrame(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIfFrame(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIfFrame(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ifFrame() throws -> IfFrameContext {
		var _localctx: IfFrameContext = IfFrameContext(_ctx, getState())
		try enterRule(_localctx, 554, EDIF300Parser.RULE_ifFrame)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3535)
		 	try match(EDIF300Parser.Tokens.T__215.rawValue)
		 	setState(3536)
		 	try frameNameDef()
		 	setState(3537)
		 	try condition()
		 	setState(3538)
		 	try logicalConnectivity()
		 	setState(3546)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3544)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(3539)
		 			try comment()

		 			break

		 		case .T__346:
		 			setState(3540)
		 			try nameInformation()

		 			break

		 		case .T__132:
		 			setState(3541)
		 			try documentation()

		 			break

		 		case .T__442:
		 			setState(3542)
		 			try property()

		 			break

		 		case .T__642:
		 			setState(3543)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3548)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3549)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IfFrameAnnotateContext: ParserRuleContext {
			open
			func extendFrameDef() -> ExtendFrameDefContext? {
				return getRuleContext(ExtendFrameDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func forFrameAnnotate() -> [ForFrameAnnotateContext] {
				return getRuleContexts(ForFrameAnnotateContext.self)
			}
			open
			func forFrameAnnotate(_ i: Int) -> ForFrameAnnotateContext? {
				return getRuleContext(ForFrameAnnotateContext.self, i)
			}
			open
			func ifFrameAnnotate() -> [IfFrameAnnotateContext] {
				return getRuleContexts(IfFrameAnnotateContext.self)
			}
			open
			func ifFrameAnnotate(_ i: Int) -> IfFrameAnnotateContext? {
				return getRuleContext(IfFrameAnnotateContext.self, i)
			}
			open
			func interconnectAnnotate() -> [InterconnectAnnotateContext] {
				return getRuleContexts(InterconnectAnnotateContext.self)
			}
			open
			func interconnectAnnotate(_ i: Int) -> InterconnectAnnotateContext? {
				return getRuleContext(InterconnectAnnotateContext.self, i)
			}
			open
			func leafOccurrenceAnnotate() -> [LeafOccurrenceAnnotateContext] {
				return getRuleContexts(LeafOccurrenceAnnotateContext.self)
			}
			open
			func leafOccurrenceAnnotate(_ i: Int) -> LeafOccurrenceAnnotateContext? {
				return getRuleContext(LeafOccurrenceAnnotateContext.self, i)
			}
			open
			func occurrenceAnnotate() -> [OccurrenceAnnotateContext] {
				return getRuleContexts(OccurrenceAnnotateContext.self)
			}
			open
			func occurrenceAnnotate(_ i: Int) -> OccurrenceAnnotateContext? {
				return getRuleContext(OccurrenceAnnotateContext.self, i)
			}
			open
			func otherwiseFrameAnnotate() -> [OtherwiseFrameAnnotateContext] {
				return getRuleContexts(OtherwiseFrameAnnotateContext.self)
			}
			open
			func otherwiseFrameAnnotate(_ i: Int) -> OtherwiseFrameAnnotateContext? {
				return getRuleContext(OtherwiseFrameAnnotateContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ifFrameAnnotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIfFrameAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIfFrameAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIfFrameAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIfFrameAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ifFrameAnnotate() throws -> IfFrameAnnotateContext {
		var _localctx: IfFrameAnnotateContext = IfFrameAnnotateContext(_ctx, getState())
		try enterRule(_localctx, 556, EDIF300Parser.RULE_ifFrameAnnotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3551)
		 	try match(EDIF300Parser.Tokens.T__216.rawValue)
		 	setState(3552)
		 	try extendFrameDef()
		 	setState(3563)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__177.rawValue || _la == EDIF300Parser.Tokens.T__216.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__259.rawValue || _la == EDIF300Parser.Tokens.T__305.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__361.rawValue || _la == EDIF300Parser.Tokens.T__372.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3561)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(3553)
		 			try comment()

		 			break

		 		case .T__177:
		 			setState(3554)
		 			try forFrameAnnotate()

		 			break

		 		case .T__216:
		 			setState(3555)
		 			try ifFrameAnnotate()

		 			break

		 		case .T__259:
		 			setState(3556)
		 			try interconnectAnnotate()

		 			break

		 		case .T__305:
		 			setState(3557)
		 			try leafOccurrenceAnnotate()

		 			break

		 		case .T__361:
		 			setState(3558)
		 			try occurrenceAnnotate()

		 			break

		 		case .T__372:
		 			setState(3559)
		 			try otherwiseFrameAnnotate()

		 			break

		 		case .T__448:
		 			setState(3560)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3565)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3566)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IfFrameRefContext: ParserRuleContext {
			open
			func frameNameRef() -> FrameNameRefContext? {
				return getRuleContext(FrameNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ifFrameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIfFrameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIfFrameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIfFrameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIfFrameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ifFrameRef() throws -> IfFrameRefContext {
		var _localctx: IfFrameRefContext = IfFrameRefContext(_ctx, getState())
		try enterRule(_localctx, 558, EDIF300Parser.RULE_ifFrameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3568)
		 	try match(EDIF300Parser.Tokens.T__217.rawValue)
		 	setState(3569)
		 	try frameNameRef()
		 	setState(3570)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IfFrameSetContext: ParserRuleContext {
			open
			func ifFrameRef() -> [IfFrameRefContext] {
				return getRuleContexts(IfFrameRefContext.self)
			}
			open
			func ifFrameRef(_ i: Int) -> IfFrameRefContext? {
				return getRuleContext(IfFrameRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ifFrameSet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIfFrameSet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIfFrameSet(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIfFrameSet(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIfFrameSet(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ifFrameSet() throws -> IfFrameSetContext {
		var _localctx: IfFrameSetContext = IfFrameSetContext(_ctx, getState())
		try enterRule(_localctx, 560, EDIF300Parser.RULE_ifFrameSet)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3572)
		 	try match(EDIF300Parser.Tokens.T__218.rawValue)
		 	setState(3576)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__217.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3573)
		 		try ifFrameRef()


		 		setState(3578)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3579)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IgnoreContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ignore
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIgnore(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIgnore(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIgnore(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIgnore(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ignore() throws -> IgnoreContext {
		var _localctx: IgnoreContext = IgnoreContext(_ctx, getState())
		try enterRule(_localctx, 562, EDIF300Parser.RULE_ignore)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3581)
		 	try match(EDIF300Parser.Tokens.T__219.rawValue)
		 	setState(3582)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ImplementationNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_implementationNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterImplementationNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitImplementationNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitImplementationNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitImplementationNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func implementationNameCaseSensitive() throws -> ImplementationNameCaseSensitiveContext {
		var _localctx: ImplementationNameCaseSensitiveContext = ImplementationNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 564, EDIF300Parser.RULE_implementationNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3584)
		 	try match(EDIF300Parser.Tokens.T__220.rawValue)
		 	setState(3585)
		 	try booleanToken()
		 	setState(3586)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ImplementationNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_implementationNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterImplementationNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitImplementationNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitImplementationNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitImplementationNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func implementationNameDef() throws -> ImplementationNameDefContext {
		var _localctx: ImplementationNameDefContext = ImplementationNameDefContext(_ctx, getState())
		try enterRule(_localctx, 566, EDIF300Parser.RULE_implementationNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3588)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ImplementationNameDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func displayNameOverride() -> [DisplayNameOverrideContext] {
				return getRuleContexts(DisplayNameOverrideContext.self)
			}
			open
			func displayNameOverride(_ i: Int) -> DisplayNameOverrideContext? {
				return getRuleContext(DisplayNameOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_implementationNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterImplementationNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitImplementationNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitImplementationNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitImplementationNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func implementationNameDisplay() throws -> ImplementationNameDisplayContext {
		var _localctx: ImplementationNameDisplayContext = ImplementationNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 568, EDIF300Parser.RULE_implementationNameDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3590)
		 	try match(EDIF300Parser.Tokens.T__221.rawValue)
		 	setState(3595)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue || _la == EDIF300Parser.Tokens.T__131.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3593)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(3591)
		 			try display()

		 			break

		 		case .T__131:
		 			setState(3592)
		 			try displayNameOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3597)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3598)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ImplementationNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_implementationNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterImplementationNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitImplementationNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitImplementationNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitImplementationNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func implementationNameRef() throws -> ImplementationNameRefContext {
		var _localctx: ImplementationNameRefContext = ImplementationNameRefContext(_ctx, getState())
		try enterRule(_localctx, 570, EDIF300Parser.RULE_implementationNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3600)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexEndDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_indexEndDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIndexEndDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIndexEndDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIndexEndDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIndexEndDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func indexEndDisplay() throws -> IndexEndDisplayContext {
		var _localctx: IndexEndDisplayContext = IndexEndDisplayContext(_ctx, getState())
		try enterRule(_localctx, 572, EDIF300Parser.RULE_indexEndDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3602)
		 	try match(EDIF300Parser.Tokens.T__222.rawValue)
		 	setState(3606)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(3603)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(3604)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(3605)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3608)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_indexNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIndexNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIndexNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIndexNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIndexNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func indexNameDef() throws -> IndexNameDefContext {
		var _localctx: IndexNameDefContext = IndexNameDefContext(_ctx, getState())
		try enterRule(_localctx, 574, EDIF300Parser.RULE_indexNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3610)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexNameDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_indexNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIndexNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIndexNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIndexNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIndexNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func indexNameDisplay() throws -> IndexNameDisplayContext {
		var _localctx: IndexNameDisplayContext = IndexNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 576, EDIF300Parser.RULE_indexNameDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3612)
		 	try match(EDIF300Parser.Tokens.T__223.rawValue)
		 	setState(3616)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(3613)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(3614)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(3615)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3618)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_indexNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIndexNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIndexNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIndexNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIndexNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func indexNameRef() throws -> IndexNameRefContext {
		var _localctx: IndexNameRefContext = IndexNameRefContext(_ctx, getState())
		try enterRule(_localctx, 578, EDIF300Parser.RULE_indexNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3620)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexStartContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_indexStart
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIndexStart(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIndexStart(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIndexStart(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIndexStart(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func indexStart() throws -> IndexStartContext {
		var _localctx: IndexStartContext = IndexStartContext(_ctx, getState())
		try enterRule(_localctx, 580, EDIF300Parser.RULE_indexStart)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3622)
		 	try match(EDIF300Parser.Tokens.T__224.rawValue)
		 	setState(3623)
		 	try integerExpression()
		 	setState(3624)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexStartDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_indexStartDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIndexStartDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIndexStartDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIndexStartDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIndexStartDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func indexStartDisplay() throws -> IndexStartDisplayContext {
		var _localctx: IndexStartDisplayContext = IndexStartDisplayContext(_ctx, getState())
		try enterRule(_localctx, 582, EDIF300Parser.RULE_indexStartDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3626)
		 	try match(EDIF300Parser.Tokens.T__225.rawValue)
		 	setState(3630)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(3627)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(3628)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(3629)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3632)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexStepContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_indexStep
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIndexStep(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIndexStep(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIndexStep(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIndexStep(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func indexStep() throws -> IndexStepContext {
		var _localctx: IndexStepContext = IndexStepContext(_ctx, getState())
		try enterRule(_localctx, 584, EDIF300Parser.RULE_indexStep)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3634)
		 	try match(EDIF300Parser.Tokens.T__226.rawValue)
		 	setState(3635)
		 	try integerExpression()
		 	setState(3636)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexStepDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_indexStepDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIndexStepDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIndexStepDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIndexStepDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIndexStepDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func indexStepDisplay() throws -> IndexStepDisplayContext {
		var _localctx: IndexStepDisplayContext = IndexStepDisplayContext(_ctx, getState())
		try enterRule(_localctx, 586, EDIF300Parser.RULE_indexStepDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3638)
		 	try match(EDIF300Parser.Tokens.T__227.rawValue)
		 	setState(3642)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(3639)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(3640)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(3641)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3644)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexValueContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_indexValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIndexValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIndexValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIndexValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIndexValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func indexValue() throws -> IndexValueContext {
		var _localctx: IndexValueContext = IndexValueContext(_ctx, getState())
		try enterRule(_localctx, 588, EDIF300Parser.RULE_indexValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3646)
		 	try match(EDIF300Parser.Tokens.T__228.rawValue)
		 	setState(3647)
		 	try integerToken()
		 	setState(3648)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InputContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_input
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInput(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInput(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInput(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInput(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func input() throws -> InputContext {
		var _localctx: InputContext = InputContext(_ctx, getState())
		try enterRule(_localctx, 590, EDIF300Parser.RULE_input)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3650)
		 	try match(EDIF300Parser.Tokens.T__229.rawValue)
		 	setState(3651)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InputPortContext: ParserRuleContext {
			open
			func inputPortAttributes() -> InputPortAttributesContext? {
				return getRuleContext(InputPortAttributesContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_inputPort
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInputPort(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInputPort(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInputPort(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInputPort(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inputPort() throws -> InputPortContext {
		var _localctx: InputPortContext = InputPortContext(_ctx, getState())
		try enterRule(_localctx, 592, EDIF300Parser.RULE_inputPort)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3653)
		 	try match(EDIF300Parser.Tokens.T__230.rawValue)
		 	setState(3655)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__231.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3654)
		 		try inputPortAttributes()

		 	}

		 	setState(3657)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InputPortAttributesContext: ParserRuleContext {
			open
			func dcFanOutLoad() -> [DcFanOutLoadContext] {
				return getRuleContexts(DcFanOutLoadContext.self)
			}
			open
			func dcFanOutLoad(_ i: Int) -> DcFanOutLoadContext? {
				return getRuleContext(DcFanOutLoadContext.self, i)
			}
			open
			func dcMaxFanIn() -> [DcMaxFanInContext] {
				return getRuleContexts(DcMaxFanInContext.self)
			}
			open
			func dcMaxFanIn(_ i: Int) -> DcMaxFanInContext? {
				return getRuleContext(DcMaxFanInContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_inputPortAttributes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInputPortAttributes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInputPortAttributes(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInputPortAttributes(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInputPortAttributes(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func inputPortAttributes() throws -> InputPortAttributesContext {
		var _localctx: InputPortAttributesContext = InputPortAttributesContext(_ctx, getState())
		try enterRule(_localctx, 594, EDIF300Parser.RULE_inputPortAttributes)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3659)
		 	try match(EDIF300Parser.Tokens.T__231.rawValue)
		 	setState(3664)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__105.rawValue || _la == EDIF300Parser.Tokens.T__107.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3662)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__105:
		 			setState(3660)
		 			try dcFanOutLoad()

		 			break

		 		case .T__107:
		 			setState(3661)
		 			try dcMaxFanIn()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3666)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3667)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceContext: ParserRuleContext {
			open
			func instanceNameDef() -> InstanceNameDefContext? {
				return getRuleContext(InstanceNameDefContext.self, 0)
			}
			open
			func clusterRef() -> ClusterRefContext? {
				return getRuleContext(ClusterRefContext.self, 0)
			}
			open
			func booleanParameterAssign() -> [BooleanParameterAssignContext] {
				return getRuleContexts(BooleanParameterAssignContext.self)
			}
			open
			func booleanParameterAssign(_ i: Int) -> BooleanParameterAssignContext? {
				return getRuleContext(BooleanParameterAssignContext.self, i)
			}
			open
			func cellPropertyOverride() -> [CellPropertyOverrideContext] {
				return getRuleContexts(CellPropertyOverrideContext.self)
			}
			open
			func cellPropertyOverride(_ i: Int) -> CellPropertyOverrideContext? {
				return getRuleContext(CellPropertyOverrideContext.self, i)
			}
			open
			func clusterPropertyOverride() -> [ClusterPropertyOverrideContext] {
				return getRuleContexts(ClusterPropertyOverrideContext.self)
			}
			open
			func clusterPropertyOverride(_ i: Int) -> ClusterPropertyOverrideContext? {
				return getRuleContext(ClusterPropertyOverrideContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func designator() -> [DesignatorContext] {
				return getRuleContexts(DesignatorContext.self)
			}
			open
			func designator(_ i: Int) -> DesignatorContext? {
				return getRuleContext(DesignatorContext.self, i)
			}
			open
			func instanceNameGenerator() -> [InstanceNameGeneratorContext] {
				return getRuleContexts(InstanceNameGeneratorContext.self)
			}
			open
			func instanceNameGenerator(_ i: Int) -> InstanceNameGeneratorContext? {
				return getRuleContext(InstanceNameGeneratorContext.self, i)
			}
			open
			func instancePortAttributes() -> [InstancePortAttributesContext] {
				return getRuleContexts(InstancePortAttributesContext.self)
			}
			open
			func instancePortAttributes(_ i: Int) -> InstancePortAttributesContext? {
				return getRuleContext(InstancePortAttributesContext.self, i)
			}
			open
			func instanceWidth() -> [InstanceWidthContext] {
				return getRuleContexts(InstanceWidthContext.self)
			}
			open
			func instanceWidth(_ i: Int) -> InstanceWidthContext? {
				return getRuleContext(InstanceWidthContext.self, i)
			}
			open
			func integerParameterAssign() -> [IntegerParameterAssignContext] {
				return getRuleContexts(IntegerParameterAssignContext.self)
			}
			open
			func integerParameterAssign(_ i: Int) -> IntegerParameterAssignContext? {
				return getRuleContext(IntegerParameterAssignContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func numberParameterAssign() -> [NumberParameterAssignContext] {
				return getRuleContexts(NumberParameterAssignContext.self)
			}
			open
			func numberParameterAssign(_ i: Int) -> NumberParameterAssignContext? {
				return getRuleContext(NumberParameterAssignContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func stringParameterAssign() -> [StringParameterAssignContext] {
				return getRuleContexts(StringParameterAssignContext.self)
			}
			open
			func stringParameterAssign(_ i: Int) -> StringParameterAssignContext? {
				return getRuleContext(StringParameterAssignContext.self, i)
			}
			open
			func timing() -> [TimingContext] {
				return getRuleContexts(TimingContext.self)
			}
			open
			func timing(_ i: Int) -> TimingContext? {
				return getRuleContext(TimingContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instance
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstance(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstance(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstance(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstance(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instance() throws -> InstanceContext {
		var _localctx: InstanceContext = InstanceContext(_ctx, getState())
		try enterRule(_localctx, 596, EDIF300Parser.RULE_instance)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3669)
		 	try match(EDIF300Parser.Tokens.T__232.rawValue)
		 	setState(3670)
		 	try instanceNameDef()
		 	setState(3671)
		 	try clusterRef()
		 	setState(3689)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__28.rawValue,EDIF300Parser.Tokens.T__42.rawValue,EDIF300Parser.Tokens.T__58.rawValue,EDIF300Parser.Tokens.T__61.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__118.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__238.rawValue,EDIF300Parser.Tokens.T__241.rawValue,EDIF300Parser.Tokens.T__245.rawValue,EDIF300Parser.Tokens.T__252.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 239)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue || _la == EDIF300Parser.Tokens.T__358.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__606.rawValue,EDIF300Parser.Tokens.T__619.rawValue,EDIF300Parser.Tokens.T__642.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 607)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(3687)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__28:
		 			setState(3672)
		 			try booleanParameterAssign()

		 			break

		 		case .T__42:
		 			setState(3673)
		 			try cellPropertyOverride()

		 			break

		 		case .T__58:
		 			setState(3674)
		 			try clusterPropertyOverride()

		 			break

		 		case .T__61:
		 			setState(3675)
		 			try comment()

		 			break

		 		case .T__118:
		 			setState(3676)
		 			try designator()

		 			break

		 		case .T__238:
		 			setState(3677)
		 			try instanceNameGenerator()

		 			break

		 		case .T__241:
		 			setState(3678)
		 			try instancePortAttributes()

		 			break

		 		case .T__245:
		 			setState(3679)
		 			try instanceWidth()

		 			break

		 		case .T__252:
		 			setState(3680)
		 			try integerParameterAssign()

		 			break

		 		case .T__346:
		 			setState(3681)
		 			try nameInformation()

		 			break

		 		case .T__358:
		 			setState(3682)
		 			try numberParameterAssign()

		 			break

		 		case .T__442:
		 			setState(3683)
		 			try property()

		 			break

		 		case .T__606:
		 			setState(3684)
		 			try stringParameterAssign()

		 			break

		 		case .T__619:
		 			setState(3685)
		 			try timing()

		 			break

		 		case .T__642:
		 			setState(3686)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3691)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3692)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceConfigurationContext: ParserRuleContext {
			open
			func instanceNameRef() -> InstanceNameRefContext? {
				return getRuleContext(InstanceNameRefContext.self, 0)
			}
			open
			func clusterConfigurationRef() -> ClusterConfigurationRefContext? {
				return getRuleContext(ClusterConfigurationRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceConfiguration
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceConfiguration(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceConfiguration(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceConfiguration(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceConfiguration(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceConfiguration() throws -> InstanceConfigurationContext {
		var _localctx: InstanceConfigurationContext = InstanceConfigurationContext(_ctx, getState())
		try enterRule(_localctx, 598, EDIF300Parser.RULE_instanceConfiguration)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3694)
		 	try match(EDIF300Parser.Tokens.T__233.rawValue)
		 	setState(3695)
		 	try instanceNameRef()
		 	setState(3696)
		 	try clusterConfigurationRef()
		 	setState(3697)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceIndexValueContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceIndexValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceIndexValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceIndexValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceIndexValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceIndexValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceIndexValue() throws -> InstanceIndexValueContext {
		var _localctx: InstanceIndexValueContext = InstanceIndexValueContext(_ctx, getState())
		try enterRule(_localctx, 600, EDIF300Parser.RULE_instanceIndexValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3699)
		 	try match(EDIF300Parser.Tokens.T__234.rawValue)
		 	setState(3700)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceMemberRefContext: ParserRuleContext {
			open
			func instanceNameRef() -> InstanceNameRefContext? {
				return getRuleContext(InstanceNameRefContext.self, 0)
			}
			open
			func indexValue() -> IndexValueContext? {
				return getRuleContext(IndexValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceMemberRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceMemberRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceMemberRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceMemberRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceMemberRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceMemberRef() throws -> InstanceMemberRefContext {
		var _localctx: InstanceMemberRefContext = InstanceMemberRefContext(_ctx, getState())
		try enterRule(_localctx, 602, EDIF300Parser.RULE_instanceMemberRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3702)
		 	try match(EDIF300Parser.Tokens.T__235.rawValue)
		 	setState(3703)
		 	try instanceNameRef()
		 	setState(3704)
		 	try indexValue()
		 	setState(3705)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceNameCaseSensitive() throws -> InstanceNameCaseSensitiveContext {
		var _localctx: InstanceNameCaseSensitiveContext = InstanceNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 604, EDIF300Parser.RULE_instanceNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3707)
		 	try match(EDIF300Parser.Tokens.T__236.rawValue)
		 	setState(3708)
		 	try booleanToken()
		 	setState(3709)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceNameDef() throws -> InstanceNameDefContext {
		var _localctx: InstanceNameDefContext = InstanceNameDefContext(_ctx, getState())
		try enterRule(_localctx, 606, EDIF300Parser.RULE_instanceNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3711)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceNameDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func displayNameOverride() -> [DisplayNameOverrideContext] {
				return getRuleContexts(DisplayNameOverrideContext.self)
			}
			open
			func displayNameOverride(_ i: Int) -> DisplayNameOverrideContext? {
				return getRuleContext(DisplayNameOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceNameDisplay() throws -> InstanceNameDisplayContext {
		var _localctx: InstanceNameDisplayContext = InstanceNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 608, EDIF300Parser.RULE_instanceNameDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3713)
		 	try match(EDIF300Parser.Tokens.T__237.rawValue)
		 	setState(3718)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue || _la == EDIF300Parser.Tokens.T__131.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3716)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(3714)
		 			try display()

		 			break

		 		case .T__131:
		 			setState(3715)
		 			try displayNameOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3720)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3721)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceNameGeneratorContext: ParserRuleContext {
			open
			func stringExpression() -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceNameGenerator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceNameGenerator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceNameGenerator(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceNameGenerator(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceNameGenerator(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceNameGenerator() throws -> InstanceNameGeneratorContext {
		var _localctx: InstanceNameGeneratorContext = InstanceNameGeneratorContext(_ctx, getState())
		try enterRule(_localctx, 610, EDIF300Parser.RULE_instanceNameGenerator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3723)
		 	try match(EDIF300Parser.Tokens.T__238.rawValue)
		 	setState(3724)
		 	try stringExpression()
		 	setState(3725)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceNameGeneratorDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceNameGeneratorDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceNameGeneratorDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceNameGeneratorDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceNameGeneratorDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceNameGeneratorDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceNameGeneratorDisplay() throws -> InstanceNameGeneratorDisplayContext {
		var _localctx: InstanceNameGeneratorDisplayContext = InstanceNameGeneratorDisplayContext(_ctx, getState())
		try enterRule(_localctx, 612, EDIF300Parser.RULE_instanceNameGeneratorDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3727)
		 	try match(EDIF300Parser.Tokens.T__239.rawValue)
		 	setState(3731)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(3728)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(3729)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(3730)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3733)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceNameRef() throws -> InstanceNameRefContext {
		var _localctx: InstanceNameRefContext = InstanceNameRefContext(_ctx, getState())
		try enterRule(_localctx, 614, EDIF300Parser.RULE_instanceNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3735)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstancePortAttributeDisplayContext: ParserRuleContext {
			open
			func symbolPortImplementationNameRef() -> SymbolPortImplementationNameRefContext? {
				return getRuleContext(SymbolPortImplementationNameRefContext.self, 0)
			}
			open
			func portRef() -> PortRefContext? {
				return getRuleContext(PortRefContext.self, 0)
			}
			open
			func portPropertyDisplayOverride() -> [PortPropertyDisplayOverrideContext] {
				return getRuleContexts(PortPropertyDisplayOverrideContext.self)
			}
			open
			func portPropertyDisplayOverride(_ i: Int) -> PortPropertyDisplayOverrideContext? {
				return getRuleContext(PortPropertyDisplayOverrideContext.self, i)
			}
			open
			func portAttributeDisplay() -> [PortAttributeDisplayContext] {
				return getRuleContexts(PortAttributeDisplayContext.self)
			}
			open
			func portAttributeDisplay(_ i: Int) -> PortAttributeDisplayContext? {
				return getRuleContext(PortAttributeDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instancePortAttributeDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstancePortAttributeDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstancePortAttributeDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstancePortAttributeDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstancePortAttributeDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instancePortAttributeDisplay() throws -> InstancePortAttributeDisplayContext {
		var _localctx: InstancePortAttributeDisplayContext = InstancePortAttributeDisplayContext(_ctx, getState())
		try enterRule(_localctx, 616, EDIF300Parser.RULE_instancePortAttributeDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3737)
		 	try match(EDIF300Parser.Tokens.T__240.rawValue)
		 	setState(3738)
		 	try symbolPortImplementationNameRef()
		 	setState(3739)
		 	try portRef()
		 	setState(3744)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__416.rawValue || _la == EDIF300Parser.Tokens.T__434.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3742)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__434:
		 			setState(3740)
		 			try portPropertyDisplayOverride()

		 			break

		 		case .T__416:
		 			setState(3741)
		 			try portAttributeDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3746)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3747)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstancePortAttributesContext: ParserRuleContext {
			open
			func extendPortDef() -> ExtendPortDefContext? {
				return getRuleContext(ExtendPortDefContext.self, 0)
			}
			open
			func acLoad() -> [AcLoadContext] {
				return getRuleContexts(AcLoadContext.self)
			}
			open
			func acLoad(_ i: Int) -> AcLoadContext? {
				return getRuleContext(AcLoadContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func connectedSignalIndexGenerator() -> [ConnectedSignalIndexGeneratorContext] {
				return getRuleContexts(ConnectedSignalIndexGeneratorContext.self)
			}
			open
			func connectedSignalIndexGenerator(_ i: Int) -> ConnectedSignalIndexGeneratorContext? {
				return getRuleContext(ConnectedSignalIndexGeneratorContext.self, i)
			}
			open
			func designator() -> [DesignatorContext] {
				return getRuleContexts(DesignatorContext.self)
			}
			open
			func designator(_ i: Int) -> DesignatorContext? {
				return getRuleContext(DesignatorContext.self, i)
			}
			open
			func directionalPortAttributeOverride() -> [DirectionalPortAttributeOverrideContext] {
				return getRuleContexts(DirectionalPortAttributeOverrideContext.self)
			}
			open
			func directionalPortAttributeOverride(_ i: Int) -> DirectionalPortAttributeOverrideContext? {
				return getRuleContext(DirectionalPortAttributeOverrideContext.self, i)
			}
			open
			func portDelay() -> [PortDelayContext] {
				return getRuleContexts(PortDelayContext.self)
			}
			open
			func portDelay(_ i: Int) -> PortDelayContext? {
				return getRuleContext(PortDelayContext.self, i)
			}
			open
			func portDelayOverride() -> [PortDelayOverrideContext] {
				return getRuleContexts(PortDelayOverrideContext.self)
			}
			open
			func portDelayOverride(_ i: Int) -> PortDelayOverrideContext? {
				return getRuleContext(PortDelayOverrideContext.self, i)
			}
			open
			func portLoadDelay() -> [PortLoadDelayContext] {
				return getRuleContexts(PortLoadDelayContext.self)
			}
			open
			func portLoadDelay(_ i: Int) -> PortLoadDelayContext? {
				return getRuleContext(PortLoadDelayContext.self, i)
			}
			open
			func portLoadDelayOverride() -> [PortLoadDelayOverrideContext] {
				return getRuleContexts(PortLoadDelayOverrideContext.self)
			}
			open
			func portLoadDelayOverride(_ i: Int) -> PortLoadDelayOverrideContext? {
				return getRuleContext(PortLoadDelayOverrideContext.self, i)
			}
			open
			func portPropertyOverride() -> [PortPropertyOverrideContext] {
				return getRuleContexts(PortPropertyOverrideContext.self)
			}
			open
			func portPropertyOverride(_ i: Int) -> PortPropertyOverrideContext? {
				return getRuleContext(PortPropertyOverrideContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func unused() -> [UnusedContext] {
				return getRuleContexts(UnusedContext.self)
			}
			open
			func unused(_ i: Int) -> UnusedContext? {
				return getRuleContext(UnusedContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instancePortAttributes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstancePortAttributes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstancePortAttributes(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstancePortAttributes(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstancePortAttributes(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instancePortAttributes() throws -> InstancePortAttributesContext {
		var _localctx: InstancePortAttributesContext = InstancePortAttributesContext(_ctx, getState())
		try enterRule(_localctx, 618, EDIF300Parser.RULE_instancePortAttributes)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3749)
		 	try match(EDIF300Parser.Tokens.T__241.rawValue)
		 	setState(3750)
		 	try extendPortDef()
		 	setState(3765)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__2.rawValue || _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__72.rawValue,EDIF300Parser.Tokens.T__118.rawValue,EDIF300Parser.Tokens.T__127.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 73)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__418.rawValue,EDIF300Parser.Tokens.T__420.rawValue,EDIF300Parser.Tokens.T__425.rawValue,EDIF300Parser.Tokens.T__427.rawValue,EDIF300Parser.Tokens.T__435.rawValue,EDIF300Parser.Tokens.T__442.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 419)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__640.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3763)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__2:
		 			setState(3751)
		 			try acLoad()

		 			break

		 		case .T__61:
		 			setState(3752)
		 			try comment()

		 			break

		 		case .T__72:
		 			setState(3753)
		 			try connectedSignalIndexGenerator()

		 			break

		 		case .T__118:
		 			setState(3754)
		 			try designator()

		 			break

		 		case .T__127:
		 			setState(3755)
		 			try directionalPortAttributeOverride()

		 			break

		 		case .T__418:
		 			setState(3756)
		 			try portDelay()

		 			break

		 		case .T__420:
		 			setState(3757)
		 			try portDelayOverride()

		 			break

		 		case .T__425:
		 			setState(3758)
		 			try portLoadDelay()

		 			break

		 		case .T__427:
		 			setState(3759)
		 			try portLoadDelayOverride()

		 			break

		 		case .T__435:
		 			setState(3760)
		 			try portPropertyOverride()

		 			break

		 		case .T__442:
		 			setState(3761)
		 			try property()

		 			break

		 		case .T__640:
		 			setState(3762)
		 			try unused()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3767)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3768)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstancePropertyDisplayContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func propertyNameDisplay() -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instancePropertyDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstancePropertyDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstancePropertyDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstancePropertyDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstancePropertyDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instancePropertyDisplay() throws -> InstancePropertyDisplayContext {
		var _localctx: InstancePropertyDisplayContext = InstancePropertyDisplayContext(_ctx, getState())
		try enterRule(_localctx, 620, EDIF300Parser.RULE_instancePropertyDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3770)
		 	try match(EDIF300Parser.Tokens.T__242.rawValue)
		 	setState(3771)
		 	try propertyNameRef()
		 	setState(3775)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,212,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3772)
		 			try display()

		 	 
		 		}
		 		setState(3777)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,212,_ctx)
		 	}
		 	setState(3779)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3778)
		 		try propertyNameDisplay()

		 	}

		 	setState(3784)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3781)
		 		try display()


		 		setState(3786)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3787)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstancePropertyOverrideContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func typedValue() -> TypedValueContext? {
				return getRuleContext(TypedValueContext.self, 0)
			}
			open
			func untyped() -> UntypedContext? {
				return getRuleContext(UntypedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func fixed() -> [FixedContext] {
				return getRuleContexts(FixedContext.self)
			}
			open
			func fixed(_ i: Int) -> FixedContext? {
				return getRuleContext(FixedContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instancePropertyOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstancePropertyOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstancePropertyOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstancePropertyOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstancePropertyOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instancePropertyOverride() throws -> InstancePropertyOverrideContext {
		var _localctx: InstancePropertyOverrideContext = InstancePropertyOverrideContext(_ctx, getState())
		try enterRule(_localctx, 622, EDIF300Parser.RULE_instancePropertyOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3789)
		 	try match(EDIF300Parser.Tokens.T__243.rawValue)
		 	setState(3790)
		 	try propertyNameRef()
		 	setState(3793)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__23:fallthrough
		 	case .T__247:fallthrough
		 	case .T__336:fallthrough
		 	case .T__356:fallthrough
		 	case .T__411:fallthrough
		 	case .T__599:
		 		setState(3791)
		 		try typedValue()

		 		break

		 	case .T__639:
		 		setState(3792)
		 		try untyped()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3800)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__165.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3798)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(3795)
		 			try comment()

		 			break

		 		case .T__165:
		 			setState(3796)
		 			try fixed()

		 			break

		 		case .T__448:
		 			setState(3797)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3802)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3803)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceRefContext: ParserRuleContext {
			open
			func instanceNameRef() -> InstanceNameRefContext? {
				return getRuleContext(InstanceNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceRef() throws -> InstanceRefContext {
		var _localctx: InstanceRefContext = InstanceRefContext(_ctx, getState())
		try enterRule(_localctx, 624, EDIF300Parser.RULE_instanceRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3805)
		 	try match(EDIF300Parser.Tokens.T__244.rawValue)
		 	setState(3806)
		 	try instanceNameRef()
		 	setState(3807)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceWidthContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceWidth
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceWidth(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceWidth(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceWidth(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceWidth(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceWidth() throws -> InstanceWidthContext {
		var _localctx: InstanceWidthContext = InstanceWidthContext(_ctx, getState())
		try enterRule(_localctx, 626, EDIF300Parser.RULE_instanceWidth)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3809)
		 	try match(EDIF300Parser.Tokens.T__245.rawValue)
		 	setState(3810)
		 	try integerExpression()
		 	setState(3811)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstanceWidthDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_instanceWidthDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInstanceWidthDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInstanceWidthDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInstanceWidthDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInstanceWidthDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func instanceWidthDisplay() throws -> InstanceWidthDisplayContext {
		var _localctx: InstanceWidthDisplayContext = InstanceWidthDisplayContext(_ctx, getState())
		try enterRule(_localctx, 628, EDIF300Parser.RULE_instanceWidthDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3813)
		 	try match(EDIF300Parser.Tokens.T__246.rawValue)
		 	setState(3817)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(3814)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(3815)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(3816)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3819)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integer
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInteger(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInteger(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInteger(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInteger(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integer() throws -> IntegerContext {
		var _localctx: IntegerContext = IntegerContext(_ctx, getState())
		try enterRule(_localctx, 630, EDIF300Parser.RULE_integer)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3821)
		 	try match(EDIF300Parser.Tokens.T__247.rawValue)
		 	setState(3822)
		 	try integerExpression()
		 	setState(3823)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerConstantContext: ParserRuleContext {
			open
			func constantNameDef() -> ConstantNameDefContext? {
				return getRuleContext(ConstantNameDefContext.self, 0)
			}
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerConstant
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerConstant(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerConstant(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerConstant(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerConstant(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerConstant() throws -> IntegerConstantContext {
		var _localctx: IntegerConstantContext = IntegerConstantContext(_ctx, getState())
		try enterRule(_localctx, 632, EDIF300Parser.RULE_integerConstant)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3825)
		 	try match(EDIF300Parser.Tokens.T__248.rawValue)
		 	setState(3826)
		 	try constantNameDef()
		 	setState(3827)
		 	try integerToken()
		 	setState(3828)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerConstantRefContext: ParserRuleContext {
			open
			func constantNameRef() -> ConstantNameRefContext? {
				return getRuleContext(ConstantNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerConstantRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerConstantRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerConstantRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerConstantRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerConstantRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerConstantRef() throws -> IntegerConstantRefContext {
		var _localctx: IntegerConstantRefContext = IntegerConstantRefContext(_ctx, getState())
		try enterRule(_localctx, 634, EDIF300Parser.RULE_integerConstantRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3830)
		 	try match(EDIF300Parser.Tokens.T__249.rawValue)
		 	setState(3831)
		 	try constantNameRef()
		 	setState(3832)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerEqualContext: ParserRuleContext {
			open
			func firstIntegerExpression() -> FirstIntegerExpressionContext? {
				return getRuleContext(FirstIntegerExpressionContext.self, 0)
			}
			open
			func secondIntegerExpression() -> SecondIntegerExpressionContext? {
				return getRuleContext(SecondIntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerEqual
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerEqual(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerEqual(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerEqual(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerEqual(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerEqual() throws -> IntegerEqualContext {
		var _localctx: IntegerEqualContext = IntegerEqualContext(_ctx, getState())
		try enterRule(_localctx, 636, EDIF300Parser.RULE_integerEqual)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3834)
		 	try match(EDIF300Parser.Tokens.T__250.rawValue)
		 	setState(3835)
		 	try firstIntegerExpression()
		 	setState(3836)
		 	try secondIntegerExpression()
		 	setState(3837)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerExpressionContext: ParserRuleContext {
			open
			func integerParameterRef() -> IntegerParameterRefContext? {
				return getRuleContext(IntegerParameterRefContext.self, 0)
			}
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
			open
			func integerProduct() -> IntegerProductContext? {
				return getRuleContext(IntegerProductContext.self, 0)
			}
			open
			func integerSubtract() -> IntegerSubtractContext? {
				return getRuleContext(IntegerSubtractContext.self, 0)
			}
			open
			func integerSum() -> IntegerSumContext? {
				return getRuleContext(IntegerSumContext.self, 0)
			}
			open
			func integerRemainder() -> IntegerRemainderContext? {
				return getRuleContext(IntegerRemainderContext.self, 0)
			}
			open
			func integerQuotient() -> IntegerQuotientContext? {
				return getRuleContext(IntegerQuotientContext.self, 0)
			}
			open
			func stringLength() -> StringLengthContext? {
				return getRuleContext(StringLengthContext.self, 0)
			}
			open
			func integerConstantRef() -> IntegerConstantRefContext? {
				return getRuleContext(IntegerConstantRefContext.self, 0)
			}
			open
			func forFrameIndexRef() -> ForFrameIndexRefContext? {
				return getRuleContext(ForFrameIndexRefContext.self, 0)
			}
			open
			func portIndexValue() -> PortIndexValueContext? {
				return getRuleContext(PortIndexValueContext.self, 0)
			}
			open
			func signalIndexValue() -> SignalIndexValueContext? {
				return getRuleContext(SignalIndexValueContext.self, 0)
			}
			open
			func absolute() -> AbsoluteContext? {
				return getRuleContext(AbsoluteContext.self, 0)
			}
			open
			func instanceIndexValue() -> InstanceIndexValueContext? {
				return getRuleContext(InstanceIndexValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerExpression(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerExpression(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerExpression(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerExpression() throws -> IntegerExpressionContext {
		var _localctx: IntegerExpressionContext = IntegerExpressionContext(_ctx, getState())
		try enterRule(_localctx, 638, EDIF300Parser.RULE_integerExpression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3853)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__253:
		 		setState(3839)
		 		try integerParameterRef()

		 		break

		 	case .DECIMAL_LITERAL:
		 		setState(3840)
		 		try integerToken()

		 		break

		 	case .T__254:
		 		setState(3841)
		 		try integerProduct()

		 		break

		 	case .T__257:
		 		setState(3842)
		 		try integerSubtract()

		 		break

		 	case .T__258:
		 		setState(3843)
		 		try integerSum()

		 		break

		 	case .T__256:
		 		setState(3844)
		 		try integerRemainder()

		 		break

		 	case .T__255:
		 		setState(3845)
		 		try integerQuotient()

		 		break

		 	case .T__604:
		 		setState(3846)
		 		try stringLength()

		 		break

		 	case .T__249:
		 		setState(3847)
		 		try integerConstantRef()

		 		break

		 	case .T__181:
		 		setState(3848)
		 		try forFrameIndexRef()

		 		break

		 	case .T__421:
		 		setState(3849)
		 		try portIndexValue()

		 		break

		 	case .T__590:
		 		setState(3850)
		 		try signalIndexValue()

		 		break

		 	case .T__0:
		 		setState(3851)
		 		try absolute()

		 		break

		 	case .T__234:
		 		setState(3852)
		 		try instanceIndexValue()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerParameterContext: ParserRuleContext {
			open
			func parameterNameDef() -> ParameterNameDefContext? {
				return getRuleContext(ParameterNameDefContext.self, 0)
			}
			open
			func integer() -> [IntegerContext] {
				return getRuleContexts(IntegerContext.self)
			}
			open
			func integer(_ i: Int) -> IntegerContext? {
				return getRuleContext(IntegerContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerParameter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerParameter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerParameter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerParameter(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerParameter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerParameter() throws -> IntegerParameterContext {
		var _localctx: IntegerParameterContext = IntegerParameterContext(_ctx, getState())
		try enterRule(_localctx, 640, EDIF300Parser.RULE_integerParameter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3855)
		 	try match(EDIF300Parser.Tokens.T__251.rawValue)
		 	setState(3856)
		 	try parameterNameDef()
		 	setState(3861)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__247.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3859)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__247:
		 			setState(3857)
		 			try integer()

		 			break

		 		case .T__346:
		 			setState(3858)
		 			try nameInformation()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3863)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3864)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerParameterAssignContext: ParserRuleContext {
			open
			func parameterNameRef() -> ParameterNameRefContext? {
				return getRuleContext(ParameterNameRefContext.self, 0)
			}
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerParameterAssign
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerParameterAssign(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerParameterAssign(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerParameterAssign(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerParameterAssign(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerParameterAssign() throws -> IntegerParameterAssignContext {
		var _localctx: IntegerParameterAssignContext = IntegerParameterAssignContext(_ctx, getState())
		try enterRule(_localctx, 642, EDIF300Parser.RULE_integerParameterAssign)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3866)
		 	try match(EDIF300Parser.Tokens.T__252.rawValue)
		 	setState(3867)
		 	try parameterNameRef()
		 	setState(3868)
		 	try integerExpression()
		 	setState(3869)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerParameterRefContext: ParserRuleContext {
			open
			func parameterNameRef() -> ParameterNameRefContext? {
				return getRuleContext(ParameterNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerParameterRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerParameterRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerParameterRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerParameterRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerParameterRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerParameterRef() throws -> IntegerParameterRefContext {
		var _localctx: IntegerParameterRefContext = IntegerParameterRefContext(_ctx, getState())
		try enterRule(_localctx, 644, EDIF300Parser.RULE_integerParameterRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3871)
		 	try match(EDIF300Parser.Tokens.T__253.rawValue)
		 	setState(3872)
		 	try parameterNameRef()
		 	setState(3873)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerProductContext: ParserRuleContext {
			open
			func integerExpression() -> [IntegerExpressionContext] {
				return getRuleContexts(IntegerExpressionContext.self)
			}
			open
			func integerExpression(_ i: Int) -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerProduct
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerProduct(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerProduct(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerProduct(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerProduct(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerProduct() throws -> IntegerProductContext {
		var _localctx: IntegerProductContext = IntegerProductContext(_ctx, getState())
		try enterRule(_localctx, 646, EDIF300Parser.RULE_integerProduct)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3875)
		 	try match(EDIF300Parser.Tokens.T__254.rawValue)
		 	setState(3879)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__0.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__181.rawValue || _la == EDIF300Parser.Tokens.T__234.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__249.rawValue,EDIF300Parser.Tokens.T__253.rawValue,EDIF300Parser.Tokens.T__254.rawValue,EDIF300Parser.Tokens.T__255.rawValue,EDIF300Parser.Tokens.T__256.rawValue,EDIF300Parser.Tokens.T__257.rawValue,EDIF300Parser.Tokens.T__258.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 250)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__421.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__590.rawValue || _la == EDIF300Parser.Tokens.T__604.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.DECIMAL_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3876)
		 		try integerExpression()


		 		setState(3881)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3882)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerQuotientContext: ParserRuleContext {
			open
			func dividend() -> DividendContext? {
				return getRuleContext(DividendContext.self, 0)
			}
			open
			func divisor() -> DivisorContext? {
				return getRuleContext(DivisorContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerQuotient
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerQuotient(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerQuotient(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerQuotient(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerQuotient(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerQuotient() throws -> IntegerQuotientContext {
		var _localctx: IntegerQuotientContext = IntegerQuotientContext(_ctx, getState())
		try enterRule(_localctx, 648, EDIF300Parser.RULE_integerQuotient)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3884)
		 	try match(EDIF300Parser.Tokens.T__255.rawValue)
		 	setState(3885)
		 	try dividend()
		 	setState(3886)
		 	try divisor()
		 	setState(3887)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerRemainderContext: ParserRuleContext {
			open
			func dividend() -> DividendContext? {
				return getRuleContext(DividendContext.self, 0)
			}
			open
			func divisor() -> DivisorContext? {
				return getRuleContext(DivisorContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerRemainder
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerRemainder(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerRemainder(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerRemainder(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerRemainder(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerRemainder() throws -> IntegerRemainderContext {
		var _localctx: IntegerRemainderContext = IntegerRemainderContext(_ctx, getState())
		try enterRule(_localctx, 650, EDIF300Parser.RULE_integerRemainder)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3889)
		 	try match(EDIF300Parser.Tokens.T__256.rawValue)
		 	setState(3890)
		 	try dividend()
		 	setState(3891)
		 	try divisor()
		 	setState(3892)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerSubtractContext: ParserRuleContext {
			open
			func minuend() -> MinuendContext? {
				return getRuleContext(MinuendContext.self, 0)
			}
			open
			func subtrahend() -> SubtrahendContext? {
				return getRuleContext(SubtrahendContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerSubtract
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerSubtract(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerSubtract(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerSubtract(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerSubtract(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerSubtract() throws -> IntegerSubtractContext {
		var _localctx: IntegerSubtractContext = IntegerSubtractContext(_ctx, getState())
		try enterRule(_localctx, 652, EDIF300Parser.RULE_integerSubtract)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3894)
		 	try match(EDIF300Parser.Tokens.T__257.rawValue)
		 	setState(3895)
		 	try minuend()
		 	setState(3896)
		 	try subtrahend()
		 	setState(3897)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerSumContext: ParserRuleContext {
			open
			func integerExpression() -> [IntegerExpressionContext] {
				return getRuleContexts(IntegerExpressionContext.self)
			}
			open
			func integerExpression(_ i: Int) -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerSum
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerSum(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerSum(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerSum(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerSum(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerSum() throws -> IntegerSumContext {
		var _localctx: IntegerSumContext = IntegerSumContext(_ctx, getState())
		try enterRule(_localctx, 654, EDIF300Parser.RULE_integerSum)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3899)
		 	try match(EDIF300Parser.Tokens.T__258.rawValue)
		 	setState(3903)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__0.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__181.rawValue || _la == EDIF300Parser.Tokens.T__234.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__249.rawValue,EDIF300Parser.Tokens.T__253.rawValue,EDIF300Parser.Tokens.T__254.rawValue,EDIF300Parser.Tokens.T__255.rawValue,EDIF300Parser.Tokens.T__256.rawValue,EDIF300Parser.Tokens.T__257.rawValue,EDIF300Parser.Tokens.T__258.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 250)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__421.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__590.rawValue || _la == EDIF300Parser.Tokens.T__604.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.DECIMAL_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3900)
		 		try integerExpression()


		 		setState(3905)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3906)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerValueContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerValue() throws -> IntegerValueContext {
		var _localctx: IntegerValueContext = IntegerValueContext(_ctx, getState())
		try enterRule(_localctx, 656, EDIF300Parser.RULE_integerValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3908)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectAnnotateContext: ParserRuleContext {
			open
			func extendInterconnectDef() -> ExtendInterconnectDefContext? {
				return getRuleContext(ExtendInterconnectDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func interconnectAnnotate() -> [InterconnectAnnotateContext] {
				return getRuleContexts(InterconnectAnnotateContext.self)
			}
			open
			func interconnectAnnotate(_ i: Int) -> InterconnectAnnotateContext? {
				return getRuleContext(InterconnectAnnotateContext.self, i)
			}
			open
			func criticality() -> [CriticalityContext] {
				return getRuleContexts(CriticalityContext.self)
			}
			open
			func criticality(_ i: Int) -> CriticalityContext? {
				return getRuleContext(CriticalityContext.self, i)
			}
			open
			func interconnectDelay() -> [InterconnectDelayContext] {
				return getRuleContexts(InterconnectDelayContext.self)
			}
			open
			func interconnectDelay(_ i: Int) -> InterconnectDelayContext? {
				return getRuleContext(InterconnectDelayContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectAnnotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectAnnotate() throws -> InterconnectAnnotateContext {
		var _localctx: InterconnectAnnotateContext = InterconnectAnnotateContext(_ctx, getState())
		try enterRule(_localctx, 658, EDIF300Parser.RULE_interconnectAnnotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3910)
		 	try match(EDIF300Parser.Tokens.T__259.rawValue)
		 	setState(3911)
		 	try extendInterconnectDef()
		 	setState(3920)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue || _la == EDIF300Parser.Tokens.T__97.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__259.rawValue || _la == EDIF300Parser.Tokens.T__261.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3918)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(3912)
		 			try comment()

		 			break

		 		case .T__259:
		 			setState(3913)
		 			try interconnectAnnotate()

		 			break

		 		case .T__97:
		 			setState(3914)
		 			try criticality()

		 			break

		 		case .T__261:
		 			setState(3915)
		 			try interconnectDelay()

		 			break

		 		case .T__442:
		 			setState(3916)
		 			try property()

		 			break

		 		case .T__448:
		 			setState(3917)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3922)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3923)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectAttachedTextContext: ParserRuleContext {
			open
			func attachmentPoint() -> AttachmentPointContext? {
				return getRuleContext(AttachmentPointContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func connectivityTagGeneratorDisplay() -> [ConnectivityTagGeneratorDisplayContext] {
				return getRuleContexts(ConnectivityTagGeneratorDisplayContext.self)
			}
			open
			func connectivityTagGeneratorDisplay(_ i: Int) -> ConnectivityTagGeneratorDisplayContext? {
				return getRuleContext(ConnectivityTagGeneratorDisplayContext.self, i)
			}
			open
			func criticalityDisplay() -> [CriticalityDisplayContext] {
				return getRuleContexts(CriticalityDisplayContext.self)
			}
			open
			func criticalityDisplay(_ i: Int) -> CriticalityDisplayContext? {
				return getRuleContext(CriticalityDisplayContext.self, i)
			}
			open
			func interconnectDelayDisplay() -> [InterconnectDelayDisplayContext] {
				return getRuleContexts(InterconnectDelayDisplayContext.self)
			}
			open
			func interconnectDelayDisplay(_ i: Int) -> InterconnectDelayDisplayContext? {
				return getRuleContext(InterconnectDelayDisplayContext.self, i)
			}
			open
			func interconnectNameDisplay() -> [InterconnectNameDisplayContext] {
				return getRuleContexts(InterconnectNameDisplayContext.self)
			}
			open
			func interconnectNameDisplay(_ i: Int) -> InterconnectNameDisplayContext? {
				return getRuleContext(InterconnectNameDisplayContext.self, i)
			}
			open
			func interconnectPropertyDisplay() -> [InterconnectPropertyDisplayContext] {
				return getRuleContexts(InterconnectPropertyDisplayContext.self)
			}
			open
			func interconnectPropertyDisplay(_ i: Int) -> InterconnectPropertyDisplayContext? {
				return getRuleContext(InterconnectPropertyDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectAttachedText
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectAttachedText(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectAttachedText(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectAttachedText(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectAttachedText(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectAttachedText() throws -> InterconnectAttachedTextContext {
		var _localctx: InterconnectAttachedTextContext = InterconnectAttachedTextContext(_ctx, getState())
		try enterRule(_localctx, 660, EDIF300Parser.RULE_interconnectAttachedText)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3925)
		 	try match(EDIF300Parser.Tokens.T__260.rawValue)
		 	setState(3926)
		 	try attachmentPoint()
		 	setState(3935)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__86.rawValue || _la == EDIF300Parser.Tokens.T__98.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__262.rawValue,EDIF300Parser.Tokens.T__265.rawValue,EDIF300Parser.Tokens.T__266.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 263)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(3933)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(3927)
		 			try annotate()

		 			break

		 		case .T__86:
		 			setState(3928)
		 			try connectivityTagGeneratorDisplay()

		 			break

		 		case .T__98:
		 			setState(3929)
		 			try criticalityDisplay()

		 			break

		 		case .T__262:
		 			setState(3930)
		 			try interconnectDelayDisplay()

		 			break

		 		case .T__265:
		 			setState(3931)
		 			try interconnectNameDisplay()

		 			break

		 		case .T__266:
		 			setState(3932)
		 			try interconnectPropertyDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3937)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3938)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectDelayContext: ParserRuleContext {
			open
			func interconnectDelayNameDef() -> InterconnectDelayNameDefContext? {
				return getRuleContext(InterconnectDelayNameDefContext.self, 0)
			}
			open
			func derivation() -> DerivationContext? {
				return getRuleContext(DerivationContext.self, 0)
			}
			open
			func delay() -> DelayContext? {
				return getRuleContext(DelayContext.self, 0)
			}
			open
			func becomes() -> [BecomesContext] {
				return getRuleContexts(BecomesContext.self)
			}
			open
			func becomes(_ i: Int) -> BecomesContext? {
				return getRuleContext(BecomesContext.self, i)
			}
			open
			func transition() -> [TransitionContext] {
				return getRuleContexts(TransitionContext.self)
			}
			open
			func transition(_ i: Int) -> TransitionContext? {
				return getRuleContext(TransitionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectDelay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectDelay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectDelay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectDelay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectDelay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectDelay() throws -> InterconnectDelayContext {
		var _localctx: InterconnectDelayContext = InterconnectDelayContext(_ctx, getState())
		try enterRule(_localctx, 662, EDIF300Parser.RULE_interconnectDelay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3940)
		 	try match(EDIF300Parser.Tokens.T__261.rawValue)
		 	setState(3941)
		 	try interconnectDelayNameDef()
		 	setState(3942)
		 	try derivation()
		 	setState(3943)
		 	try delay()
		 	setState(3948)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__16.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__625.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3946)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__16:
		 			setState(3944)
		 			try becomes()

		 			break

		 		case .T__625:
		 			setState(3945)
		 			try transition()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3950)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3951)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectDelayDisplayContext: ParserRuleContext {
			open
			func interconnectDelayNameRef() -> InterconnectDelayNameRefContext? {
				return getRuleContext(InterconnectDelayNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectDelayDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectDelayDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectDelayDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectDelayDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectDelayDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectDelayDisplay() throws -> InterconnectDelayDisplayContext {
		var _localctx: InterconnectDelayDisplayContext = InterconnectDelayDisplayContext(_ctx, getState())
		try enterRule(_localctx, 664, EDIF300Parser.RULE_interconnectDelayDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3953)
		 	try match(EDIF300Parser.Tokens.T__262.rawValue)
		 	setState(3954)
		 	try interconnectDelayNameRef()
		 	setState(3958)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3955)
		 		try display()


		 		setState(3960)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3961)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectDelayNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectDelayNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectDelayNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectDelayNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectDelayNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectDelayNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectDelayNameDef() throws -> InterconnectDelayNameDefContext {
		var _localctx: InterconnectDelayNameDefContext = InterconnectDelayNameDefContext(_ctx, getState())
		try enterRule(_localctx, 666, EDIF300Parser.RULE_interconnectDelayNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3963)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectDelayNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectDelayNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectDelayNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectDelayNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectDelayNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectDelayNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectDelayNameRef() throws -> InterconnectDelayNameRefContext {
		var _localctx: InterconnectDelayNameRefContext = InterconnectDelayNameRefContext(_ctx, getState())
		try enterRule(_localctx, 668, EDIF300Parser.RULE_interconnectDelayNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3965)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectHeaderContext: ParserRuleContext {
			open
			func criticality() -> [CriticalityContext] {
				return getRuleContexts(CriticalityContext.self)
			}
			open
			func criticality(_ i: Int) -> CriticalityContext? {
				return getRuleContext(CriticalityContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func interconnectDelay() -> [InterconnectDelayContext] {
				return getRuleContexts(InterconnectDelayContext.self)
			}
			open
			func interconnectDelay(_ i: Int) -> InterconnectDelayContext? {
				return getRuleContext(InterconnectDelayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectHeader() throws -> InterconnectHeaderContext {
		var _localctx: InterconnectHeaderContext = InterconnectHeaderContext(_ctx, getState())
		try enterRule(_localctx, 670, EDIF300Parser.RULE_interconnectHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3967)
		 	try match(EDIF300Parser.Tokens.T__263.rawValue)
		 	setState(3975)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__97.rawValue || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__261.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3973)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__97:
		 			setState(3968)
		 			try criticality()

		 			break

		 		case .T__132:
		 			setState(3969)
		 			try documentation()

		 			break

		 		case .T__261:
		 			setState(3970)
		 			try interconnectDelay()

		 			break

		 		case .T__346:
		 			setState(3971)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(3972)
		 			try property()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3977)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3978)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectNameCaseSensitive() throws -> InterconnectNameCaseSensitiveContext {
		var _localctx: InterconnectNameCaseSensitiveContext = InterconnectNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 672, EDIF300Parser.RULE_interconnectNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3980)
		 	try match(EDIF300Parser.Tokens.T__264.rawValue)
		 	setState(3981)
		 	try booleanToken()
		 	setState(3982)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectNameDef() throws -> InterconnectNameDefContext {
		var _localctx: InterconnectNameDefContext = InterconnectNameDefContext(_ctx, getState())
		try enterRule(_localctx, 674, EDIF300Parser.RULE_interconnectNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3984)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectNameDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func displayNameOverride() -> [DisplayNameOverrideContext] {
				return getRuleContexts(DisplayNameOverrideContext.self)
			}
			open
			func displayNameOverride(_ i: Int) -> DisplayNameOverrideContext? {
				return getRuleContext(DisplayNameOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectNameDisplay() throws -> InterconnectNameDisplayContext {
		var _localctx: InterconnectNameDisplayContext = InterconnectNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 676, EDIF300Parser.RULE_interconnectNameDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3986)
		 	try match(EDIF300Parser.Tokens.T__265.rawValue)
		 	setState(3991)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue || _la == EDIF300Parser.Tokens.T__131.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3989)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(3987)
		 			try display()

		 			break

		 		case .T__131:
		 			setState(3988)
		 			try displayNameOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(3993)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3994)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectNameRef() throws -> InterconnectNameRefContext {
		var _localctx: InterconnectNameRefContext = InterconnectNameRefContext(_ctx, getState())
		try enterRule(_localctx, 678, EDIF300Parser.RULE_interconnectNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3996)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectPropertyDisplayContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func propertyNameDisplay() -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectPropertyDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectPropertyDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectPropertyDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectPropertyDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectPropertyDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectPropertyDisplay() throws -> InterconnectPropertyDisplayContext {
		var _localctx: InterconnectPropertyDisplayContext = InterconnectPropertyDisplayContext(_ctx, getState())
		try enterRule(_localctx, 680, EDIF300Parser.RULE_interconnectPropertyDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3998)
		 	try match(EDIF300Parser.Tokens.T__266.rawValue)
		 	setState(3999)
		 	try propertyNameRef()
		 	setState(4003)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,235,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4000)
		 			try display()

		 	 
		 		}
		 		setState(4005)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,235,_ctx)
		 	}
		 	setState(4007)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4006)
		 		try propertyNameDisplay()

		 	}

		 	setState(4012)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4009)
		 		try display()


		 		setState(4014)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4015)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectRefContext: ParserRuleContext {
			open
			func interconnectNameRef() -> InterconnectNameRefContext? {
				return getRuleContext(InterconnectNameRefContext.self, 0)
			}
			open
			func pageRef() -> PageRefContext? {
				return getRuleContext(PageRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectRef() throws -> InterconnectRefContext {
		var _localctx: InterconnectRefContext = InterconnectRefContext(_ctx, getState())
		try enterRule(_localctx, 682, EDIF300Parser.RULE_interconnectRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4017)
		 	try match(EDIF300Parser.Tokens.T__267.rawValue)
		 	setState(4018)
		 	try interconnectNameRef()
		 	setState(4020)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__389.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4019)
		 		try pageRef()

		 	}

		 	setState(4022)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterconnectSetContext: ParserRuleContext {
			open
			func interconnectRef() -> [InterconnectRefContext] {
				return getRuleContexts(InterconnectRefContext.self)
			}
			open
			func interconnectRef(_ i: Int) -> InterconnectRefContext? {
				return getRuleContext(InterconnectRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interconnectSet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterconnectSet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterconnectSet(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterconnectSet(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterconnectSet(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interconnectSet() throws -> InterconnectSetContext {
		var _localctx: InterconnectSetContext = InterconnectSetContext(_ctx, getState())
		try enterRule(_localctx, 684, EDIF300Parser.RULE_interconnectSet)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4024)
		 	try match(EDIF300Parser.Tokens.T__268.rawValue)
		 	setState(4028)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__267.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4025)
		 		try interconnectRef()


		 		setState(4030)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4031)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EinterfaceContext: ParserRuleContext {
			open
			func interfaceUnits() -> InterfaceUnitsContext? {
				return getRuleContext(InterfaceUnitsContext.self, 0)
			}
			open
			func designator() -> [DesignatorContext] {
				return getRuleContexts(DesignatorContext.self)
			}
			open
			func designator(_ i: Int) -> DesignatorContext? {
				return getRuleContext(DesignatorContext.self, i)
			}
			open
			func booleanParameter() -> [BooleanParameterContext] {
				return getRuleContexts(BooleanParameterContext.self)
			}
			open
			func booleanParameter(_ i: Int) -> BooleanParameterContext? {
				return getRuleContext(BooleanParameterContext.self, i)
			}
			open
			func integerParameter() -> [IntegerParameterContext] {
				return getRuleContexts(IntegerParameterContext.self)
			}
			open
			func integerParameter(_ i: Int) -> IntegerParameterContext? {
				return getRuleContext(IntegerParameterContext.self, i)
			}
			open
			func interfaceJoined() -> [InterfaceJoinedContext] {
				return getRuleContexts(InterfaceJoinedContext.self)
			}
			open
			func interfaceJoined(_ i: Int) -> InterfaceJoinedContext? {
				return getRuleContext(InterfaceJoinedContext.self, i)
			}
			open
			func mustJoin() -> [MustJoinContext] {
				return getRuleContexts(MustJoinContext.self)
			}
			open
			func mustJoin(_ i: Int) -> MustJoinContext? {
				return getRuleContext(MustJoinContext.self, i)
			}
			open
			func numberParameter() -> [NumberParameterContext] {
				return getRuleContexts(NumberParameterContext.self)
			}
			open
			func numberParameter(_ i: Int) -> NumberParameterContext? {
				return getRuleContext(NumberParameterContext.self, i)
			}
			open
			func permutable() -> [PermutableContext] {
				return getRuleContexts(PermutableContext.self)
			}
			open
			func permutable(_ i: Int) -> PermutableContext? {
				return getRuleContext(PermutableContext.self, i)
			}
			open
			func port() -> [PortContext] {
				return getRuleContexts(PortContext.self)
			}
			open
			func port(_ i: Int) -> PortContext? {
				return getRuleContext(PortContext.self, i)
			}
			open
			func portBundle() -> [PortBundleContext] {
				return getRuleContexts(PortBundleContext.self)
			}
			open
			func portBundle(_ i: Int) -> PortBundleContext? {
				return getRuleContext(PortBundleContext.self, i)
			}
			open
			func stringParameter() -> [StringParameterContext] {
				return getRuleContexts(StringParameterContext.self)
			}
			open
			func stringParameter(_ i: Int) -> StringParameterContext? {
				return getRuleContext(StringParameterContext.self, i)
			}
			open
			func timing() -> [TimingContext] {
				return getRuleContexts(TimingContext.self)
			}
			open
			func timing(_ i: Int) -> TimingContext? {
				return getRuleContext(TimingContext.self, i)
			}
			open
			func weakJoined() -> [WeakJoinedContext] {
				return getRuleContexts(WeakJoinedContext.self)
			}
			open
			func weakJoined(_ i: Int) -> WeakJoinedContext? {
				return getRuleContext(WeakJoinedContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_einterface
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEinterface(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEinterface(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEinterface(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEinterface(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func einterface() throws -> EinterfaceContext {
		var _localctx: EinterfaceContext = EinterfaceContext(_ctx, getState())
		try enterRule(_localctx, 686, EDIF300Parser.RULE_einterface)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4033)
		 	try match(EDIF300Parser.Tokens.T__269.rawValue)
		 	setState(4034)
		 	try interfaceUnits()
		 	setState(4049)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__27.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__118.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__251.rawValue || _la == EDIF300Parser.Tokens.T__270.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__341.rawValue || _la == EDIF300Parser.Tokens.T__357.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__406.rawValue,EDIF300Parser.Tokens.T__414.rawValue,EDIF300Parser.Tokens.T__417.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 407)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__605.rawValue,EDIF300Parser.Tokens.T__619.rawValue,EDIF300Parser.Tokens.T__659.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 606)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4047)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__118:
		 			setState(4035)
		 			try designator()

		 			break

		 		case .T__27:
		 			setState(4036)
		 			try booleanParameter()

		 			break

		 		case .T__251:
		 			setState(4037)
		 			try integerParameter()

		 			break

		 		case .T__270:
		 			setState(4038)
		 			try interfaceJoined()

		 			break

		 		case .T__341:
		 			setState(4039)
		 			try mustJoin()

		 			break

		 		case .T__357:
		 			setState(4040)
		 			try numberParameter()

		 			break

		 		case .T__406:
		 			setState(4041)
		 			try permutable()

		 			break

		 		case .T__414:
		 			setState(4042)
		 			try port()

		 			break

		 		case .T__417:
		 			setState(4043)
		 			try portBundle()

		 			break

		 		case .T__605:
		 			setState(4044)
		 			try stringParameter()

		 			break

		 		case .T__619:
		 			setState(4045)
		 			try timing()

		 			break

		 		case .T__659:
		 			setState(4046)
		 			try weakJoined()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4051)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4052)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterfaceJoinedContext: ParserRuleContext {
			open
			func portRef() -> [PortRefContext] {
				return getRuleContexts(PortRefContext.self)
			}
			open
			func portRef(_ i: Int) -> PortRefContext? {
				return getRuleContext(PortRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interfaceJoined
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterfaceJoined(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterfaceJoined(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterfaceJoined(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterfaceJoined(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interfaceJoined() throws -> InterfaceJoinedContext {
		var _localctx: InterfaceJoinedContext = InterfaceJoinedContext(_ctx, getState())
		try enterRule(_localctx, 688, EDIF300Parser.RULE_interfaceJoined)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4054)
		 	try match(EDIF300Parser.Tokens.T__270.rawValue)
		 	setState(4058)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__436.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4055)
		 		try portRef()


		 		setState(4060)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4061)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InterfaceUnitsContext: ParserRuleContext {
			open
			func setCapacitance() -> [SetCapacitanceContext] {
				return getRuleContexts(SetCapacitanceContext.self)
			}
			open
			func setCapacitance(_ i: Int) -> SetCapacitanceContext? {
				return getRuleContext(SetCapacitanceContext.self, i)
			}
			open
			func setTime() -> [SetTimeContext] {
				return getRuleContexts(SetTimeContext.self)
			}
			open
			func setTime(_ i: Int) -> SetTimeContext? {
				return getRuleContext(SetTimeContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_interfaceUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterInterfaceUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitInterfaceUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitInterfaceUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitInterfaceUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func interfaceUnits() throws -> InterfaceUnitsContext {
		var _localctx: InterfaceUnitsContext = InterfaceUnitsContext(_ctx, getState())
		try enterRule(_localctx, 690, EDIF300Parser.RULE_interfaceUnits)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4063)
		 	try match(EDIF300Parser.Tokens.T__271.rawValue)
		 	setState(4068)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__576.rawValue || _la == EDIF300Parser.Tokens.T__580.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4066)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__576:
		 			setState(4064)
		 			try setCapacitance()

		 			break

		 		case .T__580:
		 			setState(4065)
		 			try setTime()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4070)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4071)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class Iso8859Context: ParserRuleContext {
			open
			func iso8859Part() -> Iso8859PartContext? {
				return getRuleContext(Iso8859PartContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_iso8859
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIso8859(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIso8859(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIso8859(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIso8859(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func iso8859() throws -> Iso8859Context {
		var _localctx: Iso8859Context = Iso8859Context(_ctx, getState())
		try enterRule(_localctx, 692, EDIF300Parser.RULE_iso8859)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4073)
		 	try match(EDIF300Parser.Tokens.T__272.rawValue)
		 	setState(4074)
		 	try iso8859Part()
		 	setState(4075)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class Iso8859PartContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_iso8859Part
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIso8859Part(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIso8859Part(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIso8859Part(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIso8859Part(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func iso8859Part() throws -> Iso8859PartContext {
		var _localctx: Iso8859PartContext = Iso8859PartContext(_ctx, getState())
		try enterRule(_localctx, 694, EDIF300Parser.RULE_iso8859Part)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4077)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IsolatedContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_isolated
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIsolated(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIsolated(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIsolated(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIsolated(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func isolated() throws -> IsolatedContext {
		var _localctx: IsolatedContext = IsolatedContext(_ctx, getState())
		try enterRule(_localctx, 696, EDIF300Parser.RULE_isolated)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4079)
		 	try match(EDIF300Parser.Tokens.T__273.rawValue)
		 	setState(4080)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IssueContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_issue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIssue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIssue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIssue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIssue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func issue() throws -> IssueContext {
		var _localctx: IssueContext = IssueContext(_ctx, getState())
		try enterRule(_localctx, 698, EDIF300Parser.RULE_issue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4082)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ItalicStyleContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_italicStyle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterItalicStyle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitItalicStyle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitItalicStyle(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitItalicStyle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func italicStyle() throws -> ItalicStyleContext {
		var _localctx: ItalicStyleContext = ItalicStyleContext(_ctx, getState())
		try enterRule(_localctx, 700, EDIF300Parser.RULE_italicStyle)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4084)
		 	try match(EDIF300Parser.Tokens.T__274.rawValue)
		 	setState(4085)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class Jisx0201Context: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_jisx0201
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterJisx0201(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitJisx0201(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitJisx0201(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitJisx0201(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func jisx0201() throws -> Jisx0201Context {
		var _localctx: Jisx0201Context = Jisx0201Context(_ctx, getState())
		try enterRule(_localctx, 702, EDIF300Parser.RULE_jisx0201)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4087)
		 	try match(EDIF300Parser.Tokens.T__275.rawValue)
		 	setState(4088)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class Jisx0208Context: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_jisx0208
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterJisx0208(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitJisx0208(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitJisx0208(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitJisx0208(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func jisx0208() throws -> Jisx0208Context {
		var _localctx: Jisx0208Context = Jisx0208Context(_ctx, getState())
		try enterRule(_localctx, 704, EDIF300Parser.RULE_jisx0208)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4090)
		 	try match(EDIF300Parser.Tokens.T__276.rawValue)
		 	setState(4091)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class JoinedAsSignalContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_joinedAsSignal
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterJoinedAsSignal(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitJoinedAsSignal(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitJoinedAsSignal(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitJoinedAsSignal(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func joinedAsSignal() throws -> JoinedAsSignalContext {
		var _localctx: JoinedAsSignalContext = JoinedAsSignalContext(_ctx, getState())
		try enterRule(_localctx, 706, EDIF300Parser.RULE_joinedAsSignal)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4093)
		 	try match(EDIF300Parser.Tokens.T__277.rawValue)
		 	setState(4094)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class JouleContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_joule
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterJoule(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitJoule(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitJoule(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitJoule(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func joule() throws -> JouleContext {
		var _localctx: JouleContext = JouleContext(_ctx, getState())
		try enterRule(_localctx, 708, EDIF300Parser.RULE_joule)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4096)
		 	try match(EDIF300Parser.Tokens.T__278.rawValue)
		 	setState(4097)
		 	try unitExponent()
		 	setState(4098)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K0KeywordLevelContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k0KeywordLevel
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK0KeywordLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK0KeywordLevel(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK0KeywordLevel(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK0KeywordLevel(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k0KeywordLevel() throws -> K0KeywordLevelContext {
		var _localctx: K0KeywordLevelContext = K0KeywordLevelContext(_ctx, getState())
		try enterRule(_localctx, 710, EDIF300Parser.RULE_k0KeywordLevel)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4100)
		 	try match(EDIF300Parser.Tokens.T__279.rawValue)
		 	setState(4101)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K1KeywordAliasContext: ParserRuleContext {
			open
			func k1KeywordNameDef() -> K1KeywordNameDefContext? {
				return getRuleContext(K1KeywordNameDefContext.self, 0)
			}
			open
			func k1KeywordNameRef() -> K1KeywordNameRefContext? {
				return getRuleContext(K1KeywordNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k1KeywordAlias
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK1KeywordAlias(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK1KeywordAlias(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK1KeywordAlias(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK1KeywordAlias(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k1KeywordAlias() throws -> K1KeywordAliasContext {
		var _localctx: K1KeywordAliasContext = K1KeywordAliasContext(_ctx, getState())
		try enterRule(_localctx, 712, EDIF300Parser.RULE_k1KeywordAlias)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4103)
		 	try match(EDIF300Parser.Tokens.T__280.rawValue)
		 	setState(4104)
		 	try k1KeywordNameDef()
		 	setState(4105)
		 	try k1KeywordNameRef()
		 	setState(4106)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K1KeywordLevelContext: ParserRuleContext {
			open
			func k1KeywordAlias() -> [K1KeywordAliasContext] {
				return getRuleContexts(K1KeywordAliasContext.self)
			}
			open
			func k1KeywordAlias(_ i: Int) -> K1KeywordAliasContext? {
				return getRuleContext(K1KeywordAliasContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k1KeywordLevel
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK1KeywordLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK1KeywordLevel(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK1KeywordLevel(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK1KeywordLevel(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k1KeywordLevel() throws -> K1KeywordLevelContext {
		var _localctx: K1KeywordLevelContext = K1KeywordLevelContext(_ctx, getState())
		try enterRule(_localctx, 714, EDIF300Parser.RULE_k1KeywordLevel)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4108)
		 	try match(EDIF300Parser.Tokens.T__281.rawValue)
		 	setState(4112)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__280.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4109)
		 		try k1KeywordAlias()


		 		setState(4114)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4115)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K1KeywordNameDefContext: ParserRuleContext {
			open
			func IDENTIFIER() -> TerminalNode? {
				return getToken(EDIF300Parser.Tokens.IDENTIFIER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k1KeywordNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK1KeywordNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK1KeywordNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK1KeywordNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK1KeywordNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k1KeywordNameDef() throws -> K1KeywordNameDefContext {
		var _localctx: K1KeywordNameDefContext = K1KeywordNameDefContext(_ctx, getState())
		try enterRule(_localctx, 716, EDIF300Parser.RULE_k1KeywordNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4117)
		 	try match(EDIF300Parser.Tokens.IDENTIFIER.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K1KeywordNameRefContext: ParserRuleContext {
			open
			func IDENTIFIER() -> TerminalNode? {
				return getToken(EDIF300Parser.Tokens.IDENTIFIER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k1KeywordNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK1KeywordNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK1KeywordNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK1KeywordNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK1KeywordNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k1KeywordNameRef() throws -> K1KeywordNameRefContext {
		var _localctx: K1KeywordNameRefContext = K1KeywordNameRefContext(_ctx, getState())
		try enterRule(_localctx, 718, EDIF300Parser.RULE_k1KeywordNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4119)
		 	try match(EDIF300Parser.Tokens.IDENTIFIER.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2ActualContext: ParserRuleContext {
			open
			func k2FormalNameRef() -> K2FormalNameRefContext? {
				return getRuleContext(K2FormalNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2Actual
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2Actual(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2Actual(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2Actual(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2Actual(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2Actual() throws -> K2ActualContext {
		var _localctx: K2ActualContext = K2ActualContext(_ctx, getState())
		try enterRule(_localctx, 720, EDIF300Parser.RULE_k2Actual)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4121)
		 	try match(EDIF300Parser.Tokens.T__282.rawValue)
		 	setState(4122)
		 	try k2FormalNameRef()
		 	setState(4123)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2BuildContext: ParserRuleContext {
			open
			func k1KeywordNameRef() -> K1KeywordNameRefContext? {
				return getRuleContext(K1KeywordNameRefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func k2Actual() -> [K2ActualContext] {
				return getRuleContexts(K2ActualContext.self)
			}
			open
			func k2Actual(_ i: Int) -> K2ActualContext? {
				return getRuleContext(K2ActualContext.self, i)
			}
			open
			func k2Build() -> [K2BuildContext] {
				return getRuleContexts(K2BuildContext.self)
			}
			open
			func k2Build(_ i: Int) -> K2BuildContext? {
				return getRuleContext(K2BuildContext.self, i)
			}
			open
			func k2Literal() -> [K2LiteralContext] {
				return getRuleContexts(K2LiteralContext.self)
			}
			open
			func k2Literal(_ i: Int) -> K2LiteralContext? {
				return getRuleContext(K2LiteralContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2Build
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2Build(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2Build(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2Build(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2Build(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2Build() throws -> K2BuildContext {
		var _localctx: K2BuildContext = K2BuildContext(_ctx, getState())
		try enterRule(_localctx, 722, EDIF300Parser.RULE_k2Build)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4125)
		 	try match(EDIF300Parser.Tokens.T__283.rawValue)
		 	setState(4126)
		 	try k1KeywordNameRef()
		 	setState(4133)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__282.rawValue,EDIF300Parser.Tokens.T__283.rawValue,EDIF300Parser.Tokens.T__289.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 283)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4131)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4127)
		 			try comment()

		 			break

		 		case .T__282:
		 			setState(4128)
		 			try k2Actual()

		 			break

		 		case .T__283:
		 			setState(4129)
		 			try k2Build()

		 			break

		 		case .T__289:
		 			setState(4130)
		 			try k2Literal()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4135)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4136)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2FormalContext: ParserRuleContext {
			open
			func k2FormalNameDef() -> K2FormalNameDefContext? {
				return getRuleContext(K2FormalNameDefContext.self, 0)
			}
			open
			func k2Optional() -> K2OptionalContext? {
				return getRuleContext(K2OptionalContext.self, 0)
			}
			open
			func k2Required() -> K2RequiredContext? {
				return getRuleContext(K2RequiredContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2Formal
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2Formal(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2Formal(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2Formal(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2Formal(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2Formal() throws -> K2FormalContext {
		var _localctx: K2FormalContext = K2FormalContext(_ctx, getState())
		try enterRule(_localctx, 724, EDIF300Parser.RULE_k2Formal)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4138)
		 	try match(EDIF300Parser.Tokens.T__284.rawValue)
		 	setState(4139)
		 	try k2FormalNameDef()
		 	setState(4142)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__290:
		 		setState(4140)
		 		try k2Optional()

		 		break

		 	case .T__291:
		 		setState(4141)
		 		try k2Required()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4144)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2FormalNameDefContext: ParserRuleContext {
			open
			func IDENTIFIER() -> TerminalNode? {
				return getToken(EDIF300Parser.Tokens.IDENTIFIER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2FormalNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2FormalNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2FormalNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2FormalNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2FormalNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2FormalNameDef() throws -> K2FormalNameDefContext {
		var _localctx: K2FormalNameDefContext = K2FormalNameDefContext(_ctx, getState())
		try enterRule(_localctx, 726, EDIF300Parser.RULE_k2FormalNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4146)
		 	try match(EDIF300Parser.Tokens.IDENTIFIER.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2FormalNameRefContext: ParserRuleContext {
			open
			func IDENTIFIER() -> TerminalNode? {
				return getToken(EDIF300Parser.Tokens.IDENTIFIER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2FormalNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2FormalNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2FormalNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2FormalNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2FormalNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2FormalNameRef() throws -> K2FormalNameRefContext {
		var _localctx: K2FormalNameRefContext = K2FormalNameRefContext(_ctx, getState())
		try enterRule(_localctx, 728, EDIF300Parser.RULE_k2FormalNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4148)
		 	try match(EDIF300Parser.Tokens.IDENTIFIER.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2GenerateContext: ParserRuleContext {
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func k2Actual() -> [K2ActualContext] {
				return getRuleContexts(K2ActualContext.self)
			}
			open
			func k2Actual(_ i: Int) -> K2ActualContext? {
				return getRuleContext(K2ActualContext.self, i)
			}
			open
			func k2Build() -> [K2BuildContext] {
				return getRuleContexts(K2BuildContext.self)
			}
			open
			func k2Build(_ i: Int) -> K2BuildContext? {
				return getRuleContext(K2BuildContext.self, i)
			}
			open
			func k2Literal() -> [K2LiteralContext] {
				return getRuleContexts(K2LiteralContext.self)
			}
			open
			func k2Literal(_ i: Int) -> K2LiteralContext? {
				return getRuleContext(K2LiteralContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2Generate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2Generate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2Generate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2Generate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2Generate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2Generate() throws -> K2GenerateContext {
		var _localctx: K2GenerateContext = K2GenerateContext(_ctx, getState())
		try enterRule(_localctx, 730, EDIF300Parser.RULE_k2Generate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4150)
		 	try match(EDIF300Parser.Tokens.T__285.rawValue)
		 	setState(4157)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__282.rawValue,EDIF300Parser.Tokens.T__283.rawValue,EDIF300Parser.Tokens.T__289.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 283)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4155)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4151)
		 			try comment()

		 			break

		 		case .T__282:
		 			setState(4152)
		 			try k2Actual()

		 			break

		 		case .T__283:
		 			setState(4153)
		 			try k2Build()

		 			break

		 		case .T__289:
		 			setState(4154)
		 			try k2Literal()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4159)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4160)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2KeywordDefineContext: ParserRuleContext {
			open
			func k1KeywordNameDef() -> K1KeywordNameDefContext? {
				return getRuleContext(K1KeywordNameDefContext.self, 0)
			}
			open
			func k2KeywordParameters() -> K2KeywordParametersContext? {
				return getRuleContext(K2KeywordParametersContext.self, 0)
			}
			open
			func k2Generate() -> K2GenerateContext? {
				return getRuleContext(K2GenerateContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2KeywordDefine
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2KeywordDefine(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2KeywordDefine(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2KeywordDefine(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2KeywordDefine(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2KeywordDefine() throws -> K2KeywordDefineContext {
		var _localctx: K2KeywordDefineContext = K2KeywordDefineContext(_ctx, getState())
		try enterRule(_localctx, 732, EDIF300Parser.RULE_k2KeywordDefine)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4162)
		 	try match(EDIF300Parser.Tokens.T__286.rawValue)
		 	setState(4163)
		 	try k1KeywordNameDef()
		 	setState(4164)
		 	try k2KeywordParameters()
		 	setState(4165)
		 	try k2Generate()
		 	setState(4166)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2KeywordLevelContext: ParserRuleContext {
			open
			func k1KeywordAlias() -> [K1KeywordAliasContext] {
				return getRuleContexts(K1KeywordAliasContext.self)
			}
			open
			func k1KeywordAlias(_ i: Int) -> K1KeywordAliasContext? {
				return getRuleContext(K1KeywordAliasContext.self, i)
			}
			open
			func k2KeywordDefine() -> [K2KeywordDefineContext] {
				return getRuleContexts(K2KeywordDefineContext.self)
			}
			open
			func k2KeywordDefine(_ i: Int) -> K2KeywordDefineContext? {
				return getRuleContext(K2KeywordDefineContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2KeywordLevel
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2KeywordLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2KeywordLevel(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2KeywordLevel(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2KeywordLevel(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2KeywordLevel() throws -> K2KeywordLevelContext {
		var _localctx: K2KeywordLevelContext = K2KeywordLevelContext(_ctx, getState())
		try enterRule(_localctx, 734, EDIF300Parser.RULE_k2KeywordLevel)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4168)
		 	try match(EDIF300Parser.Tokens.T__287.rawValue)
		 	setState(4173)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__280.rawValue || _la == EDIF300Parser.Tokens.T__286.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4171)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__280:
		 			setState(4169)
		 			try k1KeywordAlias()

		 			break

		 		case .T__286:
		 			setState(4170)
		 			try k2KeywordDefine()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4175)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4176)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2KeywordParametersContext: ParserRuleContext {
			open
			func k2Formal() -> [K2FormalContext] {
				return getRuleContexts(K2FormalContext.self)
			}
			open
			func k2Formal(_ i: Int) -> K2FormalContext? {
				return getRuleContext(K2FormalContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2KeywordParameters
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2KeywordParameters(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2KeywordParameters(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2KeywordParameters(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2KeywordParameters(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2KeywordParameters() throws -> K2KeywordParametersContext {
		var _localctx: K2KeywordParametersContext = K2KeywordParametersContext(_ctx, getState())
		try enterRule(_localctx, 736, EDIF300Parser.RULE_k2KeywordParameters)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4178)
		 	try match(EDIF300Parser.Tokens.T__288.rawValue)
		 	setState(4182)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__284.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4179)
		 		try k2Formal()


		 		setState(4184)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4185)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2LiteralContext: ParserRuleContext {
			open
			func IDENTIFIER() -> [TerminalNode] {
				return getTokens(EDIF300Parser.Tokens.IDENTIFIER.rawValue)
			}
			open
			func IDENTIFIER(_ i:Int) -> TerminalNode? {
				return getToken(EDIF300Parser.Tokens.IDENTIFIER.rawValue, i)
			}
			open
			func integerToken() -> [IntegerTokenContext] {
				return getRuleContexts(IntegerTokenContext.self)
			}
			open
			func integerToken(_ i: Int) -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, i)
			}
			open
			func stringToken() -> [StringTokenContext] {
				return getRuleContexts(StringTokenContext.self)
			}
			open
			func stringToken(_ i: Int) -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2Literal
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2Literal(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2Literal(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2Literal(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2Literal(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2Literal() throws -> K2LiteralContext {
		var _localctx: K2LiteralContext = K2LiteralContext(_ctx, getState())
		try enterRule(_localctx, 738, EDIF300Parser.RULE_k2Literal)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4187)
		 	try match(EDIF300Parser.Tokens.T__289.rawValue)
		 	setState(4193)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.IDENTIFIER.rawValue,EDIF300Parser.Tokens.STRING_LITERAL.rawValue,EDIF300Parser.Tokens.DECIMAL_LITERAL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 667)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(4191)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .IDENTIFIER:
		 			setState(4188)
		 			try match(EDIF300Parser.Tokens.IDENTIFIER.rawValue)

		 			break

		 		case .DECIMAL_LITERAL:
		 			setState(4189)
		 			try integerToken()

		 			break

		 		case .STRING_LITERAL:
		 			setState(4190)
		 			try stringToken()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4195)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4196)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2OptionalContext: ParserRuleContext {
			open
			func k2Literal() -> K2LiteralContext? {
				return getRuleContext(K2LiteralContext.self, 0)
			}
			open
			func k2Actual() -> K2ActualContext? {
				return getRuleContext(K2ActualContext.self, 0)
			}
			open
			func k2Build() -> K2BuildContext? {
				return getRuleContext(K2BuildContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2Optional
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2Optional(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2Optional(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2Optional(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2Optional(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2Optional() throws -> K2OptionalContext {
		var _localctx: K2OptionalContext = K2OptionalContext(_ctx, getState())
		try enterRule(_localctx, 740, EDIF300Parser.RULE_k2Optional)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4198)
		 	try match(EDIF300Parser.Tokens.T__290.rawValue)
		 	setState(4202)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__289:
		 		setState(4199)
		 		try k2Literal()

		 		break

		 	case .T__282:
		 		setState(4200)
		 		try k2Actual()

		 		break

		 	case .T__283:
		 		setState(4201)
		 		try k2Build()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4204)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K2RequiredContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k2Required
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK2Required(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK2Required(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK2Required(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK2Required(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k2Required() throws -> K2RequiredContext {
		var _localctx: K2RequiredContext = K2RequiredContext(_ctx, getState())
		try enterRule(_localctx, 742, EDIF300Parser.RULE_k2Required)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4206)
		 	try match(EDIF300Parser.Tokens.T__291.rawValue)
		 	setState(4207)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K3BuildContext: ParserRuleContext {
			open
			func k1KeywordNameRef() -> K1KeywordNameRefContext? {
				return getRuleContext(K1KeywordNameRefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func k2Actual() -> [K2ActualContext] {
				return getRuleContexts(K2ActualContext.self)
			}
			open
			func k2Actual(_ i: Int) -> K2ActualContext? {
				return getRuleContext(K2ActualContext.self, i)
			}
			open
			func k2Literal() -> [K2LiteralContext] {
				return getRuleContexts(K2LiteralContext.self)
			}
			open
			func k2Literal(_ i: Int) -> K2LiteralContext? {
				return getRuleContext(K2LiteralContext.self, i)
			}
			open
			func k3Build() -> [K3BuildContext] {
				return getRuleContexts(K3BuildContext.self)
			}
			open
			func k3Build(_ i: Int) -> K3BuildContext? {
				return getRuleContext(K3BuildContext.self, i)
			}
			open
			func k3ForEach() -> [K3ForEachContext] {
				return getRuleContexts(K3ForEachContext.self)
			}
			open
			func k3ForEach(_ i: Int) -> K3ForEachContext? {
				return getRuleContext(K3ForEachContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k3Build
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK3Build(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK3Build(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK3Build(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK3Build(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k3Build() throws -> K3BuildContext {
		var _localctx: K3BuildContext = K3BuildContext(_ctx, getState())
		try enterRule(_localctx, 744, EDIF300Parser.RULE_k3Build)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4209)
		 	try match(EDIF300Parser.Tokens.T__292.rawValue)
		 	setState(4210)
		 	try k1KeywordNameRef()
		 	setState(4218)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__282.rawValue,EDIF300Parser.Tokens.T__289.rawValue,EDIF300Parser.Tokens.T__292.rawValue,EDIF300Parser.Tokens.T__294.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 283)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4216)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4211)
		 			try comment()

		 			break

		 		case .T__282:
		 			setState(4212)
		 			try k2Actual()

		 			break

		 		case .T__289:
		 			setState(4213)
		 			try k2Literal()

		 			break

		 		case .T__292:
		 			setState(4214)
		 			try k3Build()

		 			break

		 		case .T__294:
		 			setState(4215)
		 			try k3ForEach()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4220)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4221)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K3CollectorContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k3Collector
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK3Collector(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK3Collector(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK3Collector(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK3Collector(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k3Collector() throws -> K3CollectorContext {
		var _localctx: K3CollectorContext = K3CollectorContext(_ctx, getState())
		try enterRule(_localctx, 746, EDIF300Parser.RULE_k3Collector)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4223)
		 	try match(EDIF300Parser.Tokens.T__293.rawValue)
		 	setState(4224)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K3ForEachContext: ParserRuleContext {
			open
			func k2FormalNameRef() -> K2FormalNameRefContext? {
				return getRuleContext(K2FormalNameRefContext.self, 0)
			}
			open
			func k3FormalList() -> K3FormalListContext? {
				return getRuleContext(K3FormalListContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func k2Actual() -> [K2ActualContext] {
				return getRuleContexts(K2ActualContext.self)
			}
			open
			func k2Actual(_ i: Int) -> K2ActualContext? {
				return getRuleContext(K2ActualContext.self, i)
			}
			open
			func k2Literal() -> [K2LiteralContext] {
				return getRuleContexts(K2LiteralContext.self)
			}
			open
			func k2Literal(_ i: Int) -> K2LiteralContext? {
				return getRuleContext(K2LiteralContext.self, i)
			}
			open
			func k3Build() -> [K3BuildContext] {
				return getRuleContexts(K3BuildContext.self)
			}
			open
			func k3Build(_ i: Int) -> K3BuildContext? {
				return getRuleContext(K3BuildContext.self, i)
			}
			open
			func k3ForEach() -> [K3ForEachContext] {
				return getRuleContexts(K3ForEachContext.self)
			}
			open
			func k3ForEach(_ i: Int) -> K3ForEachContext? {
				return getRuleContext(K3ForEachContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k3ForEach
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK3ForEach(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK3ForEach(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK3ForEach(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK3ForEach(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k3ForEach() throws -> K3ForEachContext {
		var _localctx: K3ForEachContext = K3ForEachContext(_ctx, getState())
		try enterRule(_localctx, 748, EDIF300Parser.RULE_k3ForEach)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4226)
		 	try match(EDIF300Parser.Tokens.T__294.rawValue)
		 	setState(4229)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IDENTIFIER:
		 		setState(4227)
		 		try k2FormalNameRef()

		 		break

		 	case .T__296:
		 		setState(4228)
		 		try k3FormalList()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4238)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__282.rawValue,EDIF300Parser.Tokens.T__289.rawValue,EDIF300Parser.Tokens.T__292.rawValue,EDIF300Parser.Tokens.T__294.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 283)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4236)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4231)
		 			try comment()

		 			break

		 		case .T__282:
		 			setState(4232)
		 			try k2Actual()

		 			break

		 		case .T__289:
		 			setState(4233)
		 			try k2Literal()

		 			break

		 		case .T__292:
		 			setState(4234)
		 			try k3Build()

		 			break

		 		case .T__294:
		 			setState(4235)
		 			try k3ForEach()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4240)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4241)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K3FormalContext: ParserRuleContext {
			open
			func k2FormalNameDef() -> K2FormalNameDefContext? {
				return getRuleContext(K2FormalNameDefContext.self, 0)
			}
			open
			func k2Optional() -> K2OptionalContext? {
				return getRuleContext(K2OptionalContext.self, 0)
			}
			open
			func k2Required() -> K2RequiredContext? {
				return getRuleContext(K2RequiredContext.self, 0)
			}
			open
			func k3Collector() -> K3CollectorContext? {
				return getRuleContext(K3CollectorContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k3Formal
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK3Formal(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK3Formal(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK3Formal(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK3Formal(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k3Formal() throws -> K3FormalContext {
		var _localctx: K3FormalContext = K3FormalContext(_ctx, getState())
		try enterRule(_localctx, 750, EDIF300Parser.RULE_k3Formal)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4243)
		 	try match(EDIF300Parser.Tokens.T__295.rawValue)
		 	setState(4244)
		 	try k2FormalNameDef()
		 	setState(4248)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__290:
		 		setState(4245)
		 		try k2Optional()

		 		break

		 	case .T__291:
		 		setState(4246)
		 		try k2Required()

		 		break

		 	case .T__293:
		 		setState(4247)
		 		try k3Collector()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4250)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K3FormalListContext: ParserRuleContext {
			open
			func k2FormalNameRef() -> [K2FormalNameRefContext] {
				return getRuleContexts(K2FormalNameRefContext.self)
			}
			open
			func k2FormalNameRef(_ i: Int) -> K2FormalNameRefContext? {
				return getRuleContext(K2FormalNameRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k3FormalList
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK3FormalList(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK3FormalList(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK3FormalList(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK3FormalList(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k3FormalList() throws -> K3FormalListContext {
		var _localctx: K3FormalListContext = K3FormalListContext(_ctx, getState())
		try enterRule(_localctx, 752, EDIF300Parser.RULE_k3FormalList)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4252)
		 	try match(EDIF300Parser.Tokens.T__296.rawValue)
		 	setState(4256)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4253)
		 		try k2FormalNameRef()


		 		setState(4258)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4259)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K3GenerateContext: ParserRuleContext {
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func k2Actual() -> [K2ActualContext] {
				return getRuleContexts(K2ActualContext.self)
			}
			open
			func k2Actual(_ i: Int) -> K2ActualContext? {
				return getRuleContext(K2ActualContext.self, i)
			}
			open
			func k2Build() -> [K2BuildContext] {
				return getRuleContexts(K2BuildContext.self)
			}
			open
			func k2Build(_ i: Int) -> K2BuildContext? {
				return getRuleContext(K2BuildContext.self, i)
			}
			open
			func k2Literal() -> [K2LiteralContext] {
				return getRuleContexts(K2LiteralContext.self)
			}
			open
			func k2Literal(_ i: Int) -> K2LiteralContext? {
				return getRuleContext(K2LiteralContext.self, i)
			}
			open
			func k3ForEach() -> [K3ForEachContext] {
				return getRuleContexts(K3ForEachContext.self)
			}
			open
			func k3ForEach(_ i: Int) -> K3ForEachContext? {
				return getRuleContext(K3ForEachContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k3Generate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK3Generate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK3Generate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK3Generate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK3Generate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k3Generate() throws -> K3GenerateContext {
		var _localctx: K3GenerateContext = K3GenerateContext(_ctx, getState())
		try enterRule(_localctx, 754, EDIF300Parser.RULE_k3Generate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4261)
		 	try match(EDIF300Parser.Tokens.T__297.rawValue)
		 	setState(4269)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__282.rawValue,EDIF300Parser.Tokens.T__283.rawValue,EDIF300Parser.Tokens.T__289.rawValue,EDIF300Parser.Tokens.T__294.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 283)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4267)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4262)
		 			try comment()

		 			break

		 		case .T__282:
		 			setState(4263)
		 			try k2Actual()

		 			break

		 		case .T__283:
		 			setState(4264)
		 			try k2Build()

		 			break

		 		case .T__289:
		 			setState(4265)
		 			try k2Literal()

		 			break

		 		case .T__294:
		 			setState(4266)
		 			try k3ForEach()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4271)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4272)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K3KeywordDefineContext: ParserRuleContext {
			open
			func k1KeywordNameDef() -> K1KeywordNameDefContext? {
				return getRuleContext(K1KeywordNameDefContext.self, 0)
			}
			open
			func k3KeywordParameters() -> K3KeywordParametersContext? {
				return getRuleContext(K3KeywordParametersContext.self, 0)
			}
			open
			func k3Generate() -> K3GenerateContext? {
				return getRuleContext(K3GenerateContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k3KeywordDefine
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK3KeywordDefine(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK3KeywordDefine(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK3KeywordDefine(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK3KeywordDefine(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k3KeywordDefine() throws -> K3KeywordDefineContext {
		var _localctx: K3KeywordDefineContext = K3KeywordDefineContext(_ctx, getState())
		try enterRule(_localctx, 756, EDIF300Parser.RULE_k3KeywordDefine)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4274)
		 	try match(EDIF300Parser.Tokens.T__298.rawValue)
		 	setState(4275)
		 	try k1KeywordNameDef()
		 	setState(4276)
		 	try k3KeywordParameters()
		 	setState(4277)
		 	try k3Generate()
		 	setState(4278)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K3KeywordLevelContext: ParserRuleContext {
			open
			func k1KeywordAlias() -> [K1KeywordAliasContext] {
				return getRuleContexts(K1KeywordAliasContext.self)
			}
			open
			func k1KeywordAlias(_ i: Int) -> K1KeywordAliasContext? {
				return getRuleContext(K1KeywordAliasContext.self, i)
			}
			open
			func k3KeywordDefine() -> [K3KeywordDefineContext] {
				return getRuleContexts(K3KeywordDefineContext.self)
			}
			open
			func k3KeywordDefine(_ i: Int) -> K3KeywordDefineContext? {
				return getRuleContext(K3KeywordDefineContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k3KeywordLevel
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK3KeywordLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK3KeywordLevel(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK3KeywordLevel(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK3KeywordLevel(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k3KeywordLevel() throws -> K3KeywordLevelContext {
		var _localctx: K3KeywordLevelContext = K3KeywordLevelContext(_ctx, getState())
		try enterRule(_localctx, 758, EDIF300Parser.RULE_k3KeywordLevel)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4280)
		 	try match(EDIF300Parser.Tokens.T__299.rawValue)
		 	setState(4285)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__280.rawValue || _la == EDIF300Parser.Tokens.T__298.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4283)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__280:
		 			setState(4281)
		 			try k1KeywordAlias()

		 			break

		 		case .T__298:
		 			setState(4282)
		 			try k3KeywordDefine()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4287)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4288)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class K3KeywordParametersContext: ParserRuleContext {
			open
			func k3Formal() -> [K3FormalContext] {
				return getRuleContexts(K3FormalContext.self)
			}
			open
			func k3Formal(_ i: Int) -> K3FormalContext? {
				return getRuleContext(K3FormalContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_k3KeywordParameters
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterK3KeywordParameters(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitK3KeywordParameters(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitK3KeywordParameters(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitK3KeywordParameters(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func k3KeywordParameters() throws -> K3KeywordParametersContext {
		var _localctx: K3KeywordParametersContext = K3KeywordParametersContext(_ctx, getState())
		try enterRule(_localctx, 760, EDIF300Parser.RULE_k3KeywordParameters)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4290)
		 	try match(EDIF300Parser.Tokens.T__300.rawValue)
		 	setState(4294)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__295.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4291)
		 		try k3Formal()


		 		setState(4296)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4297)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class KelvinContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_kelvin
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterKelvin(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitKelvin(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitKelvin(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitKelvin(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func kelvin() throws -> KelvinContext {
		var _localctx: KelvinContext = KelvinContext(_ctx, getState())
		try enterRule(_localctx, 762, EDIF300Parser.RULE_kelvin)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4299)
		 	try match(EDIF300Parser.Tokens.T__301.rawValue)
		 	setState(4300)
		 	try unitExponent()
		 	setState(4301)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class KeywordMapContext: ParserRuleContext {
			open
			func k0KeywordLevel() -> K0KeywordLevelContext? {
				return getRuleContext(K0KeywordLevelContext.self, 0)
			}
			open
			func k1KeywordLevel() -> K1KeywordLevelContext? {
				return getRuleContext(K1KeywordLevelContext.self, 0)
			}
			open
			func k2KeywordLevel() -> K2KeywordLevelContext? {
				return getRuleContext(K2KeywordLevelContext.self, 0)
			}
			open
			func k3KeywordLevel() -> K3KeywordLevelContext? {
				return getRuleContext(K3KeywordLevelContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_keywordMap
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterKeywordMap(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitKeywordMap(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitKeywordMap(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitKeywordMap(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func keywordMap() throws -> KeywordMapContext {
		var _localctx: KeywordMapContext = KeywordMapContext(_ctx, getState())
		try enterRule(_localctx, 764, EDIF300Parser.RULE_keywordMap)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4303)
		 	try match(EDIF300Parser.Tokens.T__302.rawValue)
		 	setState(4308)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__279:
		 		setState(4304)
		 		try k0KeywordLevel()

		 		break

		 	case .T__281:
		 		setState(4305)
		 		try k1KeywordLevel()

		 		break

		 	case .T__287:
		 		setState(4306)
		 		try k2KeywordLevel()

		 		break

		 	case .T__299:
		 		setState(4307)
		 		try k3KeywordLevel()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4313)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4310)
		 		try comment()


		 		setState(4315)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4316)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class KilogramContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_kilogram
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterKilogram(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitKilogram(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitKilogram(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitKilogram(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func kilogram() throws -> KilogramContext {
		var _localctx: KilogramContext = KilogramContext(_ctx, getState())
		try enterRule(_localctx, 766, EDIF300Parser.RULE_kilogram)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4318)
		 	try match(EDIF300Parser.Tokens.T__303.rawValue)
		 	setState(4319)
		 	try unitExponent()
		 	setState(4320)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LeafContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_leaf
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLeaf(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLeaf(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLeaf(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLeaf(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func leaf() throws -> LeafContext {
		var _localctx: LeafContext = LeafContext(_ctx, getState())
		try enterRule(_localctx, 768, EDIF300Parser.RULE_leaf)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4322)
		 	try match(EDIF300Parser.Tokens.T__304.rawValue)
		 	setState(4323)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LeafOccurrenceAnnotateContext: ParserRuleContext {
			open
			func extendInstanceDef() -> ExtendInstanceDefContext? {
				return getRuleContext(ExtendInstanceDefContext.self, 0)
			}
			open
			func extendInstanceMemberDef() -> ExtendInstanceMemberDefContext? {
				return getRuleContext(ExtendInstanceMemberDefContext.self, 0)
			}
			open
			func cellPropertyOverride() -> [CellPropertyOverrideContext] {
				return getRuleContexts(CellPropertyOverrideContext.self)
			}
			open
			func cellPropertyOverride(_ i: Int) -> CellPropertyOverrideContext? {
				return getRuleContext(CellPropertyOverrideContext.self, i)
			}
			open
			func clusterPropertyOverride() -> [ClusterPropertyOverrideContext] {
				return getRuleContexts(ClusterPropertyOverrideContext.self)
			}
			open
			func clusterPropertyOverride(_ i: Int) -> ClusterPropertyOverrideContext? {
				return getRuleContext(ClusterPropertyOverrideContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func designator() -> [DesignatorContext] {
				return getRuleContexts(DesignatorContext.self)
			}
			open
			func designator(_ i: Int) -> DesignatorContext? {
				return getRuleContext(DesignatorContext.self, i)
			}
			open
			func instancePropertyOverride() -> [InstancePropertyOverrideContext] {
				return getRuleContexts(InstancePropertyOverrideContext.self)
			}
			open
			func instancePropertyOverride(_ i: Int) -> InstancePropertyOverrideContext? {
				return getRuleContext(InstancePropertyOverrideContext.self, i)
			}
			open
			func portAnnotate() -> [PortAnnotateContext] {
				return getRuleContexts(PortAnnotateContext.self)
			}
			open
			func portAnnotate(_ i: Int) -> PortAnnotateContext? {
				return getRuleContext(PortAnnotateContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_leafOccurrenceAnnotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLeafOccurrenceAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLeafOccurrenceAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLeafOccurrenceAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLeafOccurrenceAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func leafOccurrenceAnnotate() throws -> LeafOccurrenceAnnotateContext {
		var _localctx: LeafOccurrenceAnnotateContext = LeafOccurrenceAnnotateContext(_ctx, getState())
		try enterRule(_localctx, 770, EDIF300Parser.RULE_leafOccurrenceAnnotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4325)
		 	try match(EDIF300Parser.Tokens.T__305.rawValue)
		 	setState(4328)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IDENTIFIER:
		 		setState(4326)
		 		try extendInstanceDef()

		 		break

		 	case .T__235:
		 		setState(4327)
		 		try extendInstanceMemberDef()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4339)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__42.rawValue,EDIF300Parser.Tokens.T__58.rawValue,EDIF300Parser.Tokens.T__61.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__118.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__243.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__415.rawValue || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4337)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__42:
		 			setState(4330)
		 			try cellPropertyOverride()

		 			break

		 		case .T__58:
		 			setState(4331)
		 			try clusterPropertyOverride()

		 			break

		 		case .T__61:
		 			setState(4332)
		 			try comment()

		 			break

		 		case .T__118:
		 			setState(4333)
		 			try designator()

		 			break

		 		case .T__243:
		 			setState(4334)
		 			try instancePropertyOverride()

		 			break

		 		case .T__415:
		 			setState(4335)
		 			try portAnnotate()

		 			break

		 		case .T__442:
		 			setState(4336)
		 			try property()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4341)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4342)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LeftJustifyContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_leftJustify
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLeftJustify(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLeftJustify(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLeftJustify(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLeftJustify(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func leftJustify() throws -> LeftJustifyContext {
		var _localctx: LeftJustifyContext = LeftJustifyContext(_ctx, getState())
		try enterRule(_localctx, 772, EDIF300Parser.RULE_leftJustify)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4344)
		 	try match(EDIF300Parser.Tokens.T__306.rawValue)
		 	setState(4345)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LengthValueContext: ParserRuleContext {
			open
			func distanceValue() -> DistanceValueContext? {
				return getRuleContext(DistanceValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_lengthValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLengthValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLengthValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLengthValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLengthValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func lengthValue() throws -> LengthValueContext {
		var _localctx: LengthValueContext = LengthValueContext(_ctx, getState())
		try enterRule(_localctx, 774, EDIF300Parser.RULE_lengthValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4347)
		 	try distanceValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LessThanContext: ParserRuleContext {
			open
			func integerExpression() -> [IntegerExpressionContext] {
				return getRuleContexts(IntegerExpressionContext.self)
			}
			open
			func integerExpression(_ i: Int) -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_lessThan
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLessThan(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLessThan(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLessThan(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLessThan(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func lessThan() throws -> LessThanContext {
		var _localctx: LessThanContext = LessThanContext(_ctx, getState())
		try enterRule(_localctx, 776, EDIF300Parser.RULE_lessThan)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4349)
		 	try match(EDIF300Parser.Tokens.T__307.rawValue)
		 	setState(4353)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__0.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__181.rawValue || _la == EDIF300Parser.Tokens.T__234.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__249.rawValue,EDIF300Parser.Tokens.T__253.rawValue,EDIF300Parser.Tokens.T__254.rawValue,EDIF300Parser.Tokens.T__255.rawValue,EDIF300Parser.Tokens.T__256.rawValue,EDIF300Parser.Tokens.T__257.rawValue,EDIF300Parser.Tokens.T__258.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 250)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__421.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__590.rawValue || _la == EDIF300Parser.Tokens.T__604.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.DECIMAL_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4350)
		 		try integerExpression()


		 		setState(4355)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4356)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LessThanOrEqualContext: ParserRuleContext {
			open
			func integerExpression() -> [IntegerExpressionContext] {
				return getRuleContexts(IntegerExpressionContext.self)
			}
			open
			func integerExpression(_ i: Int) -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_lessThanOrEqual
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLessThanOrEqual(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLessThanOrEqual(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLessThanOrEqual(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLessThanOrEqual(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func lessThanOrEqual() throws -> LessThanOrEqualContext {
		var _localctx: LessThanOrEqualContext = LessThanOrEqualContext(_ctx, getState())
		try enterRule(_localctx, 778, EDIF300Parser.RULE_lessThanOrEqual)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4358)
		 	try match(EDIF300Parser.Tokens.T__308.rawValue)
		 	setState(4362)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__0.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__181.rawValue || _la == EDIF300Parser.Tokens.T__234.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__249.rawValue,EDIF300Parser.Tokens.T__253.rawValue,EDIF300Parser.Tokens.T__254.rawValue,EDIF300Parser.Tokens.T__255.rawValue,EDIF300Parser.Tokens.T__256.rawValue,EDIF300Parser.Tokens.T__257.rawValue,EDIF300Parser.Tokens.T__258.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 250)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__421.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__590.rawValue || _la == EDIF300Parser.Tokens.T__604.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.DECIMAL_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4359)
		 		try integerExpression()


		 		setState(4364)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4365)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryContext: ParserRuleContext {
			open
			func libraryNameDef() -> LibraryNameDefContext? {
				return getRuleContext(LibraryNameDefContext.self, 0)
			}
			open
			func libraryHeader() -> LibraryHeaderContext? {
				return getRuleContext(LibraryHeaderContext.self, 0)
			}
			open
			func cell() -> [CellContext] {
				return getRuleContexts(CellContext.self)
			}
			open
			func cell(_ i: Int) -> CellContext? {
				return getRuleContext(CellContext.self, i)
			}
			open
			func schematicInterconnectTerminatorTemplate() -> [SchematicInterconnectTerminatorTemplateContext] {
				return getRuleContexts(SchematicInterconnectTerminatorTemplateContext.self)
			}
			open
			func schematicInterconnectTerminatorTemplate(_ i: Int) -> SchematicInterconnectTerminatorTemplateContext? {
				return getRuleContext(SchematicInterconnectTerminatorTemplateContext.self, i)
			}
			open
			func schematicJunctionTemplate() -> [SchematicJunctionTemplateContext] {
				return getRuleContexts(SchematicJunctionTemplateContext.self)
			}
			open
			func schematicJunctionTemplate(_ i: Int) -> SchematicJunctionTemplateContext? {
				return getRuleContext(SchematicJunctionTemplateContext.self, i)
			}
			open
			func schematicGlobalPortTemplate() -> [SchematicGlobalPortTemplateContext] {
				return getRuleContexts(SchematicGlobalPortTemplateContext.self)
			}
			open
			func schematicGlobalPortTemplate(_ i: Int) -> SchematicGlobalPortTemplateContext? {
				return getRuleContext(SchematicGlobalPortTemplateContext.self, i)
			}
			open
			func schematicMasterPortTemplate() -> [SchematicMasterPortTemplateContext] {
				return getRuleContexts(SchematicMasterPortTemplateContext.self)
			}
			open
			func schematicMasterPortTemplate(_ i: Int) -> SchematicMasterPortTemplateContext? {
				return getRuleContext(SchematicMasterPortTemplateContext.self, i)
			}
			open
			func schematicOffPageConnectorTemplate() -> [SchematicOffPageConnectorTemplateContext] {
				return getRuleContexts(SchematicOffPageConnectorTemplateContext.self)
			}
			open
			func schematicOffPageConnectorTemplate(_ i: Int) -> SchematicOffPageConnectorTemplateContext? {
				return getRuleContext(SchematicOffPageConnectorTemplateContext.self, i)
			}
			open
			func schematicOnPageConnectorTemplate() -> [SchematicOnPageConnectorTemplateContext] {
				return getRuleContexts(SchematicOnPageConnectorTemplateContext.self)
			}
			open
			func schematicOnPageConnectorTemplate(_ i: Int) -> SchematicOnPageConnectorTemplateContext? {
				return getRuleContext(SchematicOnPageConnectorTemplateContext.self, i)
			}
			open
			func schematicRipperTemplate() -> [SchematicRipperTemplateContext] {
				return getRuleContexts(SchematicRipperTemplateContext.self)
			}
			open
			func schematicRipperTemplate(_ i: Int) -> SchematicRipperTemplateContext? {
				return getRuleContext(SchematicRipperTemplateContext.self, i)
			}
			open
			func schematicSymbolBorderTemplate() -> [SchematicSymbolBorderTemplateContext] {
				return getRuleContexts(SchematicSymbolBorderTemplateContext.self)
			}
			open
			func schematicSymbolBorderTemplate(_ i: Int) -> SchematicSymbolBorderTemplateContext? {
				return getRuleContext(SchematicSymbolBorderTemplateContext.self, i)
			}
			open
			func schematicSymbolPortTemplate() -> [SchematicSymbolPortTemplateContext] {
				return getRuleContexts(SchematicSymbolPortTemplateContext.self)
			}
			open
			func schematicSymbolPortTemplate(_ i: Int) -> SchematicSymbolPortTemplateContext? {
				return getRuleContext(SchematicSymbolPortTemplateContext.self, i)
			}
			open
			func pageBorderTemplate() -> [PageBorderTemplateContext] {
				return getRuleContexts(PageBorderTemplateContext.self)
			}
			open
			func pageBorderTemplate(_ i: Int) -> PageBorderTemplateContext? {
				return getRuleContext(PageBorderTemplateContext.self, i)
			}
			open
			func pageTitleBlockTemplate() -> [PageTitleBlockTemplateContext] {
				return getRuleContexts(PageTitleBlockTemplateContext.self)
			}
			open
			func pageTitleBlockTemplate(_ i: Int) -> PageTitleBlockTemplateContext? {
				return getRuleContext(PageTitleBlockTemplateContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func geometryMacro() -> [GeometryMacroContext] {
				return getRuleContexts(GeometryMacroContext.self)
			}
			open
			func geometryMacro(_ i: Int) -> GeometryMacroContext? {
				return getRuleContext(GeometryMacroContext.self, i)
			}
			open
			func schematicFigureMacro() -> [SchematicFigureMacroContext] {
				return getRuleContexts(SchematicFigureMacroContext.self)
			}
			open
			func schematicFigureMacro(_ i: Int) -> SchematicFigureMacroContext? {
				return getRuleContext(SchematicFigureMacroContext.self, i)
			}
			open
			func schematicForFrameBorderTemplate() -> [SchematicForFrameBorderTemplateContext] {
				return getRuleContexts(SchematicForFrameBorderTemplateContext.self)
			}
			open
			func schematicForFrameBorderTemplate(_ i: Int) -> SchematicForFrameBorderTemplateContext? {
				return getRuleContext(SchematicForFrameBorderTemplateContext.self, i)
			}
			open
			func schematicIfFrameBorderTemplate() -> [SchematicIfFrameBorderTemplateContext] {
				return getRuleContexts(SchematicIfFrameBorderTemplateContext.self)
			}
			open
			func schematicIfFrameBorderTemplate(_ i: Int) -> SchematicIfFrameBorderTemplateContext? {
				return getRuleContext(SchematicIfFrameBorderTemplateContext.self, i)
			}
			open
			func schematicOtherwiseFrameBorderTemplate() -> [SchematicOtherwiseFrameBorderTemplateContext] {
				return getRuleContexts(SchematicOtherwiseFrameBorderTemplateContext.self)
			}
			open
			func schematicOtherwiseFrameBorderTemplate(_ i: Int) -> SchematicOtherwiseFrameBorderTemplateContext? {
				return getRuleContext(SchematicOtherwiseFrameBorderTemplateContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_library
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLibrary(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLibrary(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLibrary(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLibrary(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func library() throws -> LibraryContext {
		var _localctx: LibraryContext = LibraryContext(_ctx, getState())
		try enterRule(_localctx, 780, EDIF300Parser.RULE_library)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4367)
		 	try match(EDIF300Parser.Tokens.T__309.rawValue)
		 	setState(4368)
		 	try libraryNameDef()
		 	setState(4369)
		 	try libraryHeader()
		 	setState(4391)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__37.rawValue || _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__192.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__381.rawValue || _la == EDIF300Parser.Tokens.T__395.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__475.rawValue,EDIF300Parser.Tokens.T__478.rawValue,EDIF300Parser.Tokens.T__486.rawValue,EDIF300Parser.Tokens.T__489.rawValue,EDIF300Parser.Tokens.T__500.rawValue,EDIF300Parser.Tokens.T__504.rawValue,EDIF300Parser.Tokens.T__508.rawValue,EDIF300Parser.Tokens.T__517.rawValue,EDIF300Parser.Tokens.T__521.rawValue,EDIF300Parser.Tokens.T__524.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 476)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__548.rawValue,EDIF300Parser.Tokens.T__557.rawValue,EDIF300Parser.Tokens.T__562.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 549)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4389)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__37:
		 			setState(4370)
		 			try cell()

		 			break

		 		case .T__500:
		 			setState(4371)
		 			try schematicInterconnectTerminatorTemplate()

		 			break

		 		case .T__504:
		 			setState(4372)
		 			try schematicJunctionTemplate()

		 			break

		 		case .T__486:
		 			setState(4373)
		 			try schematicGlobalPortTemplate()

		 			break

		 		case .T__508:
		 			setState(4374)
		 			try schematicMasterPortTemplate()

		 			break

		 		case .T__517:
		 			setState(4375)
		 			try schematicOffPageConnectorTemplate()

		 			break

		 		case .T__521:
		 			setState(4376)
		 			try schematicOnPageConnectorTemplate()

		 			break

		 		case .T__548:
		 			setState(4377)
		 			try schematicRipperTemplate()

		 			break

		 		case .T__557:
		 			setState(4378)
		 			try schematicSymbolBorderTemplate()

		 			break

		 		case .T__562:
		 			setState(4379)
		 			try schematicSymbolPortTemplate()

		 			break

		 		case .T__381:
		 			setState(4380)
		 			try pageBorderTemplate()

		 			break

		 		case .T__395:
		 			setState(4381)
		 			try pageTitleBlockTemplate()

		 			break

		 		case .T__61:
		 			setState(4382)
		 			try comment()

		 			break

		 		case .T__192:
		 			setState(4383)
		 			try geometryMacro()

		 			break

		 		case .T__475:
		 			setState(4384)
		 			try schematicFigureMacro()

		 			break

		 		case .T__478:
		 			setState(4385)
		 			try schematicForFrameBorderTemplate()

		 			break

		 		case .T__489:
		 			setState(4386)
		 			try schematicIfFrameBorderTemplate()

		 			break

		 		case .T__524:
		 			setState(4387)
		 			try schematicOtherwiseFrameBorderTemplate()

		 			break

		 		case .T__642:
		 			setState(4388)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4393)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4394)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryHeaderContext: ParserRuleContext {
			open
			func edifLevel() -> EdifLevelContext? {
				return getRuleContext(EdifLevelContext.self, 0)
			}
			open
			func nameCaseSensitivity() -> NameCaseSensitivityContext? {
				return getRuleContext(NameCaseSensitivityContext.self, 0)
			}
			open
			func technology() -> TechnologyContext? {
				return getRuleContext(TechnologyContext.self, 0)
			}
			open
			func backgroundColor() -> [BackgroundColorContext] {
				return getRuleContexts(BackgroundColorContext.self)
			}
			open
			func backgroundColor(_ i: Int) -> BackgroundColorContext? {
				return getRuleContext(BackgroundColorContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_libraryHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLibraryHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLibraryHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLibraryHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLibraryHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryHeader() throws -> LibraryHeaderContext {
		var _localctx: LibraryHeaderContext = LibraryHeaderContext(_ctx, getState())
		try enterRule(_localctx, 782, EDIF300Parser.RULE_libraryHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4396)
		 	try match(EDIF300Parser.Tokens.T__310.rawValue)
		 	setState(4397)
		 	try edifLevel()
		 	setState(4398)
		 	try nameCaseSensitivity()
		 	setState(4399)
		 	try technology()
		 	setState(4407)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__14.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4405)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__14:
		 			setState(4400)
		 			try backgroundColor()

		 			break

		 		case .T__132:
		 			setState(4401)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(4402)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(4403)
		 			try property()

		 			break

		 		case .T__597:
		 			setState(4404)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4409)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4410)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_libraryNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLibraryNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLibraryNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLibraryNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLibraryNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryNameCaseSensitive() throws -> LibraryNameCaseSensitiveContext {
		var _localctx: LibraryNameCaseSensitiveContext = LibraryNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 784, EDIF300Parser.RULE_libraryNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4412)
		 	try match(EDIF300Parser.Tokens.T__311.rawValue)
		 	setState(4413)
		 	try booleanToken()
		 	setState(4414)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_libraryNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLibraryNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLibraryNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLibraryNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLibraryNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryNameDef() throws -> LibraryNameDefContext {
		var _localctx: LibraryNameDefContext = LibraryNameDefContext(_ctx, getState())
		try enterRule(_localctx, 786, EDIF300Parser.RULE_libraryNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4416)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_libraryNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLibraryNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLibraryNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLibraryNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLibraryNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryNameRef() throws -> LibraryNameRefContext {
		var _localctx: LibraryNameRefContext = LibraryNameRefContext(_ctx, getState())
		try enterRule(_localctx, 788, EDIF300Parser.RULE_libraryNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4418)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryObjectNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_libraryObjectNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLibraryObjectNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLibraryObjectNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLibraryObjectNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLibraryObjectNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryObjectNameCaseSensitive() throws -> LibraryObjectNameCaseSensitiveContext {
		var _localctx: LibraryObjectNameCaseSensitiveContext = LibraryObjectNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 790, EDIF300Parser.RULE_libraryObjectNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4420)
		 	try match(EDIF300Parser.Tokens.T__312.rawValue)
		 	setState(4421)
		 	try booleanToken()
		 	setState(4422)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryObjectNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_libraryObjectNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLibraryObjectNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLibraryObjectNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLibraryObjectNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLibraryObjectNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryObjectNameDef() throws -> LibraryObjectNameDefContext {
		var _localctx: LibraryObjectNameDefContext = LibraryObjectNameDefContext(_ctx, getState())
		try enterRule(_localctx, 792, EDIF300Parser.RULE_libraryObjectNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4424)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryObjectNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_libraryObjectNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLibraryObjectNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLibraryObjectNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLibraryObjectNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLibraryObjectNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryObjectNameRef() throws -> LibraryObjectNameRefContext {
		var _localctx: LibraryObjectNameRefContext = LibraryObjectNameRefContext(_ctx, getState())
		try enterRule(_localctx, 794, EDIF300Parser.RULE_libraryObjectNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4426)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LibraryRefContext: ParserRuleContext {
			open
			func libraryNameRef() -> LibraryNameRefContext? {
				return getRuleContext(LibraryNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_libraryRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLibraryRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLibraryRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLibraryRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLibraryRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func libraryRef() throws -> LibraryRefContext {
		var _localctx: LibraryRefContext = LibraryRefContext(_ctx, getState())
		try enterRule(_localctx, 796, EDIF300Parser.RULE_libraryRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4428)
		 	try match(EDIF300Parser.Tokens.T__313.rawValue)
		 	setState(4429)
		 	try libraryNameRef()
		 	setState(4430)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LoadDelayContext: ParserRuleContext {
			open
			func acLoadFactorTime() -> AcLoadFactorTimeContext? {
				return getRuleContext(AcLoadFactorTimeContext.self, 0)
			}
			open
			func acLoadFactorCapacitance() -> AcLoadFactorCapacitanceContext? {
				return getRuleContext(AcLoadFactorCapacitanceContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_loadDelay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLoadDelay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLoadDelay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLoadDelay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLoadDelay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func loadDelay() throws -> LoadDelayContext {
		var _localctx: LoadDelayContext = LoadDelayContext(_ctx, getState())
		try enterRule(_localctx, 798, EDIF300Parser.RULE_loadDelay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4432)
		 	try match(EDIF300Parser.Tokens.T__314.rawValue)
		 	setState(4433)
		 	try acLoadFactorTime()
		 	setState(4434)
		 	try acLoadFactorCapacitance()
		 	setState(4435)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LocalPortGroupContext: ParserRuleContext {
			open
			func localPortGroupNameDef() -> LocalPortGroupNameDefContext? {
				return getRuleContext(LocalPortGroupNameDefContext.self, 0)
			}
			open
			func portList() -> PortListContext? {
				return getRuleContext(PortListContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_localPortGroup
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLocalPortGroup(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLocalPortGroup(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLocalPortGroup(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLocalPortGroup(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func localPortGroup() throws -> LocalPortGroupContext {
		var _localctx: LocalPortGroupContext = LocalPortGroupContext(_ctx, getState())
		try enterRule(_localctx, 800, EDIF300Parser.RULE_localPortGroup)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4437)
		 	try match(EDIF300Parser.Tokens.T__315.rawValue)
		 	setState(4438)
		 	try localPortGroupNameDef()
		 	setState(4439)
		 	try portList()
		 	setState(4446)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4444)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4440)
		 			try comment()

		 			break

		 		case .T__346:
		 			setState(4441)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(4442)
		 			try property()

		 			break

		 		case .T__642:
		 			setState(4443)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4448)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4449)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LocalPortGroupNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_localPortGroupNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLocalPortGroupNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLocalPortGroupNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLocalPortGroupNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLocalPortGroupNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func localPortGroupNameCaseSensitive() throws -> LocalPortGroupNameCaseSensitiveContext {
		var _localctx: LocalPortGroupNameCaseSensitiveContext = LocalPortGroupNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 802, EDIF300Parser.RULE_localPortGroupNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4451)
		 	try match(EDIF300Parser.Tokens.T__316.rawValue)
		 	setState(4452)
		 	try booleanToken()
		 	setState(4453)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LocalPortGroupNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_localPortGroupNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLocalPortGroupNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLocalPortGroupNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLocalPortGroupNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLocalPortGroupNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func localPortGroupNameDef() throws -> LocalPortGroupNameDefContext {
		var _localctx: LocalPortGroupNameDefContext = LocalPortGroupNameDefContext(_ctx, getState())
		try enterRule(_localctx, 804, EDIF300Parser.RULE_localPortGroupNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4455)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LocalPortGroupNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_localPortGroupNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLocalPortGroupNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLocalPortGroupNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLocalPortGroupNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLocalPortGroupNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func localPortGroupNameRef() throws -> LocalPortGroupNameRefContext {
		var _localctx: LocalPortGroupNameRefContext = LocalPortGroupNameRefContext(_ctx, getState())
		try enterRule(_localctx, 806, EDIF300Parser.RULE_localPortGroupNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4457)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LocalPortGroupRefContext: ParserRuleContext {
			open
			func localPortGroupNameRef() -> LocalPortGroupNameRefContext? {
				return getRuleContext(LocalPortGroupNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_localPortGroupRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLocalPortGroupRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLocalPortGroupRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLocalPortGroupRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLocalPortGroupRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func localPortGroupRef() throws -> LocalPortGroupRefContext {
		var _localctx: LocalPortGroupRefContext = LocalPortGroupRefContext(_ctx, getState())
		try enterRule(_localctx, 808, EDIF300Parser.RULE_localPortGroupRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4459)
		 	try match(EDIF300Parser.Tokens.T__317.rawValue)
		 	setState(4460)
		 	try localPortGroupNameRef()
		 	setState(4461)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicalConnectivityContext: ParserRuleContext {
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func forFrame() -> [ForFrameContext] {
				return getRuleContexts(ForFrameContext.self)
			}
			open
			func forFrame(_ i: Int) -> ForFrameContext? {
				return getRuleContext(ForFrameContext.self, i)
			}
			open
			func ifFrame() -> [IfFrameContext] {
				return getRuleContexts(IfFrameContext.self)
			}
			open
			func ifFrame(_ i: Int) -> IfFrameContext? {
				return getRuleContext(IfFrameContext.self, i)
			}
			open
			func instance() -> [InstanceContext] {
				return getRuleContexts(InstanceContext.self)
			}
			open
			func instance(_ i: Int) -> InstanceContext? {
				return getRuleContext(InstanceContext.self, i)
			}
			open
			func otherwiseFrame() -> [OtherwiseFrameContext] {
				return getRuleContexts(OtherwiseFrameContext.self)
			}
			open
			func otherwiseFrame(_ i: Int) -> OtherwiseFrameContext? {
				return getRuleContext(OtherwiseFrameContext.self, i)
			}
			open
			func signal() -> [SignalContext] {
				return getRuleContexts(SignalContext.self)
			}
			open
			func signal(_ i: Int) -> SignalContext? {
				return getRuleContext(SignalContext.self, i)
			}
			open
			func signalGroup() -> [SignalGroupContext] {
				return getRuleContexts(SignalGroupContext.self)
			}
			open
			func signalGroup(_ i: Int) -> SignalGroupContext? {
				return getRuleContext(SignalGroupContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicalConnectivity
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicalConnectivity(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicalConnectivity(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicalConnectivity(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicalConnectivity(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicalConnectivity() throws -> LogicalConnectivityContext {
		var _localctx: LogicalConnectivityContext = LogicalConnectivityContext(_ctx, getState())
		try enterRule(_localctx, 810, EDIF300Parser.RULE_logicalConnectivity)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4463)
		 	try match(EDIF300Parser.Tokens.T__318.rawValue)
		 	setState(4474)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__176.rawValue,EDIF300Parser.Tokens.T__215.rawValue,EDIF300Parser.Tokens.T__232.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 177)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__371.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__584.rawValue,EDIF300Parser.Tokens.T__586.rawValue,EDIF300Parser.Tokens.T__642.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 585)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4472)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4464)
		 			try comment()

		 			break

		 		case .T__176:
		 			setState(4465)
		 			try forFrame()

		 			break

		 		case .T__215:
		 			setState(4466)
		 			try ifFrame()

		 			break

		 		case .T__232:
		 			setState(4467)
		 			try instance()

		 			break

		 		case .T__371:
		 			setState(4468)
		 			try otherwiseFrame()

		 			break

		 		case .T__584:
		 			setState(4469)
		 			try signal()

		 			break

		 		case .T__586:
		 			setState(4470)
		 			try signalGroup()

		 			break

		 		case .T__642:
		 			setState(4471)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4476)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4477)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicDefinitionsContext: ParserRuleContext {
			open
			func setVoltage() -> SetVoltageContext? {
				return getRuleContext(SetVoltageContext.self, 0)
			}
			open
			func setCurrent() -> SetCurrentContext? {
				return getRuleContext(SetCurrentContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func logicValue() -> [LogicValueContext] {
				return getRuleContexts(LogicValueContext.self)
			}
			open
			func logicValue(_ i: Int) -> LogicValueContext? {
				return getRuleContext(LogicValueContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicDefinitions
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicDefinitions(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicDefinitions(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicDefinitions(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicDefinitions(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicDefinitions() throws -> LogicDefinitionsContext {
		var _localctx: LogicDefinitionsContext = LogicDefinitionsContext(_ctx, getState())
		try enterRule(_localctx, 812, EDIF300Parser.RULE_logicDefinitions)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4479)
		 	try match(EDIF300Parser.Tokens.T__319.rawValue)
		 	setState(4480)
		 	try setVoltage()
		 	setState(4481)
		 	try setCurrent()
		 	setState(4486)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__327.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4484)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4482)
		 			try comment()

		 			break

		 		case .T__327:
		 			setState(4483)
		 			try logicValue()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4488)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4489)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicListContext: ParserRuleContext {
			open
			func ignore() -> [IgnoreContext] {
				return getRuleContexts(IgnoreContext.self)
			}
			open
			func ignore(_ i: Int) -> IgnoreContext? {
				return getRuleContext(IgnoreContext.self, i)
			}
			open
			func logicNameRef() -> [LogicNameRefContext] {
				return getRuleContexts(LogicNameRefContext.self)
			}
			open
			func logicNameRef(_ i: Int) -> LogicNameRefContext? {
				return getRuleContext(LogicNameRefContext.self, i)
			}
			open
			func logicOneOf() -> [LogicOneOfContext] {
				return getRuleContexts(LogicOneOfContext.self)
			}
			open
			func logicOneOf(_ i: Int) -> LogicOneOfContext? {
				return getRuleContext(LogicOneOfContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicList
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicList(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicList(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicList(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicList(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicList() throws -> LogicListContext {
		var _localctx: LogicListContext = LogicListContext(_ctx, getState())
		try enterRule(_localctx, 814, EDIF300Parser.RULE_logicList)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4491)
		 	try match(EDIF300Parser.Tokens.T__320.rawValue)
		 	setState(4497)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__219.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__325.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4495)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__219:
		 			setState(4492)
		 			try ignore()

		 			break

		 		case .IDENTIFIER:
		 			setState(4493)
		 			try logicNameRef()

		 			break

		 		case .T__325:
		 			setState(4494)
		 			try logicOneOf()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4499)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4500)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicMapInputContext: ParserRuleContext {
			open
			func logicRef() -> [LogicRefContext] {
				return getRuleContexts(LogicRefContext.self)
			}
			open
			func logicRef(_ i: Int) -> LogicRefContext? {
				return getRuleContext(LogicRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicMapInput
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicMapInput(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicMapInput(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicMapInput(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicMapInput(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicMapInput() throws -> LogicMapInputContext {
		var _localctx: LogicMapInputContext = LogicMapInputContext(_ctx, getState())
		try enterRule(_localctx, 816, EDIF300Parser.RULE_logicMapInput)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4502)
		 	try match(EDIF300Parser.Tokens.T__321.rawValue)
		 	setState(4506)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__326.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4503)
		 		try logicRef()


		 		setState(4508)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4509)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicMapOutputContext: ParserRuleContext {
			open
			func logicRef() -> [LogicRefContext] {
				return getRuleContexts(LogicRefContext.self)
			}
			open
			func logicRef(_ i: Int) -> LogicRefContext? {
				return getRuleContext(LogicRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicMapOutput
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicMapOutput(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicMapOutput(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicMapOutput(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicMapOutput(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicMapOutput() throws -> LogicMapOutputContext {
		var _localctx: LogicMapOutputContext = LogicMapOutputContext(_ctx, getState())
		try enterRule(_localctx, 818, EDIF300Parser.RULE_logicMapOutput)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4511)
		 	try match(EDIF300Parser.Tokens.T__322.rawValue)
		 	setState(4515)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__326.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4512)
		 		try logicRef()


		 		setState(4517)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4518)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicModelUnitsContext: ParserRuleContext {
			open
			func setCapacitance() -> [SetCapacitanceContext] {
				return getRuleContexts(SetCapacitanceContext.self)
			}
			open
			func setCapacitance(_ i: Int) -> SetCapacitanceContext? {
				return getRuleContext(SetCapacitanceContext.self, i)
			}
			open
			func setTime() -> [SetTimeContext] {
				return getRuleContexts(SetTimeContext.self)
			}
			open
			func setTime(_ i: Int) -> SetTimeContext? {
				return getRuleContext(SetTimeContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicModelUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicModelUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicModelUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicModelUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicModelUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicModelUnits() throws -> LogicModelUnitsContext {
		var _localctx: LogicModelUnitsContext = LogicModelUnitsContext(_ctx, getState())
		try enterRule(_localctx, 820, EDIF300Parser.RULE_logicModelUnits)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4520)
		 	try match(EDIF300Parser.Tokens.T__323.rawValue)
		 	setState(4525)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__576.rawValue || _la == EDIF300Parser.Tokens.T__580.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4523)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__576:
		 			setState(4521)
		 			try setCapacitance()

		 			break

		 		case .T__580:
		 			setState(4522)
		 			try setTime()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4527)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4528)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicModelViewContext: ParserRuleContext {
			open
			func viewNameDef() -> ViewNameDefContext? {
				return getRuleContext(ViewNameDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicModelView
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicModelView(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicModelView(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicModelView(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicModelView(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicModelView() throws -> LogicModelViewContext {
		var _localctx: LogicModelViewContext = LogicModelViewContext(_ctx, getState())
		try enterRule(_localctx, 822, EDIF300Parser.RULE_logicModelView)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4530)
		 	try match(EDIF300Parser.Tokens.T__324.rawValue)
		 	setState(4531)
		 	try viewNameDef()
		 	setState(4537)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4535)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4532)
		 			try comment()

		 			break

		 		case .T__346:
		 			setState(4533)
		 			try nameInformation()

		 			break

		 		case .T__642:
		 			setState(4534)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4539)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4540)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicNameDef() throws -> LogicNameDefContext {
		var _localctx: LogicNameDefContext = LogicNameDefContext(_ctx, getState())
		try enterRule(_localctx, 824, EDIF300Parser.RULE_logicNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4542)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicNameRef() throws -> LogicNameRefContext {
		var _localctx: LogicNameRefContext = LogicNameRefContext(_ctx, getState())
		try enterRule(_localctx, 826, EDIF300Parser.RULE_logicNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4544)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicOneOfContext: ParserRuleContext {
			open
			func logicList() -> [LogicListContext] {
				return getRuleContexts(LogicListContext.self)
			}
			open
			func logicList(_ i: Int) -> LogicListContext? {
				return getRuleContext(LogicListContext.self, i)
			}
			open
			func logicNameRef() -> [LogicNameRefContext] {
				return getRuleContexts(LogicNameRefContext.self)
			}
			open
			func logicNameRef(_ i: Int) -> LogicNameRefContext? {
				return getRuleContext(LogicNameRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicOneOf
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicOneOf(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicOneOf(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicOneOf(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicOneOf(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicOneOf() throws -> LogicOneOfContext {
		var _localctx: LogicOneOfContext = LogicOneOfContext(_ctx, getState())
		try enterRule(_localctx, 828, EDIF300Parser.RULE_logicOneOf)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4546)
		 	try match(EDIF300Parser.Tokens.T__325.rawValue)
		 	setState(4551)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__320.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4549)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__320:
		 			setState(4547)
		 			try logicList()

		 			break

		 		case .IDENTIFIER:
		 			setState(4548)
		 			try logicNameRef()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4553)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4554)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicRefContext: ParserRuleContext {
			open
			func logicNameRef() -> LogicNameRefContext? {
				return getRuleContext(LogicNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicRef() throws -> LogicRefContext {
		var _localctx: LogicRefContext = LogicRefContext(_ctx, getState())
		try enterRule(_localctx, 830, EDIF300Parser.RULE_logicRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4556)
		 	try match(EDIF300Parser.Tokens.T__326.rawValue)
		 	setState(4557)
		 	try logicNameRef()
		 	setState(4559)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4558)
		 		try libraryRef()

		 	}

		 	setState(4561)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicValueContext: ParserRuleContext {
			open
			func logicNameDef() -> LogicNameDefContext? {
				return getRuleContext(LogicNameDefContext.self, 0)
			}
			open
			func booleanMap() -> [BooleanMapContext] {
				return getRuleContexts(BooleanMapContext.self)
			}
			open
			func booleanMap(_ i: Int) -> BooleanMapContext? {
				return getRuleContext(BooleanMapContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func compound() -> [CompoundContext] {
				return getRuleContexts(CompoundContext.self)
			}
			open
			func compound(_ i: Int) -> CompoundContext? {
				return getRuleContext(CompoundContext.self, i)
			}
			open
			func currentMap() -> [CurrentMapContext] {
				return getRuleContexts(CurrentMapContext.self)
			}
			open
			func currentMap(_ i: Int) -> CurrentMapContext? {
				return getRuleContext(CurrentMapContext.self, i)
			}
			open
			func dominates() -> [DominatesContext] {
				return getRuleContexts(DominatesContext.self)
			}
			open
			func dominates(_ i: Int) -> DominatesContext? {
				return getRuleContext(DominatesContext.self, i)
			}
			open
			func isolated() -> [IsolatedContext] {
				return getRuleContexts(IsolatedContext.self)
			}
			open
			func isolated(_ i: Int) -> IsolatedContext? {
				return getRuleContext(IsolatedContext.self, i)
			}
			open
			func logicMapInput() -> [LogicMapInputContext] {
				return getRuleContexts(LogicMapInputContext.self)
			}
			open
			func logicMapInput(_ i: Int) -> LogicMapInputContext? {
				return getRuleContext(LogicMapInputContext.self, i)
			}
			open
			func logicMapOutput() -> [LogicMapOutputContext] {
				return getRuleContexts(LogicMapOutputContext.self)
			}
			open
			func logicMapOutput(_ i: Int) -> LogicMapOutputContext? {
				return getRuleContext(LogicMapOutputContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func resolves() -> [ResolvesContext] {
				return getRuleContexts(ResolvesContext.self)
			}
			open
			func resolves(_ i: Int) -> ResolvesContext? {
				return getRuleContext(ResolvesContext.self, i)
			}
			open
			func strong() -> [StrongContext] {
				return getRuleContexts(StrongContext.self)
			}
			open
			func strong(_ i: Int) -> StrongContext? {
				return getRuleContext(StrongContext.self, i)
			}
			open
			func voltageMap() -> [VoltageMapContext] {
				return getRuleContexts(VoltageMapContext.self)
			}
			open
			func voltageMap(_ i: Int) -> VoltageMapContext? {
				return getRuleContext(VoltageMapContext.self, i)
			}
			open
			func weak() -> [WeakContext] {
				return getRuleContexts(WeakContext.self)
			}
			open
			func weak(_ i: Int) -> WeakContext? {
				return getRuleContext(WeakContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_logicValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLogicValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLogicValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLogicValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLogicValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func logicValue() throws -> LogicValueContext {
		var _localctx: LogicValueContext = LogicValueContext(_ctx, getState())
		try enterRule(_localctx, 832, EDIF300Parser.RULE_logicValue)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4563)
		 	try match(EDIF300Parser.Tokens.T__327.rawValue)
		 	setState(4564)
		 	try logicNameDef()
		 	setState(4581)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__26.rawValue,EDIF300Parser.Tokens.T__61.rawValue,EDIF300Parser.Tokens.T__69.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 27)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__99.rawValue || _la == EDIF300Parser.Tokens.T__136.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__273.rawValue,EDIF300Parser.Tokens.T__321.rawValue,EDIF300Parser.Tokens.T__322.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 274)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue || _la == EDIF300Parser.Tokens.T__459.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__610.rawValue,EDIF300Parser.Tokens.T__656.rawValue,EDIF300Parser.Tokens.T__658.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 611)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4579)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__26:
		 			setState(4565)
		 			try booleanMap()

		 			break

		 		case .T__61:
		 			setState(4566)
		 			try comment()

		 			break

		 		case .T__69:
		 			setState(4567)
		 			try compound()

		 			break

		 		case .T__99:
		 			setState(4568)
		 			try currentMap()

		 			break

		 		case .T__136:
		 			setState(4569)
		 			try dominates()

		 			break

		 		case .T__273:
		 			setState(4570)
		 			try isolated()

		 			break

		 		case .T__321:
		 			setState(4571)
		 			try logicMapInput()

		 			break

		 		case .T__322:
		 			setState(4572)
		 			try logicMapOutput()

		 			break

		 		case .T__346:
		 			setState(4573)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(4574)
		 			try property()

		 			break

		 		case .T__459:
		 			setState(4575)
		 			try resolves()

		 			break

		 		case .T__610:
		 			setState(4576)
		 			try strong()

		 			break

		 		case .T__656:
		 			setState(4577)
		 			try voltageMap()

		 			break

		 		case .T__658:
		 			setState(4578)
		 			try weak()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4583)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4584)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LsbToMsbContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_lsbToMsb
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterLsbToMsb(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitLsbToMsb(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitLsbToMsb(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitLsbToMsb(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func lsbToMsb() throws -> LsbToMsbContext {
		var _localctx: LsbToMsbContext = LsbToMsbContext(_ctx, getState())
		try enterRule(_localctx, 834, EDIF300Parser.RULE_lsbToMsb)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4586)
		 	try match(EDIF300Parser.Tokens.T__328.rawValue)
		 	setState(4587)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MantissaContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_mantissa
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMantissa(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMantissa(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMantissa(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMantissa(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mantissa() throws -> MantissaContext {
		var _localctx: MantissaContext = MantissaContext(_ctx, getState())
		try enterRule(_localctx, 836, EDIF300Parser.RULE_mantissa)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4589)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MarkContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_mark
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMark(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMark(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMark(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMark(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mark() throws -> MarkContext {
		var _localctx: MarkContext = MarkContext(_ctx, getState())
		try enterRule(_localctx, 838, EDIF300Parser.RULE_mark)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4591)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MaskLayoutUnitsContext: ParserRuleContext {
			open
			func setAngle() -> [SetAngleContext] {
				return getRuleContexts(SetAngleContext.self)
			}
			open
			func setAngle(_ i: Int) -> SetAngleContext? {
				return getRuleContext(SetAngleContext.self, i)
			}
			open
			func setCapacitance() -> [SetCapacitanceContext] {
				return getRuleContexts(SetCapacitanceContext.self)
			}
			open
			func setCapacitance(_ i: Int) -> SetCapacitanceContext? {
				return getRuleContext(SetCapacitanceContext.self, i)
			}
			open
			func setDistance() -> [SetDistanceContext] {
				return getRuleContexts(SetDistanceContext.self)
			}
			open
			func setDistance(_ i: Int) -> SetDistanceContext? {
				return getRuleContext(SetDistanceContext.self, i)
			}
			open
			func setTime() -> [SetTimeContext] {
				return getRuleContexts(SetTimeContext.self)
			}
			open
			func setTime(_ i: Int) -> SetTimeContext? {
				return getRuleContext(SetTimeContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_maskLayoutUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMaskLayoutUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMaskLayoutUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMaskLayoutUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMaskLayoutUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func maskLayoutUnits() throws -> MaskLayoutUnitsContext {
		var _localctx: MaskLayoutUnitsContext = MaskLayoutUnitsContext(_ctx, getState())
		try enterRule(_localctx, 840, EDIF300Parser.RULE_maskLayoutUnits)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4593)
		 	try match(EDIF300Parser.Tokens.T__329.rawValue)
		 	setState(4600)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__575.rawValue,EDIF300Parser.Tokens.T__576.rawValue,EDIF300Parser.Tokens.T__578.rawValue,EDIF300Parser.Tokens.T__580.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 576)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(4598)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__575:
		 			setState(4594)
		 			try setAngle()

		 			break

		 		case .T__576:
		 			setState(4595)
		 			try setCapacitance()

		 			break

		 		case .T__578:
		 			setState(4596)
		 			try setDistance()

		 			break

		 		case .T__580:
		 			setState(4597)
		 			try setTime()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4602)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4603)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MaskLayoutViewContext: ParserRuleContext {
			open
			func viewNameDef() -> ViewNameDefContext? {
				return getRuleContext(ViewNameDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_maskLayoutView
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMaskLayoutView(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMaskLayoutView(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMaskLayoutView(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMaskLayoutView(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func maskLayoutView() throws -> MaskLayoutViewContext {
		var _localctx: MaskLayoutViewContext = MaskLayoutViewContext(_ctx, getState())
		try enterRule(_localctx, 842, EDIF300Parser.RULE_maskLayoutView)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4605)
		 	try match(EDIF300Parser.Tokens.T__330.rawValue)
		 	setState(4606)
		 	try viewNameDef()
		 	setState(4612)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4610)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4607)
		 			try comment()

		 			break

		 		case .T__346:
		 			setState(4608)
		 			try nameInformation()

		 			break

		 		case .T__642:
		 			setState(4609)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4614)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4615)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MeasuredContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_measured
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMeasured(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMeasured(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMeasured(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMeasured(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func measured() throws -> MeasuredContext {
		var _localctx: MeasuredContext = MeasuredContext(_ctx, getState())
		try enterRule(_localctx, 844, EDIF300Parser.RULE_measured)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4617)
		 	try match(EDIF300Parser.Tokens.T__331.rawValue)
		 	setState(4618)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MeterContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_meter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMeter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMeter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMeter(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMeter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func meter() throws -> MeterContext {
		var _localctx: MeterContext = MeterContext(_ctx, getState())
		try enterRule(_localctx, 846, EDIF300Parser.RULE_meter)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4620)
		 	try match(EDIF300Parser.Tokens.T__332.rawValue)
		 	setState(4621)
		 	try unitExponent()
		 	setState(4622)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MiddleJustifyContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_middleJustify
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMiddleJustify(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMiddleJustify(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMiddleJustify(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMiddleJustify(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func middleJustify() throws -> MiddleJustifyContext {
		var _localctx: MiddleJustifyContext = MiddleJustifyContext(_ctx, getState())
		try enterRule(_localctx, 848, EDIF300Parser.RULE_middleJustify)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4624)
		 	try match(EDIF300Parser.Tokens.T__333.rawValue)
		 	setState(4625)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MinimalWidthContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_minimalWidth
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMinimalWidth(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMinimalWidth(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMinimalWidth(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMinimalWidth(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func minimalWidth() throws -> MinimalWidthContext {
		var _localctx: MinimalWidthContext = MinimalWidthContext(_ctx, getState())
		try enterRule(_localctx, 850, EDIF300Parser.RULE_minimalWidth)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4627)
		 	try match(EDIF300Parser.Tokens.T__334.rawValue)
		 	setState(4628)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MinimumStringLengthContext: ParserRuleContext {
			open
			func substringLength() -> SubstringLengthContext? {
				return getRuleContext(SubstringLengthContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_minimumStringLength
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMinimumStringLength(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMinimumStringLength(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMinimumStringLength(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMinimumStringLength(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func minimumStringLength() throws -> MinimumStringLengthContext {
		var _localctx: MinimumStringLengthContext = MinimumStringLengthContext(_ctx, getState())
		try enterRule(_localctx, 852, EDIF300Parser.RULE_minimumStringLength)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4630)
		 	try match(EDIF300Parser.Tokens.T__335.rawValue)
		 	setState(4631)
		 	try substringLength()
		 	setState(4632)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MiNoMaxContext: ParserRuleContext {
			open
			func miNoMaxValue() -> MiNoMaxValueContext? {
				return getRuleContext(MiNoMaxValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_miNoMax
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMiNoMax(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMiNoMax(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMiNoMax(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMiNoMax(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func miNoMax() throws -> MiNoMaxContext {
		var _localctx: MiNoMaxContext = MiNoMaxContext(_ctx, getState())
		try enterRule(_localctx, 854, EDIF300Parser.RULE_miNoMax)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4634)
		 	try match(EDIF300Parser.Tokens.T__336.rawValue)
		 	setState(4635)
		 	try miNoMaxValue()
		 	setState(4636)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MiNoMaxValueContext: ParserRuleContext {
			open
			func numberValue() -> NumberValueContext? {
				return getRuleContext(NumberValueContext.self, 0)
			}
			open
			func mnm() -> MnmContext? {
				return getRuleContext(MnmContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_miNoMaxValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMiNoMaxValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMiNoMaxValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMiNoMaxValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMiNoMaxValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func miNoMaxValue() throws -> MiNoMaxValueContext {
		var _localctx: MiNoMaxValueContext = MiNoMaxValueContext(_ctx, getState())
		try enterRule(_localctx, 856, EDIF300Parser.RULE_miNoMaxValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4640)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__145:fallthrough
		 	case .DECIMAL_LITERAL:
		 		setState(4638)
		 		try numberValue()

		 		break

		 	case .T__338:
		 		setState(4639)
		 		try mnm()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MinuendContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_minuend
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMinuend(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMinuend(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMinuend(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMinuend(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func minuend() throws -> MinuendContext {
		var _localctx: MinuendContext = MinuendContext(_ctx, getState())
		try enterRule(_localctx, 858, EDIF300Parser.RULE_minuend)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4642)
		 	try integerExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MinuteNumberContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_minuteNumber
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMinuteNumber(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMinuteNumber(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMinuteNumber(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMinuteNumber(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func minuteNumber() throws -> MinuteNumberContext {
		var _localctx: MinuteNumberContext = MinuteNumberContext(_ctx, getState())
		try enterRule(_localctx, 860, EDIF300Parser.RULE_minuteNumber)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4644)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MixedDirectionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_mixedDirection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMixedDirection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMixedDirection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMixedDirection(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMixedDirection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mixedDirection() throws -> MixedDirectionContext {
		var _localctx: MixedDirectionContext = MixedDirectionContext(_ctx, getState())
		try enterRule(_localctx, 862, EDIF300Parser.RULE_mixedDirection)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4646)
		 	try match(EDIF300Parser.Tokens.T__337.rawValue)
		 	setState(4647)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MnmContext: ParserRuleContext {
			open
			func numberValue() -> [NumberValueContext] {
				return getRuleContexts(NumberValueContext.self)
			}
			open
			func numberValue(_ i: Int) -> NumberValueContext? {
				return getRuleContext(NumberValueContext.self, i)
			}
			open
			func undefined() -> [UndefinedContext] {
				return getRuleContexts(UndefinedContext.self)
			}
			open
			func undefined(_ i: Int) -> UndefinedContext? {
				return getRuleContext(UndefinedContext.self, i)
			}
			open
			func unconstrained() -> [UnconstrainedContext] {
				return getRuleContexts(UnconstrainedContext.self)
			}
			open
			func unconstrained(_ i: Int) -> UnconstrainedContext? {
				return getRuleContext(UnconstrainedContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_mnm
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMnm(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMnm(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMnm(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMnm(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mnm() throws -> MnmContext {
		var _localctx: MnmContext = MnmContext(_ctx, getState())
		try enterRule(_localctx, 864, EDIF300Parser.RULE_mnm)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4649)
		 	try match(EDIF300Parser.Tokens.T__338.rawValue)
		 	setState(4653)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__145:fallthrough
		 	case .DECIMAL_LITERAL:
		 		setState(4650)
		 		try numberValue()

		 		break

		 	case .T__632:
		 		setState(4651)
		 		try undefined()

		 		break

		 	case .T__631:
		 		setState(4652)
		 		try unconstrained()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4658)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__145:fallthrough
		 	case .DECIMAL_LITERAL:
		 		setState(4655)
		 		try numberValue()

		 		break

		 	case .T__632:
		 		setState(4656)
		 		try undefined()

		 		break

		 	case .T__631:
		 		setState(4657)
		 		try unconstrained()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4663)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__145:fallthrough
		 	case .DECIMAL_LITERAL:
		 		setState(4660)
		 		try numberValue()

		 		break

		 	case .T__632:
		 		setState(4661)
		 		try undefined()

		 		break

		 	case .T__631:
		 		setState(4662)
		 		try unconstrained()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4665)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MoleContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_mole
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMole(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMole(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMole(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMole(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mole() throws -> MoleContext {
		var _localctx: MoleContext = MoleContext(_ctx, getState())
		try enterRule(_localctx, 866, EDIF300Parser.RULE_mole)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4667)
		 	try match(EDIF300Parser.Tokens.T__339.rawValue)
		 	setState(4668)
		 	try unitExponent()
		 	setState(4669)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MonthNumberContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_monthNumber
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMonthNumber(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMonthNumber(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMonthNumber(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMonthNumber(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func monthNumber() throws -> MonthNumberContext {
		var _localctx: MonthNumberContext = MonthNumberContext(_ctx, getState())
		try enterRule(_localctx, 868, EDIF300Parser.RULE_monthNumber)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4671)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MsbToLsbContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_msbToLsb
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMsbToLsb(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMsbToLsb(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMsbToLsb(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMsbToLsb(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func msbToLsb() throws -> MsbToLsbContext {
		var _localctx: MsbToLsbContext = MsbToLsbContext(_ctx, getState())
		try enterRule(_localctx, 870, EDIF300Parser.RULE_msbToLsb)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4673)
		 	try match(EDIF300Parser.Tokens.T__340.rawValue)
		 	setState(4674)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MustJoinContext: ParserRuleContext {
			open
			func interfaceJoined() -> [InterfaceJoinedContext] {
				return getRuleContexts(InterfaceJoinedContext.self)
			}
			open
			func interfaceJoined(_ i: Int) -> InterfaceJoinedContext? {
				return getRuleContext(InterfaceJoinedContext.self, i)
			}
			open
			func portRef() -> [PortRefContext] {
				return getRuleContexts(PortRefContext.self)
			}
			open
			func portRef(_ i: Int) -> PortRefContext? {
				return getRuleContext(PortRefContext.self, i)
			}
			open
			func weakJoined() -> [WeakJoinedContext] {
				return getRuleContexts(WeakJoinedContext.self)
			}
			open
			func weakJoined(_ i: Int) -> WeakJoinedContext? {
				return getRuleContext(WeakJoinedContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_mustJoin
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterMustJoin(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitMustJoin(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitMustJoin(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitMustJoin(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func mustJoin() throws -> MustJoinContext {
		var _localctx: MustJoinContext = MustJoinContext(_ctx, getState())
		try enterRule(_localctx, 872, EDIF300Parser.RULE_mustJoin)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4676)
		 	try match(EDIF300Parser.Tokens.T__341.rawValue)
		 	setState(4682)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__270.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__436.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__659.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4680)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__270:
		 			setState(4677)
		 			try interfaceJoined()

		 			break

		 		case .T__436:
		 			setState(4678)
		 			try portRef()

		 			break

		 		case .T__659:
		 			setState(4679)
		 			try weakJoined()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4684)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4685)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NameAliasContext: ParserRuleContext {
			open
			func originalName() -> OriginalNameContext? {
				return getRuleContext(OriginalNameContext.self, 0)
			}
			open
			func displayName() -> [DisplayNameContext] {
				return getRuleContexts(DisplayNameContext.self)
			}
			open
			func displayName(_ i: Int) -> DisplayNameContext? {
				return getRuleContext(DisplayNameContext.self, i)
			}
			open
			func generated() -> [GeneratedContext] {
				return getRuleContexts(GeneratedContext.self)
			}
			open
			func generated(_ i: Int) -> GeneratedContext? {
				return getRuleContext(GeneratedContext.self, i)
			}
			open
			func nameStructure() -> [NameStructureContext] {
				return getRuleContexts(NameStructureContext.self)
			}
			open
			func nameStructure(_ i: Int) -> NameStructureContext? {
				return getRuleContext(NameStructureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_nameAlias
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNameAlias(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNameAlias(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNameAlias(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNameAlias(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func nameAlias() throws -> NameAliasContext {
		var _localctx: NameAliasContext = NameAliasContext(_ctx, getState())
		try enterRule(_localctx, 874, EDIF300Parser.RULE_nameAlias)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4687)
		 	try match(EDIF300Parser.Tokens.T__342.rawValue)
		 	setState(4688)
		 	try originalName()
		 	setState(4694)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__130.rawValue || _la == EDIF300Parser.Tokens.T__191.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__348.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4692)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__130:
		 			setState(4689)
		 			try displayName()

		 			break

		 		case .T__191:
		 			setState(4690)
		 			try generated()

		 			break

		 		case .T__348:
		 			setState(4691)
		 			try nameStructure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4696)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4697)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NameCaseSensitivityContext: ParserRuleContext {
			open
			func clusterConfigurationNameCaseSensitive() -> [ClusterConfigurationNameCaseSensitiveContext] {
				return getRuleContexts(ClusterConfigurationNameCaseSensitiveContext.self)
			}
			open
			func clusterConfigurationNameCaseSensitive(_ i: Int) -> ClusterConfigurationNameCaseSensitiveContext? {
				return getRuleContext(ClusterConfigurationNameCaseSensitiveContext.self, i)
			}
			open
			func clusterNameCaseSensitive() -> [ClusterNameCaseSensitiveContext] {
				return getRuleContexts(ClusterNameCaseSensitiveContext.self)
			}
			open
			func clusterNameCaseSensitive(_ i: Int) -> ClusterNameCaseSensitiveContext? {
				return getRuleContext(ClusterNameCaseSensitiveContext.self, i)
			}
			open
			func designHierarchyNameCaseSensitive() -> [DesignHierarchyNameCaseSensitiveContext] {
				return getRuleContexts(DesignHierarchyNameCaseSensitiveContext.self)
			}
			open
			func designHierarchyNameCaseSensitive(_ i: Int) -> DesignHierarchyNameCaseSensitiveContext? {
				return getRuleContext(DesignHierarchyNameCaseSensitiveContext.self, i)
			}
			open
			func designNameCaseSensitive() -> [DesignNameCaseSensitiveContext] {
				return getRuleContexts(DesignNameCaseSensitiveContext.self)
			}
			open
			func designNameCaseSensitive(_ i: Int) -> DesignNameCaseSensitiveContext? {
				return getRuleContext(DesignNameCaseSensitiveContext.self, i)
			}
			open
			func documentationNameCaseSensitive() -> [DocumentationNameCaseSensitiveContext] {
				return getRuleContexts(DocumentationNameCaseSensitiveContext.self)
			}
			open
			func documentationNameCaseSensitive(_ i: Int) -> DocumentationNameCaseSensitiveContext? {
				return getRuleContext(DocumentationNameCaseSensitiveContext.self, i)
			}
			open
			func figureGroupNameCaseSensitive() -> [FigureGroupNameCaseSensitiveContext] {
				return getRuleContexts(FigureGroupNameCaseSensitiveContext.self)
			}
			open
			func figureGroupNameCaseSensitive(_ i: Int) -> FigureGroupNameCaseSensitiveContext? {
				return getRuleContext(FigureGroupNameCaseSensitiveContext.self, i)
			}
			open
			func forFrameIndexNameCaseSensitive() -> [ForFrameIndexNameCaseSensitiveContext] {
				return getRuleContexts(ForFrameIndexNameCaseSensitiveContext.self)
			}
			open
			func forFrameIndexNameCaseSensitive(_ i: Int) -> ForFrameIndexNameCaseSensitiveContext? {
				return getRuleContext(ForFrameIndexNameCaseSensitiveContext.self, i)
			}
			open
			func frameNameCaseSensitive() -> [FrameNameCaseSensitiveContext] {
				return getRuleContexts(FrameNameCaseSensitiveContext.self)
			}
			open
			func frameNameCaseSensitive(_ i: Int) -> FrameNameCaseSensitiveContext? {
				return getRuleContext(FrameNameCaseSensitiveContext.self, i)
			}
			open
			func globalPortNameCaseSensitive() -> [GlobalPortNameCaseSensitiveContext] {
				return getRuleContexts(GlobalPortNameCaseSensitiveContext.self)
			}
			open
			func globalPortNameCaseSensitive(_ i: Int) -> GlobalPortNameCaseSensitiveContext? {
				return getRuleContext(GlobalPortNameCaseSensitiveContext.self, i)
			}
			open
			func hotspotNameCaseSensitive() -> [HotspotNameCaseSensitiveContext] {
				return getRuleContexts(HotspotNameCaseSensitiveContext.self)
			}
			open
			func hotspotNameCaseSensitive(_ i: Int) -> HotspotNameCaseSensitiveContext? {
				return getRuleContext(HotspotNameCaseSensitiveContext.self, i)
			}
			open
			func implementationNameCaseSensitive() -> [ImplementationNameCaseSensitiveContext] {
				return getRuleContexts(ImplementationNameCaseSensitiveContext.self)
			}
			open
			func implementationNameCaseSensitive(_ i: Int) -> ImplementationNameCaseSensitiveContext? {
				return getRuleContext(ImplementationNameCaseSensitiveContext.self, i)
			}
			open
			func instanceNameCaseSensitive() -> [InstanceNameCaseSensitiveContext] {
				return getRuleContexts(InstanceNameCaseSensitiveContext.self)
			}
			open
			func instanceNameCaseSensitive(_ i: Int) -> InstanceNameCaseSensitiveContext? {
				return getRuleContext(InstanceNameCaseSensitiveContext.self, i)
			}
			open
			func interconnectNameCaseSensitive() -> [InterconnectNameCaseSensitiveContext] {
				return getRuleContexts(InterconnectNameCaseSensitiveContext.self)
			}
			open
			func interconnectNameCaseSensitive(_ i: Int) -> InterconnectNameCaseSensitiveContext? {
				return getRuleContext(InterconnectNameCaseSensitiveContext.self, i)
			}
			open
			func libraryNameCaseSensitive() -> [LibraryNameCaseSensitiveContext] {
				return getRuleContexts(LibraryNameCaseSensitiveContext.self)
			}
			open
			func libraryNameCaseSensitive(_ i: Int) -> LibraryNameCaseSensitiveContext? {
				return getRuleContext(LibraryNameCaseSensitiveContext.self, i)
			}
			open
			func libraryObjectNameCaseSensitive() -> [LibraryObjectNameCaseSensitiveContext] {
				return getRuleContexts(LibraryObjectNameCaseSensitiveContext.self)
			}
			open
			func libraryObjectNameCaseSensitive(_ i: Int) -> LibraryObjectNameCaseSensitiveContext? {
				return getRuleContext(LibraryObjectNameCaseSensitiveContext.self, i)
			}
			open
			func localPortGroupNameCaseSensitive() -> [LocalPortGroupNameCaseSensitiveContext] {
				return getRuleContexts(LocalPortGroupNameCaseSensitiveContext.self)
			}
			open
			func localPortGroupNameCaseSensitive(_ i: Int) -> LocalPortGroupNameCaseSensitiveContext? {
				return getRuleContext(LocalPortGroupNameCaseSensitiveContext.self, i)
			}
			open
			func pageNameCaseSensitive() -> [PageNameCaseSensitiveContext] {
				return getRuleContexts(PageNameCaseSensitiveContext.self)
			}
			open
			func pageNameCaseSensitive(_ i: Int) -> PageNameCaseSensitiveContext? {
				return getRuleContext(PageNameCaseSensitiveContext.self, i)
			}
			open
			func parameterNameCaseSensitive() -> [ParameterNameCaseSensitiveContext] {
				return getRuleContexts(ParameterNameCaseSensitiveContext.self)
			}
			open
			func parameterNameCaseSensitive(_ i: Int) -> ParameterNameCaseSensitiveContext? {
				return getRuleContext(ParameterNameCaseSensitiveContext.self, i)
			}
			open
			func portNameCaseSensitive() -> [PortNameCaseSensitiveContext] {
				return getRuleContexts(PortNameCaseSensitiveContext.self)
			}
			open
			func portNameCaseSensitive(_ i: Int) -> PortNameCaseSensitiveContext? {
				return getRuleContext(PortNameCaseSensitiveContext.self, i)
			}
			open
			func propertyNameCaseSensitive() -> [PropertyNameCaseSensitiveContext] {
				return getRuleContexts(PropertyNameCaseSensitiveContext.self)
			}
			open
			func propertyNameCaseSensitive(_ i: Int) -> PropertyNameCaseSensitiveContext? {
				return getRuleContext(PropertyNameCaseSensitiveContext.self, i)
			}
			open
			func signalGroupNameCaseSensitive() -> [SignalGroupNameCaseSensitiveContext] {
				return getRuleContexts(SignalGroupNameCaseSensitiveContext.self)
			}
			open
			func signalGroupNameCaseSensitive(_ i: Int) -> SignalGroupNameCaseSensitiveContext? {
				return getRuleContext(SignalGroupNameCaseSensitiveContext.self, i)
			}
			open
			func signalNameCaseSensitive() -> [SignalNameCaseSensitiveContext] {
				return getRuleContexts(SignalNameCaseSensitiveContext.self)
			}
			open
			func signalNameCaseSensitive(_ i: Int) -> SignalNameCaseSensitiveContext? {
				return getRuleContext(SignalNameCaseSensitiveContext.self, i)
			}
			open
			func viewGroupNameCaseSensitive() -> [ViewGroupNameCaseSensitiveContext] {
				return getRuleContexts(ViewGroupNameCaseSensitiveContext.self)
			}
			open
			func viewGroupNameCaseSensitive(_ i: Int) -> ViewGroupNameCaseSensitiveContext? {
				return getRuleContext(ViewGroupNameCaseSensitiveContext.self, i)
			}
			open
			func viewNameCaseSensitive() -> [ViewNameCaseSensitiveContext] {
				return getRuleContexts(ViewNameCaseSensitiveContext.self)
			}
			open
			func viewNameCaseSensitive(_ i: Int) -> ViewNameCaseSensitiveContext? {
				return getRuleContext(ViewNameCaseSensitiveContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_nameCaseSensitivity
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNameCaseSensitivity(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNameCaseSensitivity(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNameCaseSensitivity(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNameCaseSensitivity(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func nameCaseSensitivity() throws -> NameCaseSensitivityContext {
		var _localctx: NameCaseSensitivityContext = NameCaseSensitivityContext(_ctx, getState())
		try enterRule(_localctx, 876, EDIF300Parser.RULE_nameCaseSensitivity)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4699)
		 	try match(EDIF300Parser.Tokens.T__343.rawValue)
		 	setState(4726)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__52.rawValue || _la == EDIF300Parser.Tokens.T__55.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__123.rawValue,EDIF300Parser.Tokens.T__124.rawValue,EDIF300Parser.Tokens.T__134.rawValue,EDIF300Parser.Tokens.T__161.rawValue,EDIF300Parser.Tokens.T__180.rawValue,EDIF300Parser.Tokens.T__185.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 124)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__200.rawValue,EDIF300Parser.Tokens.T__211.rawValue,EDIF300Parser.Tokens.T__220.rawValue,EDIF300Parser.Tokens.T__236.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 201)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__264.rawValue,EDIF300Parser.Tokens.T__311.rawValue,EDIF300Parser.Tokens.T__312.rawValue,EDIF300Parser.Tokens.T__316.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 265)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__387.rawValue,EDIF300Parser.Tokens.T__399.rawValue,EDIF300Parser.Tokens.T__429.rawValue,EDIF300Parser.Tokens.T__446.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 388)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__588.rawValue,EDIF300Parser.Tokens.T__594.rawValue,EDIF300Parser.Tokens.T__647.rawValue,EDIF300Parser.Tokens.T__649.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 589)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4724)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__52:
		 			setState(4700)
		 			try clusterConfigurationNameCaseSensitive()

		 			break

		 		case .T__55:
		 			setState(4701)
		 			try clusterNameCaseSensitive()

		 			break

		 		case .T__123:
		 			setState(4702)
		 			try designHierarchyNameCaseSensitive()

		 			break

		 		case .T__124:
		 			setState(4703)
		 			try designNameCaseSensitive()

		 			break

		 		case .T__134:
		 			setState(4704)
		 			try documentationNameCaseSensitive()

		 			break

		 		case .T__161:
		 			setState(4705)
		 			try figureGroupNameCaseSensitive()

		 			break

		 		case .T__180:
		 			setState(4706)
		 			try forFrameIndexNameCaseSensitive()

		 			break

		 		case .T__185:
		 			setState(4707)
		 			try frameNameCaseSensitive()

		 			break

		 		case .T__200:
		 			setState(4708)
		 			try globalPortNameCaseSensitive()

		 			break

		 		case .T__211:
		 			setState(4709)
		 			try hotspotNameCaseSensitive()

		 			break

		 		case .T__220:
		 			setState(4710)
		 			try implementationNameCaseSensitive()

		 			break

		 		case .T__236:
		 			setState(4711)
		 			try instanceNameCaseSensitive()

		 			break

		 		case .T__264:
		 			setState(4712)
		 			try interconnectNameCaseSensitive()

		 			break

		 		case .T__311:
		 			setState(4713)
		 			try libraryNameCaseSensitive()

		 			break

		 		case .T__312:
		 			setState(4714)
		 			try libraryObjectNameCaseSensitive()

		 			break

		 		case .T__316:
		 			setState(4715)
		 			try localPortGroupNameCaseSensitive()

		 			break

		 		case .T__387:
		 			setState(4716)
		 			try pageNameCaseSensitive()

		 			break

		 		case .T__399:
		 			setState(4717)
		 			try parameterNameCaseSensitive()

		 			break

		 		case .T__429:
		 			setState(4718)
		 			try portNameCaseSensitive()

		 			break

		 		case .T__446:
		 			setState(4719)
		 			try propertyNameCaseSensitive()

		 			break

		 		case .T__588:
		 			setState(4720)
		 			try signalGroupNameCaseSensitive()

		 			break

		 		case .T__594:
		 			setState(4721)
		 			try signalNameCaseSensitive()

		 			break

		 		case .T__647:
		 			setState(4722)
		 			try viewGroupNameCaseSensitive()

		 			break

		 		case .T__649:
		 			setState(4723)
		 			try viewNameCaseSensitive()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4728)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4729)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NameDefContext: ParserRuleContext {
			open
			func IDENTIFIER() -> TerminalNode? {
				return getToken(EDIF300Parser.Tokens.IDENTIFIER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_nameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func nameDef() throws -> NameDefContext {
		var _localctx: NameDefContext = NameDefContext(_ctx, getState())
		try enterRule(_localctx, 878, EDIF300Parser.RULE_nameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4731)
		 	try match(EDIF300Parser.Tokens.IDENTIFIER.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NameDimensionContext: ParserRuleContext {
			open
			func nameDimensionStructure() -> NameDimensionStructureContext? {
				return getRuleContext(NameDimensionStructureContext.self, 0)
			}
			open
			func bitOrder() -> BitOrderContext? {
				return getRuleContext(BitOrderContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_nameDimension
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNameDimension(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNameDimension(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNameDimension(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNameDimension(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func nameDimension() throws -> NameDimensionContext {
		var _localctx: NameDimensionContext = NameDimensionContext(_ctx, getState())
		try enterRule(_localctx, 880, EDIF300Parser.RULE_nameDimension)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4733)
		 	try match(EDIF300Parser.Tokens.T__344.rawValue)
		 	setState(4734)
		 	try nameDimensionStructure()
		 	setState(4736)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__21.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4735)
		 		try bitOrder()

		 	}

		 	setState(4738)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NameDimensionStructureContext: ParserRuleContext {
			open
			func complementedName() -> [ComplementedNameContext] {
				return getRuleContexts(ComplementedNameContext.self)
			}
			open
			func complementedName(_ i: Int) -> ComplementedNameContext? {
				return getRuleContext(ComplementedNameContext.self, i)
			}
			open
			func complexName() -> [ComplexNameContext] {
				return getRuleContexts(ComplexNameContext.self)
			}
			open
			func complexName(_ i: Int) -> ComplexNameContext? {
				return getRuleContext(ComplexNameContext.self, i)
			}
			open
			func integerValue() -> [IntegerValueContext] {
				return getRuleContexts(IntegerValueContext.self)
			}
			open
			func integerValue(_ i: Int) -> IntegerValueContext? {
				return getRuleContext(IntegerValueContext.self, i)
			}
			open
			func sequence() -> [SequenceContext] {
				return getRuleContexts(SequenceContext.self)
			}
			open
			func sequence(_ i: Int) -> SequenceContext? {
				return getRuleContext(SequenceContext.self, i)
			}
			open
			func simpleName() -> [SimpleNameContext] {
				return getRuleContexts(SimpleNameContext.self)
			}
			open
			func simpleName(_ i: Int) -> SimpleNameContext? {
				return getRuleContext(SimpleNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_nameDimensionStructure
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNameDimensionStructure(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNameDimensionStructure(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNameDimensionStructure(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNameDimensionStructure(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func nameDimensionStructure() throws -> NameDimensionStructureContext {
		var _localctx: NameDimensionStructureContext = NameDimensionStructureContext(_ctx, getState())
		try enterRule(_localctx, 882, EDIF300Parser.RULE_nameDimensionStructure)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4740)
		 	try match(EDIF300Parser.Tokens.T__345.rawValue)
		 	setState(4748)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__65.rawValue || _la == EDIF300Parser.Tokens.T__68.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__574.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.STRING_LITERAL.rawValue || _la == EDIF300Parser.Tokens.DECIMAL_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4746)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__65:
		 			setState(4741)
		 			try complementedName()

		 			break

		 		case .T__68:
		 			setState(4742)
		 			try complexName()

		 			break

		 		case .DECIMAL_LITERAL:
		 			setState(4743)
		 			try integerValue()

		 			break

		 		case .T__574:
		 			setState(4744)
		 			try sequence()

		 			break

		 		case .STRING_LITERAL:
		 			setState(4745)
		 			try simpleName()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4750)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4751)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NameInformationContext: ParserRuleContext {
			open
			func primaryName() -> PrimaryNameContext? {
				return getRuleContext(PrimaryNameContext.self, 0)
			}
			open
			func nameAlias() -> [NameAliasContext] {
				return getRuleContexts(NameAliasContext.self)
			}
			open
			func nameAlias(_ i: Int) -> NameAliasContext? {
				return getRuleContext(NameAliasContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_nameInformation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNameInformation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNameInformation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNameInformation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNameInformation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func nameInformation() throws -> NameInformationContext {
		var _localctx: NameInformationContext = NameInformationContext(_ctx, getState())
		try enterRule(_localctx, 884, EDIF300Parser.RULE_nameInformation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4753)
		 	try match(EDIF300Parser.Tokens.T__346.rawValue)
		 	setState(4754)
		 	try primaryName()
		 	setState(4758)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__342.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4755)
		 		try nameAlias()


		 		setState(4760)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4761)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NamePartSeparatorContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_namePartSeparator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNamePartSeparator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNamePartSeparator(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNamePartSeparator(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNamePartSeparator(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func namePartSeparator() throws -> NamePartSeparatorContext {
		var _localctx: NamePartSeparatorContext = NamePartSeparatorContext(_ctx, getState())
		try enterRule(_localctx, 886, EDIF300Parser.RULE_namePartSeparator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4763)
		 	try match(EDIF300Parser.Tokens.T__347.rawValue)
		 	setState(4764)
		 	try stringToken()
		 	setState(4765)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NameRefContext: ParserRuleContext {
			open
			func IDENTIFIER() -> TerminalNode? {
				return getToken(EDIF300Parser.Tokens.IDENTIFIER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_nameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func nameRef() throws -> NameRefContext {
		var _localctx: NameRefContext = NameRefContext(_ctx, getState())
		try enterRule(_localctx, 888, EDIF300Parser.RULE_nameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4767)
		 	try match(EDIF300Parser.Tokens.IDENTIFIER.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NameStructureContext: ParserRuleContext {
			open
			func simpleName() -> SimpleNameContext? {
				return getRuleContext(SimpleNameContext.self, 0)
			}
			open
			func complexName() -> ComplexNameContext? {
				return getRuleContext(ComplexNameContext.self, 0)
			}
			open
			func complementedName() -> ComplementedNameContext? {
				return getRuleContext(ComplementedNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_nameStructure
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNameStructure(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNameStructure(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNameStructure(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNameStructure(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func nameStructure() throws -> NameStructureContext {
		var _localctx: NameStructureContext = NameStructureContext(_ctx, getState())
		try enterRule(_localctx, 890, EDIF300Parser.RULE_nameStructure)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4769)
		 	try match(EDIF300Parser.Tokens.T__348.rawValue)
		 	setState(4773)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .STRING_LITERAL:
		 		setState(4770)
		 		try simpleName()

		 		break

		 	case .T__68:
		 		setState(4771)
		 		try complexName()

		 		break

		 	case .T__65:
		 		setState(4772)
		 		try complementedName()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4775)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NarrowPortContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_narrowPort
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNarrowPort(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNarrowPort(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNarrowPort(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNarrowPort(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func narrowPort() throws -> NarrowPortContext {
		var _localctx: NarrowPortContext = NarrowPortContext(_ctx, getState())
		try enterRule(_localctx, 892, EDIF300Parser.RULE_narrowPort)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4777)
		 	try match(EDIF300Parser.Tokens.T__349.rawValue)
		 	setState(4778)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NarrowWireContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_narrowWire
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNarrowWire(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNarrowWire(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNarrowWire(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNarrowWire(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func narrowWire() throws -> NarrowWireContext {
		var _localctx: NarrowWireContext = NarrowWireContext(_ctx, getState())
		try enterRule(_localctx, 894, EDIF300Parser.RULE_narrowWire)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4780)
		 	try match(EDIF300Parser.Tokens.T__350.rawValue)
		 	setState(4781)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NoHotspotGridContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_noHotspotGrid
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNoHotspotGrid(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNoHotspotGrid(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNoHotspotGrid(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNoHotspotGrid(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func noHotspotGrid() throws -> NoHotspotGridContext {
		var _localctx: NoHotspotGridContext = NoHotspotGridContext(_ctx, getState())
		try enterRule(_localctx, 896, EDIF300Parser.RULE_noHotspotGrid)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4783)
		 	try match(EDIF300Parser.Tokens.T__351.rawValue)
		 	setState(4784)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NominalHotspotGridContext: ParserRuleContext {
			open
			func lengthValue() -> LengthValueContext? {
				return getRuleContext(LengthValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_nominalHotspotGrid
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNominalHotspotGrid(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNominalHotspotGrid(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNominalHotspotGrid(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNominalHotspotGrid(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func nominalHotspotGrid() throws -> NominalHotspotGridContext {
		var _localctx: NominalHotspotGridContext = NominalHotspotGridContext(_ctx, getState())
		try enterRule(_localctx, 898, EDIF300Parser.RULE_nominalHotspotGrid)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4786)
		 	try match(EDIF300Parser.Tokens.T__352.rawValue)
		 	setState(4787)
		 	try lengthValue()
		 	setState(4788)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NonPermutableContext: ParserRuleContext {
			open
			func permutable() -> [PermutableContext] {
				return getRuleContexts(PermutableContext.self)
			}
			open
			func permutable(_ i: Int) -> PermutableContext? {
				return getRuleContext(PermutableContext.self, i)
			}
			open
			func portRef() -> [PortRefContext] {
				return getRuleContexts(PortRefContext.self)
			}
			open
			func portRef(_ i: Int) -> PortRefContext? {
				return getRuleContext(PortRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_nonPermutable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNonPermutable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNonPermutable(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNonPermutable(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNonPermutable(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func nonPermutable() throws -> NonPermutableContext {
		var _localctx: NonPermutableContext = NonPermutableContext(_ctx, getState())
		try enterRule(_localctx, 900, EDIF300Parser.RULE_nonPermutable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4790)
		 	try match(EDIF300Parser.Tokens.T__353.rawValue)
		 	setState(4795)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__406.rawValue || _la == EDIF300Parser.Tokens.T__436.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4793)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__406:
		 			setState(4791)
		 			try permutable()

		 			break

		 		case .T__436:
		 			setState(4792)
		 			try portRef()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4797)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4798)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NotContext: ParserRuleContext {
			open
			func booleanExpression() -> BooleanExpressionContext? {
				return getRuleContext(BooleanExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_not
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNot(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNot(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNot(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNot(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func not() throws -> NotContext {
		var _localctx: NotContext = NotContext(_ctx, getState())
		try enterRule(_localctx, 902, EDIF300Parser.RULE_not)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4800)
		 	try match(EDIF300Parser.Tokens.T__354.rawValue)
		 	setState(4801)
		 	try booleanExpression()
		 	setState(4802)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NotInheritedContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_notInherited
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNotInherited(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNotInherited(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNotInherited(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNotInherited(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func notInherited() throws -> NotInheritedContext {
		var _localctx: NotInheritedContext = NotInheritedContext(_ctx, getState())
		try enterRule(_localctx, 904, EDIF300Parser.RULE_notInherited)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4804)
		 	try match(EDIF300Parser.Tokens.T__355.rawValue)
		 	setState(4805)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NumberContext: ParserRuleContext {
			open
			func numberExpression() -> NumberExpressionContext? {
				return getRuleContext(NumberExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_number
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNumber(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNumber(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNumber(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNumber(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func number() throws -> NumberContext {
		var _localctx: NumberContext = NumberContext(_ctx, getState())
		try enterRule(_localctx, 906, EDIF300Parser.RULE_number)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4807)
		 	try match(EDIF300Parser.Tokens.T__356.rawValue)
		 	setState(4808)
		 	try numberExpression()
		 	setState(4809)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NumberExpressionContext: ParserRuleContext {
			open
			func numberValue() -> NumberValueContext? {
				return getRuleContext(NumberValueContext.self, 0)
			}
			open
			func numberParameterRef() -> NumberParameterRefContext? {
				return getRuleContext(NumberParameterRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_numberExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNumberExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNumberExpression(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNumberExpression(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNumberExpression(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func numberExpression() throws -> NumberExpressionContext {
		var _localctx: NumberExpressionContext = NumberExpressionContext(_ctx, getState())
		try enterRule(_localctx, 908, EDIF300Parser.RULE_numberExpression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4813)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__145:fallthrough
		 	case .DECIMAL_LITERAL:
		 		setState(4811)
		 		try numberValue()

		 		break

		 	case .T__359:
		 		setState(4812)
		 		try numberParameterRef()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NumberOfBasicUnitsContext: ParserRuleContext {
			open
			func scaledInteger() -> ScaledIntegerContext? {
				return getRuleContext(ScaledIntegerContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_numberOfBasicUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNumberOfBasicUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNumberOfBasicUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNumberOfBasicUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNumberOfBasicUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func numberOfBasicUnits() throws -> NumberOfBasicUnitsContext {
		var _localctx: NumberOfBasicUnitsContext = NumberOfBasicUnitsContext(_ctx, getState())
		try enterRule(_localctx, 910, EDIF300Parser.RULE_numberOfBasicUnits)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4815)
		 	try scaledInteger()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NumberOfNewUnitsContext: ParserRuleContext {
			open
			func scaledInteger() -> ScaledIntegerContext? {
				return getRuleContext(ScaledIntegerContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_numberOfNewUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNumberOfNewUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNumberOfNewUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNumberOfNewUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNumberOfNewUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func numberOfNewUnits() throws -> NumberOfNewUnitsContext {
		var _localctx: NumberOfNewUnitsContext = NumberOfNewUnitsContext(_ctx, getState())
		try enterRule(_localctx, 912, EDIF300Parser.RULE_numberOfNewUnits)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4817)
		 	try scaledInteger()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NumberParameterContext: ParserRuleContext {
			open
			func parameterNameDef() -> ParameterNameDefContext? {
				return getRuleContext(ParameterNameDefContext.self, 0)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func number() -> [NumberContext] {
				return getRuleContexts(NumberContext.self)
			}
			open
			func number(_ i: Int) -> NumberContext? {
				return getRuleContext(NumberContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_numberParameter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNumberParameter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNumberParameter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNumberParameter(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNumberParameter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func numberParameter() throws -> NumberParameterContext {
		var _localctx: NumberParameterContext = NumberParameterContext(_ctx, getState())
		try enterRule(_localctx, 914, EDIF300Parser.RULE_numberParameter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4819)
		 	try match(EDIF300Parser.Tokens.T__357.rawValue)
		 	setState(4820)
		 	try parameterNameDef()
		 	setState(4825)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__346.rawValue || _la == EDIF300Parser.Tokens.T__356.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4823)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__346:
		 			setState(4821)
		 			try nameInformation()

		 			break

		 		case .T__356:
		 			setState(4822)
		 			try number()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4827)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4828)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NumberParameterAssignContext: ParserRuleContext {
			open
			func parameterNameRef() -> ParameterNameRefContext? {
				return getRuleContext(ParameterNameRefContext.self, 0)
			}
			open
			func numberExpression() -> NumberExpressionContext? {
				return getRuleContext(NumberExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_numberParameterAssign
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNumberParameterAssign(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNumberParameterAssign(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNumberParameterAssign(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNumberParameterAssign(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func numberParameterAssign() throws -> NumberParameterAssignContext {
		var _localctx: NumberParameterAssignContext = NumberParameterAssignContext(_ctx, getState())
		try enterRule(_localctx, 916, EDIF300Parser.RULE_numberParameterAssign)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4830)
		 	try match(EDIF300Parser.Tokens.T__358.rawValue)
		 	setState(4831)
		 	try parameterNameRef()
		 	setState(4832)
		 	try numberExpression()
		 	setState(4833)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NumberParameterRefContext: ParserRuleContext {
			open
			func parameterNameRef() -> ParameterNameRefContext? {
				return getRuleContext(ParameterNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_numberParameterRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNumberParameterRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNumberParameterRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNumberParameterRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNumberParameterRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func numberParameterRef() throws -> NumberParameterRefContext {
		var _localctx: NumberParameterRefContext = NumberParameterRefContext(_ctx, getState())
		try enterRule(_localctx, 918, EDIF300Parser.RULE_numberParameterRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4835)
		 	try match(EDIF300Parser.Tokens.T__359.rawValue)
		 	setState(4836)
		 	try parameterNameRef()
		 	setState(4837)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NumberPointContext: ParserRuleContext {
			open
			func xNumberValue() -> XNumberValueContext? {
				return getRuleContext(XNumberValueContext.self, 0)
			}
			open
			func yNumberValue() -> YNumberValueContext? {
				return getRuleContext(YNumberValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_numberPoint
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNumberPoint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNumberPoint(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNumberPoint(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNumberPoint(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func numberPoint() throws -> NumberPointContext {
		var _localctx: NumberPointContext = NumberPointContext(_ctx, getState())
		try enterRule(_localctx, 920, EDIF300Parser.RULE_numberPoint)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4839)
		 	try match(EDIF300Parser.Tokens.T__360.rawValue)
		 	setState(4840)
		 	try xNumberValue()
		 	setState(4841)
		 	try yNumberValue()
		 	setState(4842)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NumberValueContext: ParserRuleContext {
			open
			func scaledInteger() -> ScaledIntegerContext? {
				return getRuleContext(ScaledIntegerContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_numberValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNumberValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNumberValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNumberValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNumberValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func numberValue() throws -> NumberValueContext {
		var _localctx: NumberValueContext = NumberValueContext(_ctx, getState())
		try enterRule(_localctx, 922, EDIF300Parser.RULE_numberValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4844)
		 	try scaledInteger()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NumeratorContext: ParserRuleContext {
			open
			func integerValue() -> IntegerValueContext? {
				return getRuleContext(IntegerValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_numerator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterNumerator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitNumerator(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitNumerator(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitNumerator(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func numerator() throws -> NumeratorContext {
		var _localctx: NumeratorContext = NumeratorContext(_ctx, getState())
		try enterRule(_localctx, 924, EDIF300Parser.RULE_numerator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4846)
		 	try integerValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OccurrenceAnnotateContext: ParserRuleContext {
			open
			func extendInstanceDef() -> ExtendInstanceDefContext? {
				return getRuleContext(ExtendInstanceDefContext.self, 0)
			}
			open
			func extendInstanceMemberDef() -> ExtendInstanceMemberDefContext? {
				return getRuleContext(ExtendInstanceMemberDefContext.self, 0)
			}
			open
			func cellPropertyOverride() -> [CellPropertyOverrideContext] {
				return getRuleContexts(CellPropertyOverrideContext.self)
			}
			open
			func cellPropertyOverride(_ i: Int) -> CellPropertyOverrideContext? {
				return getRuleContext(CellPropertyOverrideContext.self, i)
			}
			open
			func clusterPropertyOverride() -> [ClusterPropertyOverrideContext] {
				return getRuleContexts(ClusterPropertyOverrideContext.self)
			}
			open
			func clusterPropertyOverride(_ i: Int) -> ClusterPropertyOverrideContext? {
				return getRuleContext(ClusterPropertyOverrideContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func designator() -> [DesignatorContext] {
				return getRuleContexts(DesignatorContext.self)
			}
			open
			func designator(_ i: Int) -> DesignatorContext? {
				return getRuleContext(DesignatorContext.self, i)
			}
			open
			func forFrameAnnotate() -> [ForFrameAnnotateContext] {
				return getRuleContexts(ForFrameAnnotateContext.self)
			}
			open
			func forFrameAnnotate(_ i: Int) -> ForFrameAnnotateContext? {
				return getRuleContext(ForFrameAnnotateContext.self, i)
			}
			open
			func ifFrameAnnotate() -> [IfFrameAnnotateContext] {
				return getRuleContexts(IfFrameAnnotateContext.self)
			}
			open
			func ifFrameAnnotate(_ i: Int) -> IfFrameAnnotateContext? {
				return getRuleContext(IfFrameAnnotateContext.self, i)
			}
			open
			func instancePropertyOverride() -> [InstancePropertyOverrideContext] {
				return getRuleContexts(InstancePropertyOverrideContext.self)
			}
			open
			func instancePropertyOverride(_ i: Int) -> InstancePropertyOverrideContext? {
				return getRuleContext(InstancePropertyOverrideContext.self, i)
			}
			open
			func interconnectAnnotate() -> [InterconnectAnnotateContext] {
				return getRuleContexts(InterconnectAnnotateContext.self)
			}
			open
			func interconnectAnnotate(_ i: Int) -> InterconnectAnnotateContext? {
				return getRuleContext(InterconnectAnnotateContext.self, i)
			}
			open
			func leafOccurrenceAnnotate() -> [LeafOccurrenceAnnotateContext] {
				return getRuleContexts(LeafOccurrenceAnnotateContext.self)
			}
			open
			func leafOccurrenceAnnotate(_ i: Int) -> LeafOccurrenceAnnotateContext? {
				return getRuleContext(LeafOccurrenceAnnotateContext.self, i)
			}
			open
			func occurrenceAnnotate() -> [OccurrenceAnnotateContext] {
				return getRuleContexts(OccurrenceAnnotateContext.self)
			}
			open
			func occurrenceAnnotate(_ i: Int) -> OccurrenceAnnotateContext? {
				return getRuleContext(OccurrenceAnnotateContext.self, i)
			}
			open
			func otherwiseFrameAnnotate() -> [OtherwiseFrameAnnotateContext] {
				return getRuleContexts(OtherwiseFrameAnnotateContext.self)
			}
			open
			func otherwiseFrameAnnotate(_ i: Int) -> OtherwiseFrameAnnotateContext? {
				return getRuleContext(OtherwiseFrameAnnotateContext.self, i)
			}
			open
			func pageAnnotate() -> [PageAnnotateContext] {
				return getRuleContexts(PageAnnotateContext.self)
			}
			open
			func pageAnnotate(_ i: Int) -> PageAnnotateContext? {
				return getRuleContext(PageAnnotateContext.self, i)
			}
			open
			func portAnnotate() -> [PortAnnotateContext] {
				return getRuleContexts(PortAnnotateContext.self)
			}
			open
			func portAnnotate(_ i: Int) -> PortAnnotateContext? {
				return getRuleContext(PortAnnotateContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func signalAnnotate() -> [SignalAnnotateContext] {
				return getRuleContexts(SignalAnnotateContext.self)
			}
			open
			func signalAnnotate(_ i: Int) -> SignalAnnotateContext? {
				return getRuleContext(SignalAnnotateContext.self, i)
			}
			open
			func signalGroupAnnotate() -> [SignalGroupAnnotateContext] {
				return getRuleContexts(SignalGroupAnnotateContext.self)
			}
			open
			func signalGroupAnnotate(_ i: Int) -> SignalGroupAnnotateContext? {
				return getRuleContext(SignalGroupAnnotateContext.self, i)
			}
			open
			func timing() -> [TimingContext] {
				return getRuleContexts(TimingContext.self)
			}
			open
			func timing(_ i: Int) -> TimingContext? {
				return getRuleContext(TimingContext.self, i)
			}
			open
			func viewPropertyOverride() -> [ViewPropertyOverrideContext] {
				return getRuleContexts(ViewPropertyOverrideContext.self)
			}
			open
			func viewPropertyOverride(_ i: Int) -> ViewPropertyOverrideContext? {
				return getRuleContext(ViewPropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_occurrenceAnnotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOccurrenceAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOccurrenceAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOccurrenceAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOccurrenceAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func occurrenceAnnotate() throws -> OccurrenceAnnotateContext {
		var _localctx: OccurrenceAnnotateContext = OccurrenceAnnotateContext(_ctx, getState())
		try enterRule(_localctx, 926, EDIF300Parser.RULE_occurrenceAnnotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4848)
		 	try match(EDIF300Parser.Tokens.T__361.rawValue)
		 	setState(4851)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IDENTIFIER:
		 		setState(4849)
		 		try extendInstanceDef()

		 		break

		 	case .T__235:
		 		setState(4850)
		 		try extendInstanceMemberDef()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4873)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__42.rawValue,EDIF300Parser.Tokens.T__58.rawValue,EDIF300Parser.Tokens.T__61.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__118.rawValue || _la == EDIF300Parser.Tokens.T__177.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__216.rawValue,EDIF300Parser.Tokens.T__243.rawValue,EDIF300Parser.Tokens.T__259.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 217)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__305.rawValue || _la == EDIF300Parser.Tokens.T__361.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__372.rawValue,EDIF300Parser.Tokens.T__379.rawValue,EDIF300Parser.Tokens.T__415.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 373)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__585.rawValue,EDIF300Parser.Tokens.T__587.rawValue,EDIF300Parser.Tokens.T__619.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 586)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__652.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4871)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__42:
		 			setState(4853)
		 			try cellPropertyOverride()

		 			break

		 		case .T__58:
		 			setState(4854)
		 			try clusterPropertyOverride()

		 			break

		 		case .T__61:
		 			setState(4855)
		 			try comment()

		 			break

		 		case .T__118:
		 			setState(4856)
		 			try designator()

		 			break

		 		case .T__177:
		 			setState(4857)
		 			try forFrameAnnotate()

		 			break

		 		case .T__216:
		 			setState(4858)
		 			try ifFrameAnnotate()

		 			break

		 		case .T__243:
		 			setState(4859)
		 			try instancePropertyOverride()

		 			break

		 		case .T__259:
		 			setState(4860)
		 			try interconnectAnnotate()

		 			break

		 		case .T__305:
		 			setState(4861)
		 			try leafOccurrenceAnnotate()

		 			break

		 		case .T__361:
		 			setState(4862)
		 			try occurrenceAnnotate()

		 			break

		 		case .T__372:
		 			setState(4863)
		 			try otherwiseFrameAnnotate()

		 			break

		 		case .T__379:
		 			setState(4864)
		 			try pageAnnotate()

		 			break

		 		case .T__415:
		 			setState(4865)
		 			try portAnnotate()

		 			break

		 		case .T__442:
		 			setState(4866)
		 			try property()

		 			break

		 		case .T__585:
		 			setState(4867)
		 			try signalAnnotate()

		 			break

		 		case .T__587:
		 			setState(4868)
		 			try signalGroupAnnotate()

		 			break

		 		case .T__619:
		 			setState(4869)
		 			try timing()

		 			break

		 		case .T__652:
		 			setState(4870)
		 			try viewPropertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4875)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4876)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OccurrenceHierarchyAnnotateContext: ParserRuleContext {
			open
			func cellPropertyOverride() -> [CellPropertyOverrideContext] {
				return getRuleContexts(CellPropertyOverrideContext.self)
			}
			open
			func cellPropertyOverride(_ i: Int) -> CellPropertyOverrideContext? {
				return getRuleContext(CellPropertyOverrideContext.self, i)
			}
			open
			func clusterPropertyOverride() -> [ClusterPropertyOverrideContext] {
				return getRuleContexts(ClusterPropertyOverrideContext.self)
			}
			open
			func clusterPropertyOverride(_ i: Int) -> ClusterPropertyOverrideContext? {
				return getRuleContext(ClusterPropertyOverrideContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func forFrameAnnotate() -> [ForFrameAnnotateContext] {
				return getRuleContexts(ForFrameAnnotateContext.self)
			}
			open
			func forFrameAnnotate(_ i: Int) -> ForFrameAnnotateContext? {
				return getRuleContext(ForFrameAnnotateContext.self, i)
			}
			open
			func ifFrameAnnotate() -> [IfFrameAnnotateContext] {
				return getRuleContexts(IfFrameAnnotateContext.self)
			}
			open
			func ifFrameAnnotate(_ i: Int) -> IfFrameAnnotateContext? {
				return getRuleContext(IfFrameAnnotateContext.self, i)
			}
			open
			func interconnectAnnotate() -> [InterconnectAnnotateContext] {
				return getRuleContexts(InterconnectAnnotateContext.self)
			}
			open
			func interconnectAnnotate(_ i: Int) -> InterconnectAnnotateContext? {
				return getRuleContext(InterconnectAnnotateContext.self, i)
			}
			open
			func leafOccurrenceAnnotate() -> [LeafOccurrenceAnnotateContext] {
				return getRuleContexts(LeafOccurrenceAnnotateContext.self)
			}
			open
			func leafOccurrenceAnnotate(_ i: Int) -> LeafOccurrenceAnnotateContext? {
				return getRuleContext(LeafOccurrenceAnnotateContext.self, i)
			}
			open
			func occurrenceAnnotate() -> [OccurrenceAnnotateContext] {
				return getRuleContexts(OccurrenceAnnotateContext.self)
			}
			open
			func occurrenceAnnotate(_ i: Int) -> OccurrenceAnnotateContext? {
				return getRuleContext(OccurrenceAnnotateContext.self, i)
			}
			open
			func otherwiseFrameAnnotate() -> [OtherwiseFrameAnnotateContext] {
				return getRuleContexts(OtherwiseFrameAnnotateContext.self)
			}
			open
			func otherwiseFrameAnnotate(_ i: Int) -> OtherwiseFrameAnnotateContext? {
				return getRuleContext(OtherwiseFrameAnnotateContext.self, i)
			}
			open
			func pageAnnotate() -> [PageAnnotateContext] {
				return getRuleContexts(PageAnnotateContext.self)
			}
			open
			func pageAnnotate(_ i: Int) -> PageAnnotateContext? {
				return getRuleContext(PageAnnotateContext.self, i)
			}
			open
			func portAnnotate() -> [PortAnnotateContext] {
				return getRuleContexts(PortAnnotateContext.self)
			}
			open
			func portAnnotate(_ i: Int) -> PortAnnotateContext? {
				return getRuleContext(PortAnnotateContext.self, i)
			}
			open
			func signalAnnotate() -> [SignalAnnotateContext] {
				return getRuleContexts(SignalAnnotateContext.self)
			}
			open
			func signalAnnotate(_ i: Int) -> SignalAnnotateContext? {
				return getRuleContext(SignalAnnotateContext.self, i)
			}
			open
			func signalGroupAnnotate() -> [SignalGroupAnnotateContext] {
				return getRuleContexts(SignalGroupAnnotateContext.self)
			}
			open
			func signalGroupAnnotate(_ i: Int) -> SignalGroupAnnotateContext? {
				return getRuleContext(SignalGroupAnnotateContext.self, i)
			}
			open
			func timing() -> [TimingContext] {
				return getRuleContexts(TimingContext.self)
			}
			open
			func timing(_ i: Int) -> TimingContext? {
				return getRuleContext(TimingContext.self, i)
			}
			open
			func viewPropertyOverride() -> [ViewPropertyOverrideContext] {
				return getRuleContexts(ViewPropertyOverrideContext.self)
			}
			open
			func viewPropertyOverride(_ i: Int) -> ViewPropertyOverrideContext? {
				return getRuleContext(ViewPropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_occurrenceHierarchyAnnotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOccurrenceHierarchyAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOccurrenceHierarchyAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOccurrenceHierarchyAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOccurrenceHierarchyAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func occurrenceHierarchyAnnotate() throws -> OccurrenceHierarchyAnnotateContext {
		var _localctx: OccurrenceHierarchyAnnotateContext = OccurrenceHierarchyAnnotateContext(_ctx, getState())
		try enterRule(_localctx, 928, EDIF300Parser.RULE_occurrenceHierarchyAnnotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4878)
		 	try match(EDIF300Parser.Tokens.T__362.rawValue)
		 	setState(4896)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__42.rawValue,EDIF300Parser.Tokens.T__58.rawValue,EDIF300Parser.Tokens.T__61.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__177.rawValue || _la == EDIF300Parser.Tokens.T__216.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__259.rawValue || _la == EDIF300Parser.Tokens.T__305.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__361.rawValue,EDIF300Parser.Tokens.T__372.rawValue,EDIF300Parser.Tokens.T__379.rawValue,EDIF300Parser.Tokens.T__415.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 362)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__585.rawValue,EDIF300Parser.Tokens.T__587.rawValue,EDIF300Parser.Tokens.T__619.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 586)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__652.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4894)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__42:
		 			setState(4879)
		 			try cellPropertyOverride()

		 			break

		 		case .T__58:
		 			setState(4880)
		 			try clusterPropertyOverride()

		 			break

		 		case .T__61:
		 			setState(4881)
		 			try comment()

		 			break

		 		case .T__177:
		 			setState(4882)
		 			try forFrameAnnotate()

		 			break

		 		case .T__216:
		 			setState(4883)
		 			try ifFrameAnnotate()

		 			break

		 		case .T__259:
		 			setState(4884)
		 			try interconnectAnnotate()

		 			break

		 		case .T__305:
		 			setState(4885)
		 			try leafOccurrenceAnnotate()

		 			break

		 		case .T__361:
		 			setState(4886)
		 			try occurrenceAnnotate()

		 			break

		 		case .T__372:
		 			setState(4887)
		 			try otherwiseFrameAnnotate()

		 			break

		 		case .T__379:
		 			setState(4888)
		 			try pageAnnotate()

		 			break

		 		case .T__415:
		 			setState(4889)
		 			try portAnnotate()

		 			break

		 		case .T__585:
		 			setState(4890)
		 			try signalAnnotate()

		 			break

		 		case .T__587:
		 			setState(4891)
		 			try signalGroupAnnotate()

		 			break

		 		case .T__619:
		 			setState(4892)
		 			try timing()

		 			break

		 		case .T__652:
		 			setState(4893)
		 			try viewPropertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4898)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4899)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OffsetEventContext: ParserRuleContext {
			open
			func event() -> EventContext? {
				return getRuleContext(EventContext.self, 0)
			}
			open
			func numberValue() -> NumberValueContext? {
				return getRuleContext(NumberValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_offsetEvent
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOffsetEvent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOffsetEvent(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOffsetEvent(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOffsetEvent(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func offsetEvent() throws -> OffsetEventContext {
		var _localctx: OffsetEventContext = OffsetEventContext(_ctx, getState())
		try enterRule(_localctx, 930, EDIF300Parser.RULE_offsetEvent)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4901)
		 	try match(EDIF300Parser.Tokens.T__363.rawValue)
		 	setState(4902)
		 	try event()
		 	setState(4903)
		 	try numberValue()
		 	setState(4904)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OhmContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ohm
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOhm(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOhm(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOhm(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOhm(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ohm() throws -> OhmContext {
		var _localctx: OhmContext = OhmContext(_ctx, getState())
		try enterRule(_localctx, 932, EDIF300Parser.RULE_ohm)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4906)
		 	try match(EDIF300Parser.Tokens.T__364.rawValue)
		 	setState(4907)
		 	try unitExponent()
		 	setState(4908)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OpenShapeContext: ParserRuleContext {
			open
			func curve() -> CurveContext? {
				return getRuleContext(CurveContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_openShape
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOpenShape(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOpenShape(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOpenShape(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOpenShape(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func openShape() throws -> OpenShapeContext {
		var _localctx: OpenShapeContext = OpenShapeContext(_ctx, getState())
		try enterRule(_localctx, 934, EDIF300Parser.RULE_openShape)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4910)
		 	try match(EDIF300Parser.Tokens.T__365.rawValue)
		 	setState(4911)
		 	try curve()
		 	setState(4912)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OrContext: ParserRuleContext {
			open
			func booleanExpression() -> [BooleanExpressionContext] {
				return getRuleContexts(BooleanExpressionContext.self)
			}
			open
			func booleanExpression(_ i: Int) -> BooleanExpressionContext? {
				return getRuleContext(BooleanExpressionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_or
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOr(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOr(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOr(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOr(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func or() throws -> OrContext {
		var _localctx: OrContext = OrContext(_ctx, getState())
		try enterRule(_localctx, 936, EDIF300Parser.RULE_or)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4914)
		 	try match(EDIF300Parser.Tokens.T__366.rawValue)
		 	setState(4918)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__6.rawValue,EDIF300Parser.Tokens.T__25.rawValue,EDIF300Parser.Tokens.T__29.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__157.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__250.rawValue,EDIF300Parser.Tokens.T__307.rawValue,EDIF300Parser.Tokens.T__308.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 251)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__354.rawValue || _la == EDIF300Parser.Tokens.T__366.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__603.rawValue,EDIF300Parser.Tokens.T__626.rawValue,EDIF300Parser.Tokens.T__664.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 604)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(4915)
		 		try booleanExpression()


		 		setState(4920)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4921)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OriginContext: ParserRuleContext {
			open
			func pointValue() -> PointValueContext? {
				return getRuleContext(PointValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_origin
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOrigin(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOrigin(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOrigin(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOrigin(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func origin() throws -> OriginContext {
		var _localctx: OriginContext = OriginContext(_ctx, getState())
		try enterRule(_localctx, 938, EDIF300Parser.RULE_origin)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4923)
		 	try match(EDIF300Parser.Tokens.T__367.rawValue)
		 	setState(4924)
		 	try pointValue()
		 	setState(4925)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OriginalBoundingBoxContext: ParserRuleContext {
			open
			func rectangle() -> RectangleContext? {
				return getRuleContext(RectangleContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_originalBoundingBox
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOriginalBoundingBox(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOriginalBoundingBox(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOriginalBoundingBox(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOriginalBoundingBox(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func originalBoundingBox() throws -> OriginalBoundingBoxContext {
		var _localctx: OriginalBoundingBoxContext = OriginalBoundingBoxContext(_ctx, getState())
		try enterRule(_localctx, 940, EDIF300Parser.RULE_originalBoundingBox)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4927)
		 	try match(EDIF300Parser.Tokens.T__368.rawValue)
		 	setState(4928)
		 	try rectangle()
		 	setState(4929)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OriginalDrawingDateContext: ParserRuleContext {
			open
			func date() -> DateContext? {
				return getRuleContext(DateContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_originalDrawingDate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOriginalDrawingDate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOriginalDrawingDate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOriginalDrawingDate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOriginalDrawingDate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func originalDrawingDate() throws -> OriginalDrawingDateContext {
		var _localctx: OriginalDrawingDateContext = OriginalDrawingDateContext(_ctx, getState())
		try enterRule(_localctx, 942, EDIF300Parser.RULE_originalDrawingDate)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4931)
		 	try match(EDIF300Parser.Tokens.T__369.rawValue)
		 	setState(4932)
		 	try date()
		 	setState(4933)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OriginalDrawingDateDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_originalDrawingDateDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOriginalDrawingDateDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOriginalDrawingDateDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOriginalDrawingDateDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOriginalDrawingDateDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func originalDrawingDateDisplay() throws -> OriginalDrawingDateDisplayContext {
		var _localctx: OriginalDrawingDateDisplayContext = OriginalDrawingDateDisplayContext(_ctx, getState())
		try enterRule(_localctx, 944, EDIF300Parser.RULE_originalDrawingDateDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4935)
		 	try match(EDIF300Parser.Tokens.T__370.rawValue)
		 	setState(4939)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(4936)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(4937)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(4938)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4941)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OriginalNameContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_originalName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOriginalName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOriginalName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOriginalName(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOriginalName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func originalName() throws -> OriginalNameContext {
		var _localctx: OriginalNameContext = OriginalNameContext(_ctx, getState())
		try enterRule(_localctx, 946, EDIF300Parser.RULE_originalName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4943)
		 	try stringToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OtherwiseFrameContext: ParserRuleContext {
			open
			func frameNameDef() -> FrameNameDefContext? {
				return getRuleContext(FrameNameDefContext.self, 0)
			}
			open
			func ifFrameSet() -> IfFrameSetContext? {
				return getRuleContext(IfFrameSetContext.self, 0)
			}
			open
			func logicalConnectivity() -> LogicalConnectivityContext? {
				return getRuleContext(LogicalConnectivityContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_otherwiseFrame
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOtherwiseFrame(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOtherwiseFrame(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOtherwiseFrame(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOtherwiseFrame(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func otherwiseFrame() throws -> OtherwiseFrameContext {
		var _localctx: OtherwiseFrameContext = OtherwiseFrameContext(_ctx, getState())
		try enterRule(_localctx, 948, EDIF300Parser.RULE_otherwiseFrame)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4945)
		 	try match(EDIF300Parser.Tokens.T__371.rawValue)
		 	setState(4946)
		 	try frameNameDef()
		 	setState(4947)
		 	try ifFrameSet()
		 	setState(4948)
		 	try logicalConnectivity()
		 	setState(4956)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4954)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4949)
		 			try comment()

		 			break

		 		case .T__132:
		 			setState(4950)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(4951)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(4952)
		 			try property()

		 			break

		 		case .T__642:
		 			setState(4953)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4958)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4959)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OtherwiseFrameAnnotateContext: ParserRuleContext {
			open
			func extendFrameDef() -> ExtendFrameDefContext? {
				return getRuleContext(ExtendFrameDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func forFrameAnnotate() -> [ForFrameAnnotateContext] {
				return getRuleContexts(ForFrameAnnotateContext.self)
			}
			open
			func forFrameAnnotate(_ i: Int) -> ForFrameAnnotateContext? {
				return getRuleContext(ForFrameAnnotateContext.self, i)
			}
			open
			func ifFrameAnnotate() -> [IfFrameAnnotateContext] {
				return getRuleContexts(IfFrameAnnotateContext.self)
			}
			open
			func ifFrameAnnotate(_ i: Int) -> IfFrameAnnotateContext? {
				return getRuleContext(IfFrameAnnotateContext.self, i)
			}
			open
			func interconnectAnnotate() -> [InterconnectAnnotateContext] {
				return getRuleContexts(InterconnectAnnotateContext.self)
			}
			open
			func interconnectAnnotate(_ i: Int) -> InterconnectAnnotateContext? {
				return getRuleContext(InterconnectAnnotateContext.self, i)
			}
			open
			func leafOccurrenceAnnotate() -> [LeafOccurrenceAnnotateContext] {
				return getRuleContexts(LeafOccurrenceAnnotateContext.self)
			}
			open
			func leafOccurrenceAnnotate(_ i: Int) -> LeafOccurrenceAnnotateContext? {
				return getRuleContext(LeafOccurrenceAnnotateContext.self, i)
			}
			open
			func occurrenceAnnotate() -> [OccurrenceAnnotateContext] {
				return getRuleContexts(OccurrenceAnnotateContext.self)
			}
			open
			func occurrenceAnnotate(_ i: Int) -> OccurrenceAnnotateContext? {
				return getRuleContext(OccurrenceAnnotateContext.self, i)
			}
			open
			func otherwiseFrameAnnotate() -> [OtherwiseFrameAnnotateContext] {
				return getRuleContexts(OtherwiseFrameAnnotateContext.self)
			}
			open
			func otherwiseFrameAnnotate(_ i: Int) -> OtherwiseFrameAnnotateContext? {
				return getRuleContext(OtherwiseFrameAnnotateContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_otherwiseFrameAnnotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOtherwiseFrameAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOtherwiseFrameAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOtherwiseFrameAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOtherwiseFrameAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func otherwiseFrameAnnotate() throws -> OtherwiseFrameAnnotateContext {
		var _localctx: OtherwiseFrameAnnotateContext = OtherwiseFrameAnnotateContext(_ctx, getState())
		try enterRule(_localctx, 950, EDIF300Parser.RULE_otherwiseFrameAnnotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4961)
		 	try match(EDIF300Parser.Tokens.T__372.rawValue)
		 	setState(4962)
		 	try extendFrameDef()
		 	setState(4973)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__177.rawValue || _la == EDIF300Parser.Tokens.T__216.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__259.rawValue || _la == EDIF300Parser.Tokens.T__305.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__361.rawValue || _la == EDIF300Parser.Tokens.T__372.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4971)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(4963)
		 			try comment()

		 			break

		 		case .T__177:
		 			setState(4964)
		 			try forFrameAnnotate()

		 			break

		 		case .T__216:
		 			setState(4965)
		 			try ifFrameAnnotate()

		 			break

		 		case .T__259:
		 			setState(4966)
		 			try interconnectAnnotate()

		 			break

		 		case .T__305:
		 			setState(4967)
		 			try leafOccurrenceAnnotate()

		 			break

		 		case .T__361:
		 			setState(4968)
		 			try occurrenceAnnotate()

		 			break

		 		case .T__372:
		 			setState(4969)
		 			try otherwiseFrameAnnotate()

		 			break

		 		case .T__448:
		 			setState(4970)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4975)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4976)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OtherwiseFrameRefContext: ParserRuleContext {
			open
			func frameNameRef() -> FrameNameRefContext? {
				return getRuleContext(FrameNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_otherwiseFrameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOtherwiseFrameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOtherwiseFrameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOtherwiseFrameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOtherwiseFrameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func otherwiseFrameRef() throws -> OtherwiseFrameRefContext {
		var _localctx: OtherwiseFrameRefContext = OtherwiseFrameRefContext(_ctx, getState())
		try enterRule(_localctx, 952, EDIF300Parser.RULE_otherwiseFrameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4978)
		 	try match(EDIF300Parser.Tokens.T__373.rawValue)
		 	setState(4979)
		 	try frameNameRef()
		 	setState(4980)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OutputContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_output
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOutput(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOutput(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOutput(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOutput(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func output() throws -> OutputContext {
		var _localctx: OutputContext = OutputContext(_ctx, getState())
		try enterRule(_localctx, 954, EDIF300Parser.RULE_output)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4982)
		 	try match(EDIF300Parser.Tokens.T__374.rawValue)
		 	setState(4983)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OutputPortContext: ParserRuleContext {
			open
			func outputPortAttributes() -> OutputPortAttributesContext? {
				return getRuleContext(OutputPortAttributesContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_outputPort
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOutputPort(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOutputPort(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOutputPort(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOutputPort(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func outputPort() throws -> OutputPortContext {
		var _localctx: OutputPortContext = OutputPortContext(_ctx, getState())
		try enterRule(_localctx, 956, EDIF300Parser.RULE_outputPort)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4985)
		 	try match(EDIF300Parser.Tokens.T__375.rawValue)
		 	setState(4987)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__376.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4986)
		 		try outputPortAttributes()

		 	}

		 	setState(4989)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OutputPortAttributesContext: ParserRuleContext {
			open
			func dcFanInLoad() -> [DcFanInLoadContext] {
				return getRuleContexts(DcFanInLoadContext.self)
			}
			open
			func dcFanInLoad(_ i: Int) -> DcFanInLoadContext? {
				return getRuleContext(DcFanInLoadContext.self, i)
			}
			open
			func dcMaxFanOut() -> [DcMaxFanOutContext] {
				return getRuleContexts(DcMaxFanOutContext.self)
			}
			open
			func dcMaxFanOut(_ i: Int) -> DcMaxFanOutContext? {
				return getRuleContext(DcMaxFanOutContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_outputPortAttributes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOutputPortAttributes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOutputPortAttributes(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOutputPortAttributes(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOutputPortAttributes(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func outputPortAttributes() throws -> OutputPortAttributesContext {
		var _localctx: OutputPortAttributesContext = OutputPortAttributesContext(_ctx, getState())
		try enterRule(_localctx, 958, EDIF300Parser.RULE_outputPortAttributes)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4991)
		 	try match(EDIF300Parser.Tokens.T__376.rawValue)
		 	setState(4996)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__103.rawValue || _la == EDIF300Parser.Tokens.T__109.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4994)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__103:
		 			setState(4992)
		 			try dcFanInLoad()

		 			break

		 		case .T__109:
		 			setState(4993)
		 			try dcMaxFanOut()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(4998)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4999)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OwnerContext: ParserRuleContext {
			open
			func stringValue() -> StringValueContext? {
				return getRuleContext(StringValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_owner
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterOwner(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitOwner(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitOwner(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitOwner(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func owner() throws -> OwnerContext {
		var _localctx: OwnerContext = OwnerContext(_ctx, getState())
		try enterRule(_localctx, 960, EDIF300Parser.RULE_owner)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5001)
		 	try match(EDIF300Parser.Tokens.T__377.rawValue)
		 	setState(5002)
		 	try stringValue()
		 	setState(5003)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageContext: ParserRuleContext {
			open
			func pageNameDef() -> PageNameDefContext? {
				return getRuleContext(PageNameDefContext.self, 0)
			}
			open
			func pageHeader() -> PageHeaderContext? {
				return getRuleContext(PageHeaderContext.self, 0)
			}
			open
			func cellPropertyDisplay() -> [CellPropertyDisplayContext] {
				return getRuleContexts(CellPropertyDisplayContext.self)
			}
			open
			func cellPropertyDisplay(_ i: Int) -> CellPropertyDisplayContext? {
				return getRuleContext(CellPropertyDisplayContext.self, i)
			}
			open
			func clusterPropertyDisplay() -> [ClusterPropertyDisplayContext] {
				return getRuleContexts(ClusterPropertyDisplayContext.self)
			}
			open
			func clusterPropertyDisplay(_ i: Int) -> ClusterPropertyDisplayContext? {
				return getRuleContext(ClusterPropertyDisplayContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func localPortGroup() -> [LocalPortGroupContext] {
				return getRuleContexts(LocalPortGroupContext.self)
			}
			open
			func localPortGroup(_ i: Int) -> LocalPortGroupContext? {
				return getRuleContext(LocalPortGroupContext.self, i)
			}
			open
			func pageCommentGraphics() -> [PageCommentGraphicsContext] {
				return getRuleContexts(PageCommentGraphicsContext.self)
			}
			open
			func pageCommentGraphics(_ i: Int) -> PageCommentGraphicsContext? {
				return getRuleContext(PageCommentGraphicsContext.self, i)
			}
			open
			func pageTitleBlock() -> [PageTitleBlockContext] {
				return getRuleContexts(PageTitleBlockContext.self)
			}
			open
			func pageTitleBlock(_ i: Int) -> PageTitleBlockContext? {
				return getRuleContext(PageTitleBlockContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicBus() -> [SchematicBusContext] {
				return getRuleContexts(SchematicBusContext.self)
			}
			open
			func schematicBus(_ i: Int) -> SchematicBusContext? {
				return getRuleContext(SchematicBusContext.self, i)
			}
			open
			func schematicForFrameImplementation() -> [SchematicForFrameImplementationContext] {
				return getRuleContexts(SchematicForFrameImplementationContext.self)
			}
			open
			func schematicForFrameImplementation(_ i: Int) -> SchematicForFrameImplementationContext? {
				return getRuleContext(SchematicForFrameImplementationContext.self, i)
			}
			open
			func schematicGlobalPortImplementation() -> [SchematicGlobalPortImplementationContext] {
				return getRuleContexts(SchematicGlobalPortImplementationContext.self)
			}
			open
			func schematicGlobalPortImplementation(_ i: Int) -> SchematicGlobalPortImplementationContext? {
				return getRuleContext(SchematicGlobalPortImplementationContext.self, i)
			}
			open
			func schematicIfFrameImplementation() -> [SchematicIfFrameImplementationContext] {
				return getRuleContexts(SchematicIfFrameImplementationContext.self)
			}
			open
			func schematicIfFrameImplementation(_ i: Int) -> SchematicIfFrameImplementationContext? {
				return getRuleContext(SchematicIfFrameImplementationContext.self, i)
			}
			open
			func schematicInstanceImplementation() -> [SchematicInstanceImplementationContext] {
				return getRuleContexts(SchematicInstanceImplementationContext.self)
			}
			open
			func schematicInstanceImplementation(_ i: Int) -> SchematicInstanceImplementationContext? {
				return getRuleContext(SchematicInstanceImplementationContext.self, i)
			}
			open
			func schematicMasterPortImplementation() -> [SchematicMasterPortImplementationContext] {
				return getRuleContexts(SchematicMasterPortImplementationContext.self)
			}
			open
			func schematicMasterPortImplementation(_ i: Int) -> SchematicMasterPortImplementationContext? {
				return getRuleContext(SchematicMasterPortImplementationContext.self, i)
			}
			open
			func schematicNet() -> [SchematicNetContext] {
				return getRuleContexts(SchematicNetContext.self)
			}
			open
			func schematicNet(_ i: Int) -> SchematicNetContext? {
				return getRuleContext(SchematicNetContext.self, i)
			}
			open
			func schematicOffPageConnectorImplementation() -> [SchematicOffPageConnectorImplementationContext] {
				return getRuleContexts(SchematicOffPageConnectorImplementationContext.self)
			}
			open
			func schematicOffPageConnectorImplementation(_ i: Int) -> SchematicOffPageConnectorImplementationContext? {
				return getRuleContext(SchematicOffPageConnectorImplementationContext.self, i)
			}
			open
			func schematicOnPageConnectorImplementation() -> [SchematicOnPageConnectorImplementationContext] {
				return getRuleContexts(SchematicOnPageConnectorImplementationContext.self)
			}
			open
			func schematicOnPageConnectorImplementation(_ i: Int) -> SchematicOnPageConnectorImplementationContext? {
				return getRuleContext(SchematicOnPageConnectorImplementationContext.self, i)
			}
			open
			func schematicOtherwiseFrameImplementation() -> [SchematicOtherwiseFrameImplementationContext] {
				return getRuleContexts(SchematicOtherwiseFrameImplementationContext.self)
			}
			open
			func schematicOtherwiseFrameImplementation(_ i: Int) -> SchematicOtherwiseFrameImplementationContext? {
				return getRuleContext(SchematicOtherwiseFrameImplementationContext.self, i)
			}
			open
			func schematicRipperImplementation() -> [SchematicRipperImplementationContext] {
				return getRuleContexts(SchematicRipperImplementationContext.self)
			}
			open
			func schematicRipperImplementation(_ i: Int) -> SchematicRipperImplementationContext? {
				return getRuleContext(SchematicRipperImplementationContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
			open
			func viewPropertyDisplay() -> [ViewPropertyDisplayContext] {
				return getRuleContexts(ViewPropertyDisplayContext.self)
			}
			open
			func viewPropertyDisplay(_ i: Int) -> ViewPropertyDisplayContext? {
				return getRuleContext(ViewPropertyDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_page
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPage(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPage(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPage(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPage(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func page() throws -> PageContext {
		var _localctx: PageContext = PageContext(_ctx, getState())
		try enterRule(_localctx, 962, EDIF300Parser.RULE_page)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5005)
		 	try match(EDIF300Parser.Tokens.T__378.rawValue)
		 	setState(5006)
		 	try pageNameDef()
		 	setState(5007)
		 	try pageHeader()
		 	setState(5030)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__40.rawValue,EDIF300Parser.Tokens.T__56.rawValue,EDIF300Parser.Tokens.T__61.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__315.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__383.rawValue,EDIF300Parser.Tokens.T__392.rawValue,EDIF300Parser.Tokens.T__443.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 384)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__469.rawValue,EDIF300Parser.Tokens.T__480.rawValue,EDIF300Parser.Tokens.T__484.rawValue,EDIF300Parser.Tokens.T__491.rawValue,EDIF300Parser.Tokens.T__494.rawValue,EDIF300Parser.Tokens.T__506.rawValue,EDIF300Parser.Tokens.T__511.rawValue,EDIF300Parser.Tokens.T__515.rawValue,EDIF300Parser.Tokens.T__519.rawValue,EDIF300Parser.Tokens.T__526.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 470)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__546.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue || _la == EDIF300Parser.Tokens.T__651.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5028)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__40:
		 			setState(5008)
		 			try cellPropertyDisplay()

		 			break

		 		case .T__56:
		 			setState(5009)
		 			try clusterPropertyDisplay()

		 			break

		 		case .T__61:
		 			setState(5010)
		 			try comment()

		 			break

		 		case .T__315:
		 			setState(5011)
		 			try localPortGroup()

		 			break

		 		case .T__383:
		 			setState(5012)
		 			try pageCommentGraphics()

		 			break

		 		case .T__392:
		 			setState(5013)
		 			try pageTitleBlock()

		 			break

		 		case .T__443:
		 			setState(5014)
		 			try propertyDisplay()

		 			break

		 		case .T__469:
		 			setState(5015)
		 			try schematicBus()

		 			break

		 		case .T__480:
		 			setState(5016)
		 			try schematicForFrameImplementation()

		 			break

		 		case .T__484:
		 			setState(5017)
		 			try schematicGlobalPortImplementation()

		 			break

		 		case .T__491:
		 			setState(5018)
		 			try schematicIfFrameImplementation()

		 			break

		 		case .T__494:
		 			setState(5019)
		 			try schematicInstanceImplementation()

		 			break

		 		case .T__506:
		 			setState(5020)
		 			try schematicMasterPortImplementation()

		 			break

		 		case .T__511:
		 			setState(5021)
		 			try schematicNet()

		 			break

		 		case .T__515:
		 			setState(5022)
		 			try schematicOffPageConnectorImplementation()

		 			break

		 		case .T__519:
		 			setState(5023)
		 			try schematicOnPageConnectorImplementation()

		 			break

		 		case .T__526:
		 			setState(5024)
		 			try schematicOtherwiseFrameImplementation()

		 			break

		 		case .T__546:
		 			setState(5025)
		 			try schematicRipperImplementation()

		 			break

		 		case .T__642:
		 			setState(5026)
		 			try userData()

		 			break

		 		case .T__651:
		 			setState(5027)
		 			try viewPropertyDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5032)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5033)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageAnnotateContext: ParserRuleContext {
			open
			func extendPageDef() -> ExtendPageDefContext? {
				return getRuleContext(ExtendPageDefContext.self, 0)
			}
			open
			func interconnectAnnotate() -> [InterconnectAnnotateContext] {
				return getRuleContexts(InterconnectAnnotateContext.self)
			}
			open
			func interconnectAnnotate(_ i: Int) -> InterconnectAnnotateContext? {
				return getRuleContext(InterconnectAnnotateContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageAnnotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageAnnotate() throws -> PageAnnotateContext {
		var _localctx: PageAnnotateContext = PageAnnotateContext(_ctx, getState())
		try enterRule(_localctx, 964, EDIF300Parser.RULE_pageAnnotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5035)
		 	try match(EDIF300Parser.Tokens.T__379.rawValue)
		 	setState(5036)
		 	try extendPageDef()
		 	setState(5040)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__259.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5037)
		 		try interconnectAnnotate()


		 		setState(5042)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5043)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageBorderContext: ParserRuleContext {
			open
			func pageBorderTemplateRef() -> PageBorderTemplateRefContext? {
				return getRuleContext(PageBorderTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageBorder
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageBorder(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageBorder(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageBorder(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageBorder(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageBorder() throws -> PageBorderContext {
		var _localctx: PageBorderContext = PageBorderContext(_ctx, getState())
		try enterRule(_localctx, 966, EDIF300Parser.RULE_pageBorder)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5045)
		 	try match(EDIF300Parser.Tokens.T__380.rawValue)
		 	setState(5046)
		 	try pageBorderTemplateRef()
		 	setState(5047)
		 	try transform()
		 	setState(5052)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__444.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5050)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__444:
		 			setState(5048)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(5049)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5054)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5055)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageBorderTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func usableArea() -> UsableAreaContext? {
				return getRuleContext(UsableAreaContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageBorderTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageBorderTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageBorderTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageBorderTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageBorderTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageBorderTemplate() throws -> PageBorderTemplateContext {
		var _localctx: PageBorderTemplateContext = PageBorderTemplateContext(_ctx, getState())
		try enterRule(_localctx, 968, EDIF300Parser.RULE_pageBorderTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5057)
		 	try match(EDIF300Parser.Tokens.T__381.rawValue)
		 	setState(5058)
		 	try libraryObjectNameDef()
		 	setState(5059)
		 	try schematicTemplateHeader()
		 	setState(5060)
		 	try usableArea()
		 	setState(5068)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__443.rawValue || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5066)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(5061)
		 			try annotate()

		 			break

		 		case .T__62:
		 			setState(5062)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(5063)
		 			try figure()

		 			break

		 		case .T__443:
		 			setState(5064)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(5065)
		 			try schematicComplexFigure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5070)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5071)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageBorderTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageBorderTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageBorderTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageBorderTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageBorderTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageBorderTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageBorderTemplateRef() throws -> PageBorderTemplateRefContext {
		var _localctx: PageBorderTemplateRefContext = PageBorderTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 970, EDIF300Parser.RULE_pageBorderTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5073)
		 	try match(EDIF300Parser.Tokens.T__382.rawValue)
		 	setState(5074)
		 	try libraryObjectNameRef()
		 	setState(5076)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5075)
		 		try libraryRef()

		 	}

		 	setState(5078)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageCommentGraphicsContext: ParserRuleContext {
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageCommentGraphics
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageCommentGraphics(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageCommentGraphics(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageCommentGraphics(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageCommentGraphics(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageCommentGraphics() throws -> PageCommentGraphicsContext {
		var _localctx: PageCommentGraphicsContext = PageCommentGraphicsContext(_ctx, getState())
		try enterRule(_localctx, 972, EDIF300Parser.RULE_pageCommentGraphics)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5080)
		 	try match(EDIF300Parser.Tokens.T__383.rawValue)
		 	setState(5088)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5086)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(5081)
		 			try annotate()

		 			break

		 		case .T__61:
		 			setState(5082)
		 			try comment()

		 			break

		 		case .T__159:
		 			setState(5083)
		 			try figure()

		 			break

		 		case .T__474:
		 			setState(5084)
		 			try schematicComplexFigure()

		 			break

		 		case .T__642:
		 			setState(5085)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5090)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5091)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageHeaderContext: ParserRuleContext {
			open
			func backgroundColor() -> [BackgroundColorContext] {
				return getRuleContexts(BackgroundColorContext.self)
			}
			open
			func backgroundColor(_ i: Int) -> BackgroundColorContext? {
				return getRuleContext(BackgroundColorContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func originalBoundingBox() -> [OriginalBoundingBoxContext] {
				return getRuleContexts(OriginalBoundingBoxContext.self)
			}
			open
			func originalBoundingBox(_ i: Int) -> OriginalBoundingBoxContext? {
				return getRuleContext(OriginalBoundingBoxContext.self, i)
			}
			open
			func pageBorder() -> [PageBorderContext] {
				return getRuleContexts(PageBorderContext.self)
			}
			open
			func pageBorder(_ i: Int) -> PageBorderContext? {
				return getRuleContext(PageBorderContext.self, i)
			}
			open
			func pageSize() -> [PageSizeContext] {
				return getRuleContexts(PageSizeContext.self)
			}
			open
			func pageSize(_ i: Int) -> PageSizeContext? {
				return getRuleContext(PageSizeContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageHeader() throws -> PageHeaderContext {
		var _localctx: PageHeaderContext = PageHeaderContext(_ctx, getState())
		try enterRule(_localctx, 974, EDIF300Parser.RULE_pageHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5093)
		 	try match(EDIF300Parser.Tokens.T__384.rawValue)
		 	setState(5104)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__14.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__346.rawValue,EDIF300Parser.Tokens.T__368.rawValue,EDIF300Parser.Tokens.T__380.rawValue,EDIF300Parser.Tokens.T__390.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 347)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5102)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__14:
		 			setState(5094)
		 			try backgroundColor()

		 			break

		 		case .T__132:
		 			setState(5095)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(5096)
		 			try nameInformation()

		 			break

		 		case .T__368:
		 			setState(5097)
		 			try originalBoundingBox()

		 			break

		 		case .T__380:
		 			setState(5098)
		 			try pageBorder()

		 			break

		 		case .T__390:
		 			setState(5099)
		 			try pageSize()

		 			break

		 		case .T__442:
		 			setState(5100)
		 			try property()

		 			break

		 		case .T__597:
		 			setState(5101)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5106)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5107)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageIdentificationContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageIdentification
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageIdentification(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageIdentification(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageIdentification(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageIdentification(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageIdentification() throws -> PageIdentificationContext {
		var _localctx: PageIdentificationContext = PageIdentificationContext(_ctx, getState())
		try enterRule(_localctx, 976, EDIF300Parser.RULE_pageIdentification)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5109)
		 	try match(EDIF300Parser.Tokens.T__385.rawValue)
		 	setState(5110)
		 	try stringToken()
		 	setState(5111)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageIdentificationDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageIdentificationDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageIdentificationDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageIdentificationDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageIdentificationDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageIdentificationDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageIdentificationDisplay() throws -> PageIdentificationDisplayContext {
		var _localctx: PageIdentificationDisplayContext = PageIdentificationDisplayContext(_ctx, getState())
		try enterRule(_localctx, 978, EDIF300Parser.RULE_pageIdentificationDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5113)
		 	try match(EDIF300Parser.Tokens.T__386.rawValue)
		 	setState(5117)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(5114)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(5115)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(5116)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5119)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageNameCaseSensitive() throws -> PageNameCaseSensitiveContext {
		var _localctx: PageNameCaseSensitiveContext = PageNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 980, EDIF300Parser.RULE_pageNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5121)
		 	try match(EDIF300Parser.Tokens.T__387.rawValue)
		 	setState(5122)
		 	try booleanToken()
		 	setState(5123)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageNameDef() throws -> PageNameDefContext {
		var _localctx: PageNameDefContext = PageNameDefContext(_ctx, getState())
		try enterRule(_localctx, 982, EDIF300Parser.RULE_pageNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5125)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageNameRef() throws -> PageNameRefContext {
		var _localctx: PageNameRefContext = PageNameRefContext(_ctx, getState())
		try enterRule(_localctx, 984, EDIF300Parser.RULE_pageNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5127)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PagePropertyDisplayContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func propertyNameDisplay() -> [PropertyNameDisplayContext] {
				return getRuleContexts(PropertyNameDisplayContext.self)
			}
			open
			func propertyNameDisplay(_ i: Int) -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pagePropertyDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPagePropertyDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPagePropertyDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPagePropertyDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPagePropertyDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pagePropertyDisplay() throws -> PagePropertyDisplayContext {
		var _localctx: PagePropertyDisplayContext = PagePropertyDisplayContext(_ctx, getState())
		try enterRule(_localctx, 986, EDIF300Parser.RULE_pagePropertyDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5129)
		 	try match(EDIF300Parser.Tokens.T__388.rawValue)
		 	setState(5130)
		 	try propertyNameRef()
		 	setState(5135)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5133)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(5131)
		 			try display()

		 			break

		 		case .T__447:
		 			setState(5132)
		 			try propertyNameDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5137)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5138)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageRefContext: ParserRuleContext {
			open
			func pageNameRef() -> PageNameRefContext? {
				return getRuleContext(PageNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageRef() throws -> PageRefContext {
		var _localctx: PageRefContext = PageRefContext(_ctx, getState())
		try enterRule(_localctx, 988, EDIF300Parser.RULE_pageRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5140)
		 	try match(EDIF300Parser.Tokens.T__389.rawValue)
		 	setState(5141)
		 	try pageNameRef()
		 	setState(5142)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageSizeContext: ParserRuleContext {
			open
			func rectangle() -> RectangleContext? {
				return getRuleContext(RectangleContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageSize
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageSize(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageSize(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageSize(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageSize(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageSize() throws -> PageSizeContext {
		var _localctx: PageSizeContext = PageSizeContext(_ctx, getState())
		try enterRule(_localctx, 990, EDIF300Parser.RULE_pageSize)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5144)
		 	try match(EDIF300Parser.Tokens.T__390.rawValue)
		 	setState(5145)
		 	try rectangle()
		 	setState(5146)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageTitleContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageTitle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageTitle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageTitle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageTitle(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageTitle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageTitle() throws -> PageTitleContext {
		var _localctx: PageTitleContext = PageTitleContext(_ctx, getState())
		try enterRule(_localctx, 992, EDIF300Parser.RULE_pageTitle)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5148)
		 	try match(EDIF300Parser.Tokens.T__391.rawValue)
		 	setState(5149)
		 	try stringToken()
		 	setState(5150)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageTitleBlockContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func pageTitleBlockTemplateRef() -> PageTitleBlockTemplateRefContext? {
				return getRuleContext(PageTitleBlockTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func pagePropertyDisplay() -> [PagePropertyDisplayContext] {
				return getRuleContexts(PagePropertyDisplayContext.self)
			}
			open
			func pagePropertyDisplay(_ i: Int) -> PagePropertyDisplayContext? {
				return getRuleContext(PagePropertyDisplayContext.self, i)
			}
			open
			func pageTitleBlockAttributeDisplay() -> [PageTitleBlockAttributeDisplayContext] {
				return getRuleContexts(PageTitleBlockAttributeDisplayContext.self)
			}
			open
			func pageTitleBlockAttributeDisplay(_ i: Int) -> PageTitleBlockAttributeDisplayContext? {
				return getRuleContext(PageTitleBlockAttributeDisplayContext.self, i)
			}
			open
			func pageTitleBlockAttributes() -> [PageTitleBlockAttributesContext] {
				return getRuleContexts(PageTitleBlockAttributesContext.self)
			}
			open
			func pageTitleBlockAttributes(_ i: Int) -> PageTitleBlockAttributesContext? {
				return getRuleContext(PageTitleBlockAttributesContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageTitleBlock
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageTitleBlock(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageTitleBlock(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageTitleBlock(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageTitleBlock(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageTitleBlock() throws -> PageTitleBlockContext {
		var _localctx: PageTitleBlockContext = PageTitleBlockContext(_ctx, getState())
		try enterRule(_localctx, 994, EDIF300Parser.RULE_pageTitleBlock)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5152)
		 	try match(EDIF300Parser.Tokens.T__392.rawValue)
		 	setState(5153)
		 	try implementationNameDef()
		 	setState(5154)
		 	try pageTitleBlockTemplateRef()
		 	setState(5155)
		 	try transform()
		 	setState(5166)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__346.rawValue,EDIF300Parser.Tokens.T__388.rawValue,EDIF300Parser.Tokens.T__393.rawValue,EDIF300Parser.Tokens.T__394.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 347)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__442.rawValue,EDIF300Parser.Tokens.T__443.rawValue,EDIF300Parser.Tokens.T__444.rawValue,EDIF300Parser.Tokens.T__448.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 443)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(5164)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__346:
		 			setState(5156)
		 			try nameInformation()

		 			break

		 		case .T__388:
		 			setState(5157)
		 			try pagePropertyDisplay()

		 			break

		 		case .T__393:
		 			setState(5158)
		 			try pageTitleBlockAttributeDisplay()

		 			break

		 		case .T__394:
		 			setState(5159)
		 			try pageTitleBlockAttributes()

		 			break

		 		case .T__442:
		 			setState(5160)
		 			try property()

		 			break

		 		case .T__443:
		 			setState(5161)
		 			try propertyDisplay()

		 			break

		 		case .T__444:
		 			setState(5162)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(5163)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5168)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5169)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageTitleBlockAttributeDisplayContext: ParserRuleContext {
			open
			func approvedDateDisplay() -> [ApprovedDateDisplayContext] {
				return getRuleContexts(ApprovedDateDisplayContext.self)
			}
			open
			func approvedDateDisplay(_ i: Int) -> ApprovedDateDisplayContext? {
				return getRuleContext(ApprovedDateDisplayContext.self, i)
			}
			open
			func checkDateDisplay() -> [CheckDateDisplayContext] {
				return getRuleContexts(CheckDateDisplayContext.self)
			}
			open
			func checkDateDisplay(_ i: Int) -> CheckDateDisplayContext? {
				return getRuleContext(CheckDateDisplayContext.self, i)
			}
			open
			func companyNameDisplay() -> [CompanyNameDisplayContext] {
				return getRuleContexts(CompanyNameDisplayContext.self)
			}
			open
			func companyNameDisplay(_ i: Int) -> CompanyNameDisplayContext? {
				return getRuleContext(CompanyNameDisplayContext.self, i)
			}
			open
			func contractDisplay() -> [ContractDisplayContext] {
				return getRuleContexts(ContractDisplayContext.self)
			}
			open
			func contractDisplay(_ i: Int) -> ContractDisplayContext? {
				return getRuleContext(ContractDisplayContext.self, i)
			}
			open
			func copyrightDisplay() -> [CopyrightDisplayContext] {
				return getRuleContexts(CopyrightDisplayContext.self)
			}
			open
			func copyrightDisplay(_ i: Int) -> CopyrightDisplayContext? {
				return getRuleContext(CopyrightDisplayContext.self, i)
			}
			open
			func drawingDescriptionDisplay() -> [DrawingDescriptionDisplayContext] {
				return getRuleContexts(DrawingDescriptionDisplayContext.self)
			}
			open
			func drawingDescriptionDisplay(_ i: Int) -> DrawingDescriptionDisplayContext? {
				return getRuleContext(DrawingDescriptionDisplayContext.self, i)
			}
			open
			func drawingIdentificationDisplay() -> [DrawingIdentificationDisplayContext] {
				return getRuleContexts(DrawingIdentificationDisplayContext.self)
			}
			open
			func drawingIdentificationDisplay(_ i: Int) -> DrawingIdentificationDisplayContext? {
				return getRuleContext(DrawingIdentificationDisplayContext.self, i)
			}
			open
			func drawingSizeDisplay() -> [DrawingSizeDisplayContext] {
				return getRuleContexts(DrawingSizeDisplayContext.self)
			}
			open
			func drawingSizeDisplay(_ i: Int) -> DrawingSizeDisplayContext? {
				return getRuleContext(DrawingSizeDisplayContext.self, i)
			}
			open
			func engineeringDateDisplay() -> [EngineeringDateDisplayContext] {
				return getRuleContexts(EngineeringDateDisplayContext.self)
			}
			open
			func engineeringDateDisplay(_ i: Int) -> EngineeringDateDisplayContext? {
				return getRuleContext(EngineeringDateDisplayContext.self, i)
			}
			open
			func originalDrawingDateDisplay() -> [OriginalDrawingDateDisplayContext] {
				return getRuleContexts(OriginalDrawingDateDisplayContext.self)
			}
			open
			func originalDrawingDateDisplay(_ i: Int) -> OriginalDrawingDateDisplayContext? {
				return getRuleContext(OriginalDrawingDateDisplayContext.self, i)
			}
			open
			func pageIdentificationDisplay() -> [PageIdentificationDisplayContext] {
				return getRuleContexts(PageIdentificationDisplayContext.self)
			}
			open
			func pageIdentificationDisplay(_ i: Int) -> PageIdentificationDisplayContext? {
				return getRuleContext(PageIdentificationDisplayContext.self, i)
			}
			open
			func pageTitleDisplay() -> [PageTitleDisplayContext] {
				return getRuleContexts(PageTitleDisplayContext.self)
			}
			open
			func pageTitleDisplay(_ i: Int) -> PageTitleDisplayContext? {
				return getRuleContext(PageTitleDisplayContext.self, i)
			}
			open
			func revisionDisplay() -> [RevisionDisplayContext] {
				return getRuleContexts(RevisionDisplayContext.self)
			}
			open
			func revisionDisplay(_ i: Int) -> RevisionDisplayContext? {
				return getRuleContext(RevisionDisplayContext.self, i)
			}
			open
			func totalPagesDisplay() -> [TotalPagesDisplayContext] {
				return getRuleContexts(TotalPagesDisplayContext.self)
			}
			open
			func totalPagesDisplay(_ i: Int) -> TotalPagesDisplayContext? {
				return getRuleContext(TotalPagesDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageTitleBlockAttributeDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageTitleBlockAttributeDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageTitleBlockAttributeDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageTitleBlockAttributeDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageTitleBlockAttributeDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageTitleBlockAttributeDisplay() throws -> PageTitleBlockAttributeDisplayContext {
		var _localctx: PageTitleBlockAttributeDisplayContext = PageTitleBlockAttributeDisplayContext(_ctx, getState())
		try enterRule(_localctx, 996, EDIF300Parser.RULE_pageTitleBlockAttributeDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5171)
		 	try match(EDIF300Parser.Tokens.T__393.rawValue)
		 	setState(5188)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__9.rawValue,EDIF300Parser.Tokens.T__48.rawValue,EDIF300Parser.Tokens.T__64.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 10)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__92.rawValue,EDIF300Parser.Tokens.T__94.rawValue,EDIF300Parser.Tokens.T__139.rawValue,EDIF300Parser.Tokens.T__141.rawValue,EDIF300Parser.Tokens.T__143.rawValue,EDIF300Parser.Tokens.T__152.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 93)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__370.rawValue,EDIF300Parser.Tokens.T__386.rawValue,EDIF300Parser.Tokens.T__397.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 371)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__461.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__623.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5186)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__9:
		 			setState(5172)
		 			try approvedDateDisplay()

		 			break

		 		case .T__48:
		 			setState(5173)
		 			try checkDateDisplay()

		 			break

		 		case .T__64:
		 			setState(5174)
		 			try companyNameDisplay()

		 			break

		 		case .T__92:
		 			setState(5175)
		 			try contractDisplay()

		 			break

		 		case .T__94:
		 			setState(5176)
		 			try copyrightDisplay()

		 			break

		 		case .T__139:
		 			setState(5177)
		 			try drawingDescriptionDisplay()

		 			break

		 		case .T__141:
		 			setState(5178)
		 			try drawingIdentificationDisplay()

		 			break

		 		case .T__143:
		 			setState(5179)
		 			try drawingSizeDisplay()

		 			break

		 		case .T__152:
		 			setState(5180)
		 			try engineeringDateDisplay()

		 			break

		 		case .T__370:
		 			setState(5181)
		 			try originalDrawingDateDisplay()

		 			break

		 		case .T__386:
		 			setState(5182)
		 			try pageIdentificationDisplay()

		 			break

		 		case .T__397:
		 			setState(5183)
		 			try pageTitleDisplay()

		 			break

		 		case .T__461:
		 			setState(5184)
		 			try revisionDisplay()

		 			break

		 		case .T__623:
		 			setState(5185)
		 			try totalPagesDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5190)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5191)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageTitleBlockAttributesContext: ParserRuleContext {
			open
			func approvedDate() -> [ApprovedDateContext] {
				return getRuleContexts(ApprovedDateContext.self)
			}
			open
			func approvedDate(_ i: Int) -> ApprovedDateContext? {
				return getRuleContext(ApprovedDateContext.self, i)
			}
			open
			func checkDate() -> [CheckDateContext] {
				return getRuleContexts(CheckDateContext.self)
			}
			open
			func checkDate(_ i: Int) -> CheckDateContext? {
				return getRuleContext(CheckDateContext.self, i)
			}
			open
			func companyName() -> [CompanyNameContext] {
				return getRuleContexts(CompanyNameContext.self)
			}
			open
			func companyName(_ i: Int) -> CompanyNameContext? {
				return getRuleContext(CompanyNameContext.self, i)
			}
			open
			func contract() -> [ContractContext] {
				return getRuleContexts(ContractContext.self)
			}
			open
			func contract(_ i: Int) -> ContractContext? {
				return getRuleContext(ContractContext.self, i)
			}
			open
			func drawingDescription() -> [DrawingDescriptionContext] {
				return getRuleContexts(DrawingDescriptionContext.self)
			}
			open
			func drawingDescription(_ i: Int) -> DrawingDescriptionContext? {
				return getRuleContext(DrawingDescriptionContext.self, i)
			}
			open
			func drawingIdentification() -> [DrawingIdentificationContext] {
				return getRuleContexts(DrawingIdentificationContext.self)
			}
			open
			func drawingIdentification(_ i: Int) -> DrawingIdentificationContext? {
				return getRuleContext(DrawingIdentificationContext.self, i)
			}
			open
			func drawingSize() -> [DrawingSizeContext] {
				return getRuleContexts(DrawingSizeContext.self)
			}
			open
			func drawingSize(_ i: Int) -> DrawingSizeContext? {
				return getRuleContext(DrawingSizeContext.self, i)
			}
			open
			func engineeringDate() -> [EngineeringDateContext] {
				return getRuleContexts(EngineeringDateContext.self)
			}
			open
			func engineeringDate(_ i: Int) -> EngineeringDateContext? {
				return getRuleContext(EngineeringDateContext.self, i)
			}
			open
			func originalDrawingDate() -> [OriginalDrawingDateContext] {
				return getRuleContexts(OriginalDrawingDateContext.self)
			}
			open
			func originalDrawingDate(_ i: Int) -> OriginalDrawingDateContext? {
				return getRuleContext(OriginalDrawingDateContext.self, i)
			}
			open
			func pageIdentification() -> [PageIdentificationContext] {
				return getRuleContexts(PageIdentificationContext.self)
			}
			open
			func pageIdentification(_ i: Int) -> PageIdentificationContext? {
				return getRuleContext(PageIdentificationContext.self, i)
			}
			open
			func pageTitle() -> [PageTitleContext] {
				return getRuleContexts(PageTitleContext.self)
			}
			open
			func pageTitle(_ i: Int) -> PageTitleContext? {
				return getRuleContext(PageTitleContext.self, i)
			}
			open
			func revision() -> [RevisionContext] {
				return getRuleContexts(RevisionContext.self)
			}
			open
			func revision(_ i: Int) -> RevisionContext? {
				return getRuleContext(RevisionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageTitleBlockAttributes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageTitleBlockAttributes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageTitleBlockAttributes(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageTitleBlockAttributes(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageTitleBlockAttributes(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageTitleBlockAttributes() throws -> PageTitleBlockAttributesContext {
		var _localctx: PageTitleBlockAttributesContext = PageTitleBlockAttributesContext(_ctx, getState())
		try enterRule(_localctx, 998, EDIF300Parser.RULE_pageTitleBlockAttributes)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5193)
		 	try match(EDIF300Parser.Tokens.T__394.rawValue)
		 	setState(5208)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__8.rawValue,EDIF300Parser.Tokens.T__47.rawValue,EDIF300Parser.Tokens.T__63.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 9)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__91.rawValue,EDIF300Parser.Tokens.T__138.rawValue,EDIF300Parser.Tokens.T__140.rawValue,EDIF300Parser.Tokens.T__142.rawValue,EDIF300Parser.Tokens.T__151.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 92)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__369.rawValue,EDIF300Parser.Tokens.T__385.rawValue,EDIF300Parser.Tokens.T__391.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 370)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__460.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5206)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__8:
		 			setState(5194)
		 			try approvedDate()

		 			break

		 		case .T__47:
		 			setState(5195)
		 			try checkDate()

		 			break

		 		case .T__63:
		 			setState(5196)
		 			try companyName()

		 			break

		 		case .T__91:
		 			setState(5197)
		 			try contract()

		 			break

		 		case .T__138:
		 			setState(5198)
		 			try drawingDescription()

		 			break

		 		case .T__140:
		 			setState(5199)
		 			try drawingIdentification()

		 			break

		 		case .T__142:
		 			setState(5200)
		 			try drawingSize()

		 			break

		 		case .T__151:
		 			setState(5201)
		 			try engineeringDate()

		 			break

		 		case .T__369:
		 			setState(5202)
		 			try originalDrawingDate()

		 			break

		 		case .T__385:
		 			setState(5203)
		 			try pageIdentification()

		 			break

		 		case .T__391:
		 			setState(5204)
		 			try pageTitle()

		 			break

		 		case .T__460:
		 			setState(5205)
		 			try revision()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5210)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5211)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageTitleBlockTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func pageTitleBlockAttributeDisplay() -> [PageTitleBlockAttributeDisplayContext] {
				return getRuleContexts(PageTitleBlockAttributeDisplayContext.self)
			}
			open
			func pageTitleBlockAttributeDisplay(_ i: Int) -> PageTitleBlockAttributeDisplayContext? {
				return getRuleContext(PageTitleBlockAttributeDisplayContext.self, i)
			}
			open
			func pageTitleBlockAttributes() -> [PageTitleBlockAttributesContext] {
				return getRuleContexts(PageTitleBlockAttributesContext.self)
			}
			open
			func pageTitleBlockAttributes(_ i: Int) -> PageTitleBlockAttributesContext? {
				return getRuleContext(PageTitleBlockAttributesContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageTitleBlockTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageTitleBlockTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageTitleBlockTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageTitleBlockTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageTitleBlockTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageTitleBlockTemplate() throws -> PageTitleBlockTemplateContext {
		var _localctx: PageTitleBlockTemplateContext = PageTitleBlockTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1000, EDIF300Parser.RULE_pageTitleBlockTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5213)
		 	try match(EDIF300Parser.Tokens.T__395.rawValue)
		 	setState(5214)
		 	try libraryObjectNameDef()
		 	setState(5215)
		 	try schematicTemplateHeader()
		 	setState(5225)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__393.rawValue,EDIF300Parser.Tokens.T__394.rawValue,EDIF300Parser.Tokens.T__443.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 394)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5223)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(5216)
		 			try annotate()

		 			break

		 		case .T__62:
		 			setState(5217)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(5218)
		 			try figure()

		 			break

		 		case .T__393:
		 			setState(5219)
		 			try pageTitleBlockAttributeDisplay()

		 			break

		 		case .T__394:
		 			setState(5220)
		 			try pageTitleBlockAttributes()

		 			break

		 		case .T__443:
		 			setState(5221)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(5222)
		 			try schematicComplexFigure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5227)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5228)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageTitleBlockTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageTitleBlockTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageTitleBlockTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageTitleBlockTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageTitleBlockTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageTitleBlockTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageTitleBlockTemplateRef() throws -> PageTitleBlockTemplateRefContext {
		var _localctx: PageTitleBlockTemplateRefContext = PageTitleBlockTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1002, EDIF300Parser.RULE_pageTitleBlockTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5230)
		 	try match(EDIF300Parser.Tokens.T__396.rawValue)
		 	setState(5231)
		 	try libraryObjectNameRef()
		 	setState(5233)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5232)
		 		try libraryRef()

		 	}

		 	setState(5235)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PageTitleDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pageTitleDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPageTitleDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPageTitleDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPageTitleDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPageTitleDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pageTitleDisplay() throws -> PageTitleDisplayContext {
		var _localctx: PageTitleDisplayContext = PageTitleDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1004, EDIF300Parser.RULE_pageTitleDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5237)
		 	try match(EDIF300Parser.Tokens.T__397.rawValue)
		 	setState(5241)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(5238)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(5239)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(5240)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5243)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ParameterDisplayContext: ParserRuleContext {
			open
			func parameterNameRef() -> ParameterNameRefContext? {
				return getRuleContext(ParameterNameRefContext.self, 0)
			}
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
			open
			func parameterNameDisplay() -> ParameterNameDisplayContext? {
				return getRuleContext(ParameterNameDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_parameterDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterParameterDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitParameterDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitParameterDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitParameterDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func parameterDisplay() throws -> ParameterDisplayContext {
		var _localctx: ParameterDisplayContext = ParameterDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1006, EDIF300Parser.RULE_parameterDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5245)
		 	try match(EDIF300Parser.Tokens.T__398.rawValue)
		 	setState(5246)
		 	try parameterNameRef()
		 	setState(5250)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(5247)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(5248)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(5249)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5253)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__400.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5252)
		 		try parameterNameDisplay()

		 	}

		 	setState(5255)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ParameterNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_parameterNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterParameterNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitParameterNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitParameterNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitParameterNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func parameterNameCaseSensitive() throws -> ParameterNameCaseSensitiveContext {
		var _localctx: ParameterNameCaseSensitiveContext = ParameterNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 1008, EDIF300Parser.RULE_parameterNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5257)
		 	try match(EDIF300Parser.Tokens.T__399.rawValue)
		 	setState(5258)
		 	try booleanToken()
		 	setState(5259)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ParameterNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_parameterNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterParameterNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitParameterNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitParameterNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitParameterNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func parameterNameDef() throws -> ParameterNameDefContext {
		var _localctx: ParameterNameDefContext = ParameterNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1010, EDIF300Parser.RULE_parameterNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5261)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ParameterNameDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_parameterNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterParameterNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitParameterNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitParameterNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitParameterNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func parameterNameDisplay() throws -> ParameterNameDisplayContext {
		var _localctx: ParameterNameDisplayContext = ParameterNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1012, EDIF300Parser.RULE_parameterNameDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5263)
		 	try match(EDIF300Parser.Tokens.T__400.rawValue)
		 	setState(5267)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(5264)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(5265)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(5266)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5269)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ParameterNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_parameterNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterParameterNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitParameterNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitParameterNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitParameterNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func parameterNameRef() throws -> ParameterNameRefContext {
		var _localctx: ParameterNameRefContext = ParameterNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1014, EDIF300Parser.RULE_parameterNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5271)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PathContext: ParserRuleContext {
			open
			func pointList() -> PointListContext? {
				return getRuleContext(PointListContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_path
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPath(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPath(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPath(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPath(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func path() throws -> PathContext {
		var _localctx: PathContext = PathContext(_ctx, getState())
		try enterRule(_localctx, 1016, EDIF300Parser.RULE_path)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5273)
		 	try match(EDIF300Parser.Tokens.T__401.rawValue)
		 	setState(5274)
		 	try pointList()
		 	setState(5275)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PathDelayContext: ParserRuleContext {
			open
			func delay() -> DelayContext? {
				return getRuleContext(DelayContext.self, 0)
			}
			open
			func event() -> [EventContext] {
				return getRuleContexts(EventContext.self)
			}
			open
			func event(_ i: Int) -> EventContext? {
				return getRuleContext(EventContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pathDelay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPathDelay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPathDelay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPathDelay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPathDelay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pathDelay() throws -> PathDelayContext {
		var _localctx: PathDelayContext = PathDelayContext(_ctx, getState())
		try enterRule(_localctx, 1018, EDIF300Parser.RULE_pathDelay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5277)
		 	try match(EDIF300Parser.Tokens.T__402.rawValue)
		 	setState(5278)
		 	try delay()
		 	setState(5282)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__153.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5279)
		 		try event()


		 		setState(5284)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5285)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PathWidthContext: ParserRuleContext {
			open
			func lengthValue() -> LengthValueContext? {
				return getRuleContext(LengthValueContext.self, 0)
			}
			open
			func minimalWidth() -> MinimalWidthContext? {
				return getRuleContext(MinimalWidthContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pathWidth
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPathWidth(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPathWidth(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPathWidth(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPathWidth(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pathWidth() throws -> PathWidthContext {
		var _localctx: PathWidthContext = PathWidthContext(_ctx, getState())
		try enterRule(_localctx, 1020, EDIF300Parser.RULE_pathWidth)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5287)
		 	try match(EDIF300Parser.Tokens.T__403.rawValue)
		 	setState(5290)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DECIMAL_LITERAL:
		 		setState(5288)
		 		try lengthValue()

		 		break

		 	case .T__334:
		 		setState(5289)
		 		try minimalWidth()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5292)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PcbLayoutUnitsContext: ParserRuleContext {
			open
			func setAngle() -> [SetAngleContext] {
				return getRuleContexts(SetAngleContext.self)
			}
			open
			func setAngle(_ i: Int) -> SetAngleContext? {
				return getRuleContext(SetAngleContext.self, i)
			}
			open
			func setCapacitance() -> [SetCapacitanceContext] {
				return getRuleContexts(SetCapacitanceContext.self)
			}
			open
			func setCapacitance(_ i: Int) -> SetCapacitanceContext? {
				return getRuleContext(SetCapacitanceContext.self, i)
			}
			open
			func setDistance() -> [SetDistanceContext] {
				return getRuleContexts(SetDistanceContext.self)
			}
			open
			func setDistance(_ i: Int) -> SetDistanceContext? {
				return getRuleContext(SetDistanceContext.self, i)
			}
			open
			func setTime() -> [SetTimeContext] {
				return getRuleContexts(SetTimeContext.self)
			}
			open
			func setTime(_ i: Int) -> SetTimeContext? {
				return getRuleContext(SetTimeContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pcbLayoutUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPcbLayoutUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPcbLayoutUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPcbLayoutUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPcbLayoutUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pcbLayoutUnits() throws -> PcbLayoutUnitsContext {
		var _localctx: PcbLayoutUnitsContext = PcbLayoutUnitsContext(_ctx, getState())
		try enterRule(_localctx, 1022, EDIF300Parser.RULE_pcbLayoutUnits)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5294)
		 	try match(EDIF300Parser.Tokens.T__404.rawValue)
		 	setState(5301)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__575.rawValue,EDIF300Parser.Tokens.T__576.rawValue,EDIF300Parser.Tokens.T__578.rawValue,EDIF300Parser.Tokens.T__580.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 576)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(5299)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__575:
		 			setState(5295)
		 			try setAngle()

		 			break

		 		case .T__576:
		 			setState(5296)
		 			try setCapacitance()

		 			break

		 		case .T__578:
		 			setState(5297)
		 			try setDistance()

		 			break

		 		case .T__580:
		 			setState(5298)
		 			try setTime()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5303)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5304)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PcbLayoutViewContext: ParserRuleContext {
			open
			func viewNameDef() -> ViewNameDefContext? {
				return getRuleContext(ViewNameDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pcbLayoutView
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPcbLayoutView(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPcbLayoutView(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPcbLayoutView(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPcbLayoutView(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pcbLayoutView() throws -> PcbLayoutViewContext {
		var _localctx: PcbLayoutViewContext = PcbLayoutViewContext(_ctx, getState())
		try enterRule(_localctx, 1024, EDIF300Parser.RULE_pcbLayoutView)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5306)
		 	try match(EDIF300Parser.Tokens.T__405.rawValue)
		 	setState(5307)
		 	try viewNameDef()
		 	setState(5313)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5311)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(5308)
		 			try comment()

		 			break

		 		case .T__346:
		 			setState(5309)
		 			try nameInformation()

		 			break

		 		case .T__642:
		 			setState(5310)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5315)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5316)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PermutableContext: ParserRuleContext {
			open
			func nonPermutable() -> [NonPermutableContext] {
				return getRuleContexts(NonPermutableContext.self)
			}
			open
			func nonPermutable(_ i: Int) -> NonPermutableContext? {
				return getRuleContext(NonPermutableContext.self, i)
			}
			open
			func permutable() -> [PermutableContext] {
				return getRuleContexts(PermutableContext.self)
			}
			open
			func permutable(_ i: Int) -> PermutableContext? {
				return getRuleContext(PermutableContext.self, i)
			}
			open
			func portRef() -> [PortRefContext] {
				return getRuleContexts(PortRefContext.self)
			}
			open
			func portRef(_ i: Int) -> PortRefContext? {
				return getRuleContext(PortRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_permutable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPermutable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPermutable(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPermutable(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPermutable(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func permutable() throws -> PermutableContext {
		var _localctx: PermutableContext = PermutableContext(_ctx, getState())
		try enterRule(_localctx, 1026, EDIF300Parser.RULE_permutable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5318)
		 	try match(EDIF300Parser.Tokens.T__406.rawValue)
		 	setState(5324)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__353.rawValue || _la == EDIF300Parser.Tokens.T__406.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__436.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5322)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__353:
		 			setState(5319)
		 			try nonPermutable()

		 			break

		 		case .T__406:
		 			setState(5320)
		 			try permutable()

		 			break

		 		case .T__436:
		 			setState(5321)
		 			try portRef()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5326)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5327)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PhysicalDefaultsContext: ParserRuleContext {
			open
			func schematicRequiredDefaults() -> SchematicRequiredDefaultsContext? {
				return getRuleContext(SchematicRequiredDefaultsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_physicalDefaults
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPhysicalDefaults(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPhysicalDefaults(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPhysicalDefaults(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPhysicalDefaults(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func physicalDefaults() throws -> PhysicalDefaultsContext {
		var _localctx: PhysicalDefaultsContext = PhysicalDefaultsContext(_ctx, getState())
		try enterRule(_localctx, 1028, EDIF300Parser.RULE_physicalDefaults)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5329)
		 	try match(EDIF300Parser.Tokens.T__407.rawValue)
		 	setState(5331)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__545.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5330)
		 		try schematicRequiredDefaults()

		 	}

		 	setState(5333)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PhysicalScalingContext: ParserRuleContext {
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func connectivityUnits() -> [ConnectivityUnitsContext] {
				return getRuleContexts(ConnectivityUnitsContext.self)
			}
			open
			func connectivityUnits(_ i: Int) -> ConnectivityUnitsContext? {
				return getRuleContext(ConnectivityUnitsContext.self, i)
			}
			open
			func documentationUnits() -> [DocumentationUnitsContext] {
				return getRuleContexts(DocumentationUnitsContext.self)
			}
			open
			func documentationUnits(_ i: Int) -> DocumentationUnitsContext? {
				return getRuleContext(DocumentationUnitsContext.self, i)
			}
			open
			func geometryMacroUnits() -> [GeometryMacroUnitsContext] {
				return getRuleContexts(GeometryMacroUnitsContext.self)
			}
			open
			func geometryMacroUnits(_ i: Int) -> GeometryMacroUnitsContext? {
				return getRuleContext(GeometryMacroUnitsContext.self, i)
			}
			open
			func interfaceUnits() -> [InterfaceUnitsContext] {
				return getRuleContexts(InterfaceUnitsContext.self)
			}
			open
			func interfaceUnits(_ i: Int) -> InterfaceUnitsContext? {
				return getRuleContext(InterfaceUnitsContext.self, i)
			}
			open
			func logicModelUnits() -> [LogicModelUnitsContext] {
				return getRuleContexts(LogicModelUnitsContext.self)
			}
			open
			func logicModelUnits(_ i: Int) -> LogicModelUnitsContext? {
				return getRuleContext(LogicModelUnitsContext.self, i)
			}
			open
			func maskLayoutUnits() -> [MaskLayoutUnitsContext] {
				return getRuleContexts(MaskLayoutUnitsContext.self)
			}
			open
			func maskLayoutUnits(_ i: Int) -> MaskLayoutUnitsContext? {
				return getRuleContext(MaskLayoutUnitsContext.self, i)
			}
			open
			func pcbLayoutUnits() -> [PcbLayoutUnitsContext] {
				return getRuleContexts(PcbLayoutUnitsContext.self)
			}
			open
			func pcbLayoutUnits(_ i: Int) -> PcbLayoutUnitsContext? {
				return getRuleContext(PcbLayoutUnitsContext.self, i)
			}
			open
			func schematicUnits() -> [SchematicUnitsContext] {
				return getRuleContexts(SchematicUnitsContext.self)
			}
			open
			func schematicUnits(_ i: Int) -> SchematicUnitsContext? {
				return getRuleContext(SchematicUnitsContext.self, i)
			}
			open
			func symbolicLayoutUnits() -> [SymbolicLayoutUnitsContext] {
				return getRuleContexts(SymbolicLayoutUnitsContext.self)
			}
			open
			func symbolicLayoutUnits(_ i: Int) -> SymbolicLayoutUnitsContext? {
				return getRuleContext(SymbolicLayoutUnitsContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_physicalScaling
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPhysicalScaling(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPhysicalScaling(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPhysicalScaling(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPhysicalScaling(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func physicalScaling() throws -> PhysicalScalingContext {
		var _localctx: PhysicalScalingContext = PhysicalScalingContext(_ctx, getState())
		try enterRule(_localctx, 1030, EDIF300Parser.RULE_physicalScaling)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5335)
		 	try match(EDIF300Parser.Tokens.T__408.rawValue)
		 	setState(5348)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue || _la == EDIF300Parser.Tokens.T__87.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__135.rawValue || _la == EDIF300Parser.Tokens.T__195.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__271.rawValue,EDIF300Parser.Tokens.T__323.rawValue,EDIF300Parser.Tokens.T__329.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 272)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__404.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__566.rawValue || _la == EDIF300Parser.Tokens.T__612.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5346)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(5336)
		 			try comment()

		 			break

		 		case .T__87:
		 			setState(5337)
		 			try connectivityUnits()

		 			break

		 		case .T__135:
		 			setState(5338)
		 			try documentationUnits()

		 			break

		 		case .T__195:
		 			setState(5339)
		 			try geometryMacroUnits()

		 			break

		 		case .T__271:
		 			setState(5340)
		 			try interfaceUnits()

		 			break

		 		case .T__323:
		 			setState(5341)
		 			try logicModelUnits()

		 			break

		 		case .T__329:
		 			setState(5342)
		 			try maskLayoutUnits()

		 			break

		 		case .T__404:
		 			setState(5343)
		 			try pcbLayoutUnits()

		 			break

		 		case .T__566:
		 			setState(5344)
		 			try schematicUnits()

		 			break

		 		case .T__612:
		 			setState(5345)
		 			try symbolicLayoutUnits()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5350)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5351)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PixelPatternContext: ParserRuleContext {
			open
			func rowSize() -> RowSizeContext? {
				return getRuleContext(RowSizeContext.self, 0)
			}
			open
			func pixelRow() -> [PixelRowContext] {
				return getRuleContexts(PixelRowContext.self)
			}
			open
			func pixelRow(_ i: Int) -> PixelRowContext? {
				return getRuleContext(PixelRowContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pixelPattern
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPixelPattern(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPixelPattern(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPixelPattern(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPixelPattern(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pixelPattern() throws -> PixelPatternContext {
		var _localctx: PixelPatternContext = PixelPatternContext(_ctx, getState())
		try enterRule(_localctx, 1032, EDIF300Parser.RULE_pixelPattern)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5353)
		 	try match(EDIF300Parser.Tokens.T__409.rawValue)
		 	setState(5354)
		 	try rowSize()
		 	setState(5358)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__410.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5355)
		 		try pixelRow()


		 		setState(5360)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5361)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PixelRowContext: ParserRuleContext {
			open
			func booleanToken() -> [BooleanTokenContext] {
				return getRuleContexts(BooleanTokenContext.self)
			}
			open
			func booleanToken(_ i: Int) -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pixelRow
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPixelRow(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPixelRow(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPixelRow(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPixelRow(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pixelRow() throws -> PixelRowContext {
		var _localctx: PixelRowContext = PixelRowContext(_ctx, getState())
		try enterRule(_localctx, 1034, EDIF300Parser.RULE_pixelRow)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5363)
		 	try match(EDIF300Parser.Tokens.T__410.rawValue)
		 	setState(5367)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__157.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__626.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5364)
		 		try booleanToken()


		 		setState(5369)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5370)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PointContext: ParserRuleContext {
			open
			func pointValue() -> PointValueContext? {
				return getRuleContext(PointValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_point
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPoint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPoint(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPoint(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPoint(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func point() throws -> PointContext {
		var _localctx: PointContext = PointContext(_ctx, getState())
		try enterRule(_localctx, 1036, EDIF300Parser.RULE_point)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5372)
		 	try match(EDIF300Parser.Tokens.T__411.rawValue)
		 	setState(5373)
		 	try pointValue()
		 	setState(5374)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PointListContext: ParserRuleContext {
			open
			func pointValue() -> [PointValueContext] {
				return getRuleContexts(PointValueContext.self)
			}
			open
			func pointValue(_ i: Int) -> PointValueContext? {
				return getRuleContext(PointValueContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pointList
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPointList(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPointList(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPointList(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPointList(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pointList() throws -> PointListContext {
		var _localctx: PointListContext = PointListContext(_ctx, getState())
		try enterRule(_localctx, 1038, EDIF300Parser.RULE_pointList)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5376)
		 	try match(EDIF300Parser.Tokens.T__412.rawValue)
		 	setState(5380)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__450.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5377)
		 		try pointValue()


		 		setState(5382)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5383)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PointValueContext: ParserRuleContext {
			open
			func pt() -> PtContext? {
				return getRuleContext(PtContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pointValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPointValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPointValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPointValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPointValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pointValue() throws -> PointValueContext {
		var _localctx: PointValueContext = PointValueContext(_ctx, getState())
		try enterRule(_localctx, 1040, EDIF300Parser.RULE_pointValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5385)
		 	try pt()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PolygonContext: ParserRuleContext {
			open
			func pointList() -> PointListContext? {
				return getRuleContext(PointListContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_polygon
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPolygon(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPolygon(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPolygon(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPolygon(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func polygon() throws -> PolygonContext {
		var _localctx: PolygonContext = PolygonContext(_ctx, getState())
		try enterRule(_localctx, 1042, EDIF300Parser.RULE_polygon)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5387)
		 	try match(EDIF300Parser.Tokens.T__413.rawValue)
		 	setState(5388)
		 	try pointList()
		 	setState(5389)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortContext: ParserRuleContext {
			open
			func portNameDef() -> PortNameDefContext? {
				return getRuleContext(PortNameDefContext.self, 0)
			}
			open
			func portDirection() -> PortDirectionContext? {
				return getRuleContext(PortDirectionContext.self, 0)
			}
			open
			func acLoad() -> [AcLoadContext] {
				return getRuleContexts(AcLoadContext.self)
			}
			open
			func acLoad(_ i: Int) -> AcLoadContext? {
				return getRuleContext(AcLoadContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func defaultConnection() -> [DefaultConnectionContext] {
				return getRuleContexts(DefaultConnectionContext.self)
			}
			open
			func defaultConnection(_ i: Int) -> DefaultConnectionContext? {
				return getRuleContext(DefaultConnectionContext.self, i)
			}
			open
			func designator() -> [DesignatorContext] {
				return getRuleContexts(DesignatorContext.self)
			}
			open
			func designator(_ i: Int) -> DesignatorContext? {
				return getRuleContext(DesignatorContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func portDelay() -> [PortDelayContext] {
				return getRuleContexts(PortDelayContext.self)
			}
			open
			func portDelay(_ i: Int) -> PortDelayContext? {
				return getRuleContext(PortDelayContext.self, i)
			}
			open
			func portLoadDelay() -> [PortLoadDelayContext] {
				return getRuleContexts(PortLoadDelayContext.self)
			}
			open
			func portLoadDelay(_ i: Int) -> PortLoadDelayContext? {
				return getRuleContext(PortLoadDelayContext.self, i)
			}
			open
			func portNameGenerator() -> [PortNameGeneratorContext] {
				return getRuleContexts(PortNameGeneratorContext.self)
			}
			open
			func portNameGenerator(_ i: Int) -> PortNameGeneratorContext? {
				return getRuleContext(PortNameGeneratorContext.self, i)
			}
			open
			func portWidth() -> [PortWidthContext] {
				return getRuleContexts(PortWidthContext.self)
			}
			open
			func portWidth(_ i: Int) -> PortWidthContext? {
				return getRuleContext(PortWidthContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func schematicPortAttributes() -> [SchematicPortAttributesContext] {
				return getRuleContexts(SchematicPortAttributesContext.self)
			}
			open
			func schematicPortAttributes(_ i: Int) -> SchematicPortAttributesContext? {
				return getRuleContext(SchematicPortAttributesContext.self, i)
			}
			open
			func unused() -> [UnusedContext] {
				return getRuleContexts(UnusedContext.self)
			}
			open
			func unused(_ i: Int) -> UnusedContext? {
				return getRuleContext(UnusedContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_port
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPort(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPort(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPort(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPort(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func port() throws -> PortContext {
		var _localctx: PortContext = PortContext(_ctx, getState())
		try enterRule(_localctx, 1044, EDIF300Parser.RULE_port)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5391)
		 	try match(EDIF300Parser.Tokens.T__414.rawValue)
		 	setState(5393)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5392)
		 		try portNameDef()

		 	}

		 	setState(5396)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__19.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__230.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__375.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__638.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5395)
		 		try portDirection()

		 	}

		 	setState(5413)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__2.rawValue || _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__113.rawValue || _la == EDIF300Parser.Tokens.T__118.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__418.rawValue,EDIF300Parser.Tokens.T__425.rawValue,EDIF300Parser.Tokens.T__431.rawValue,EDIF300Parser.Tokens.T__438.rawValue,EDIF300Parser.Tokens.T__442.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 419)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__532.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__640.rawValue || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5411)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__2:
		 			setState(5398)
		 			try acLoad()

		 			break

		 		case .T__61:
		 			setState(5399)
		 			try comment()

		 			break

		 		case .T__113:
		 			setState(5400)
		 			try defaultConnection()

		 			break

		 		case .T__118:
		 			setState(5401)
		 			try designator()

		 			break

		 		case .T__346:
		 			setState(5402)
		 			try nameInformation()

		 			break

		 		case .T__418:
		 			setState(5403)
		 			try portDelay()

		 			break

		 		case .T__425:
		 			setState(5404)
		 			try portLoadDelay()

		 			break

		 		case .T__431:
		 			setState(5405)
		 			try portNameGenerator()

		 			break

		 		case .T__438:
		 			setState(5406)
		 			try portWidth()

		 			break

		 		case .T__442:
		 			setState(5407)
		 			try property()

		 			break

		 		case .T__532:
		 			setState(5408)
		 			try schematicPortAttributes()

		 			break

		 		case .T__640:
		 			setState(5409)
		 			try unused()

		 			break

		 		case .T__642:
		 			setState(5410)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5415)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5416)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortAnnotateContext: ParserRuleContext {
			open
			func extendPortDef() -> ExtendPortDefContext? {
				return getRuleContext(ExtendPortDefContext.self, 0)
			}
			open
			func extendPortMemberDef() -> ExtendPortMemberDefContext? {
				return getRuleContext(ExtendPortMemberDefContext.self, 0)
			}
			open
			func acLoad() -> [AcLoadContext] {
				return getRuleContexts(AcLoadContext.self)
			}
			open
			func acLoad(_ i: Int) -> AcLoadContext? {
				return getRuleContext(AcLoadContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func designator() -> [DesignatorContext] {
				return getRuleContexts(DesignatorContext.self)
			}
			open
			func designator(_ i: Int) -> DesignatorContext? {
				return getRuleContext(DesignatorContext.self, i)
			}
			open
			func directionalPortAttributeOverride() -> [DirectionalPortAttributeOverrideContext] {
				return getRuleContexts(DirectionalPortAttributeOverrideContext.self)
			}
			open
			func directionalPortAttributeOverride(_ i: Int) -> DirectionalPortAttributeOverrideContext? {
				return getRuleContext(DirectionalPortAttributeOverrideContext.self, i)
			}
			open
			func portDelay() -> [PortDelayContext] {
				return getRuleContexts(PortDelayContext.self)
			}
			open
			func portDelay(_ i: Int) -> PortDelayContext? {
				return getRuleContext(PortDelayContext.self, i)
			}
			open
			func portDelayOverride() -> [PortDelayOverrideContext] {
				return getRuleContexts(PortDelayOverrideContext.self)
			}
			open
			func portDelayOverride(_ i: Int) -> PortDelayOverrideContext? {
				return getRuleContext(PortDelayOverrideContext.self, i)
			}
			open
			func portLoadDelay() -> [PortLoadDelayContext] {
				return getRuleContexts(PortLoadDelayContext.self)
			}
			open
			func portLoadDelay(_ i: Int) -> PortLoadDelayContext? {
				return getRuleContext(PortLoadDelayContext.self, i)
			}
			open
			func portLoadDelayOverride() -> [PortLoadDelayOverrideContext] {
				return getRuleContexts(PortLoadDelayOverrideContext.self)
			}
			open
			func portLoadDelayOverride(_ i: Int) -> PortLoadDelayOverrideContext? {
				return getRuleContext(PortLoadDelayOverrideContext.self, i)
			}
			open
			func portPropertyOverride() -> [PortPropertyOverrideContext] {
				return getRuleContexts(PortPropertyOverrideContext.self)
			}
			open
			func portPropertyOverride(_ i: Int) -> PortPropertyOverrideContext? {
				return getRuleContext(PortPropertyOverrideContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portAnnotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portAnnotate() throws -> PortAnnotateContext {
		var _localctx: PortAnnotateContext = PortAnnotateContext(_ctx, getState())
		try enterRule(_localctx, 1046, EDIF300Parser.RULE_portAnnotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5418)
		 	try match(EDIF300Parser.Tokens.T__415.rawValue)
		 	setState(5421)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IDENTIFIER:
		 		setState(5419)
		 		try extendPortDef()

		 		break

		 	case .T__428:
		 		setState(5420)
		 		try extendPortMemberDef()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5435)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__2.rawValue || _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__118.rawValue || _la == EDIF300Parser.Tokens.T__127.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__418.rawValue,EDIF300Parser.Tokens.T__420.rawValue,EDIF300Parser.Tokens.T__425.rawValue,EDIF300Parser.Tokens.T__427.rawValue,EDIF300Parser.Tokens.T__435.rawValue,EDIF300Parser.Tokens.T__442.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 419)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(5433)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__2:
		 			setState(5423)
		 			try acLoad()

		 			break

		 		case .T__61:
		 			setState(5424)
		 			try comment()

		 			break

		 		case .T__118:
		 			setState(5425)
		 			try designator()

		 			break

		 		case .T__127:
		 			setState(5426)
		 			try directionalPortAttributeOverride()

		 			break

		 		case .T__418:
		 			setState(5427)
		 			try portDelay()

		 			break

		 		case .T__420:
		 			setState(5428)
		 			try portDelayOverride()

		 			break

		 		case .T__425:
		 			setState(5429)
		 			try portLoadDelay()

		 			break

		 		case .T__427:
		 			setState(5430)
		 			try portLoadDelayOverride()

		 			break

		 		case .T__435:
		 			setState(5431)
		 			try portPropertyOverride()

		 			break

		 		case .T__442:
		 			setState(5432)
		 			try property()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5437)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5438)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortAttributeDisplayContext: ParserRuleContext {
			open
			func acLoadDisplay() -> [AcLoadDisplayContext] {
				return getRuleContexts(AcLoadDisplayContext.self)
			}
			open
			func acLoadDisplay(_ i: Int) -> AcLoadDisplayContext? {
				return getRuleContext(AcLoadDisplayContext.self, i)
			}
			open
			func connectedSignalIndexGeneratorDisplay() -> [ConnectedSignalIndexGeneratorDisplayContext] {
				return getRuleContexts(ConnectedSignalIndexGeneratorDisplayContext.self)
			}
			open
			func connectedSignalIndexGeneratorDisplay(_ i: Int) -> ConnectedSignalIndexGeneratorDisplayContext? {
				return getRuleContext(ConnectedSignalIndexGeneratorDisplayContext.self, i)
			}
			open
			func dcFanInLoadDisplay() -> [DcFanInLoadDisplayContext] {
				return getRuleContexts(DcFanInLoadDisplayContext.self)
			}
			open
			func dcFanInLoadDisplay(_ i: Int) -> DcFanInLoadDisplayContext? {
				return getRuleContext(DcFanInLoadDisplayContext.self, i)
			}
			open
			func dcFanOutLoadDisplay() -> [DcFanOutLoadDisplayContext] {
				return getRuleContexts(DcFanOutLoadDisplayContext.self)
			}
			open
			func dcFanOutLoadDisplay(_ i: Int) -> DcFanOutLoadDisplayContext? {
				return getRuleContext(DcFanOutLoadDisplayContext.self, i)
			}
			open
			func dcMaxFanInDisplay() -> [DcMaxFanInDisplayContext] {
				return getRuleContexts(DcMaxFanInDisplayContext.self)
			}
			open
			func dcMaxFanInDisplay(_ i: Int) -> DcMaxFanInDisplayContext? {
				return getRuleContext(DcMaxFanInDisplayContext.self, i)
			}
			open
			func dcMaxFanOutDisplay() -> [DcMaxFanOutDisplayContext] {
				return getRuleContexts(DcMaxFanOutDisplayContext.self)
			}
			open
			func dcMaxFanOutDisplay(_ i: Int) -> DcMaxFanOutDisplayContext? {
				return getRuleContext(DcMaxFanOutDisplayContext.self, i)
			}
			open
			func designatorDisplay() -> [DesignatorDisplayContext] {
				return getRuleContexts(DesignatorDisplayContext.self)
			}
			open
			func designatorDisplay(_ i: Int) -> DesignatorDisplayContext? {
				return getRuleContext(DesignatorDisplayContext.self, i)
			}
			open
			func portDelayDisplay() -> [PortDelayDisplayContext] {
				return getRuleContexts(PortDelayDisplayContext.self)
			}
			open
			func portDelayDisplay(_ i: Int) -> PortDelayDisplayContext? {
				return getRuleContext(PortDelayDisplayContext.self, i)
			}
			open
			func portLoadDelayDisplay() -> [PortLoadDelayDisplayContext] {
				return getRuleContexts(PortLoadDelayDisplayContext.self)
			}
			open
			func portLoadDelayDisplay(_ i: Int) -> PortLoadDelayDisplayContext? {
				return getRuleContext(PortLoadDelayDisplayContext.self, i)
			}
			open
			func portNameDisplay() -> [PortNameDisplayContext] {
				return getRuleContexts(PortNameDisplayContext.self)
			}
			open
			func portNameDisplay(_ i: Int) -> PortNameDisplayContext? {
				return getRuleContext(PortNameDisplayContext.self, i)
			}
			open
			func portNameGeneratorDisplay() -> [PortNameGeneratorDisplayContext] {
				return getRuleContexts(PortNameGeneratorDisplayContext.self)
			}
			open
			func portNameGeneratorDisplay(_ i: Int) -> PortNameGeneratorDisplayContext? {
				return getRuleContext(PortNameGeneratorDisplayContext.self, i)
			}
			open
			func portPropertyDisplay() -> [PortPropertyDisplayContext] {
				return getRuleContexts(PortPropertyDisplayContext.self)
			}
			open
			func portPropertyDisplay(_ i: Int) -> PortPropertyDisplayContext? {
				return getRuleContext(PortPropertyDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portAttributeDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortAttributeDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortAttributeDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortAttributeDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortAttributeDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portAttributeDisplay() throws -> PortAttributeDisplayContext {
		var _localctx: PortAttributeDisplayContext = PortAttributeDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1048, EDIF300Parser.RULE_portAttributeDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5440)
		 	try match(EDIF300Parser.Tokens.T__416.rawValue)
		 	setState(5455)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__3.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__73.rawValue,EDIF300Parser.Tokens.T__104.rawValue,EDIF300Parser.Tokens.T__106.rawValue,EDIF300Parser.Tokens.T__108.rawValue,EDIF300Parser.Tokens.T__110.rawValue,EDIF300Parser.Tokens.T__119.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 74)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__419.rawValue,EDIF300Parser.Tokens.T__426.rawValue,EDIF300Parser.Tokens.T__430.rawValue,EDIF300Parser.Tokens.T__432.rawValue,EDIF300Parser.Tokens.T__433.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 420)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(5453)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__3:
		 			setState(5441)
		 			try acLoadDisplay()

		 			break

		 		case .T__73:
		 			setState(5442)
		 			try connectedSignalIndexGeneratorDisplay()

		 			break

		 		case .T__104:
		 			setState(5443)
		 			try dcFanInLoadDisplay()

		 			break

		 		case .T__106:
		 			setState(5444)
		 			try dcFanOutLoadDisplay()

		 			break

		 		case .T__108:
		 			setState(5445)
		 			try dcMaxFanInDisplay()

		 			break

		 		case .T__110:
		 			setState(5446)
		 			try dcMaxFanOutDisplay()

		 			break

		 		case .T__119:
		 			setState(5447)
		 			try designatorDisplay()

		 			break

		 		case .T__419:
		 			setState(5448)
		 			try portDelayDisplay()

		 			break

		 		case .T__426:
		 			setState(5449)
		 			try portLoadDelayDisplay()

		 			break

		 		case .T__430:
		 			setState(5450)
		 			try portNameDisplay()

		 			break

		 		case .T__432:
		 			setState(5451)
		 			try portNameGeneratorDisplay()

		 			break

		 		case .T__433:
		 			setState(5452)
		 			try portPropertyDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5457)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5458)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortBundleContext: ParserRuleContext {
			open
			func portNameDef() -> PortNameDefContext? {
				return getRuleContext(PortNameDefContext.self, 0)
			}
			open
			func portList() -> PortListContext? {
				return getRuleContext(PortListContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
			open
			func designator() -> [DesignatorContext] {
				return getRuleContexts(DesignatorContext.self)
			}
			open
			func designator(_ i: Int) -> DesignatorContext? {
				return getRuleContext(DesignatorContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portBundle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortBundle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortBundle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortBundle(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortBundle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portBundle() throws -> PortBundleContext {
		var _localctx: PortBundleContext = PortBundleContext(_ctx, getState())
		try enterRule(_localctx, 1050, EDIF300Parser.RULE_portBundle)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5460)
		 	try match(EDIF300Parser.Tokens.T__417.rawValue)
		 	setState(5461)
		 	try portNameDef()
		 	setState(5462)
		 	try portList()
		 	setState(5470)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue || _la == EDIF300Parser.Tokens.T__118.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5468)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(5463)
		 			try comment()

		 			break

		 		case .T__346:
		 			setState(5464)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(5465)
		 			try property()

		 			break

		 		case .T__642:
		 			setState(5466)
		 			try userData()

		 			break

		 		case .T__118:
		 			setState(5467)
		 			try designator()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5472)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5473)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortDelayContext: ParserRuleContext {
			open
			func portDelayNameDef() -> PortDelayNameDefContext? {
				return getRuleContext(PortDelayNameDefContext.self, 0)
			}
			open
			func derivation() -> DerivationContext? {
				return getRuleContext(DerivationContext.self, 0)
			}
			open
			func delay() -> DelayContext? {
				return getRuleContext(DelayContext.self, 0)
			}
			open
			func becomes() -> [BecomesContext] {
				return getRuleContexts(BecomesContext.self)
			}
			open
			func becomes(_ i: Int) -> BecomesContext? {
				return getRuleContext(BecomesContext.self, i)
			}
			open
			func transition() -> [TransitionContext] {
				return getRuleContexts(TransitionContext.self)
			}
			open
			func transition(_ i: Int) -> TransitionContext? {
				return getRuleContext(TransitionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portDelay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortDelay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortDelay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortDelay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortDelay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portDelay() throws -> PortDelayContext {
		var _localctx: PortDelayContext = PortDelayContext(_ctx, getState())
		try enterRule(_localctx, 1052, EDIF300Parser.RULE_portDelay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5475)
		 	try match(EDIF300Parser.Tokens.T__418.rawValue)
		 	setState(5476)
		 	try portDelayNameDef()
		 	setState(5477)
		 	try derivation()
		 	setState(5478)
		 	try delay()
		 	setState(5483)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__16.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__625.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5481)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__16:
		 			setState(5479)
		 			try becomes()

		 			break

		 		case .T__625:
		 			setState(5480)
		 			try transition()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5485)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5486)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortDelayDisplayContext: ParserRuleContext {
			open
			func portDelayNameRef() -> PortDelayNameRefContext? {
				return getRuleContext(PortDelayNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portDelayDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortDelayDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortDelayDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortDelayDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortDelayDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portDelayDisplay() throws -> PortDelayDisplayContext {
		var _localctx: PortDelayDisplayContext = PortDelayDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1054, EDIF300Parser.RULE_portDelayDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5488)
		 	try match(EDIF300Parser.Tokens.T__419.rawValue)
		 	setState(5489)
		 	try portDelayNameRef()
		 	setState(5493)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5490)
		 		try display()


		 		setState(5495)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5496)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortDelayNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portDelayNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortDelayNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortDelayNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortDelayNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortDelayNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portDelayNameDef() throws -> PortDelayNameDefContext {
		var _localctx: PortDelayNameDefContext = PortDelayNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1056, EDIF300Parser.RULE_portDelayNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5498)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortDelayNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portDelayNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortDelayNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortDelayNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortDelayNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortDelayNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portDelayNameRef() throws -> PortDelayNameRefContext {
		var _localctx: PortDelayNameRefContext = PortDelayNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1058, EDIF300Parser.RULE_portDelayNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5500)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortDelayOverrideContext: ParserRuleContext {
			open
			func portDelayNameRef() -> PortDelayNameRefContext? {
				return getRuleContext(PortDelayNameRefContext.self, 0)
			}
			open
			func derivation() -> DerivationContext? {
				return getRuleContext(DerivationContext.self, 0)
			}
			open
			func delay() -> DelayContext? {
				return getRuleContext(DelayContext.self, 0)
			}
			open
			func becomes() -> [BecomesContext] {
				return getRuleContexts(BecomesContext.self)
			}
			open
			func becomes(_ i: Int) -> BecomesContext? {
				return getRuleContext(BecomesContext.self, i)
			}
			open
			func transition() -> [TransitionContext] {
				return getRuleContexts(TransitionContext.self)
			}
			open
			func transition(_ i: Int) -> TransitionContext? {
				return getRuleContext(TransitionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portDelayOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortDelayOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortDelayOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortDelayOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortDelayOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portDelayOverride() throws -> PortDelayOverrideContext {
		var _localctx: PortDelayOverrideContext = PortDelayOverrideContext(_ctx, getState())
		try enterRule(_localctx, 1060, EDIF300Parser.RULE_portDelayOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5502)
		 	try match(EDIF300Parser.Tokens.T__420.rawValue)
		 	setState(5503)
		 	try portDelayNameRef()
		 	setState(5504)
		 	try derivation()
		 	setState(5505)
		 	try delay()
		 	setState(5510)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__16.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__625.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5508)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__16:
		 			setState(5506)
		 			try becomes()

		 			break

		 		case .T__625:
		 			setState(5507)
		 			try transition()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5512)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5513)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortDirectionContext: ParserRuleContext {
			open
			func inputPort() -> InputPortContext? {
				return getRuleContext(InputPortContext.self, 0)
			}
			open
			func outputPort() -> OutputPortContext? {
				return getRuleContext(OutputPortContext.self, 0)
			}
			open
			func bidirectionalPort() -> BidirectionalPortContext? {
				return getRuleContext(BidirectionalPortContext.self, 0)
			}
			open
			func unspecifiedDirectionPort() -> UnspecifiedDirectionPortContext? {
				return getRuleContext(UnspecifiedDirectionPortContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portDirection
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortDirection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortDirection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortDirection(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortDirection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portDirection() throws -> PortDirectionContext {
		var _localctx: PortDirectionContext = PortDirectionContext(_ctx, getState())
		try enterRule(_localctx, 1062, EDIF300Parser.RULE_portDirection)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5519)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__230:
		 		setState(5515)
		 		try inputPort()

		 		break

		 	case .T__375:
		 		setState(5516)
		 		try outputPort()

		 		break

		 	case .T__19:
		 		setState(5517)
		 		try bidirectionalPort()

		 		break

		 	case .T__638:
		 		setState(5518)
		 		try unspecifiedDirectionPort()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortDirectionIndicatorContext: ParserRuleContext {
			open
			func input() -> InputContext? {
				return getRuleContext(InputContext.self, 0)
			}
			open
			func output() -> OutputContext? {
				return getRuleContext(OutputContext.self, 0)
			}
			open
			func bidirectional() -> BidirectionalContext? {
				return getRuleContext(BidirectionalContext.self, 0)
			}
			open
			func unspecified() -> UnspecifiedContext? {
				return getRuleContext(UnspecifiedContext.self, 0)
			}
			open
			func unrestricted() -> UnrestrictedContext? {
				return getRuleContext(UnrestrictedContext.self, 0)
			}
			open
			func mixedDirection() -> MixedDirectionContext? {
				return getRuleContext(MixedDirectionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portDirectionIndicator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortDirectionIndicator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortDirectionIndicator(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortDirectionIndicator(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortDirectionIndicator(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portDirectionIndicator() throws -> PortDirectionIndicatorContext {
		var _localctx: PortDirectionIndicatorContext = PortDirectionIndicatorContext(_ctx, getState())
		try enterRule(_localctx, 1064, EDIF300Parser.RULE_portDirectionIndicator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5527)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__229:
		 		setState(5521)
		 		try input()

		 		break

		 	case .T__374:
		 		setState(5522)
		 		try output()

		 		break

		 	case .T__18:
		 		setState(5523)
		 		try bidirectional()

		 		break

		 	case .T__637:
		 		setState(5524)
		 		try unspecified()

		 		break

		 	case .T__636:
		 		setState(5525)
		 		try unrestricted()

		 		break

		 	case .T__337:
		 		setState(5526)
		 		try mixedDirection()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortIndexValueContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portIndexValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortIndexValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortIndexValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortIndexValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortIndexValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portIndexValue() throws -> PortIndexValueContext {
		var _localctx: PortIndexValueContext = PortIndexValueContext(_ctx, getState())
		try enterRule(_localctx, 1066, EDIF300Parser.RULE_portIndexValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5529)
		 	try match(EDIF300Parser.Tokens.T__421.rawValue)
		 	setState(5530)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortInstanceRefContext: ParserRuleContext {
			open
			func portNameRef() -> PortNameRefContext? {
				return getRuleContext(PortNameRefContext.self, 0)
			}
			open
			func portMemberRef() -> PortMemberRefContext? {
				return getRuleContext(PortMemberRefContext.self, 0)
			}
			open
			func instanceRef() -> InstanceRefContext? {
				return getRuleContext(InstanceRefContext.self, 0)
			}
			open
			func instanceMemberRef() -> InstanceMemberRefContext? {
				return getRuleContext(InstanceMemberRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portInstanceRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortInstanceRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortInstanceRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortInstanceRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortInstanceRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portInstanceRef() throws -> PortInstanceRefContext {
		var _localctx: PortInstanceRefContext = PortInstanceRefContext(_ctx, getState())
		try enterRule(_localctx, 1068, EDIF300Parser.RULE_portInstanceRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5532)
		 	try match(EDIF300Parser.Tokens.T__422.rawValue)
		 	setState(5535)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IDENTIFIER:
		 		setState(5533)
		 		try portNameRef()

		 		break

		 	case .T__428:
		 		setState(5534)
		 		try portMemberRef()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5539)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__244:
		 		setState(5537)
		 		try instanceRef()

		 		break

		 	case .T__235:
		 		setState(5538)
		 		try instanceMemberRef()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5541)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortJoinedContext: ParserRuleContext {
			open
			func globalPortRef() -> [GlobalPortRefContext] {
				return getRuleContexts(GlobalPortRefContext.self)
			}
			open
			func globalPortRef(_ i: Int) -> GlobalPortRefContext? {
				return getRuleContext(GlobalPortRefContext.self, i)
			}
			open
			func localPortGroupRef() -> [LocalPortGroupRefContext] {
				return getRuleContexts(LocalPortGroupRefContext.self)
			}
			open
			func localPortGroupRef(_ i: Int) -> LocalPortGroupRefContext? {
				return getRuleContext(LocalPortGroupRefContext.self, i)
			}
			open
			func portInstanceRef() -> [PortInstanceRefContext] {
				return getRuleContexts(PortInstanceRefContext.self)
			}
			open
			func portInstanceRef(_ i: Int) -> PortInstanceRefContext? {
				return getRuleContext(PortInstanceRefContext.self, i)
			}
			open
			func portRef() -> [PortRefContext] {
				return getRuleContexts(PortRefContext.self)
			}
			open
			func portRef(_ i: Int) -> PortRefContext? {
				return getRuleContext(PortRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portJoined
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortJoined(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortJoined(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortJoined(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortJoined(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portJoined() throws -> PortJoinedContext {
		var _localctx: PortJoinedContext = PortJoinedContext(_ctx, getState())
		try enterRule(_localctx, 1070, EDIF300Parser.RULE_portJoined)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5543)
		 	try match(EDIF300Parser.Tokens.T__423.rawValue)
		 	setState(5550)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__203.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__317.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__422.rawValue || _la == EDIF300Parser.Tokens.T__436.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5548)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__203:
		 			setState(5544)
		 			try globalPortRef()

		 			break

		 		case .T__317:
		 			setState(5545)
		 			try localPortGroupRef()

		 			break

		 		case .T__422:
		 			setState(5546)
		 			try portInstanceRef()

		 			break

		 		case .T__436:
		 			setState(5547)
		 			try portRef()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5552)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5553)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortListContext: ParserRuleContext {
			open
			func portRef() -> [PortRefContext] {
				return getRuleContexts(PortRefContext.self)
			}
			open
			func portRef(_ i: Int) -> PortRefContext? {
				return getRuleContext(PortRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portList
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortList(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortList(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortList(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortList(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portList() throws -> PortListContext {
		var _localctx: PortListContext = PortListContext(_ctx, getState())
		try enterRule(_localctx, 1072, EDIF300Parser.RULE_portList)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5555)
		 	try match(EDIF300Parser.Tokens.T__424.rawValue)
		 	setState(5559)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__436.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5556)
		 		try portRef()


		 		setState(5561)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5562)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortLoadDelayContext: ParserRuleContext {
			open
			func portLoadDelayNameDef() -> PortLoadDelayNameDefContext? {
				return getRuleContext(PortLoadDelayNameDefContext.self, 0)
			}
			open
			func derivation() -> DerivationContext? {
				return getRuleContext(DerivationContext.self, 0)
			}
			open
			func loadDelay() -> LoadDelayContext? {
				return getRuleContext(LoadDelayContext.self, 0)
			}
			open
			func becomes() -> [BecomesContext] {
				return getRuleContexts(BecomesContext.self)
			}
			open
			func becomes(_ i: Int) -> BecomesContext? {
				return getRuleContext(BecomesContext.self, i)
			}
			open
			func transition() -> [TransitionContext] {
				return getRuleContexts(TransitionContext.self)
			}
			open
			func transition(_ i: Int) -> TransitionContext? {
				return getRuleContext(TransitionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portLoadDelay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortLoadDelay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortLoadDelay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortLoadDelay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortLoadDelay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portLoadDelay() throws -> PortLoadDelayContext {
		var _localctx: PortLoadDelayContext = PortLoadDelayContext(_ctx, getState())
		try enterRule(_localctx, 1074, EDIF300Parser.RULE_portLoadDelay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5564)
		 	try match(EDIF300Parser.Tokens.T__425.rawValue)
		 	setState(5565)
		 	try portLoadDelayNameDef()
		 	setState(5566)
		 	try derivation()
		 	setState(5567)
		 	try loadDelay()
		 	setState(5572)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__16.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__625.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5570)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__16:
		 			setState(5568)
		 			try becomes()

		 			break

		 		case .T__625:
		 			setState(5569)
		 			try transition()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5574)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5575)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortLoadDelayDisplayContext: ParserRuleContext {
			open
			func portLoadDelayNameRef() -> PortLoadDelayNameRefContext? {
				return getRuleContext(PortLoadDelayNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portLoadDelayDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortLoadDelayDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortLoadDelayDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortLoadDelayDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortLoadDelayDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portLoadDelayDisplay() throws -> PortLoadDelayDisplayContext {
		var _localctx: PortLoadDelayDisplayContext = PortLoadDelayDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1076, EDIF300Parser.RULE_portLoadDelayDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5577)
		 	try match(EDIF300Parser.Tokens.T__426.rawValue)
		 	setState(5578)
		 	try portLoadDelayNameRef()
		 	setState(5582)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5579)
		 		try display()


		 		setState(5584)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5585)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortLoadDelayNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portLoadDelayNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortLoadDelayNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortLoadDelayNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortLoadDelayNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortLoadDelayNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portLoadDelayNameDef() throws -> PortLoadDelayNameDefContext {
		var _localctx: PortLoadDelayNameDefContext = PortLoadDelayNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1078, EDIF300Parser.RULE_portLoadDelayNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5587)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortLoadDelayNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portLoadDelayNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortLoadDelayNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortLoadDelayNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortLoadDelayNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortLoadDelayNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portLoadDelayNameRef() throws -> PortLoadDelayNameRefContext {
		var _localctx: PortLoadDelayNameRefContext = PortLoadDelayNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1080, EDIF300Parser.RULE_portLoadDelayNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5589)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortLoadDelayOverrideContext: ParserRuleContext {
			open
			func portLoadDelayNameRef() -> PortLoadDelayNameRefContext? {
				return getRuleContext(PortLoadDelayNameRefContext.self, 0)
			}
			open
			func derivation() -> DerivationContext? {
				return getRuleContext(DerivationContext.self, 0)
			}
			open
			func loadDelay() -> LoadDelayContext? {
				return getRuleContext(LoadDelayContext.self, 0)
			}
			open
			func becomes() -> [BecomesContext] {
				return getRuleContexts(BecomesContext.self)
			}
			open
			func becomes(_ i: Int) -> BecomesContext? {
				return getRuleContext(BecomesContext.self, i)
			}
			open
			func transition() -> [TransitionContext] {
				return getRuleContexts(TransitionContext.self)
			}
			open
			func transition(_ i: Int) -> TransitionContext? {
				return getRuleContext(TransitionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portLoadDelayOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortLoadDelayOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortLoadDelayOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortLoadDelayOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortLoadDelayOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portLoadDelayOverride() throws -> PortLoadDelayOverrideContext {
		var _localctx: PortLoadDelayOverrideContext = PortLoadDelayOverrideContext(_ctx, getState())
		try enterRule(_localctx, 1082, EDIF300Parser.RULE_portLoadDelayOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5591)
		 	try match(EDIF300Parser.Tokens.T__427.rawValue)
		 	setState(5592)
		 	try portLoadDelayNameRef()
		 	setState(5593)
		 	try derivation()
		 	setState(5594)
		 	try loadDelay()
		 	setState(5599)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__16.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__625.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5597)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__16:
		 			setState(5595)
		 			try becomes()

		 			break

		 		case .T__625:
		 			setState(5596)
		 			try transition()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5601)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5602)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortMemberRefContext: ParserRuleContext {
			open
			func portNameRef() -> PortNameRefContext? {
				return getRuleContext(PortNameRefContext.self, 0)
			}
			open
			func indexValue() -> IndexValueContext? {
				return getRuleContext(IndexValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portMemberRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortMemberRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortMemberRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortMemberRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortMemberRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portMemberRef() throws -> PortMemberRefContext {
		var _localctx: PortMemberRefContext = PortMemberRefContext(_ctx, getState())
		try enterRule(_localctx, 1084, EDIF300Parser.RULE_portMemberRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5604)
		 	try match(EDIF300Parser.Tokens.T__428.rawValue)
		 	setState(5605)
		 	try portNameRef()
		 	setState(5606)
		 	try indexValue()
		 	setState(5607)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portNameCaseSensitive() throws -> PortNameCaseSensitiveContext {
		var _localctx: PortNameCaseSensitiveContext = PortNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 1086, EDIF300Parser.RULE_portNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5609)
		 	try match(EDIF300Parser.Tokens.T__429.rawValue)
		 	setState(5610)
		 	try booleanToken()
		 	setState(5611)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portNameDef() throws -> PortNameDefContext {
		var _localctx: PortNameDefContext = PortNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1088, EDIF300Parser.RULE_portNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5613)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortNameDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func displayNameOverride() -> [DisplayNameOverrideContext] {
				return getRuleContexts(DisplayNameOverrideContext.self)
			}
			open
			func displayNameOverride(_ i: Int) -> DisplayNameOverrideContext? {
				return getRuleContext(DisplayNameOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portNameDisplay() throws -> PortNameDisplayContext {
		var _localctx: PortNameDisplayContext = PortNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1090, EDIF300Parser.RULE_portNameDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5615)
		 	try match(EDIF300Parser.Tokens.T__430.rawValue)
		 	setState(5620)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue || _la == EDIF300Parser.Tokens.T__131.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5618)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(5616)
		 			try display()

		 			break

		 		case .T__131:
		 			setState(5617)
		 			try displayNameOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5622)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5623)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortNameGeneratorContext: ParserRuleContext {
			open
			func stringExpression() -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portNameGenerator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortNameGenerator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortNameGenerator(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortNameGenerator(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortNameGenerator(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portNameGenerator() throws -> PortNameGeneratorContext {
		var _localctx: PortNameGeneratorContext = PortNameGeneratorContext(_ctx, getState())
		try enterRule(_localctx, 1092, EDIF300Parser.RULE_portNameGenerator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5625)
		 	try match(EDIF300Parser.Tokens.T__431.rawValue)
		 	setState(5626)
		 	try stringExpression()
		 	setState(5627)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortNameGeneratorDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portNameGeneratorDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortNameGeneratorDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortNameGeneratorDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortNameGeneratorDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortNameGeneratorDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portNameGeneratorDisplay() throws -> PortNameGeneratorDisplayContext {
		var _localctx: PortNameGeneratorDisplayContext = PortNameGeneratorDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1094, EDIF300Parser.RULE_portNameGeneratorDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5629)
		 	try match(EDIF300Parser.Tokens.T__432.rawValue)
		 	setState(5633)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(5630)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(5631)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(5632)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5635)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portNameRef() throws -> PortNameRefContext {
		var _localctx: PortNameRefContext = PortNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1096, EDIF300Parser.RULE_portNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5637)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortPropertyDisplayContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func propertyNameDisplay() -> [PropertyNameDisplayContext] {
				return getRuleContexts(PropertyNameDisplayContext.self)
			}
			open
			func propertyNameDisplay(_ i: Int) -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portPropertyDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortPropertyDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortPropertyDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortPropertyDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortPropertyDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portPropertyDisplay() throws -> PortPropertyDisplayContext {
		var _localctx: PortPropertyDisplayContext = PortPropertyDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1098, EDIF300Parser.RULE_portPropertyDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5639)
		 	try match(EDIF300Parser.Tokens.T__433.rawValue)
		 	setState(5640)
		 	try propertyNameRef()
		 	setState(5645)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5643)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(5641)
		 			try display()

		 			break

		 		case .T__447:
		 			setState(5642)
		 			try propertyNameDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5647)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5648)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortPropertyDisplayOverrideContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
			open
			func propertyNameDisplay() -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portPropertyDisplayOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortPropertyDisplayOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortPropertyDisplayOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortPropertyDisplayOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortPropertyDisplayOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portPropertyDisplayOverride() throws -> PortPropertyDisplayOverrideContext {
		var _localctx: PortPropertyDisplayOverrideContext = PortPropertyDisplayOverrideContext(_ctx, getState())
		try enterRule(_localctx, 1100, EDIF300Parser.RULE_portPropertyDisplayOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5650)
		 	try match(EDIF300Parser.Tokens.T__434.rawValue)
		 	setState(5651)
		 	try propertyNameRef()
		 	setState(5655)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(5652)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(5653)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(5654)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5658)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5657)
		 		try propertyNameDisplay()

		 	}

		 	setState(5660)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortPropertyOverrideContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func typedValue() -> TypedValueContext? {
				return getRuleContext(TypedValueContext.self, 0)
			}
			open
			func untyped() -> UntypedContext? {
				return getRuleContext(UntypedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func fixed() -> [FixedContext] {
				return getRuleContexts(FixedContext.self)
			}
			open
			func fixed(_ i: Int) -> FixedContext? {
				return getRuleContext(FixedContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portPropertyOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortPropertyOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortPropertyOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortPropertyOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortPropertyOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portPropertyOverride() throws -> PortPropertyOverrideContext {
		var _localctx: PortPropertyOverrideContext = PortPropertyOverrideContext(_ctx, getState())
		try enterRule(_localctx, 1102, EDIF300Parser.RULE_portPropertyOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5662)
		 	try match(EDIF300Parser.Tokens.T__435.rawValue)
		 	setState(5663)
		 	try propertyNameRef()
		 	setState(5666)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__23:fallthrough
		 	case .T__247:fallthrough
		 	case .T__336:fallthrough
		 	case .T__356:fallthrough
		 	case .T__411:fallthrough
		 	case .T__599:
		 		setState(5664)
		 		try typedValue()

		 		break

		 	case .T__639:
		 		setState(5665)
		 		try untyped()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5673)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__165.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5671)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(5668)
		 			try comment()

		 			break

		 		case .T__165:
		 			setState(5669)
		 			try fixed()

		 			break

		 		case .T__448:
		 			setState(5670)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5675)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5676)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortRefContext: ParserRuleContext {
			open
			func portNameRef() -> PortNameRefContext? {
				return getRuleContext(PortNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portRef() throws -> PortRefContext {
		var _localctx: PortRefContext = PortRefContext(_ctx, getState())
		try enterRule(_localctx, 1104, EDIF300Parser.RULE_portRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5678)
		 	try match(EDIF300Parser.Tokens.T__436.rawValue)
		 	setState(5679)
		 	try portNameRef()
		 	setState(5680)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortSetContext: ParserRuleContext {
			open
			func portRef() -> [PortRefContext] {
				return getRuleContexts(PortRefContext.self)
			}
			open
			func portRef(_ i: Int) -> PortRefContext? {
				return getRuleContext(PortRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portSet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortSet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortSet(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortSet(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortSet(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portSet() throws -> PortSetContext {
		var _localctx: PortSetContext = PortSetContext(_ctx, getState())
		try enterRule(_localctx, 1106, EDIF300Parser.RULE_portSet)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5682)
		 	try match(EDIF300Parser.Tokens.T__437.rawValue)
		 	setState(5686)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__436.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5683)
		 		try portRef()


		 		setState(5688)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5689)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PortWidthContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_portWidth
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPortWidth(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPortWidth(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPortWidth(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPortWidth(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func portWidth() throws -> PortWidthContext {
		var _localctx: PortWidthContext = PortWidthContext(_ctx, getState())
		try enterRule(_localctx, 1108, EDIF300Parser.RULE_portWidth)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5691)
		 	try match(EDIF300Parser.Tokens.T__438.rawValue)
		 	setState(5692)
		 	try integerExpression()
		 	setState(5693)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PresentLogicValueContext: ParserRuleContext {
			open
			func logicNameRef() -> LogicNameRefContext? {
				return getRuleContext(LogicNameRefContext.self, 0)
			}
			open
			func logicList() -> LogicListContext? {
				return getRuleContext(LogicListContext.self, 0)
			}
			open
			func logicOneOf() -> LogicOneOfContext? {
				return getRuleContext(LogicOneOfContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_presentLogicValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPresentLogicValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPresentLogicValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPresentLogicValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPresentLogicValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func presentLogicValue() throws -> PresentLogicValueContext {
		var _localctx: PresentLogicValueContext = PresentLogicValueContext(_ctx, getState())
		try enterRule(_localctx, 1110, EDIF300Parser.RULE_presentLogicValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5698)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IDENTIFIER:
		 		setState(5695)
		 		try logicNameRef()

		 		break

		 	case .T__320:
		 		setState(5696)
		 		try logicList()

		 		break

		 	case .T__325:
		 		setState(5697)
		 		try logicOneOf()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PreviousLogicValueContext: ParserRuleContext {
			open
			func logicNameRef() -> LogicNameRefContext? {
				return getRuleContext(LogicNameRefContext.self, 0)
			}
			open
			func logicList() -> LogicListContext? {
				return getRuleContext(LogicListContext.self, 0)
			}
			open
			func logicOneOf() -> LogicOneOfContext? {
				return getRuleContext(LogicOneOfContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_previousLogicValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPreviousLogicValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPreviousLogicValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPreviousLogicValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPreviousLogicValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func previousLogicValue() throws -> PreviousLogicValueContext {
		var _localctx: PreviousLogicValueContext = PreviousLogicValueContext(_ctx, getState())
		try enterRule(_localctx, 1112, EDIF300Parser.RULE_previousLogicValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5703)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IDENTIFIER:
		 		setState(5700)
		 		try logicNameRef()

		 		break

		 	case .T__320:
		 		setState(5701)
		 		try logicList()

		 		break

		 	case .T__325:
		 		setState(5702)
		 		try logicOneOf()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PreviousVersionContext: ParserRuleContext {
			open
			func viewRef() -> ViewRefContext? {
				return getRuleContext(ViewRefContext.self, 0)
			}
			open
			func reason() -> ReasonContext? {
				return getRuleContext(ReasonContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_previousVersion
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPreviousVersion(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPreviousVersion(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPreviousVersion(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPreviousVersion(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func previousVersion() throws -> PreviousVersionContext {
		var _localctx: PreviousVersionContext = PreviousVersionContext(_ctx, getState())
		try enterRule(_localctx, 1114, EDIF300Parser.RULE_previousVersion)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5705)
		 	try match(EDIF300Parser.Tokens.T__439.rawValue)
		 	setState(5706)
		 	try viewRef()
		 	setState(5708)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__452.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5707)
		 		try reason()

		 	}

		 	setState(5710)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PrimaryNameContext: ParserRuleContext {
			open
			func originalName() -> OriginalNameContext? {
				return getRuleContext(OriginalNameContext.self, 0)
			}
			open
			func displayName() -> [DisplayNameContext] {
				return getRuleContexts(DisplayNameContext.self)
			}
			open
			func displayName(_ i: Int) -> DisplayNameContext? {
				return getRuleContext(DisplayNameContext.self, i)
			}
			open
			func generated() -> [GeneratedContext] {
				return getRuleContexts(GeneratedContext.self)
			}
			open
			func generated(_ i: Int) -> GeneratedContext? {
				return getRuleContext(GeneratedContext.self, i)
			}
			open
			func nameStructure() -> [NameStructureContext] {
				return getRuleContexts(NameStructureContext.self)
			}
			open
			func nameStructure(_ i: Int) -> NameStructureContext? {
				return getRuleContext(NameStructureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_primaryName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPrimaryName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPrimaryName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPrimaryName(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPrimaryName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func primaryName() throws -> PrimaryNameContext {
		var _localctx: PrimaryNameContext = PrimaryNameContext(_ctx, getState())
		try enterRule(_localctx, 1116, EDIF300Parser.RULE_primaryName)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5712)
		 	try match(EDIF300Parser.Tokens.T__440.rawValue)
		 	setState(5713)
		 	try originalName()
		 	setState(5719)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__130.rawValue || _la == EDIF300Parser.Tokens.T__191.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__348.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5717)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__130:
		 			setState(5714)
		 			try displayName()

		 			break

		 		case .T__191:
		 			setState(5715)
		 			try generated()

		 			break

		 		case .T__348:
		 			setState(5716)
		 			try nameStructure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5721)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5722)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProgramContext: ParserRuleContext {
			open
			func stringValue() -> StringValueContext? {
				return getRuleContext(StringValueContext.self, 0)
			}
			open
			func version() -> VersionContext? {
				return getRuleContext(VersionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_program
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterProgram(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitProgram(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitProgram(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitProgram(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func program() throws -> ProgramContext {
		var _localctx: ProgramContext = ProgramContext(_ctx, getState())
		try enterRule(_localctx, 1118, EDIF300Parser.RULE_program)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5724)
		 	try match(EDIF300Parser.Tokens.T__441.rawValue)
		 	setState(5725)
		 	try stringValue()
		 	setState(5727)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__643.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5726)
		 		try version()

		 	}

		 	setState(5729)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PropertyContext: ParserRuleContext {
			open
			func propertyNameDef() -> PropertyNameDefContext? {
				return getRuleContext(PropertyNameDefContext.self, 0)
			}
			open
			func typedValue() -> TypedValueContext? {
				return getRuleContext(TypedValueContext.self, 0)
			}
			open
			func untyped() -> UntypedContext? {
				return getRuleContext(UntypedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func owner() -> [OwnerContext] {
				return getRuleContexts(OwnerContext.self)
			}
			open
			func owner(_ i: Int) -> OwnerContext? {
				return getRuleContext(OwnerContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func propertyInheritanceControl() -> [PropertyInheritanceControlContext] {
				return getRuleContexts(PropertyInheritanceControlContext.self)
			}
			open
			func propertyInheritanceControl(_ i: Int) -> PropertyInheritanceControlContext? {
				return getRuleContext(PropertyInheritanceControlContext.self, i)
			}
			open
			func unitRef() -> [UnitRefContext] {
				return getRuleContexts(UnitRefContext.self)
			}
			open
			func unitRef(_ i: Int) -> UnitRefContext? {
				return getRuleContext(UnitRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_property
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterProperty(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitProperty(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitProperty(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitProperty(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func property() throws -> PropertyContext {
		var _localctx: PropertyContext = PropertyContext(_ctx, getState())
		try enterRule(_localctx, 1120, EDIF300Parser.RULE_property)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5731)
		 	try match(EDIF300Parser.Tokens.T__442.rawValue)
		 	setState(5732)
		 	try propertyNameDef()
		 	setState(5735)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__23:fallthrough
		 	case .T__247:fallthrough
		 	case .T__336:fallthrough
		 	case .T__356:fallthrough
		 	case .T__411:fallthrough
		 	case .T__599:
		 		setState(5733)
		 		try typedValue()

		 		break

		 	case .T__639:
		 		setState(5734)
		 		try untyped()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5745)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue || _la == EDIF300Parser.Tokens.T__377.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue || _la == EDIF300Parser.Tokens.T__445.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__635.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5743)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(5737)
		 			try comment()

		 			break

		 		case .T__346:
		 			setState(5738)
		 			try nameInformation()

		 			break

		 		case .T__377:
		 			setState(5739)
		 			try owner()

		 			break

		 		case .T__442:
		 			setState(5740)
		 			try property()

		 			break

		 		case .T__445:
		 			setState(5741)
		 			try propertyInheritanceControl()

		 			break

		 		case .T__635:
		 			setState(5742)
		 			try unitRef()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5747)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5748)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PropertyDisplayContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func propertyNameDisplay() -> [PropertyNameDisplayContext] {
				return getRuleContexts(PropertyNameDisplayContext.self)
			}
			open
			func propertyNameDisplay(_ i: Int) -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_propertyDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPropertyDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPropertyDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPropertyDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPropertyDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func propertyDisplay() throws -> PropertyDisplayContext {
		var _localctx: PropertyDisplayContext = PropertyDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1122, EDIF300Parser.RULE_propertyDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5750)
		 	try match(EDIF300Parser.Tokens.T__443.rawValue)
		 	setState(5751)
		 	try propertyNameRef()
		 	setState(5756)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5754)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(5752)
		 			try display()

		 			break

		 		case .T__447:
		 			setState(5753)
		 			try propertyNameDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5758)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5759)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PropertyDisplayOverrideContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
			open
			func propertyNameDisplay() -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_propertyDisplayOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPropertyDisplayOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPropertyDisplayOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPropertyDisplayOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPropertyDisplayOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func propertyDisplayOverride() throws -> PropertyDisplayOverrideContext {
		var _localctx: PropertyDisplayOverrideContext = PropertyDisplayOverrideContext(_ctx, getState())
		try enterRule(_localctx, 1124, EDIF300Parser.RULE_propertyDisplayOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5761)
		 	try match(EDIF300Parser.Tokens.T__444.rawValue)
		 	setState(5762)
		 	try propertyNameRef()
		 	setState(5766)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(5763)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(5764)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(5765)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5769)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5768)
		 		try propertyNameDisplay()

		 	}

		 	setState(5771)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PropertyInheritanceControlContext: ParserRuleContext {
			open
			func fixed() -> FixedContext? {
				return getRuleContext(FixedContext.self, 0)
			}
			open
			func notInherited() -> NotInheritedContext? {
				return getRuleContext(NotInheritedContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_propertyInheritanceControl
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPropertyInheritanceControl(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPropertyInheritanceControl(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPropertyInheritanceControl(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPropertyInheritanceControl(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func propertyInheritanceControl() throws -> PropertyInheritanceControlContext {
		var _localctx: PropertyInheritanceControlContext = PropertyInheritanceControlContext(_ctx, getState())
		try enterRule(_localctx, 1126, EDIF300Parser.RULE_propertyInheritanceControl)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5773)
		 	try match(EDIF300Parser.Tokens.T__445.rawValue)
		 	setState(5776)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__165:
		 		setState(5774)
		 		try fixed()

		 		break

		 	case .T__355:
		 		setState(5775)
		 		try notInherited()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5778)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PropertyNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_propertyNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPropertyNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPropertyNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPropertyNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPropertyNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func propertyNameCaseSensitive() throws -> PropertyNameCaseSensitiveContext {
		var _localctx: PropertyNameCaseSensitiveContext = PropertyNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 1128, EDIF300Parser.RULE_propertyNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5780)
		 	try match(EDIF300Parser.Tokens.T__446.rawValue)
		 	setState(5781)
		 	try booleanToken()
		 	setState(5782)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PropertyNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_propertyNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPropertyNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPropertyNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPropertyNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPropertyNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func propertyNameDef() throws -> PropertyNameDefContext {
		var _localctx: PropertyNameDefContext = PropertyNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1130, EDIF300Parser.RULE_propertyNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5784)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PropertyNameDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func displayNameOverride() -> [DisplayNameOverrideContext] {
				return getRuleContexts(DisplayNameOverrideContext.self)
			}
			open
			func displayNameOverride(_ i: Int) -> DisplayNameOverrideContext? {
				return getRuleContext(DisplayNameOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_propertyNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPropertyNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPropertyNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPropertyNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPropertyNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func propertyNameDisplay() throws -> PropertyNameDisplayContext {
		var _localctx: PropertyNameDisplayContext = PropertyNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1132, EDIF300Parser.RULE_propertyNameDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5786)
		 	try match(EDIF300Parser.Tokens.T__447.rawValue)
		 	setState(5791)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue || _la == EDIF300Parser.Tokens.T__131.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5789)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(5787)
		 			try display()

		 			break

		 		case .T__131:
		 			setState(5788)
		 			try displayNameOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5793)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5794)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PropertyNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_propertyNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPropertyNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPropertyNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPropertyNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPropertyNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func propertyNameRef() throws -> PropertyNameRefContext {
		var _localctx: PropertyNameRefContext = PropertyNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1134, EDIF300Parser.RULE_propertyNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5796)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PropertyOverrideContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func typedValue() -> TypedValueContext? {
				return getRuleContext(TypedValueContext.self, 0)
			}
			open
			func untyped() -> UntypedContext? {
				return getRuleContext(UntypedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func fixed() -> [FixedContext] {
				return getRuleContexts(FixedContext.self)
			}
			open
			func fixed(_ i: Int) -> FixedContext? {
				return getRuleContext(FixedContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_propertyOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPropertyOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPropertyOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPropertyOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPropertyOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func propertyOverride() throws -> PropertyOverrideContext {
		var _localctx: PropertyOverrideContext = PropertyOverrideContext(_ctx, getState())
		try enterRule(_localctx, 1136, EDIF300Parser.RULE_propertyOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5798)
		 	try match(EDIF300Parser.Tokens.T__448.rawValue)
		 	setState(5799)
		 	try propertyNameRef()
		 	setState(5802)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__23:fallthrough
		 	case .T__247:fallthrough
		 	case .T__336:fallthrough
		 	case .T__356:fallthrough
		 	case .T__411:fallthrough
		 	case .T__599:
		 		setState(5800)
		 		try typedValue()

		 		break

		 	case .T__639:
		 		setState(5801)
		 		try untyped()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5809)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__165.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5807)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(5804)
		 			try comment()

		 			break

		 		case .T__165:
		 			setState(5805)
		 			try fixed()

		 			break

		 		case .T__448:
		 			setState(5806)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5811)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5812)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProportionalFontContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_proportionalFont
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterProportionalFont(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitProportionalFont(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitProportionalFont(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitProportionalFont(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func proportionalFont() throws -> ProportionalFontContext {
		var _localctx: ProportionalFontContext = ProportionalFontContext(_ctx, getState())
		try enterRule(_localctx, 1138, EDIF300Parser.RULE_proportionalFont)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5814)
		 	try match(EDIF300Parser.Tokens.T__449.rawValue)
		 	setState(5815)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PtContext: ParserRuleContext {
			open
			func xCoordinate() -> XCoordinateContext? {
				return getRuleContext(XCoordinateContext.self, 0)
			}
			open
			func yCoordinate() -> YCoordinateContext? {
				return getRuleContext(YCoordinateContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pt
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPt(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPt(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPt(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPt(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pt() throws -> PtContext {
		var _localctx: PtContext = PtContext(_ctx, getState())
		try enterRule(_localctx, 1140, EDIF300Parser.RULE_pt)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5817)
		 	try match(EDIF300Parser.Tokens.T__450.rawValue)
		 	setState(5818)
		 	try xCoordinate()
		 	setState(5819)
		 	try yCoordinate()
		 	setState(5820)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class Pt1Context: ParserRuleContext {
			open
			func pointValue() -> PointValueContext? {
				return getRuleContext(PointValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pt1
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPt1(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPt1(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPt1(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPt1(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pt1() throws -> Pt1Context {
		var _localctx: Pt1Context = Pt1Context(_ctx, getState())
		try enterRule(_localctx, 1142, EDIF300Parser.RULE_pt1)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5822)
		 	try pointValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class Pt2Context: ParserRuleContext {
			open
			func pointValue() -> PointValueContext? {
				return getRuleContext(PointValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_pt2
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterPt2(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitPt2(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitPt2(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitPt2(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func pt2() throws -> Pt2Context {
		var _localctx: Pt2Context = Pt2Context(_ctx, getState())
		try enterRule(_localctx, 1144, EDIF300Parser.RULE_pt2)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5824)
		 	try pointValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RadianContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_radian
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRadian(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRadian(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRadian(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRadian(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func radian() throws -> RadianContext {
		var _localctx: RadianContext = RadianContext(_ctx, getState())
		try enterRule(_localctx, 1146, EDIF300Parser.RULE_radian)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5826)
		 	try match(EDIF300Parser.Tokens.T__451.rawValue)
		 	setState(5827)
		 	try unitExponent()
		 	setState(5828)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReasonContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_reason
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterReason(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitReason(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitReason(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitReason(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func reason() throws -> ReasonContext {
		var _localctx: ReasonContext = ReasonContext(_ctx, getState())
		try enterRule(_localctx, 1148, EDIF300Parser.RULE_reason)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5830)
		 	try match(EDIF300Parser.Tokens.T__452.rawValue)
		 	setState(5831)
		 	try stringToken()
		 	setState(5832)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RectangleContext: ParserRuleContext {
			open
			func pt1() -> Pt1Context? {
				return getRuleContext(Pt1Context.self, 0)
			}
			open
			func pt2() -> Pt2Context? {
				return getRuleContext(Pt2Context.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_rectangle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRectangle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRectangle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRectangle(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRectangle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func rectangle() throws -> RectangleContext {
		var _localctx: RectangleContext = RectangleContext(_ctx, getState())
		try enterRule(_localctx, 1150, EDIF300Parser.RULE_rectangle)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5834)
		 	try match(EDIF300Parser.Tokens.T__453.rawValue)
		 	setState(5835)
		 	try pt1()
		 	setState(5836)
		 	try pt2()
		 	setState(5837)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RedContext: ParserRuleContext {
			open
			func scaledInteger() -> ScaledIntegerContext? {
				return getRuleContext(ScaledIntegerContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_red
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRed(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRed(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRed(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRed(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func red() throws -> RedContext {
		var _localctx: RedContext = RedContext(_ctx, getState())
		try enterRule(_localctx, 1152, EDIF300Parser.RULE_red)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5839)
		 	try scaledInteger()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RemoveDisplayContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_removeDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRemoveDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRemoveDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRemoveDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRemoveDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func removeDisplay() throws -> RemoveDisplayContext {
		var _localctx: RemoveDisplayContext = RemoveDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1154, EDIF300Parser.RULE_removeDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5841)
		 	try match(EDIF300Parser.Tokens.T__454.rawValue)
		 	setState(5842)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RepetitionCountContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_repetitionCount
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRepetitionCount(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRepetitionCount(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRepetitionCount(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRepetitionCount(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func repetitionCount() throws -> RepetitionCountContext {
		var _localctx: RepetitionCountContext = RepetitionCountContext(_ctx, getState())
		try enterRule(_localctx, 1156, EDIF300Parser.RULE_repetitionCount)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5844)
		 	try match(EDIF300Parser.Tokens.T__455.rawValue)
		 	setState(5845)
		 	try integerExpression()
		 	setState(5846)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RepetitionCountDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_repetitionCountDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRepetitionCountDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRepetitionCountDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRepetitionCountDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRepetitionCountDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func repetitionCountDisplay() throws -> RepetitionCountDisplayContext {
		var _localctx: RepetitionCountDisplayContext = RepetitionCountDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1158, EDIF300Parser.RULE_repetitionCountDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5848)
		 	try match(EDIF300Parser.Tokens.T__456.rawValue)
		 	setState(5852)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(5849)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(5850)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(5851)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5854)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReplaceDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_replaceDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterReplaceDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitReplaceDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitReplaceDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitReplaceDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func replaceDisplay() throws -> ReplaceDisplayContext {
		var _localctx: ReplaceDisplayContext = ReplaceDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1160, EDIF300Parser.RULE_replaceDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5856)
		 	try match(EDIF300Parser.Tokens.T__457.rawValue)
		 	setState(5860)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5857)
		 		try display()


		 		setState(5862)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5863)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RequiredContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_required
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRequired(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRequired(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRequired(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRequired(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func required() throws -> RequiredContext {
		var _localctx: RequiredContext = RequiredContext(_ctx, getState())
		try enterRule(_localctx, 1162, EDIF300Parser.RULE_required)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5865)
		 	try match(EDIF300Parser.Tokens.T__458.rawValue)
		 	setState(5866)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ResolvesContext: ParserRuleContext {
			open
			func logicNameRef() -> [LogicNameRefContext] {
				return getRuleContexts(LogicNameRefContext.self)
			}
			open
			func logicNameRef(_ i: Int) -> LogicNameRefContext? {
				return getRuleContext(LogicNameRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_resolves
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterResolves(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitResolves(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitResolves(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitResolves(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func resolves() throws -> ResolvesContext {
		var _localctx: ResolvesContext = ResolvesContext(_ctx, getState())
		try enterRule(_localctx, 1164, EDIF300Parser.RULE_resolves)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5868)
		 	try match(EDIF300Parser.Tokens.T__459.rawValue)
		 	setState(5872)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.IDENTIFIER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5869)
		 		try logicNameRef()


		 		setState(5874)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5875)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RevisionContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_revision
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRevision(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRevision(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRevision(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRevision(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func revision() throws -> RevisionContext {
		var _localctx: RevisionContext = RevisionContext(_ctx, getState())
		try enterRule(_localctx, 1166, EDIF300Parser.RULE_revision)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5877)
		 	try match(EDIF300Parser.Tokens.T__460.rawValue)
		 	setState(5878)
		 	try stringToken()
		 	setState(5879)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RevisionDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_revisionDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRevisionDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRevisionDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRevisionDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRevisionDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func revisionDisplay() throws -> RevisionDisplayContext {
		var _localctx: RevisionDisplayContext = RevisionDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1168, EDIF300Parser.RULE_revisionDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5881)
		 	try match(EDIF300Parser.Tokens.T__461.rawValue)
		 	setState(5885)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(5882)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(5883)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(5884)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5887)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RightJustifyContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_rightJustify
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRightJustify(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRightJustify(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRightJustify(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRightJustify(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func rightJustify() throws -> RightJustifyContext {
		var _localctx: RightJustifyContext = RightJustifyContext(_ctx, getState())
		try enterRule(_localctx, 1170, EDIF300Parser.RULE_rightJustify)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5889)
		 	try match(EDIF300Parser.Tokens.T__462.rawValue)
		 	setState(5890)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RipperHotspotContext: ParserRuleContext {
			open
			func hotspotNameDef() -> HotspotNameDefContext? {
				return getRuleContext(HotspotNameDefContext.self, 0)
			}
			open
			func hotspot() -> HotspotContext? {
				return getRuleContext(HotspotContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ripperHotspot
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRipperHotspot(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRipperHotspot(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRipperHotspot(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRipperHotspot(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ripperHotspot() throws -> RipperHotspotContext {
		var _localctx: RipperHotspotContext = RipperHotspotContext(_ctx, getState())
		try enterRule(_localctx, 1172, EDIF300Parser.RULE_ripperHotspot)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5892)
		 	try match(EDIF300Parser.Tokens.T__463.rawValue)
		 	setState(5893)
		 	try hotspotNameDef()
		 	setState(5894)
		 	try hotspot()
		 	setState(5895)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RipperHotspotRefContext: ParserRuleContext {
			open
			func hotspotNameRef() -> HotspotNameRefContext? {
				return getRuleContext(HotspotNameRefContext.self, 0)
			}
			open
			func schematicRipperImplementationRef() -> SchematicRipperImplementationRefContext? {
				return getRuleContext(SchematicRipperImplementationRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_ripperHotspotRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRipperHotspotRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRipperHotspotRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRipperHotspotRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRipperHotspotRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func ripperHotspotRef() throws -> RipperHotspotRefContext {
		var _localctx: RipperHotspotRefContext = RipperHotspotRefContext(_ctx, getState())
		try enterRule(_localctx, 1174, EDIF300Parser.RULE_ripperHotspotRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5897)
		 	try match(EDIF300Parser.Tokens.T__464.rawValue)
		 	setState(5898)
		 	try hotspotNameRef()
		 	setState(5899)
		 	try schematicRipperImplementationRef()
		 	setState(5900)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RotationContext: ParserRuleContext {
			open
			func angleValue() -> AngleValueContext? {
				return getRuleContext(AngleValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_rotation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRotation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRotation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRotation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRotation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func rotation() throws -> RotationContext {
		var _localctx: RotationContext = RotationContext(_ctx, getState())
		try enterRule(_localctx, 1176, EDIF300Parser.RULE_rotation)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5902)
		 	try match(EDIF300Parser.Tokens.T__465.rawValue)
		 	setState(5903)
		 	try angleValue()
		 	setState(5904)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RoundContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_round
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRound(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRound(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRound(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRound(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func round() throws -> RoundContext {
		var _localctx: RoundContext = RoundContext(_ctx, getState())
		try enterRule(_localctx, 1178, EDIF300Parser.RULE_round)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5906)
		 	try match(EDIF300Parser.Tokens.T__466.rawValue)
		 	setState(5907)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RowSizeContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_rowSize
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterRowSize(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitRowSize(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitRowSize(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitRowSize(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func rowSize() throws -> RowSizeContext {
		var _localctx: RowSizeContext = RowSizeContext(_ctx, getState())
		try enterRule(_localctx, 1180, EDIF300Parser.RULE_rowSize)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5909)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScaledIntegerContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
			open
			func e() -> EContext? {
				return getRuleContext(EContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_scaledInteger
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterScaledInteger(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitScaledInteger(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitScaledInteger(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitScaledInteger(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func scaledInteger() throws -> ScaledIntegerContext {
		var _localctx: ScaledIntegerContext = ScaledIntegerContext(_ctx, getState())
		try enterRule(_localctx, 1182, EDIF300Parser.RULE_scaledInteger)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5913)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DECIMAL_LITERAL:
		 		setState(5911)
		 		try integerToken()

		 		break

		 	case .T__145:
		 		setState(5912)
		 		try e()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScaleXContext: ParserRuleContext {
			open
			func numerator() -> NumeratorContext? {
				return getRuleContext(NumeratorContext.self, 0)
			}
			open
			func denominator() -> DenominatorContext? {
				return getRuleContext(DenominatorContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_scaleX
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterScaleX(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitScaleX(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitScaleX(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitScaleX(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func scaleX() throws -> ScaleXContext {
		var _localctx: ScaleXContext = ScaleXContext(_ctx, getState())
		try enterRule(_localctx, 1184, EDIF300Parser.RULE_scaleX)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5915)
		 	try match(EDIF300Parser.Tokens.T__467.rawValue)
		 	setState(5916)
		 	try numerator()
		 	setState(5917)
		 	try denominator()
		 	setState(5918)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScaleYContext: ParserRuleContext {
			open
			func numerator() -> NumeratorContext? {
				return getRuleContext(NumeratorContext.self, 0)
			}
			open
			func denominator() -> DenominatorContext? {
				return getRuleContext(DenominatorContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_scaleY
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterScaleY(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitScaleY(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitScaleY(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitScaleY(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func scaleY() throws -> ScaleYContext {
		var _localctx: ScaleYContext = ScaleYContext(_ctx, getState())
		try enterRule(_localctx, 1186, EDIF300Parser.RULE_scaleY)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5920)
		 	try match(EDIF300Parser.Tokens.T__468.rawValue)
		 	setState(5921)
		 	try numerator()
		 	setState(5922)
		 	try denominator()
		 	setState(5923)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicBusContext: ParserRuleContext {
			open
			func interconnectNameDef() -> InterconnectNameDefContext? {
				return getRuleContext(InterconnectNameDefContext.self, 0)
			}
			open
			func signalGroupRef() -> SignalGroupRefContext? {
				return getRuleContext(SignalGroupRefContext.self, 0)
			}
			open
			func schematicInterconnectHeader() -> SchematicInterconnectHeaderContext? {
				return getRuleContext(SchematicInterconnectHeaderContext.self, 0)
			}
			open
			func schematicBusJoined() -> SchematicBusJoinedContext? {
				return getRuleContext(SchematicBusJoinedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func schematicBusDetails() -> [SchematicBusDetailsContext] {
				return getRuleContexts(SchematicBusDetailsContext.self)
			}
			open
			func schematicBusDetails(_ i: Int) -> SchematicBusDetailsContext? {
				return getRuleContext(SchematicBusDetailsContext.self, i)
			}
			open
			func schematicBusSlice() -> [SchematicBusSliceContext] {
				return getRuleContexts(SchematicBusSliceContext.self)
			}
			open
			func schematicBusSlice(_ i: Int) -> SchematicBusSliceContext? {
				return getRuleContext(SchematicBusSliceContext.self, i)
			}
			open
			func schematicInterconnectAttributeDisplay() -> [SchematicInterconnectAttributeDisplayContext] {
				return getRuleContexts(SchematicInterconnectAttributeDisplayContext.self)
			}
			open
			func schematicInterconnectAttributeDisplay(_ i: Int) -> SchematicInterconnectAttributeDisplayContext? {
				return getRuleContext(SchematicInterconnectAttributeDisplayContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicBus
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicBus(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicBus(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicBus(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicBus(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicBus() throws -> SchematicBusContext {
		var _localctx: SchematicBusContext = SchematicBusContext(_ctx, getState())
		try enterRule(_localctx, 1188, EDIF300Parser.RULE_schematicBus)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5925)
		 	try match(EDIF300Parser.Tokens.T__469.rawValue)
		 	setState(5926)
		 	try interconnectNameDef()
		 	setState(5927)
		 	try signalGroupRef()
		 	setState(5928)
		 	try schematicInterconnectHeader()
		 	setState(5929)
		 	try schematicBusJoined()
		 	setState(5937)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__470.rawValue,EDIF300Parser.Tokens.T__473.rawValue,EDIF300Parser.Tokens.T__496.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 471)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5935)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(5930)
		 			try comment()

		 			break

		 		case .T__470:
		 			setState(5931)
		 			try schematicBusDetails()

		 			break

		 		case .T__473:
		 			setState(5932)
		 			try schematicBusSlice()

		 			break

		 		case .T__496:
		 			setState(5933)
		 			try schematicInterconnectAttributeDisplay()

		 			break

		 		case .T__642:
		 			setState(5934)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5939)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5940)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicBusDetailsContext: ParserRuleContext {
			open
			func schematicBusGraphics() -> SchematicBusGraphicsContext? {
				return getRuleContext(SchematicBusGraphicsContext.self, 0)
			}
			open
			func schematicSubBusSet() -> SchematicSubBusSetContext? {
				return getRuleContext(SchematicSubBusSetContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicBusDetails
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicBusDetails(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicBusDetails(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicBusDetails(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicBusDetails(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicBusDetails() throws -> SchematicBusDetailsContext {
		var _localctx: SchematicBusDetailsContext = SchematicBusDetailsContext(_ctx, getState())
		try enterRule(_localctx, 1190, EDIF300Parser.RULE_schematicBusDetails)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5942)
		 	try match(EDIF300Parser.Tokens.T__470.rawValue)
		 	setState(5945)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__471:
		 		setState(5943)
		 		try schematicBusGraphics()

		 		break

		 	case .T__551:
		 		setState(5944)
		 		try schematicSubBusSet()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(5947)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicBusGraphicsContext: ParserRuleContext {
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicBusGraphics
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicBusGraphics(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicBusGraphics(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicBusGraphics(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicBusGraphics(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicBusGraphics() throws -> SchematicBusGraphicsContext {
		var _localctx: SchematicBusGraphicsContext = SchematicBusGraphicsContext(_ctx, getState())
		try enterRule(_localctx, 1192, EDIF300Parser.RULE_schematicBusGraphics)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5949)
		 	try match(EDIF300Parser.Tokens.T__471.rawValue)
		 	setState(5956)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5954)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(5950)
		 			try comment()

		 			break

		 		case .T__159:
		 			setState(5951)
		 			try figure()

		 			break

		 		case .T__474:
		 			setState(5952)
		 			try schematicComplexFigure()

		 			break

		 		case .T__642:
		 			setState(5953)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5958)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5959)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicBusJoinedContext: ParserRuleContext {
			open
			func portJoined() -> [PortJoinedContext] {
				return getRuleContexts(PortJoinedContext.self)
			}
			open
			func portJoined(_ i: Int) -> PortJoinedContext? {
				return getRuleContext(PortJoinedContext.self, i)
			}
			open
			func ripperHotspotRef() -> [RipperHotspotRefContext] {
				return getRuleContexts(RipperHotspotRefContext.self)
			}
			open
			func ripperHotspotRef(_ i: Int) -> RipperHotspotRefContext? {
				return getRuleContext(RipperHotspotRefContext.self, i)
			}
			open
			func schematicGlobalPortImplementationRef() -> [SchematicGlobalPortImplementationRefContext] {
				return getRuleContexts(SchematicGlobalPortImplementationRefContext.self)
			}
			open
			func schematicGlobalPortImplementationRef(_ i: Int) -> SchematicGlobalPortImplementationRefContext? {
				return getRuleContext(SchematicGlobalPortImplementationRefContext.self, i)
			}
			open
			func schematicInterconnectTerminatorImplementationRef() -> [SchematicInterconnectTerminatorImplementationRefContext] {
				return getRuleContexts(SchematicInterconnectTerminatorImplementationRefContext.self)
			}
			open
			func schematicInterconnectTerminatorImplementationRef(_ i: Int) -> SchematicInterconnectTerminatorImplementationRefContext? {
				return getRuleContext(SchematicInterconnectTerminatorImplementationRefContext.self, i)
			}
			open
			func schematicJunctionImplementationRef() -> [SchematicJunctionImplementationRefContext] {
				return getRuleContexts(SchematicJunctionImplementationRefContext.self)
			}
			open
			func schematicJunctionImplementationRef(_ i: Int) -> SchematicJunctionImplementationRefContext? {
				return getRuleContext(SchematicJunctionImplementationRefContext.self, i)
			}
			open
			func schematicMasterPortImplementationRef() -> [SchematicMasterPortImplementationRefContext] {
				return getRuleContexts(SchematicMasterPortImplementationRefContext.self)
			}
			open
			func schematicMasterPortImplementationRef(_ i: Int) -> SchematicMasterPortImplementationRefContext? {
				return getRuleContext(SchematicMasterPortImplementationRefContext.self, i)
			}
			open
			func schematicOffPageConnectorImplementationRef() -> [SchematicOffPageConnectorImplementationRefContext] {
				return getRuleContexts(SchematicOffPageConnectorImplementationRefContext.self)
			}
			open
			func schematicOffPageConnectorImplementationRef(_ i: Int) -> SchematicOffPageConnectorImplementationRefContext? {
				return getRuleContext(SchematicOffPageConnectorImplementationRefContext.self, i)
			}
			open
			func schematicOnPageConnectorImplementationRef() -> [SchematicOnPageConnectorImplementationRefContext] {
				return getRuleContexts(SchematicOnPageConnectorImplementationRefContext.self)
			}
			open
			func schematicOnPageConnectorImplementationRef(_ i: Int) -> SchematicOnPageConnectorImplementationRefContext? {
				return getRuleContext(SchematicOnPageConnectorImplementationRefContext.self, i)
			}
			open
			func schematicSymbolPortImplementationRef() -> [SchematicSymbolPortImplementationRefContext] {
				return getRuleContexts(SchematicSymbolPortImplementationRefContext.self)
			}
			open
			func schematicSymbolPortImplementationRef(_ i: Int) -> SchematicSymbolPortImplementationRefContext? {
				return getRuleContext(SchematicSymbolPortImplementationRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicBusJoined
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicBusJoined(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicBusJoined(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicBusJoined(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicBusJoined(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicBusJoined() throws -> SchematicBusJoinedContext {
		var _localctx: SchematicBusJoinedContext = SchematicBusJoinedContext(_ctx, getState())
		try enterRule(_localctx, 1194, EDIF300Parser.RULE_schematicBusJoined)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5961)
		 	try match(EDIF300Parser.Tokens.T__472.rawValue)
		 	setState(5973)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__423.rawValue,EDIF300Parser.Tokens.T__464.rawValue,EDIF300Parser.Tokens.T__485.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 424)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__499.rawValue,EDIF300Parser.Tokens.T__503.rawValue,EDIF300Parser.Tokens.T__507.rawValue,EDIF300Parser.Tokens.T__516.rawValue,EDIF300Parser.Tokens.T__520.rawValue,EDIF300Parser.Tokens.T__561.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 500)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(5971)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__423:
		 			setState(5962)
		 			try portJoined()

		 			break

		 		case .T__464:
		 			setState(5963)
		 			try ripperHotspotRef()

		 			break

		 		case .T__485:
		 			setState(5964)
		 			try schematicGlobalPortImplementationRef()

		 			break

		 		case .T__499:
		 			setState(5965)
		 			try schematicInterconnectTerminatorImplementationRef()

		 			break

		 		case .T__503:
		 			setState(5966)
		 			try schematicJunctionImplementationRef()

		 			break

		 		case .T__507:
		 			setState(5967)
		 			try schematicMasterPortImplementationRef()

		 			break

		 		case .T__516:
		 			setState(5968)
		 			try schematicOffPageConnectorImplementationRef()

		 			break

		 		case .T__520:
		 			setState(5969)
		 			try schematicOnPageConnectorImplementationRef()

		 			break

		 		case .T__561:
		 			setState(5970)
		 			try schematicSymbolPortImplementationRef()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5975)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5976)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicBusSliceContext: ParserRuleContext {
			open
			func interconnectNameDef() -> InterconnectNameDefContext? {
				return getRuleContext(InterconnectNameDefContext.self, 0)
			}
			open
			func signalGroupRef() -> SignalGroupRefContext? {
				return getRuleContext(SignalGroupRefContext.self, 0)
			}
			open
			func schematicInterconnectHeader() -> SchematicInterconnectHeaderContext? {
				return getRuleContext(SchematicInterconnectHeaderContext.self, 0)
			}
			open
			func schematicBusJoined() -> SchematicBusJoinedContext? {
				return getRuleContext(SchematicBusJoinedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func schematicBusDetails() -> [SchematicBusDetailsContext] {
				return getRuleContexts(SchematicBusDetailsContext.self)
			}
			open
			func schematicBusDetails(_ i: Int) -> SchematicBusDetailsContext? {
				return getRuleContext(SchematicBusDetailsContext.self, i)
			}
			open
			func schematicBusSlice() -> [SchematicBusSliceContext] {
				return getRuleContexts(SchematicBusSliceContext.self)
			}
			open
			func schematicBusSlice(_ i: Int) -> SchematicBusSliceContext? {
				return getRuleContext(SchematicBusSliceContext.self, i)
			}
			open
			func schematicInterconnectAttributeDisplay() -> [SchematicInterconnectAttributeDisplayContext] {
				return getRuleContexts(SchematicInterconnectAttributeDisplayContext.self)
			}
			open
			func schematicInterconnectAttributeDisplay(_ i: Int) -> SchematicInterconnectAttributeDisplayContext? {
				return getRuleContext(SchematicInterconnectAttributeDisplayContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicBusSlice
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicBusSlice(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicBusSlice(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicBusSlice(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicBusSlice(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicBusSlice() throws -> SchematicBusSliceContext {
		var _localctx: SchematicBusSliceContext = SchematicBusSliceContext(_ctx, getState())
		try enterRule(_localctx, 1196, EDIF300Parser.RULE_schematicBusSlice)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5978)
		 	try match(EDIF300Parser.Tokens.T__473.rawValue)
		 	setState(5979)
		 	try interconnectNameDef()
		 	setState(5980)
		 	try signalGroupRef()
		 	setState(5981)
		 	try schematicInterconnectHeader()
		 	setState(5982)
		 	try schematicBusJoined()
		 	setState(5990)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__470.rawValue,EDIF300Parser.Tokens.T__473.rawValue,EDIF300Parser.Tokens.T__496.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 471)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(5988)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(5983)
		 			try comment()

		 			break

		 		case .T__470:
		 			setState(5984)
		 			try schematicBusDetails()

		 			break

		 		case .T__473:
		 			setState(5985)
		 			try schematicBusSlice()

		 			break

		 		case .T__496:
		 			setState(5986)
		 			try schematicInterconnectAttributeDisplay()

		 			break

		 		case .T__642:
		 			setState(5987)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(5992)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5993)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicComplexFigureContext: ParserRuleContext {
			open
			func schematicFigureMacroRef() -> SchematicFigureMacroRefContext? {
				return getRuleContext(SchematicFigureMacroRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicComplexFigure
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicComplexFigure(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicComplexFigure(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicComplexFigure(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicComplexFigure(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicComplexFigure() throws -> SchematicComplexFigureContext {
		var _localctx: SchematicComplexFigureContext = SchematicComplexFigureContext(_ctx, getState())
		try enterRule(_localctx, 1198, EDIF300Parser.RULE_schematicComplexFigure)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5995)
		 	try match(EDIF300Parser.Tokens.T__474.rawValue)
		 	setState(5996)
		 	try schematicFigureMacroRef()
		 	setState(5997)
		 	try transform()
		 	setState(6002)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__444.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6000)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__444:
		 			setState(5998)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(5999)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6004)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6005)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicFigureMacroContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicFigureMacro
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicFigureMacro(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicFigureMacro(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicFigureMacro(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicFigureMacro(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicFigureMacro() throws -> SchematicFigureMacroContext {
		var _localctx: SchematicFigureMacroContext = SchematicFigureMacroContext(_ctx, getState())
		try enterRule(_localctx, 1200, EDIF300Parser.RULE_schematicFigureMacro)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6007)
		 	try match(EDIF300Parser.Tokens.T__475.rawValue)
		 	setState(6008)
		 	try libraryObjectNameDef()
		 	setState(6009)
		 	try schematicTemplateHeader()
		 	setState(6019)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__7.rawValue,EDIF300Parser.Tokens.T__61.rawValue,EDIF300Parser.Tokens.T__62.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__443.rawValue || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6017)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6010)
		 			try annotate()

		 			break

		 		case .T__61:
		 			setState(6011)
		 			try comment()

		 			break

		 		case .T__62:
		 			setState(6012)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6013)
		 			try figure()

		 			break

		 		case .T__443:
		 			setState(6014)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6015)
		 			try schematicComplexFigure()

		 			break

		 		case .T__642:
		 			setState(6016)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6021)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6022)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicFigureMacroRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicFigureMacroRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicFigureMacroRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicFigureMacroRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicFigureMacroRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicFigureMacroRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicFigureMacroRef() throws -> SchematicFigureMacroRefContext {
		var _localctx: SchematicFigureMacroRefContext = SchematicFigureMacroRefContext(_ctx, getState())
		try enterRule(_localctx, 1202, EDIF300Parser.RULE_schematicFigureMacroRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6024)
		 	try match(EDIF300Parser.Tokens.T__476.rawValue)
		 	setState(6025)
		 	try libraryObjectNameRef()
		 	setState(6027)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6026)
		 		try libraryRef()

		 	}

		 	setState(6029)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicForFrameBorderContext: ParserRuleContext {
			open
			func schematicForFrameBorderTemplateRef() -> SchematicForFrameBorderTemplateRefContext? {
				return getRuleContext(SchematicForFrameBorderTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func forFrameIndexDisplay() -> [ForFrameIndexDisplayContext] {
				return getRuleContexts(ForFrameIndexDisplayContext.self)
			}
			open
			func forFrameIndexDisplay(_ i: Int) -> ForFrameIndexDisplayContext? {
				return getRuleContext(ForFrameIndexDisplayContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
			open
			func repetitionCountDisplay() -> [RepetitionCountDisplayContext] {
				return getRuleContexts(RepetitionCountDisplayContext.self)
			}
			open
			func repetitionCountDisplay(_ i: Int) -> RepetitionCountDisplayContext? {
				return getRuleContext(RepetitionCountDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicForFrameBorder
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicForFrameBorder(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicForFrameBorder(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicForFrameBorder(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicForFrameBorder(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicForFrameBorder() throws -> SchematicForFrameBorderContext {
		var _localctx: SchematicForFrameBorderContext = SchematicForFrameBorderContext(_ctx, getState())
		try enterRule(_localctx, 1204, EDIF300Parser.RULE_schematicForFrameBorder)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6031)
		 	try match(EDIF300Parser.Tokens.T__477.rawValue)
		 	setState(6032)
		 	try schematicForFrameBorderTemplateRef()
		 	setState(6033)
		 	try transform()
		 	setState(6040)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__179.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__444.rawValue,EDIF300Parser.Tokens.T__448.rawValue,EDIF300Parser.Tokens.T__456.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 445)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6038)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__179:
		 			setState(6034)
		 			try forFrameIndexDisplay()

		 			break

		 		case .T__444:
		 			setState(6035)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6036)
		 			try propertyOverride()

		 			break

		 		case .T__456:
		 			setState(6037)
		 			try repetitionCountDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6042)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6043)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicForFrameBorderTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func usableArea() -> UsableAreaContext? {
				return getRuleContext(UsableAreaContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func forFrameIndexDisplay() -> [ForFrameIndexDisplayContext] {
				return getRuleContexts(ForFrameIndexDisplayContext.self)
			}
			open
			func forFrameIndexDisplay(_ i: Int) -> ForFrameIndexDisplayContext? {
				return getRuleContext(ForFrameIndexDisplayContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func repetitionCountDisplay() -> [RepetitionCountDisplayContext] {
				return getRuleContexts(RepetitionCountDisplayContext.self)
			}
			open
			func repetitionCountDisplay(_ i: Int) -> RepetitionCountDisplayContext? {
				return getRuleContext(RepetitionCountDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicForFrameBorderTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicForFrameBorderTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicForFrameBorderTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicForFrameBorderTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicForFrameBorderTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicForFrameBorderTemplate() throws -> SchematicForFrameBorderTemplateContext {
		var _localctx: SchematicForFrameBorderTemplateContext = SchematicForFrameBorderTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1206, EDIF300Parser.RULE_schematicForFrameBorderTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6045)
		 	try match(EDIF300Parser.Tokens.T__478.rawValue)
		 	setState(6046)
		 	try libraryObjectNameDef()
		 	setState(6047)
		 	try schematicTemplateHeader()
		 	setState(6048)
		 	try usableArea()
		 	setState(6058)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue || _la == EDIF300Parser.Tokens.T__179.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__443.rawValue,EDIF300Parser.Tokens.T__456.rawValue,EDIF300Parser.Tokens.T__474.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 444)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6056)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6049)
		 			try annotate()

		 			break

		 		case .T__62:
		 			setState(6050)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6051)
		 			try figure()

		 			break

		 		case .T__179:
		 			setState(6052)
		 			try forFrameIndexDisplay()

		 			break

		 		case .T__443:
		 			setState(6053)
		 			try propertyDisplay()

		 			break

		 		case .T__456:
		 			setState(6054)
		 			try repetitionCountDisplay()

		 			break

		 		case .T__474:
		 			setState(6055)
		 			try schematicComplexFigure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6060)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6061)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicForFrameBorderTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicForFrameBorderTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicForFrameBorderTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicForFrameBorderTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicForFrameBorderTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicForFrameBorderTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicForFrameBorderTemplateRef() throws -> SchematicForFrameBorderTemplateRefContext {
		var _localctx: SchematicForFrameBorderTemplateRefContext = SchematicForFrameBorderTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1208, EDIF300Parser.RULE_schematicForFrameBorderTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6063)
		 	try match(EDIF300Parser.Tokens.T__479.rawValue)
		 	setState(6064)
		 	try libraryObjectNameRef()
		 	setState(6066)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6065)
		 		try libraryRef()

		 	}

		 	setState(6068)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicForFrameImplementationContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func forFrameRef() -> ForFrameRefContext? {
				return getRuleContext(ForFrameRefContext.self, 0)
			}
			open
			func schematicForFrameImplementationHeader() -> SchematicForFrameImplementationHeaderContext? {
				return getRuleContext(SchematicForFrameImplementationHeaderContext.self, 0)
			}
			open
			func schematicFrameImplementationDetails() -> SchematicFrameImplementationDetailsContext? {
				return getRuleContext(SchematicFrameImplementationDetailsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicForFrameImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicForFrameImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicForFrameImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicForFrameImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicForFrameImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicForFrameImplementation() throws -> SchematicForFrameImplementationContext {
		var _localctx: SchematicForFrameImplementationContext = SchematicForFrameImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1210, EDIF300Parser.RULE_schematicForFrameImplementation)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6070)
		 	try match(EDIF300Parser.Tokens.T__480.rawValue)
		 	setState(6071)
		 	try implementationNameDef()
		 	setState(6072)
		 	try forFrameRef()
		 	setState(6073)
		 	try schematicForFrameImplementationHeader()
		 	setState(6074)
		 	try schematicFrameImplementationDetails()
		 	setState(6075)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicForFrameImplementationHeaderContext: ParserRuleContext {
			open
			func schematicForFrameBorder() -> SchematicForFrameBorderContext? {
				return getRuleContext(SchematicForFrameBorderContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicForFrameImplementationHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicForFrameImplementationHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicForFrameImplementationHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicForFrameImplementationHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicForFrameImplementationHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicForFrameImplementationHeader() throws -> SchematicForFrameImplementationHeaderContext {
		var _localctx: SchematicForFrameImplementationHeaderContext = SchematicForFrameImplementationHeaderContext(_ctx, getState())
		try enterRule(_localctx, 1212, EDIF300Parser.RULE_schematicForFrameImplementationHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6077)
		 	try match(EDIF300Parser.Tokens.T__481.rawValue)
		 	setState(6079)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__477.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6078)
		 		try schematicForFrameBorder()

		 	}

		 	setState(6081)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicFrameImplementationDetailsContext: ParserRuleContext {
			open
			func cellPropertyDisplay() -> [CellPropertyDisplayContext] {
				return getRuleContexts(CellPropertyDisplayContext.self)
			}
			open
			func cellPropertyDisplay(_ i: Int) -> CellPropertyDisplayContext? {
				return getRuleContext(CellPropertyDisplayContext.self, i)
			}
			open
			func clusterPropertyDisplay() -> [ClusterPropertyDisplayContext] {
				return getRuleContexts(ClusterPropertyDisplayContext.self)
			}
			open
			func clusterPropertyDisplay(_ i: Int) -> ClusterPropertyDisplayContext? {
				return getRuleContext(ClusterPropertyDisplayContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicBus() -> [SchematicBusContext] {
				return getRuleContexts(SchematicBusContext.self)
			}
			open
			func schematicBus(_ i: Int) -> SchematicBusContext? {
				return getRuleContext(SchematicBusContext.self, i)
			}
			open
			func schematicForFrameImplementation() -> [SchematicForFrameImplementationContext] {
				return getRuleContexts(SchematicForFrameImplementationContext.self)
			}
			open
			func schematicForFrameImplementation(_ i: Int) -> SchematicForFrameImplementationContext? {
				return getRuleContext(SchematicForFrameImplementationContext.self, i)
			}
			open
			func schematicGlobalPortImplementation() -> [SchematicGlobalPortImplementationContext] {
				return getRuleContexts(SchematicGlobalPortImplementationContext.self)
			}
			open
			func schematicGlobalPortImplementation(_ i: Int) -> SchematicGlobalPortImplementationContext? {
				return getRuleContext(SchematicGlobalPortImplementationContext.self, i)
			}
			open
			func schematicIfFrameImplementation() -> [SchematicIfFrameImplementationContext] {
				return getRuleContexts(SchematicIfFrameImplementationContext.self)
			}
			open
			func schematicIfFrameImplementation(_ i: Int) -> SchematicIfFrameImplementationContext? {
				return getRuleContext(SchematicIfFrameImplementationContext.self, i)
			}
			open
			func schematicInstanceImplementation() -> [SchematicInstanceImplementationContext] {
				return getRuleContexts(SchematicInstanceImplementationContext.self)
			}
			open
			func schematicInstanceImplementation(_ i: Int) -> SchematicInstanceImplementationContext? {
				return getRuleContext(SchematicInstanceImplementationContext.self, i)
			}
			open
			func schematicMasterPortImplementation() -> [SchematicMasterPortImplementationContext] {
				return getRuleContexts(SchematicMasterPortImplementationContext.self)
			}
			open
			func schematicMasterPortImplementation(_ i: Int) -> SchematicMasterPortImplementationContext? {
				return getRuleContext(SchematicMasterPortImplementationContext.self, i)
			}
			open
			func schematicNet() -> [SchematicNetContext] {
				return getRuleContexts(SchematicNetContext.self)
			}
			open
			func schematicNet(_ i: Int) -> SchematicNetContext? {
				return getRuleContext(SchematicNetContext.self, i)
			}
			open
			func schematicOffPageConnectorImplementation() -> [SchematicOffPageConnectorImplementationContext] {
				return getRuleContexts(SchematicOffPageConnectorImplementationContext.self)
			}
			open
			func schematicOffPageConnectorImplementation(_ i: Int) -> SchematicOffPageConnectorImplementationContext? {
				return getRuleContext(SchematicOffPageConnectorImplementationContext.self, i)
			}
			open
			func schematicOnPageConnectorImplementation() -> [SchematicOnPageConnectorImplementationContext] {
				return getRuleContexts(SchematicOnPageConnectorImplementationContext.self)
			}
			open
			func schematicOnPageConnectorImplementation(_ i: Int) -> SchematicOnPageConnectorImplementationContext? {
				return getRuleContext(SchematicOnPageConnectorImplementationContext.self, i)
			}
			open
			func schematicOtherwiseFrameImplementation() -> [SchematicOtherwiseFrameImplementationContext] {
				return getRuleContexts(SchematicOtherwiseFrameImplementationContext.self)
			}
			open
			func schematicOtherwiseFrameImplementation(_ i: Int) -> SchematicOtherwiseFrameImplementationContext? {
				return getRuleContext(SchematicOtherwiseFrameImplementationContext.self, i)
			}
			open
			func schematicRipperImplementation() -> [SchematicRipperImplementationContext] {
				return getRuleContexts(SchematicRipperImplementationContext.self)
			}
			open
			func schematicRipperImplementation(_ i: Int) -> SchematicRipperImplementationContext? {
				return getRuleContext(SchematicRipperImplementationContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
			open
			func viewPropertyDisplay() -> [ViewPropertyDisplayContext] {
				return getRuleContexts(ViewPropertyDisplayContext.self)
			}
			open
			func viewPropertyDisplay(_ i: Int) -> ViewPropertyDisplayContext? {
				return getRuleContext(ViewPropertyDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicFrameImplementationDetails
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicFrameImplementationDetails(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicFrameImplementationDetails(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicFrameImplementationDetails(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicFrameImplementationDetails(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicFrameImplementationDetails() throws -> SchematicFrameImplementationDetailsContext {
		var _localctx: SchematicFrameImplementationDetailsContext = SchematicFrameImplementationDetailsContext(_ctx, getState())
		try enterRule(_localctx, 1214, EDIF300Parser.RULE_schematicFrameImplementationDetails)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6083)
		 	try match(EDIF300Parser.Tokens.T__482.rawValue)
		 	setState(6104)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__40.rawValue,EDIF300Parser.Tokens.T__56.rawValue,EDIF300Parser.Tokens.T__61.rawValue,EDIF300Parser.Tokens.T__62.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__443.rawValue,EDIF300Parser.Tokens.T__469.rawValue,EDIF300Parser.Tokens.T__480.rawValue,EDIF300Parser.Tokens.T__484.rawValue,EDIF300Parser.Tokens.T__491.rawValue,EDIF300Parser.Tokens.T__494.rawValue,EDIF300Parser.Tokens.T__506.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 444)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__511.rawValue,EDIF300Parser.Tokens.T__515.rawValue,EDIF300Parser.Tokens.T__519.rawValue,EDIF300Parser.Tokens.T__526.rawValue,EDIF300Parser.Tokens.T__546.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 512)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue || _la == EDIF300Parser.Tokens.T__651.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6102)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__40:
		 			setState(6084)
		 			try cellPropertyDisplay()

		 			break

		 		case .T__56:
		 			setState(6085)
		 			try clusterPropertyDisplay()

		 			break

		 		case .T__61:
		 			setState(6086)
		 			try comment()

		 			break

		 		case .T__62:
		 			setState(6087)
		 			try commentGraphics()

		 			break

		 		case .T__443:
		 			setState(6088)
		 			try propertyDisplay()

		 			break

		 		case .T__469:
		 			setState(6089)
		 			try schematicBus()

		 			break

		 		case .T__480:
		 			setState(6090)
		 			try schematicForFrameImplementation()

		 			break

		 		case .T__484:
		 			setState(6091)
		 			try schematicGlobalPortImplementation()

		 			break

		 		case .T__491:
		 			setState(6092)
		 			try schematicIfFrameImplementation()

		 			break

		 		case .T__494:
		 			setState(6093)
		 			try schematicInstanceImplementation()

		 			break

		 		case .T__506:
		 			setState(6094)
		 			try schematicMasterPortImplementation()

		 			break

		 		case .T__511:
		 			setState(6095)
		 			try schematicNet()

		 			break

		 		case .T__515:
		 			setState(6096)
		 			try schematicOffPageConnectorImplementation()

		 			break

		 		case .T__519:
		 			setState(6097)
		 			try schematicOnPageConnectorImplementation()

		 			break

		 		case .T__526:
		 			setState(6098)
		 			try schematicOtherwiseFrameImplementation()

		 			break

		 		case .T__546:
		 			setState(6099)
		 			try schematicRipperImplementation()

		 			break

		 		case .T__642:
		 			setState(6100)
		 			try userData()

		 			break

		 		case .T__651:
		 			setState(6101)
		 			try viewPropertyDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6106)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6107)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicGlobalPortAttributesContext: ParserRuleContext {
			open
			func ieeeStandard() -> [IeeeStandardContext] {
				return getRuleContexts(IeeeStandardContext.self)
			}
			open
			func ieeeStandard(_ i: Int) -> IeeeStandardContext? {
				return getRuleContext(IeeeStandardContext.self, i)
			}
			open
			func schematicPortAcPower() -> [SchematicPortAcPowerContext] {
				return getRuleContexts(SchematicPortAcPowerContext.self)
			}
			open
			func schematicPortAcPower(_ i: Int) -> SchematicPortAcPowerContext? {
				return getRuleContext(SchematicPortAcPowerContext.self, i)
			}
			open
			func schematicPortAnalog() -> [SchematicPortAnalogContext] {
				return getRuleContexts(SchematicPortAnalogContext.self)
			}
			open
			func schematicPortAnalog(_ i: Int) -> SchematicPortAnalogContext? {
				return getRuleContext(SchematicPortAnalogContext.self, i)
			}
			open
			func schematicPortChassisGround() -> [SchematicPortChassisGroundContext] {
				return getRuleContexts(SchematicPortChassisGroundContext.self)
			}
			open
			func schematicPortChassisGround(_ i: Int) -> SchematicPortChassisGroundContext? {
				return getRuleContext(SchematicPortChassisGroundContext.self, i)
			}
			open
			func schematicPortClock() -> [SchematicPortClockContext] {
				return getRuleContexts(SchematicPortClockContext.self)
			}
			open
			func schematicPortClock(_ i: Int) -> SchematicPortClockContext? {
				return getRuleContext(SchematicPortClockContext.self, i)
			}
			open
			func schematicPortDcPower() -> [SchematicPortDcPowerContext] {
				return getRuleContexts(SchematicPortDcPowerContext.self)
			}
			open
			func schematicPortDcPower(_ i: Int) -> SchematicPortDcPowerContext? {
				return getRuleContext(SchematicPortDcPowerContext.self, i)
			}
			open
			func schematicPortEarthGround() -> [SchematicPortEarthGroundContext] {
				return getRuleContexts(SchematicPortEarthGroundContext.self)
			}
			open
			func schematicPortEarthGround(_ i: Int) -> SchematicPortEarthGroundContext? {
				return getRuleContext(SchematicPortEarthGroundContext.self, i)
			}
			open
			func schematicPortGround() -> [SchematicPortGroundContext] {
				return getRuleContexts(SchematicPortGroundContext.self)
			}
			open
			func schematicPortGround(_ i: Int) -> SchematicPortGroundContext? {
				return getRuleContext(SchematicPortGroundContext.self, i)
			}
			open
			func schematicPortNonLogical() -> [SchematicPortNonLogicalContext] {
				return getRuleContexts(SchematicPortNonLogicalContext.self)
			}
			open
			func schematicPortNonLogical(_ i: Int) -> SchematicPortNonLogicalContext? {
				return getRuleContext(SchematicPortNonLogicalContext.self, i)
			}
			open
			func schematicPortOpenCollector() -> [SchematicPortOpenCollectorContext] {
				return getRuleContexts(SchematicPortOpenCollectorContext.self)
			}
			open
			func schematicPortOpenCollector(_ i: Int) -> SchematicPortOpenCollectorContext? {
				return getRuleContext(SchematicPortOpenCollectorContext.self, i)
			}
			open
			func schematicPortOpenEmitter() -> [SchematicPortOpenEmitterContext] {
				return getRuleContexts(SchematicPortOpenEmitterContext.self)
			}
			open
			func schematicPortOpenEmitter(_ i: Int) -> SchematicPortOpenEmitterContext? {
				return getRuleContext(SchematicPortOpenEmitterContext.self, i)
			}
			open
			func schematicPortPower() -> [SchematicPortPowerContext] {
				return getRuleContexts(SchematicPortPowerContext.self)
			}
			open
			func schematicPortPower(_ i: Int) -> SchematicPortPowerContext? {
				return getRuleContext(SchematicPortPowerContext.self, i)
			}
			open
			func schematicPortThreeState() -> [SchematicPortThreeStateContext] {
				return getRuleContexts(SchematicPortThreeStateContext.self)
			}
			open
			func schematicPortThreeState(_ i: Int) -> SchematicPortThreeStateContext? {
				return getRuleContext(SchematicPortThreeStateContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicGlobalPortAttributes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicGlobalPortAttributes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicGlobalPortAttributes(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicGlobalPortAttributes(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicGlobalPortAttributes(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicGlobalPortAttributes() throws -> SchematicGlobalPortAttributesContext {
		var _localctx: SchematicGlobalPortAttributesContext = SchematicGlobalPortAttributesContext(_ctx, getState())
		try enterRule(_localctx, 1216, EDIF300Parser.RULE_schematicGlobalPortAttributes)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6109)
		 	try match(EDIF300Parser.Tokens.T__483.rawValue)
		 	setState(6125)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__214.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__528.rawValue,EDIF300Parser.Tokens.T__531.rawValue,EDIF300Parser.Tokens.T__533.rawValue,EDIF300Parser.Tokens.T__534.rawValue,EDIF300Parser.Tokens.T__535.rawValue,EDIF300Parser.Tokens.T__537.rawValue,EDIF300Parser.Tokens.T__538.rawValue,EDIF300Parser.Tokens.T__539.rawValue,EDIF300Parser.Tokens.T__540.rawValue,EDIF300Parser.Tokens.T__541.rawValue,EDIF300Parser.Tokens.T__542.rawValue,EDIF300Parser.Tokens.T__544.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 529)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6123)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__214:
		 			setState(6110)
		 			try ieeeStandard()

		 			break

		 		case .T__528:
		 			setState(6111)
		 			try schematicPortAcPower()

		 			break

		 		case .T__531:
		 			setState(6112)
		 			try schematicPortAnalog()

		 			break

		 		case .T__533:
		 			setState(6113)
		 			try schematicPortChassisGround()

		 			break

		 		case .T__534:
		 			setState(6114)
		 			try schematicPortClock()

		 			break

		 		case .T__535:
		 			setState(6115)
		 			try schematicPortDcPower()

		 			break

		 		case .T__537:
		 			setState(6116)
		 			try schematicPortEarthGround()

		 			break

		 		case .T__538:
		 			setState(6117)
		 			try schematicPortGround()

		 			break

		 		case .T__539:
		 			setState(6118)
		 			try schematicPortNonLogical()

		 			break

		 		case .T__540:
		 			setState(6119)
		 			try schematicPortOpenCollector()

		 			break

		 		case .T__541:
		 			setState(6120)
		 			try schematicPortOpenEmitter()

		 			break

		 		case .T__542:
		 			setState(6121)
		 			try schematicPortPower()

		 			break

		 		case .T__544:
		 			setState(6122)
		 			try schematicPortThreeState()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6127)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6128)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicGlobalPortImplementationContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func schematicGlobalPortTemplateRef() -> SchematicGlobalPortTemplateRefContext? {
				return getRuleContext(SchematicGlobalPortTemplateRefContext.self, 0)
			}
			open
			func globalPortRef() -> GlobalPortRefContext? {
				return getRuleContext(GlobalPortRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func globalPortNameDisplay() -> [GlobalPortNameDisplayContext] {
				return getRuleContexts(GlobalPortNameDisplayContext.self)
			}
			open
			func globalPortNameDisplay(_ i: Int) -> GlobalPortNameDisplayContext? {
				return getRuleContext(GlobalPortNameDisplayContext.self, i)
			}
			open
			func globalPortPropertyDisplay() -> [GlobalPortPropertyDisplayContext] {
				return getRuleContexts(GlobalPortPropertyDisplayContext.self)
			}
			open
			func globalPortPropertyDisplay(_ i: Int) -> GlobalPortPropertyDisplayContext? {
				return getRuleContext(GlobalPortPropertyDisplayContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicGlobalPortImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicGlobalPortImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicGlobalPortImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicGlobalPortImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicGlobalPortImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicGlobalPortImplementation() throws -> SchematicGlobalPortImplementationContext {
		var _localctx: SchematicGlobalPortImplementationContext = SchematicGlobalPortImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1218, EDIF300Parser.RULE_schematicGlobalPortImplementation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6130)
		 	try match(EDIF300Parser.Tokens.T__484.rawValue)
		 	setState(6131)
		 	try implementationNameDef()
		 	setState(6132)
		 	try schematicGlobalPortTemplateRef()
		 	setState(6133)
		 	try globalPortRef()
		 	setState(6134)
		 	try transform()
		 	setState(6143)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__201.rawValue,EDIF300Parser.Tokens.T__202.rawValue,EDIF300Parser.Tokens.T__221.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 202)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__444.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6141)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__201:
		 			setState(6135)
		 			try globalPortNameDisplay()

		 			break

		 		case .T__202:
		 			setState(6136)
		 			try globalPortPropertyDisplay()

		 			break

		 		case .T__221:
		 			setState(6137)
		 			try implementationNameDisplay()

		 			break

		 		case .T__346:
		 			setState(6138)
		 			try nameInformation()

		 			break

		 		case .T__444:
		 			setState(6139)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6140)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6145)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6146)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicGlobalPortImplementationRefContext: ParserRuleContext {
			open
			func implementationNameRef() -> ImplementationNameRefContext? {
				return getRuleContext(ImplementationNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicGlobalPortImplementationRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicGlobalPortImplementationRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicGlobalPortImplementationRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicGlobalPortImplementationRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicGlobalPortImplementationRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicGlobalPortImplementationRef() throws -> SchematicGlobalPortImplementationRefContext {
		var _localctx: SchematicGlobalPortImplementationRefContext = SchematicGlobalPortImplementationRefContext(_ctx, getState())
		try enterRule(_localctx, 1220, EDIF300Parser.RULE_schematicGlobalPortImplementationRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6148)
		 	try match(EDIF300Parser.Tokens.T__485.rawValue)
		 	setState(6149)
		 	try implementationNameRef()
		 	setState(6150)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicGlobalPortTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func hotspot() -> [HotspotContext] {
				return getRuleContexts(HotspotContext.self)
			}
			open
			func hotspot(_ i: Int) -> HotspotContext? {
				return getRuleContext(HotspotContext.self, i)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func globalPortNameDisplay() -> [GlobalPortNameDisplayContext] {
				return getRuleContexts(GlobalPortNameDisplayContext.self)
			}
			open
			func globalPortNameDisplay(_ i: Int) -> GlobalPortNameDisplayContext? {
				return getRuleContext(GlobalPortNameDisplayContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
			open
			func schematicGlobalPortAttributes() -> [SchematicGlobalPortAttributesContext] {
				return getRuleContexts(SchematicGlobalPortAttributesContext.self)
			}
			open
			func schematicGlobalPortAttributes(_ i: Int) -> SchematicGlobalPortAttributesContext? {
				return getRuleContext(SchematicGlobalPortAttributesContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicGlobalPortTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicGlobalPortTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicGlobalPortTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicGlobalPortTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicGlobalPortTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicGlobalPortTemplate() throws -> SchematicGlobalPortTemplateContext {
		var _localctx: SchematicGlobalPortTemplateContext = SchematicGlobalPortTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1222, EDIF300Parser.RULE_schematicGlobalPortTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6152)
		 	try match(EDIF300Parser.Tokens.T__486.rawValue)
		 	setState(6153)
		 	try libraryObjectNameDef()
		 	setState(6154)
		 	try schematicTemplateHeader()
		 	setState(6156)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,468,_ctx)) {
		 	case 1:
		 		setState(6155)
		 		try hotspot()

		 		break
		 	default: break
		 	}
		 	setState(6168)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__159.rawValue,EDIF300Parser.Tokens.T__201.rawValue,EDIF300Parser.Tokens.T__221.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 160)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__443.rawValue,EDIF300Parser.Tokens.T__474.rawValue,EDIF300Parser.Tokens.T__483.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 444)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6166)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6158)
		 			try annotate()

		 			break

		 		case .T__62:
		 			setState(6159)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6160)
		 			try figure()

		 			break

		 		case .T__201:
		 			setState(6161)
		 			try globalPortNameDisplay()

		 			break

		 		case .T__221:
		 			setState(6162)
		 			try implementationNameDisplay()

		 			break

		 		case .T__443:
		 			setState(6163)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6164)
		 			try schematicComplexFigure()

		 			break

		 		case .T__483:
		 			setState(6165)
		 			try schematicGlobalPortAttributes()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6170)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6172)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__208.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6171)
		 		try hotspot()

		 	}

		 	setState(6174)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicGlobalPortTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicGlobalPortTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicGlobalPortTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicGlobalPortTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicGlobalPortTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicGlobalPortTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicGlobalPortTemplateRef() throws -> SchematicGlobalPortTemplateRefContext {
		var _localctx: SchematicGlobalPortTemplateRefContext = SchematicGlobalPortTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1224, EDIF300Parser.RULE_schematicGlobalPortTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6176)
		 	try match(EDIF300Parser.Tokens.T__487.rawValue)
		 	setState(6177)
		 	try libraryObjectNameRef()
		 	setState(6179)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6178)
		 		try libraryRef()

		 	}

		 	setState(6181)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicIfFrameBorderContext: ParserRuleContext {
			open
			func schematicIfFrameBorderTemplateRef() -> SchematicIfFrameBorderTemplateRefContext? {
				return getRuleContext(SchematicIfFrameBorderTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func conditionDisplay() -> [ConditionDisplayContext] {
				return getRuleContexts(ConditionDisplayContext.self)
			}
			open
			func conditionDisplay(_ i: Int) -> ConditionDisplayContext? {
				return getRuleContext(ConditionDisplayContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicIfFrameBorder
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicIfFrameBorder(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicIfFrameBorder(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicIfFrameBorder(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicIfFrameBorder(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicIfFrameBorder() throws -> SchematicIfFrameBorderContext {
		var _localctx: SchematicIfFrameBorderContext = SchematicIfFrameBorderContext(_ctx, getState())
		try enterRule(_localctx, 1226, EDIF300Parser.RULE_schematicIfFrameBorder)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6183)
		 	try match(EDIF300Parser.Tokens.T__488.rawValue)
		 	setState(6184)
		 	try schematicIfFrameBorderTemplateRef()
		 	setState(6185)
		 	try transform()
		 	setState(6191)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__71.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__444.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6189)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__71:
		 			setState(6186)
		 			try conditionDisplay()

		 			break

		 		case .T__444:
		 			setState(6187)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6188)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6193)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6194)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicIfFrameBorderTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func usableArea() -> UsableAreaContext? {
				return getRuleContext(UsableAreaContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func conditionDisplay() -> [ConditionDisplayContext] {
				return getRuleContexts(ConditionDisplayContext.self)
			}
			open
			func conditionDisplay(_ i: Int) -> ConditionDisplayContext? {
				return getRuleContext(ConditionDisplayContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicIfFrameBorderTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicIfFrameBorderTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicIfFrameBorderTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicIfFrameBorderTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicIfFrameBorderTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicIfFrameBorderTemplate() throws -> SchematicIfFrameBorderTemplateContext {
		var _localctx: SchematicIfFrameBorderTemplateContext = SchematicIfFrameBorderTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1228, EDIF300Parser.RULE_schematicIfFrameBorderTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6196)
		 	try match(EDIF300Parser.Tokens.T__489.rawValue)
		 	setState(6197)
		 	try libraryObjectNameDef()
		 	setState(6198)
		 	try schematicTemplateHeader()
		 	setState(6199)
		 	try usableArea()
		 	setState(6208)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__71.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__443.rawValue || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6206)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6200)
		 			try annotate()

		 			break

		 		case .T__62:
		 			setState(6201)
		 			try commentGraphics()

		 			break

		 		case .T__71:
		 			setState(6202)
		 			try conditionDisplay()

		 			break

		 		case .T__159:
		 			setState(6203)
		 			try figure()

		 			break

		 		case .T__443:
		 			setState(6204)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6205)
		 			try schematicComplexFigure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6210)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6211)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicIfFrameBorderTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicIfFrameBorderTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicIfFrameBorderTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicIfFrameBorderTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicIfFrameBorderTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicIfFrameBorderTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicIfFrameBorderTemplateRef() throws -> SchematicIfFrameBorderTemplateRefContext {
		var _localctx: SchematicIfFrameBorderTemplateRefContext = SchematicIfFrameBorderTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1230, EDIF300Parser.RULE_schematicIfFrameBorderTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6213)
		 	try match(EDIF300Parser.Tokens.T__490.rawValue)
		 	setState(6214)
		 	try libraryObjectNameRef()
		 	setState(6216)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6215)
		 		try libraryRef()

		 	}

		 	setState(6218)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicIfFrameImplementationContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func ifFrameRef() -> IfFrameRefContext? {
				return getRuleContext(IfFrameRefContext.self, 0)
			}
			open
			func schematicIfFrameImplementationHeader() -> SchematicIfFrameImplementationHeaderContext? {
				return getRuleContext(SchematicIfFrameImplementationHeaderContext.self, 0)
			}
			open
			func schematicFrameImplementationDetails() -> SchematicFrameImplementationDetailsContext? {
				return getRuleContext(SchematicFrameImplementationDetailsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicIfFrameImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicIfFrameImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicIfFrameImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicIfFrameImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicIfFrameImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicIfFrameImplementation() throws -> SchematicIfFrameImplementationContext {
		var _localctx: SchematicIfFrameImplementationContext = SchematicIfFrameImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1232, EDIF300Parser.RULE_schematicIfFrameImplementation)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6220)
		 	try match(EDIF300Parser.Tokens.T__491.rawValue)
		 	setState(6221)
		 	try implementationNameDef()
		 	setState(6222)
		 	try ifFrameRef()
		 	setState(6223)
		 	try schematicIfFrameImplementationHeader()
		 	setState(6224)
		 	try schematicFrameImplementationDetails()
		 	setState(6225)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicIfFrameImplementationHeaderContext: ParserRuleContext {
			open
			func schematicIfFrameBorder() -> SchematicIfFrameBorderContext? {
				return getRuleContext(SchematicIfFrameBorderContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicIfFrameImplementationHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicIfFrameImplementationHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicIfFrameImplementationHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicIfFrameImplementationHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicIfFrameImplementationHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicIfFrameImplementationHeader() throws -> SchematicIfFrameImplementationHeaderContext {
		var _localctx: SchematicIfFrameImplementationHeaderContext = SchematicIfFrameImplementationHeaderContext(_ctx, getState())
		try enterRule(_localctx, 1234, EDIF300Parser.RULE_schematicIfFrameImplementationHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6227)
		 	try match(EDIF300Parser.Tokens.T__492.rawValue)
		 	setState(6229)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__488.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6228)
		 		try schematicIfFrameBorder()

		 	}

		 	setState(6231)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicImplementationContext: ParserRuleContext {
			open
			func page() -> [PageContext] {
				return getRuleContexts(PageContext.self)
			}
			open
			func page(_ i: Int) -> PageContext? {
				return getRuleContext(PageContext.self, i)
			}
			open
			func totalPages() -> [TotalPagesContext] {
				return getRuleContexts(TotalPagesContext.self)
			}
			open
			func totalPages(_ i: Int) -> TotalPagesContext? {
				return getRuleContext(TotalPagesContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicImplementation() throws -> SchematicImplementationContext {
		var _localctx: SchematicImplementationContext = SchematicImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1236, EDIF300Parser.RULE_schematicImplementation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6233)
		 	try match(EDIF300Parser.Tokens.T__493.rawValue)
		 	setState(6238)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__378.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__622.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6236)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__378:
		 			setState(6234)
		 			try page()

		 			break

		 		case .T__622:
		 			setState(6235)
		 			try totalPages()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6240)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6241)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicInstanceImplementationContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func instanceRef() -> InstanceRefContext? {
				return getRuleContext(InstanceRefContext.self, 0)
			}
			open
			func schematicSymbolRef() -> SchematicSymbolRefContext? {
				return getRuleContext(SchematicSymbolRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func cellNameDisplay() -> [CellNameDisplayContext] {
				return getRuleContexts(CellNameDisplayContext.self)
			}
			open
			func cellNameDisplay(_ i: Int) -> CellNameDisplayContext? {
				return getRuleContext(CellNameDisplayContext.self, i)
			}
			open
			func cellPropertyDisplayOverride() -> [CellPropertyDisplayOverrideContext] {
				return getRuleContexts(CellPropertyDisplayOverrideContext.self)
			}
			open
			func cellPropertyDisplayOverride(_ i: Int) -> CellPropertyDisplayOverrideContext? {
				return getRuleContext(CellPropertyDisplayOverrideContext.self, i)
			}
			open
			func clusterPropertyDisplayOverride() -> [ClusterPropertyDisplayOverrideContext] {
				return getRuleContexts(ClusterPropertyDisplayOverrideContext.self)
			}
			open
			func clusterPropertyDisplayOverride(_ i: Int) -> ClusterPropertyDisplayOverrideContext? {
				return getRuleContext(ClusterPropertyDisplayOverrideContext.self, i)
			}
			open
			func designatorDisplay() -> [DesignatorDisplayContext] {
				return getRuleContexts(DesignatorDisplayContext.self)
			}
			open
			func designatorDisplay(_ i: Int) -> DesignatorDisplayContext? {
				return getRuleContext(DesignatorDisplayContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func instanceNameDisplay() -> [InstanceNameDisplayContext] {
				return getRuleContexts(InstanceNameDisplayContext.self)
			}
			open
			func instanceNameDisplay(_ i: Int) -> InstanceNameDisplayContext? {
				return getRuleContext(InstanceNameDisplayContext.self, i)
			}
			open
			func instanceNameGeneratorDisplay() -> [InstanceNameGeneratorDisplayContext] {
				return getRuleContexts(InstanceNameGeneratorDisplayContext.self)
			}
			open
			func instanceNameGeneratorDisplay(_ i: Int) -> InstanceNameGeneratorDisplayContext? {
				return getRuleContext(InstanceNameGeneratorDisplayContext.self, i)
			}
			open
			func instancePortAttributeDisplay() -> [InstancePortAttributeDisplayContext] {
				return getRuleContexts(InstancePortAttributeDisplayContext.self)
			}
			open
			func instancePortAttributeDisplay(_ i: Int) -> InstancePortAttributeDisplayContext? {
				return getRuleContext(InstancePortAttributeDisplayContext.self, i)
			}
			open
			func instancePropertyDisplay() -> [InstancePropertyDisplayContext] {
				return getRuleContexts(InstancePropertyDisplayContext.self)
			}
			open
			func instancePropertyDisplay(_ i: Int) -> InstancePropertyDisplayContext? {
				return getRuleContext(InstancePropertyDisplayContext.self, i)
			}
			open
			func instanceWidthDisplay() -> [InstanceWidthDisplayContext] {
				return getRuleContexts(InstanceWidthDisplayContext.self)
			}
			open
			func instanceWidthDisplay(_ i: Int) -> InstanceWidthDisplayContext? {
				return getRuleContext(InstanceWidthDisplayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func pageCommentGraphics() -> [PageCommentGraphicsContext] {
				return getRuleContexts(PageCommentGraphicsContext.self)
			}
			open
			func pageCommentGraphics(_ i: Int) -> PageCommentGraphicsContext? {
				return getRuleContext(PageCommentGraphicsContext.self, i)
			}
			open
			func parameterDisplay() -> [ParameterDisplayContext] {
				return getRuleContexts(ParameterDisplayContext.self)
			}
			open
			func parameterDisplay(_ i: Int) -> ParameterDisplayContext? {
				return getRuleContext(ParameterDisplayContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
			open
			func timingDisplay() -> [TimingDisplayContext] {
				return getRuleContexts(TimingDisplayContext.self)
			}
			open
			func timingDisplay(_ i: Int) -> TimingDisplayContext? {
				return getRuleContext(TimingDisplayContext.self, i)
			}
			open
			func viewNameDisplay() -> [ViewNameDisplayContext] {
				return getRuleContexts(ViewNameDisplayContext.self)
			}
			open
			func viewNameDisplay(_ i: Int) -> ViewNameDisplayContext? {
				return getRuleContext(ViewNameDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicInstanceImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicInstanceImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicInstanceImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicInstanceImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicInstanceImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicInstanceImplementation() throws -> SchematicInstanceImplementationContext {
		var _localctx: SchematicInstanceImplementationContext = SchematicInstanceImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1238, EDIF300Parser.RULE_schematicInstanceImplementation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6243)
		 	try match(EDIF300Parser.Tokens.T__494.rawValue)
		 	setState(6244)
		 	try implementationNameDef()
		 	setState(6245)
		 	try instanceRef()
		 	setState(6246)
		 	try schematicSymbolRef()
		 	setState(6247)
		 	try transform()
		 	setState(6267)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__39.rawValue,EDIF300Parser.Tokens.T__41.rawValue,EDIF300Parser.Tokens.T__57.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__119.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__221.rawValue,EDIF300Parser.Tokens.T__237.rawValue,EDIF300Parser.Tokens.T__239.rawValue,EDIF300Parser.Tokens.T__240.rawValue,EDIF300Parser.Tokens.T__242.rawValue,EDIF300Parser.Tokens.T__246.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 222)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__346.rawValue,EDIF300Parser.Tokens.T__383.rawValue,EDIF300Parser.Tokens.T__398.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 347)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__444.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__620.rawValue || _la == EDIF300Parser.Tokens.T__650.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6265)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__39:
		 			setState(6248)
		 			try cellNameDisplay()

		 			break

		 		case .T__41:
		 			setState(6249)
		 			try cellPropertyDisplayOverride()

		 			break

		 		case .T__57:
		 			setState(6250)
		 			try clusterPropertyDisplayOverride()

		 			break

		 		case .T__119:
		 			setState(6251)
		 			try designatorDisplay()

		 			break

		 		case .T__221:
		 			setState(6252)
		 			try implementationNameDisplay()

		 			break

		 		case .T__237:
		 			setState(6253)
		 			try instanceNameDisplay()

		 			break

		 		case .T__239:
		 			setState(6254)
		 			try instanceNameGeneratorDisplay()

		 			break

		 		case .T__240:
		 			setState(6255)
		 			try instancePortAttributeDisplay()

		 			break

		 		case .T__242:
		 			setState(6256)
		 			try instancePropertyDisplay()

		 			break

		 		case .T__246:
		 			setState(6257)
		 			try instanceWidthDisplay()

		 			break

		 		case .T__346:
		 			setState(6258)
		 			try nameInformation()

		 			break

		 		case .T__383:
		 			setState(6259)
		 			try pageCommentGraphics()

		 			break

		 		case .T__398:
		 			setState(6260)
		 			try parameterDisplay()

		 			break

		 		case .T__444:
		 			setState(6261)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6262)
		 			try propertyOverride()

		 			break

		 		case .T__620:
		 			setState(6263)
		 			try timingDisplay()

		 			break

		 		case .T__650:
		 			setState(6264)
		 			try viewNameDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6269)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6270)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicInstanceImplementationRefContext: ParserRuleContext {
			open
			func implementationNameRef() -> ImplementationNameRefContext? {
				return getRuleContext(ImplementationNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicInstanceImplementationRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicInstanceImplementationRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicInstanceImplementationRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicInstanceImplementationRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicInstanceImplementationRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicInstanceImplementationRef() throws -> SchematicInstanceImplementationRefContext {
		var _localctx: SchematicInstanceImplementationRefContext = SchematicInstanceImplementationRefContext(_ctx, getState())
		try enterRule(_localctx, 1240, EDIF300Parser.RULE_schematicInstanceImplementationRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6272)
		 	try match(EDIF300Parser.Tokens.T__495.rawValue)
		 	setState(6273)
		 	try implementationNameRef()
		 	setState(6274)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicInterconnectAttributeDisplayContext: ParserRuleContext {
			open
			func connectivityTagGeneratorDisplay() -> [ConnectivityTagGeneratorDisplayContext] {
				return getRuleContexts(ConnectivityTagGeneratorDisplayContext.self)
			}
			open
			func connectivityTagGeneratorDisplay(_ i: Int) -> ConnectivityTagGeneratorDisplayContext? {
				return getRuleContext(ConnectivityTagGeneratorDisplayContext.self, i)
			}
			open
			func criticalityDisplay() -> [CriticalityDisplayContext] {
				return getRuleContexts(CriticalityDisplayContext.self)
			}
			open
			func criticalityDisplay(_ i: Int) -> CriticalityDisplayContext? {
				return getRuleContext(CriticalityDisplayContext.self, i)
			}
			open
			func interconnectAttachedText() -> [InterconnectAttachedTextContext] {
				return getRuleContexts(InterconnectAttachedTextContext.self)
			}
			open
			func interconnectAttachedText(_ i: Int) -> InterconnectAttachedTextContext? {
				return getRuleContext(InterconnectAttachedTextContext.self, i)
			}
			open
			func interconnectDelayDisplay() -> [InterconnectDelayDisplayContext] {
				return getRuleContexts(InterconnectDelayDisplayContext.self)
			}
			open
			func interconnectDelayDisplay(_ i: Int) -> InterconnectDelayDisplayContext? {
				return getRuleContext(InterconnectDelayDisplayContext.self, i)
			}
			open
			func interconnectNameDisplay() -> [InterconnectNameDisplayContext] {
				return getRuleContexts(InterconnectNameDisplayContext.self)
			}
			open
			func interconnectNameDisplay(_ i: Int) -> InterconnectNameDisplayContext? {
				return getRuleContext(InterconnectNameDisplayContext.self, i)
			}
			open
			func interconnectPropertyDisplay() -> [InterconnectPropertyDisplayContext] {
				return getRuleContexts(InterconnectPropertyDisplayContext.self)
			}
			open
			func interconnectPropertyDisplay(_ i: Int) -> InterconnectPropertyDisplayContext? {
				return getRuleContext(InterconnectPropertyDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicInterconnectAttributeDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicInterconnectAttributeDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicInterconnectAttributeDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicInterconnectAttributeDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicInterconnectAttributeDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicInterconnectAttributeDisplay() throws -> SchematicInterconnectAttributeDisplayContext {
		var _localctx: SchematicInterconnectAttributeDisplayContext = SchematicInterconnectAttributeDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1242, EDIF300Parser.RULE_schematicInterconnectAttributeDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6276)
		 	try match(EDIF300Parser.Tokens.T__496.rawValue)
		 	setState(6285)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__86.rawValue || _la == EDIF300Parser.Tokens.T__98.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__260.rawValue,EDIF300Parser.Tokens.T__262.rawValue,EDIF300Parser.Tokens.T__265.rawValue,EDIF300Parser.Tokens.T__266.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 261)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6283)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__86:
		 			setState(6277)
		 			try connectivityTagGeneratorDisplay()

		 			break

		 		case .T__98:
		 			setState(6278)
		 			try criticalityDisplay()

		 			break

		 		case .T__260:
		 			setState(6279)
		 			try interconnectAttachedText()

		 			break

		 		case .T__262:
		 			setState(6280)
		 			try interconnectDelayDisplay()

		 			break

		 		case .T__265:
		 			setState(6281)
		 			try interconnectNameDisplay()

		 			break

		 		case .T__266:
		 			setState(6282)
		 			try interconnectPropertyDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6287)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6288)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicInterconnectHeaderContext: ParserRuleContext {
			open
			func criticality() -> [CriticalityContext] {
				return getRuleContexts(CriticalityContext.self)
			}
			open
			func criticality(_ i: Int) -> CriticalityContext? {
				return getRuleContext(CriticalityContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func interconnectDelay() -> [InterconnectDelayContext] {
				return getRuleContexts(InterconnectDelayContext.self)
			}
			open
			func interconnectDelay(_ i: Int) -> InterconnectDelayContext? {
				return getRuleContext(InterconnectDelayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func schematicInterconnectTerminatorImplementation() -> [SchematicInterconnectTerminatorImplementationContext] {
				return getRuleContexts(SchematicInterconnectTerminatorImplementationContext.self)
			}
			open
			func schematicInterconnectTerminatorImplementation(_ i: Int) -> SchematicInterconnectTerminatorImplementationContext? {
				return getRuleContext(SchematicInterconnectTerminatorImplementationContext.self, i)
			}
			open
			func schematicJunctionImplementation() -> [SchematicJunctionImplementationContext] {
				return getRuleContexts(SchematicJunctionImplementationContext.self)
			}
			open
			func schematicJunctionImplementation(_ i: Int) -> SchematicJunctionImplementationContext? {
				return getRuleContext(SchematicJunctionImplementationContext.self, i)
			}
			open
			func schematicWireStyle() -> [SchematicWireStyleContext] {
				return getRuleContexts(SchematicWireStyleContext.self)
			}
			open
			func schematicWireStyle(_ i: Int) -> SchematicWireStyleContext? {
				return getRuleContext(SchematicWireStyleContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicInterconnectHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicInterconnectHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicInterconnectHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicInterconnectHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicInterconnectHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicInterconnectHeader() throws -> SchematicInterconnectHeaderContext {
		var _localctx: SchematicInterconnectHeaderContext = SchematicInterconnectHeaderContext(_ctx, getState())
		try enterRule(_localctx, 1244, EDIF300Parser.RULE_schematicInterconnectHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6290)
		 	try match(EDIF300Parser.Tokens.T__497.rawValue)
		 	setState(6301)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__97.rawValue || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__261.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__442.rawValue,EDIF300Parser.Tokens.T__498.rawValue,EDIF300Parser.Tokens.T__502.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 443)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__570.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6299)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__97:
		 			setState(6291)
		 			try criticality()

		 			break

		 		case .T__132:
		 			setState(6292)
		 			try documentation()

		 			break

		 		case .T__261:
		 			setState(6293)
		 			try interconnectDelay()

		 			break

		 		case .T__346:
		 			setState(6294)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(6295)
		 			try property()

		 			break

		 		case .T__498:
		 			setState(6296)
		 			try schematicInterconnectTerminatorImplementation()

		 			break

		 		case .T__502:
		 			setState(6297)
		 			try schematicJunctionImplementation()

		 			break

		 		case .T__570:
		 			setState(6298)
		 			try schematicWireStyle()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6303)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6304)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicInterconnectTerminatorImplementationContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func schematicInterconnectTerminatorTemplateRef() -> SchematicInterconnectTerminatorTemplateRefContext? {
				return getRuleContext(SchematicInterconnectTerminatorTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicInterconnectTerminatorImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicInterconnectTerminatorImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicInterconnectTerminatorImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicInterconnectTerminatorImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicInterconnectTerminatorImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicInterconnectTerminatorImplementation() throws -> SchematicInterconnectTerminatorImplementationContext {
		var _localctx: SchematicInterconnectTerminatorImplementationContext = SchematicInterconnectTerminatorImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1246, EDIF300Parser.RULE_schematicInterconnectTerminatorImplementation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6306)
		 	try match(EDIF300Parser.Tokens.T__498.rawValue)
		 	setState(6307)
		 	try implementationNameDef()
		 	setState(6308)
		 	try schematicInterconnectTerminatorTemplateRef()
		 	setState(6309)
		 	try transform()
		 	setState(6316)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__444.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6314)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__221:
		 			setState(6310)
		 			try implementationNameDisplay()

		 			break

		 		case .T__346:
		 			setState(6311)
		 			try nameInformation()

		 			break

		 		case .T__444:
		 			setState(6312)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6313)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6318)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6319)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicInterconnectTerminatorImplementationRefContext: ParserRuleContext {
			open
			func implementationNameRef() -> ImplementationNameRefContext? {
				return getRuleContext(ImplementationNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicInterconnectTerminatorImplementationRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicInterconnectTerminatorImplementationRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicInterconnectTerminatorImplementationRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicInterconnectTerminatorImplementationRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicInterconnectTerminatorImplementationRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicInterconnectTerminatorImplementationRef() throws -> SchematicInterconnectTerminatorImplementationRefContext {
		var _localctx: SchematicInterconnectTerminatorImplementationRefContext = SchematicInterconnectTerminatorImplementationRefContext(_ctx, getState())
		try enterRule(_localctx, 1248, EDIF300Parser.RULE_schematicInterconnectTerminatorImplementationRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6321)
		 	try match(EDIF300Parser.Tokens.T__499.rawValue)
		 	setState(6322)
		 	try implementationNameRef()
		 	setState(6323)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicInterconnectTerminatorTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func hotspot() -> HotspotContext? {
				return getRuleContext(HotspotContext.self, 0)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicInterconnectTerminatorTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicInterconnectTerminatorTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicInterconnectTerminatorTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicInterconnectTerminatorTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicInterconnectTerminatorTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicInterconnectTerminatorTemplate() throws -> SchematicInterconnectTerminatorTemplateContext {
		var _localctx: SchematicInterconnectTerminatorTemplateContext = SchematicInterconnectTerminatorTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1250, EDIF300Parser.RULE_schematicInterconnectTerminatorTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6325)
		 	try match(EDIF300Parser.Tokens.T__500.rawValue)
		 	setState(6326)
		 	try libraryObjectNameDef()
		 	setState(6327)
		 	try schematicTemplateHeader()
		 	setState(6328)
		 	try hotspot()
		 	setState(6336)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue || _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__443.rawValue || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6334)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__62:
		 			setState(6329)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6330)
		 			try figure()

		 			break

		 		case .T__221:
		 			setState(6331)
		 			try implementationNameDisplay()

		 			break

		 		case .T__443:
		 			setState(6332)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6333)
		 			try schematicComplexFigure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6338)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6339)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicInterconnectTerminatorTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicInterconnectTerminatorTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicInterconnectTerminatorTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicInterconnectTerminatorTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicInterconnectTerminatorTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicInterconnectTerminatorTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicInterconnectTerminatorTemplateRef() throws -> SchematicInterconnectTerminatorTemplateRefContext {
		var _localctx: SchematicInterconnectTerminatorTemplateRefContext = SchematicInterconnectTerminatorTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1252, EDIF300Parser.RULE_schematicInterconnectTerminatorTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6341)
		 	try match(EDIF300Parser.Tokens.T__501.rawValue)
		 	setState(6342)
		 	try libraryObjectNameRef()
		 	setState(6344)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6343)
		 		try libraryRef()

		 	}

		 	setState(6346)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicJunctionImplementationContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func schematicJunctionTemplateRef() -> SchematicJunctionTemplateRefContext? {
				return getRuleContext(SchematicJunctionTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicJunctionImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicJunctionImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicJunctionImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicJunctionImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicJunctionImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicJunctionImplementation() throws -> SchematicJunctionImplementationContext {
		var _localctx: SchematicJunctionImplementationContext = SchematicJunctionImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1254, EDIF300Parser.RULE_schematicJunctionImplementation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6348)
		 	try match(EDIF300Parser.Tokens.T__502.rawValue)
		 	setState(6349)
		 	try implementationNameDef()
		 	setState(6350)
		 	try schematicJunctionTemplateRef()
		 	setState(6351)
		 	try transform()
		 	setState(6358)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__444.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6356)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__221:
		 			setState(6352)
		 			try implementationNameDisplay()

		 			break

		 		case .T__346:
		 			setState(6353)
		 			try nameInformation()

		 			break

		 		case .T__444:
		 			setState(6354)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6355)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6360)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6361)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicJunctionImplementationRefContext: ParserRuleContext {
			open
			func implementationNameRef() -> ImplementationNameRefContext? {
				return getRuleContext(ImplementationNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicJunctionImplementationRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicJunctionImplementationRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicJunctionImplementationRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicJunctionImplementationRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicJunctionImplementationRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicJunctionImplementationRef() throws -> SchematicJunctionImplementationRefContext {
		var _localctx: SchematicJunctionImplementationRefContext = SchematicJunctionImplementationRefContext(_ctx, getState())
		try enterRule(_localctx, 1256, EDIF300Parser.RULE_schematicJunctionImplementationRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6363)
		 	try match(EDIF300Parser.Tokens.T__503.rawValue)
		 	setState(6364)
		 	try implementationNameRef()
		 	setState(6365)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicJunctionTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func hotspot() -> HotspotContext? {
				return getRuleContext(HotspotContext.self, 0)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicJunctionTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicJunctionTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicJunctionTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicJunctionTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicJunctionTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicJunctionTemplate() throws -> SchematicJunctionTemplateContext {
		var _localctx: SchematicJunctionTemplateContext = SchematicJunctionTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1258, EDIF300Parser.RULE_schematicJunctionTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6367)
		 	try match(EDIF300Parser.Tokens.T__504.rawValue)
		 	setState(6368)
		 	try libraryObjectNameDef()
		 	setState(6369)
		 	try schematicTemplateHeader()
		 	setState(6370)
		 	try hotspot()
		 	setState(6378)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue || _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__443.rawValue || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6376)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__62:
		 			setState(6371)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6372)
		 			try figure()

		 			break

		 		case .T__221:
		 			setState(6373)
		 			try implementationNameDisplay()

		 			break

		 		case .T__443:
		 			setState(6374)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6375)
		 			try schematicComplexFigure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6380)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6381)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicJunctionTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicJunctionTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicJunctionTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicJunctionTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicJunctionTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicJunctionTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicJunctionTemplateRef() throws -> SchematicJunctionTemplateRefContext {
		var _localctx: SchematicJunctionTemplateRefContext = SchematicJunctionTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1260, EDIF300Parser.RULE_schematicJunctionTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6383)
		 	try match(EDIF300Parser.Tokens.T__505.rawValue)
		 	setState(6384)
		 	try libraryObjectNameRef()
		 	setState(6386)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6385)
		 		try libraryRef()

		 	}

		 	setState(6388)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicMasterPortImplementationContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func schematicMasterPortTemplateRef() -> SchematicMasterPortTemplateRefContext? {
				return getRuleContext(SchematicMasterPortTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func portRef() -> PortRefContext? {
				return getRuleContext(PortRefContext.self, 0)
			}
			open
			func localPortGroupRef() -> LocalPortGroupRefContext? {
				return getRuleContext(LocalPortGroupRefContext.self, 0)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func portAttributeDisplay() -> [PortAttributeDisplayContext] {
				return getRuleContexts(PortAttributeDisplayContext.self)
			}
			open
			func portAttributeDisplay(_ i: Int) -> PortAttributeDisplayContext? {
				return getRuleContext(PortAttributeDisplayContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicMasterPortImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicMasterPortImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicMasterPortImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicMasterPortImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicMasterPortImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicMasterPortImplementation() throws -> SchematicMasterPortImplementationContext {
		var _localctx: SchematicMasterPortImplementationContext = SchematicMasterPortImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1262, EDIF300Parser.RULE_schematicMasterPortImplementation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6390)
		 	try match(EDIF300Parser.Tokens.T__506.rawValue)
		 	setState(6391)
		 	try implementationNameDef()
		 	setState(6392)
		 	try schematicMasterPortTemplateRef()
		 	setState(6395)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__436:
		 		setState(6393)
		 		try portRef()

		 		break

		 	case .T__317:
		 		setState(6394)
		 		try localPortGroupRef()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(6397)
		 	try transform()
		 	setState(6405)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__416.rawValue,EDIF300Parser.Tokens.T__444.rawValue,EDIF300Parser.Tokens.T__448.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 417)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6403)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__221:
		 			setState(6398)
		 			try implementationNameDisplay()

		 			break

		 		case .T__346:
		 			setState(6399)
		 			try nameInformation()

		 			break

		 		case .T__416:
		 			setState(6400)
		 			try portAttributeDisplay()

		 			break

		 		case .T__444:
		 			setState(6401)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6402)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6407)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6408)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicMasterPortImplementationRefContext: ParserRuleContext {
			open
			func implementationNameRef() -> ImplementationNameRefContext? {
				return getRuleContext(ImplementationNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicMasterPortImplementationRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicMasterPortImplementationRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicMasterPortImplementationRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicMasterPortImplementationRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicMasterPortImplementationRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicMasterPortImplementationRef() throws -> SchematicMasterPortImplementationRefContext {
		var _localctx: SchematicMasterPortImplementationRefContext = SchematicMasterPortImplementationRefContext(_ctx, getState())
		try enterRule(_localctx, 1264, EDIF300Parser.RULE_schematicMasterPortImplementationRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6410)
		 	try match(EDIF300Parser.Tokens.T__507.rawValue)
		 	setState(6411)
		 	try implementationNameRef()
		 	setState(6412)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicMasterPortTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func hotspot() -> HotspotContext? {
				return getRuleContext(HotspotContext.self, 0)
			}
			open
			func portDirectionIndicator() -> PortDirectionIndicatorContext? {
				return getRuleContext(PortDirectionIndicatorContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func portAttributeDisplay() -> [PortAttributeDisplayContext] {
				return getRuleContexts(PortAttributeDisplayContext.self)
			}
			open
			func portAttributeDisplay(_ i: Int) -> PortAttributeDisplayContext? {
				return getRuleContext(PortAttributeDisplayContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
			open
			func schematicPortStyle() -> [SchematicPortStyleContext] {
				return getRuleContexts(SchematicPortStyleContext.self)
			}
			open
			func schematicPortStyle(_ i: Int) -> SchematicPortStyleContext? {
				return getRuleContext(SchematicPortStyleContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicMasterPortTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicMasterPortTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicMasterPortTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicMasterPortTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicMasterPortTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicMasterPortTemplate() throws -> SchematicMasterPortTemplateContext {
		var _localctx: SchematicMasterPortTemplateContext = SchematicMasterPortTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1266, EDIF300Parser.RULE_schematicMasterPortTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6414)
		 	try match(EDIF300Parser.Tokens.T__508.rawValue)
		 	setState(6415)
		 	try libraryObjectNameDef()
		 	setState(6416)
		 	try schematicTemplateHeader()
		 	setState(6417)
		 	try hotspot()
		 	setState(6418)
		 	try portDirectionIndicator()
		 	setState(6429)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue || _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__416.rawValue,EDIF300Parser.Tokens.T__443.rawValue,EDIF300Parser.Tokens.T__474.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 417)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__543.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6427)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6419)
		 			try annotate()

		 			break

		 		case .T__62:
		 			setState(6420)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6421)
		 			try figure()

		 			break

		 		case .T__221:
		 			setState(6422)
		 			try implementationNameDisplay()

		 			break

		 		case .T__416:
		 			setState(6423)
		 			try portAttributeDisplay()

		 			break

		 		case .T__443:
		 			setState(6424)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6425)
		 			try schematicComplexFigure()

		 			break

		 		case .T__543:
		 			setState(6426)
		 			try schematicPortStyle()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6431)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6432)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicMasterPortTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicMasterPortTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicMasterPortTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicMasterPortTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicMasterPortTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicMasterPortTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicMasterPortTemplateRef() throws -> SchematicMasterPortTemplateRefContext {
		var _localctx: SchematicMasterPortTemplateRefContext = SchematicMasterPortTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1268, EDIF300Parser.RULE_schematicMasterPortTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6434)
		 	try match(EDIF300Parser.Tokens.T__509.rawValue)
		 	setState(6435)
		 	try libraryObjectNameRef()
		 	setState(6437)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6436)
		 		try libraryRef()

		 	}

		 	setState(6439)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicMetricContext: ParserRuleContext {
			open
			func setDistance() -> SetDistanceContext? {
				return getRuleContext(SetDistanceContext.self, 0)
			}
			open
			func hotspotGrid() -> HotspotGridContext? {
				return getRuleContext(HotspotGridContext.self, 0)
			}
			open
			func noHotspotGrid() -> NoHotspotGridContext? {
				return getRuleContext(NoHotspotGridContext.self, 0)
			}
			open
			func nominalHotspotGrid() -> NominalHotspotGridContext? {
				return getRuleContext(NominalHotspotGridContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicMetric
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicMetric(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicMetric(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicMetric(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicMetric(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicMetric() throws -> SchematicMetricContext {
		var _localctx: SchematicMetricContext = SchematicMetricContext(_ctx, getState())
		try enterRule(_localctx, 1270, EDIF300Parser.RULE_schematicMetric)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6441)
		 	try match(EDIF300Parser.Tokens.T__510.rawValue)
		 	setState(6442)
		 	try setDistance()
		 	setState(6445)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__210:
		 		setState(6443)
		 		try hotspotGrid()

		 		break

		 	case .T__351:
		 		setState(6444)
		 		try noHotspotGrid()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(6448)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__352.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6447)
		 		try nominalHotspotGrid()

		 	}

		 	setState(6450)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicNetContext: ParserRuleContext {
			open
			func interconnectNameDef() -> InterconnectNameDefContext? {
				return getRuleContext(InterconnectNameDefContext.self, 0)
			}
			open
			func signalRef() -> SignalRefContext? {
				return getRuleContext(SignalRefContext.self, 0)
			}
			open
			func schematicInterconnectHeader() -> SchematicInterconnectHeaderContext? {
				return getRuleContext(SchematicInterconnectHeaderContext.self, 0)
			}
			open
			func schematicNetJoined() -> SchematicNetJoinedContext? {
				return getRuleContext(SchematicNetJoinedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func schematicInterconnectAttributeDisplay() -> [SchematicInterconnectAttributeDisplayContext] {
				return getRuleContexts(SchematicInterconnectAttributeDisplayContext.self)
			}
			open
			func schematicInterconnectAttributeDisplay(_ i: Int) -> SchematicInterconnectAttributeDisplayContext? {
				return getRuleContext(SchematicInterconnectAttributeDisplayContext.self, i)
			}
			open
			func schematicNetDetails() -> [SchematicNetDetailsContext] {
				return getRuleContexts(SchematicNetDetailsContext.self)
			}
			open
			func schematicNetDetails(_ i: Int) -> SchematicNetDetailsContext? {
				return getRuleContext(SchematicNetDetailsContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicNet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicNet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicNet(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicNet(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicNet(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicNet() throws -> SchematicNetContext {
		var _localctx: SchematicNetContext = SchematicNetContext(_ctx, getState())
		try enterRule(_localctx, 1272, EDIF300Parser.RULE_schematicNet)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6452)
		 	try match(EDIF300Parser.Tokens.T__511.rawValue)
		 	setState(6453)
		 	try interconnectNameDef()
		 	setState(6454)
		 	try signalRef()
		 	setState(6455)
		 	try schematicInterconnectHeader()
		 	setState(6456)
		 	try schematicNetJoined()
		 	setState(6463)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__496.rawValue || _la == EDIF300Parser.Tokens.T__512.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6461)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(6457)
		 			try comment()

		 			break

		 		case .T__496:
		 			setState(6458)
		 			try schematicInterconnectAttributeDisplay()

		 			break

		 		case .T__512:
		 			setState(6459)
		 			try schematicNetDetails()

		 			break

		 		case .T__642:
		 			setState(6460)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6465)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6466)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicNetDetailsContext: ParserRuleContext {
			open
			func schematicNetGraphics() -> SchematicNetGraphicsContext? {
				return getRuleContext(SchematicNetGraphicsContext.self, 0)
			}
			open
			func schematicSubNetSet() -> SchematicSubNetSetContext? {
				return getRuleContext(SchematicSubNetSetContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicNetDetails
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicNetDetails(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicNetDetails(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicNetDetails(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicNetDetails(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicNetDetails() throws -> SchematicNetDetailsContext {
		var _localctx: SchematicNetDetailsContext = SchematicNetDetailsContext(_ctx, getState())
		try enterRule(_localctx, 1274, EDIF300Parser.RULE_schematicNetDetails)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6468)
		 	try match(EDIF300Parser.Tokens.T__512.rawValue)
		 	setState(6471)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__513:
		 		setState(6469)
		 		try schematicNetGraphics()

		 		break

		 	case .T__554:
		 		setState(6470)
		 		try schematicSubNetSet()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(6473)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicNetGraphicsContext: ParserRuleContext {
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicNetGraphics
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicNetGraphics(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicNetGraphics(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicNetGraphics(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicNetGraphics(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicNetGraphics() throws -> SchematicNetGraphicsContext {
		var _localctx: SchematicNetGraphicsContext = SchematicNetGraphicsContext(_ctx, getState())
		try enterRule(_localctx, 1276, EDIF300Parser.RULE_schematicNetGraphics)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6475)
		 	try match(EDIF300Parser.Tokens.T__513.rawValue)
		 	setState(6482)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6480)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(6476)
		 			try comment()

		 			break

		 		case .T__159:
		 			setState(6477)
		 			try figure()

		 			break

		 		case .T__474:
		 			setState(6478)
		 			try schematicComplexFigure()

		 			break

		 		case .T__642:
		 			setState(6479)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6484)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6485)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicNetJoinedContext: ParserRuleContext {
			open
			func portJoined() -> [PortJoinedContext] {
				return getRuleContexts(PortJoinedContext.self)
			}
			open
			func portJoined(_ i: Int) -> PortJoinedContext? {
				return getRuleContext(PortJoinedContext.self, i)
			}
			open
			func joinedAsSignal() -> [JoinedAsSignalContext] {
				return getRuleContexts(JoinedAsSignalContext.self)
			}
			open
			func joinedAsSignal(_ i: Int) -> JoinedAsSignalContext? {
				return getRuleContext(JoinedAsSignalContext.self, i)
			}
			open
			func ripperHotspotRef() -> [RipperHotspotRefContext] {
				return getRuleContexts(RipperHotspotRefContext.self)
			}
			open
			func ripperHotspotRef(_ i: Int) -> RipperHotspotRefContext? {
				return getRuleContext(RipperHotspotRefContext.self, i)
			}
			open
			func schematicGlobalPortImplementationRef() -> [SchematicGlobalPortImplementationRefContext] {
				return getRuleContexts(SchematicGlobalPortImplementationRefContext.self)
			}
			open
			func schematicGlobalPortImplementationRef(_ i: Int) -> SchematicGlobalPortImplementationRefContext? {
				return getRuleContext(SchematicGlobalPortImplementationRefContext.self, i)
			}
			open
			func schematicInterconnectTerminatorImplementationRef() -> [SchematicInterconnectTerminatorImplementationRefContext] {
				return getRuleContexts(SchematicInterconnectTerminatorImplementationRefContext.self)
			}
			open
			func schematicInterconnectTerminatorImplementationRef(_ i: Int) -> SchematicInterconnectTerminatorImplementationRefContext? {
				return getRuleContext(SchematicInterconnectTerminatorImplementationRefContext.self, i)
			}
			open
			func schematicJunctionImplementationRef() -> [SchematicJunctionImplementationRefContext] {
				return getRuleContexts(SchematicJunctionImplementationRefContext.self)
			}
			open
			func schematicJunctionImplementationRef(_ i: Int) -> SchematicJunctionImplementationRefContext? {
				return getRuleContext(SchematicJunctionImplementationRefContext.self, i)
			}
			open
			func schematicMasterPortImplementationRef() -> [SchematicMasterPortImplementationRefContext] {
				return getRuleContexts(SchematicMasterPortImplementationRefContext.self)
			}
			open
			func schematicMasterPortImplementationRef(_ i: Int) -> SchematicMasterPortImplementationRefContext? {
				return getRuleContext(SchematicMasterPortImplementationRefContext.self, i)
			}
			open
			func schematicOffPageConnectorImplementationRef() -> [SchematicOffPageConnectorImplementationRefContext] {
				return getRuleContexts(SchematicOffPageConnectorImplementationRefContext.self)
			}
			open
			func schematicOffPageConnectorImplementationRef(_ i: Int) -> SchematicOffPageConnectorImplementationRefContext? {
				return getRuleContext(SchematicOffPageConnectorImplementationRefContext.self, i)
			}
			open
			func schematicOnPageConnectorImplementationRef() -> [SchematicOnPageConnectorImplementationRefContext] {
				return getRuleContexts(SchematicOnPageConnectorImplementationRefContext.self)
			}
			open
			func schematicOnPageConnectorImplementationRef(_ i: Int) -> SchematicOnPageConnectorImplementationRefContext? {
				return getRuleContext(SchematicOnPageConnectorImplementationRefContext.self, i)
			}
			open
			func schematicSymbolPortImplementationRef() -> [SchematicSymbolPortImplementationRefContext] {
				return getRuleContexts(SchematicSymbolPortImplementationRefContext.self)
			}
			open
			func schematicSymbolPortImplementationRef(_ i: Int) -> SchematicSymbolPortImplementationRefContext? {
				return getRuleContext(SchematicSymbolPortImplementationRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicNetJoined
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicNetJoined(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicNetJoined(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicNetJoined(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicNetJoined(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicNetJoined() throws -> SchematicNetJoinedContext {
		var _localctx: SchematicNetJoinedContext = SchematicNetJoinedContext(_ctx, getState())
		try enterRule(_localctx, 1278, EDIF300Parser.RULE_schematicNetJoined)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6487)
		 	try match(EDIF300Parser.Tokens.T__514.rawValue)
		 	setState(6490)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,510,_ctx)) {
		 	case 1:
		 		setState(6488)
		 		try portJoined()

		 		break
		 	case 2:
		 		setState(6489)
		 		try joinedAsSignal()

		 		break
		 	default: break
		 	}
		 	setState(6502)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,512,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(6500)
		 			try _errHandler.sync(self)
		 			switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .T__464:
		 				setState(6492)
		 				try ripperHotspotRef()

		 				break

		 			case .T__485:
		 				setState(6493)
		 				try schematicGlobalPortImplementationRef()

		 				break

		 			case .T__499:
		 				setState(6494)
		 				try schematicInterconnectTerminatorImplementationRef()

		 				break

		 			case .T__503:
		 				setState(6495)
		 				try schematicJunctionImplementationRef()

		 				break

		 			case .T__507:
		 				setState(6496)
		 				try schematicMasterPortImplementationRef()

		 				break

		 			case .T__516:
		 				setState(6497)
		 				try schematicOffPageConnectorImplementationRef()

		 				break

		 			case .T__520:
		 				setState(6498)
		 				try schematicOnPageConnectorImplementationRef()

		 				break

		 			case .T__561:
		 				setState(6499)
		 				try schematicSymbolPortImplementationRef()

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 	 
		 		}
		 		setState(6504)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,512,_ctx)
		 	}
		 	setState(6507)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__423:
		 	 	setState(6505)
		 	 	try portJoined()

		 		break

		 	case .T__277:
		 	 	setState(6506)
		 	 	try joinedAsSignal()

		 		break
		 	case .T__1:fallthrough
		 	case .T__464:fallthrough
		 	case .T__485:fallthrough
		 	case .T__499:fallthrough
		 	case .T__503:fallthrough
		 	case .T__507:fallthrough
		 	case .T__516:fallthrough
		 	case .T__520:fallthrough
		 	case .T__561:
		 		break
		 	default:
		 		break
		 	}
		 	setState(6519)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__464.rawValue,EDIF300Parser.Tokens.T__485.rawValue,EDIF300Parser.Tokens.T__499.rawValue,EDIF300Parser.Tokens.T__503.rawValue,EDIF300Parser.Tokens.T__507.rawValue,EDIF300Parser.Tokens.T__516.rawValue,EDIF300Parser.Tokens.T__520.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 465)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__561.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6517)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__464:
		 			setState(6509)
		 			try ripperHotspotRef()

		 			break

		 		case .T__485:
		 			setState(6510)
		 			try schematicGlobalPortImplementationRef()

		 			break

		 		case .T__499:
		 			setState(6511)
		 			try schematicInterconnectTerminatorImplementationRef()

		 			break

		 		case .T__503:
		 			setState(6512)
		 			try schematicJunctionImplementationRef()

		 			break

		 		case .T__507:
		 			setState(6513)
		 			try schematicMasterPortImplementationRef()

		 			break

		 		case .T__516:
		 			setState(6514)
		 			try schematicOffPageConnectorImplementationRef()

		 			break

		 		case .T__520:
		 			setState(6515)
		 			try schematicOnPageConnectorImplementationRef()

		 			break

		 		case .T__561:
		 			setState(6516)
		 			try schematicSymbolPortImplementationRef()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6521)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6522)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOffPageConnectorImplementationContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func schematicOffPageConnectorTemplateRef() -> SchematicOffPageConnectorTemplateRefContext? {
				return getRuleContext(SchematicOffPageConnectorTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func associatedInterconnectNameDisplay() -> [AssociatedInterconnectNameDisplayContext] {
				return getRuleContexts(AssociatedInterconnectNameDisplayContext.self)
			}
			open
			func associatedInterconnectNameDisplay(_ i: Int) -> AssociatedInterconnectNameDisplayContext? {
				return getRuleContext(AssociatedInterconnectNameDisplayContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOffPageConnectorImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOffPageConnectorImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOffPageConnectorImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOffPageConnectorImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOffPageConnectorImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOffPageConnectorImplementation() throws -> SchematicOffPageConnectorImplementationContext {
		var _localctx: SchematicOffPageConnectorImplementationContext = SchematicOffPageConnectorImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1280, EDIF300Parser.RULE_schematicOffPageConnectorImplementation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6524)
		 	try match(EDIF300Parser.Tokens.T__515.rawValue)
		 	setState(6525)
		 	try implementationNameDef()
		 	setState(6526)
		 	try schematicOffPageConnectorTemplateRef()
		 	setState(6527)
		 	try transform()
		 	setState(6537)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__12.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__442.rawValue,EDIF300Parser.Tokens.T__443.rawValue,EDIF300Parser.Tokens.T__444.rawValue,EDIF300Parser.Tokens.T__448.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 443)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6535)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__12:
		 			setState(6528)
		 			try associatedInterconnectNameDisplay()

		 			break

		 		case .T__221:
		 			setState(6529)
		 			try implementationNameDisplay()

		 			break

		 		case .T__346:
		 			setState(6530)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(6531)
		 			try property()

		 			break

		 		case .T__443:
		 			setState(6532)
		 			try propertyDisplay()

		 			break

		 		case .T__444:
		 			setState(6533)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6534)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6539)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6540)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOffPageConnectorImplementationRefContext: ParserRuleContext {
			open
			func implementationNameRef() -> ImplementationNameRefContext? {
				return getRuleContext(ImplementationNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOffPageConnectorImplementationRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOffPageConnectorImplementationRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOffPageConnectorImplementationRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOffPageConnectorImplementationRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOffPageConnectorImplementationRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOffPageConnectorImplementationRef() throws -> SchematicOffPageConnectorImplementationRefContext {
		var _localctx: SchematicOffPageConnectorImplementationRefContext = SchematicOffPageConnectorImplementationRefContext(_ctx, getState())
		try enterRule(_localctx, 1282, EDIF300Parser.RULE_schematicOffPageConnectorImplementationRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6542)
		 	try match(EDIF300Parser.Tokens.T__516.rawValue)
		 	setState(6543)
		 	try implementationNameRef()
		 	setState(6544)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOffPageConnectorTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func hotspot() -> HotspotContext? {
				return getRuleContext(HotspotContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func associatedInterconnectNameDisplay() -> [AssociatedInterconnectNameDisplayContext] {
				return getRuleContexts(AssociatedInterconnectNameDisplayContext.self)
			}
			open
			func associatedInterconnectNameDisplay(_ i: Int) -> AssociatedInterconnectNameDisplayContext? {
				return getRuleContext(AssociatedInterconnectNameDisplayContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOffPageConnectorTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOffPageConnectorTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOffPageConnectorTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOffPageConnectorTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOffPageConnectorTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOffPageConnectorTemplate() throws -> SchematicOffPageConnectorTemplateContext {
		var _localctx: SchematicOffPageConnectorTemplateContext = SchematicOffPageConnectorTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1284, EDIF300Parser.RULE_schematicOffPageConnectorTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6546)
		 	try match(EDIF300Parser.Tokens.T__517.rawValue)
		 	setState(6547)
		 	try libraryObjectNameDef()
		 	setState(6548)
		 	try schematicTemplateHeader()
		 	setState(6549)
		 	try hotspot()
		 	setState(6559)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__7.rawValue,EDIF300Parser.Tokens.T__12.rawValue,EDIF300Parser.Tokens.T__62.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue || _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__443.rawValue || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6557)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6550)
		 			try annotate()

		 			break

		 		case .T__12:
		 			setState(6551)
		 			try associatedInterconnectNameDisplay()

		 			break

		 		case .T__62:
		 			setState(6552)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6553)
		 			try figure()

		 			break

		 		case .T__221:
		 			setState(6554)
		 			try implementationNameDisplay()

		 			break

		 		case .T__443:
		 			setState(6555)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6556)
		 			try schematicComplexFigure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6561)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6562)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOffPageConnectorTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOffPageConnectorTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOffPageConnectorTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOffPageConnectorTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOffPageConnectorTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOffPageConnectorTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOffPageConnectorTemplateRef() throws -> SchematicOffPageConnectorTemplateRefContext {
		var _localctx: SchematicOffPageConnectorTemplateRefContext = SchematicOffPageConnectorTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1286, EDIF300Parser.RULE_schematicOffPageConnectorTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6564)
		 	try match(EDIF300Parser.Tokens.T__518.rawValue)
		 	setState(6565)
		 	try libraryObjectNameRef()
		 	setState(6567)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6566)
		 		try libraryRef()

		 	}

		 	setState(6569)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOnPageConnectorImplementationContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func schematicOnPageConnectorTemplateRef() -> SchematicOnPageConnectorTemplateRefContext? {
				return getRuleContext(SchematicOnPageConnectorTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func associatedInterconnectNameDisplay() -> [AssociatedInterconnectNameDisplayContext] {
				return getRuleContexts(AssociatedInterconnectNameDisplayContext.self)
			}
			open
			func associatedInterconnectNameDisplay(_ i: Int) -> AssociatedInterconnectNameDisplayContext? {
				return getRuleContext(AssociatedInterconnectNameDisplayContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOnPageConnectorImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOnPageConnectorImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOnPageConnectorImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOnPageConnectorImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOnPageConnectorImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOnPageConnectorImplementation() throws -> SchematicOnPageConnectorImplementationContext {
		var _localctx: SchematicOnPageConnectorImplementationContext = SchematicOnPageConnectorImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1288, EDIF300Parser.RULE_schematicOnPageConnectorImplementation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6571)
		 	try match(EDIF300Parser.Tokens.T__519.rawValue)
		 	setState(6572)
		 	try implementationNameDef()
		 	setState(6573)
		 	try schematicOnPageConnectorTemplateRef()
		 	setState(6574)
		 	try transform()
		 	setState(6584)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__12.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__442.rawValue,EDIF300Parser.Tokens.T__443.rawValue,EDIF300Parser.Tokens.T__444.rawValue,EDIF300Parser.Tokens.T__448.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 443)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6582)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__12:
		 			setState(6575)
		 			try associatedInterconnectNameDisplay()

		 			break

		 		case .T__221:
		 			setState(6576)
		 			try implementationNameDisplay()

		 			break

		 		case .T__346:
		 			setState(6577)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(6578)
		 			try property()

		 			break

		 		case .T__443:
		 			setState(6579)
		 			try propertyDisplay()

		 			break

		 		case .T__444:
		 			setState(6580)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6581)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6586)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6587)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOnPageConnectorImplementationRefContext: ParserRuleContext {
			open
			func implementationNameRef() -> ImplementationNameRefContext? {
				return getRuleContext(ImplementationNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOnPageConnectorImplementationRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOnPageConnectorImplementationRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOnPageConnectorImplementationRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOnPageConnectorImplementationRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOnPageConnectorImplementationRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOnPageConnectorImplementationRef() throws -> SchematicOnPageConnectorImplementationRefContext {
		var _localctx: SchematicOnPageConnectorImplementationRefContext = SchematicOnPageConnectorImplementationRefContext(_ctx, getState())
		try enterRule(_localctx, 1290, EDIF300Parser.RULE_schematicOnPageConnectorImplementationRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6589)
		 	try match(EDIF300Parser.Tokens.T__520.rawValue)
		 	setState(6590)
		 	try implementationNameRef()
		 	setState(6591)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOnPageConnectorTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func hotspot() -> HotspotContext? {
				return getRuleContext(HotspotContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func associatedInterconnectNameDisplay() -> [AssociatedInterconnectNameDisplayContext] {
				return getRuleContexts(AssociatedInterconnectNameDisplayContext.self)
			}
			open
			func associatedInterconnectNameDisplay(_ i: Int) -> AssociatedInterconnectNameDisplayContext? {
				return getRuleContext(AssociatedInterconnectNameDisplayContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOnPageConnectorTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOnPageConnectorTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOnPageConnectorTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOnPageConnectorTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOnPageConnectorTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOnPageConnectorTemplate() throws -> SchematicOnPageConnectorTemplateContext {
		var _localctx: SchematicOnPageConnectorTemplateContext = SchematicOnPageConnectorTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1292, EDIF300Parser.RULE_schematicOnPageConnectorTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6593)
		 	try match(EDIF300Parser.Tokens.T__521.rawValue)
		 	setState(6594)
		 	try libraryObjectNameDef()
		 	setState(6595)
		 	try schematicTemplateHeader()
		 	setState(6596)
		 	try hotspot()
		 	setState(6606)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__7.rawValue,EDIF300Parser.Tokens.T__12.rawValue,EDIF300Parser.Tokens.T__62.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue || _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__443.rawValue || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6604)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6597)
		 			try annotate()

		 			break

		 		case .T__12:
		 			setState(6598)
		 			try associatedInterconnectNameDisplay()

		 			break

		 		case .T__62:
		 			setState(6599)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6600)
		 			try figure()

		 			break

		 		case .T__221:
		 			setState(6601)
		 			try implementationNameDisplay()

		 			break

		 		case .T__443:
		 			setState(6602)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6603)
		 			try schematicComplexFigure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6608)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6609)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOnPageConnectorTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOnPageConnectorTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOnPageConnectorTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOnPageConnectorTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOnPageConnectorTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOnPageConnectorTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOnPageConnectorTemplateRef() throws -> SchematicOnPageConnectorTemplateRefContext {
		var _localctx: SchematicOnPageConnectorTemplateRefContext = SchematicOnPageConnectorTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1294, EDIF300Parser.RULE_schematicOnPageConnectorTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6611)
		 	try match(EDIF300Parser.Tokens.T__522.rawValue)
		 	setState(6612)
		 	try libraryObjectNameRef()
		 	setState(6614)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6613)
		 		try libraryRef()

		 	}

		 	setState(6616)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOtherwiseFrameBorderContext: ParserRuleContext {
			open
			func schematicOtherwiseFrameBorderTemplateRef() -> SchematicOtherwiseFrameBorderTemplateRefContext? {
				return getRuleContext(SchematicOtherwiseFrameBorderTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOtherwiseFrameBorder
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOtherwiseFrameBorder(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOtherwiseFrameBorder(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOtherwiseFrameBorder(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOtherwiseFrameBorder(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOtherwiseFrameBorder() throws -> SchematicOtherwiseFrameBorderContext {
		var _localctx: SchematicOtherwiseFrameBorderContext = SchematicOtherwiseFrameBorderContext(_ctx, getState())
		try enterRule(_localctx, 1296, EDIF300Parser.RULE_schematicOtherwiseFrameBorder)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6618)
		 	try match(EDIF300Parser.Tokens.T__523.rawValue)
		 	setState(6619)
		 	try schematicOtherwiseFrameBorderTemplateRef()
		 	setState(6620)
		 	try transform()
		 	setState(6625)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__444.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6623)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__444:
		 			setState(6621)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6622)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6627)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6628)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOtherwiseFrameBorderTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func usableArea() -> UsableAreaContext? {
				return getRuleContext(UsableAreaContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOtherwiseFrameBorderTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOtherwiseFrameBorderTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOtherwiseFrameBorderTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOtherwiseFrameBorderTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOtherwiseFrameBorderTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOtherwiseFrameBorderTemplate() throws -> SchematicOtherwiseFrameBorderTemplateContext {
		var _localctx: SchematicOtherwiseFrameBorderTemplateContext = SchematicOtherwiseFrameBorderTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1298, EDIF300Parser.RULE_schematicOtherwiseFrameBorderTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6630)
		 	try match(EDIF300Parser.Tokens.T__524.rawValue)
		 	setState(6631)
		 	try libraryObjectNameDef()
		 	setState(6632)
		 	try schematicTemplateHeader()
		 	setState(6633)
		 	try usableArea()
		 	setState(6641)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__443.rawValue || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6639)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6634)
		 			try annotate()

		 			break

		 		case .T__62:
		 			setState(6635)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6636)
		 			try figure()

		 			break

		 		case .T__443:
		 			setState(6637)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6638)
		 			try schematicComplexFigure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6643)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6644)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOtherwiseFrameBorderTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOtherwiseFrameBorderTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOtherwiseFrameBorderTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOtherwiseFrameBorderTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOtherwiseFrameBorderTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOtherwiseFrameBorderTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOtherwiseFrameBorderTemplateRef() throws -> SchematicOtherwiseFrameBorderTemplateRefContext {
		var _localctx: SchematicOtherwiseFrameBorderTemplateRefContext = SchematicOtherwiseFrameBorderTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1300, EDIF300Parser.RULE_schematicOtherwiseFrameBorderTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6646)
		 	try match(EDIF300Parser.Tokens.T__525.rawValue)
		 	setState(6647)
		 	try libraryObjectNameRef()
		 	setState(6649)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6648)
		 		try libraryRef()

		 	}

		 	setState(6651)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOtherwiseFrameImplementationContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func otherwiseFrameRef() -> OtherwiseFrameRefContext? {
				return getRuleContext(OtherwiseFrameRefContext.self, 0)
			}
			open
			func schematicOtherwiseFrameImplementationHeader() -> SchematicOtherwiseFrameImplementationHeaderContext? {
				return getRuleContext(SchematicOtherwiseFrameImplementationHeaderContext.self, 0)
			}
			open
			func schematicFrameImplementationDetails() -> SchematicFrameImplementationDetailsContext? {
				return getRuleContext(SchematicFrameImplementationDetailsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOtherwiseFrameImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOtherwiseFrameImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOtherwiseFrameImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOtherwiseFrameImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOtherwiseFrameImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOtherwiseFrameImplementation() throws -> SchematicOtherwiseFrameImplementationContext {
		var _localctx: SchematicOtherwiseFrameImplementationContext = SchematicOtherwiseFrameImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1302, EDIF300Parser.RULE_schematicOtherwiseFrameImplementation)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6653)
		 	try match(EDIF300Parser.Tokens.T__526.rawValue)
		 	setState(6654)
		 	try implementationNameDef()
		 	setState(6655)
		 	try otherwiseFrameRef()
		 	setState(6656)
		 	try schematicOtherwiseFrameImplementationHeader()
		 	setState(6657)
		 	try schematicFrameImplementationDetails()
		 	setState(6658)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicOtherwiseFrameImplementationHeaderContext: ParserRuleContext {
			open
			func schematicOtherwiseFrameBorder() -> SchematicOtherwiseFrameBorderContext? {
				return getRuleContext(SchematicOtherwiseFrameBorderContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicOtherwiseFrameImplementationHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicOtherwiseFrameImplementationHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicOtherwiseFrameImplementationHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicOtherwiseFrameImplementationHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicOtherwiseFrameImplementationHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicOtherwiseFrameImplementationHeader() throws -> SchematicOtherwiseFrameImplementationHeaderContext {
		var _localctx: SchematicOtherwiseFrameImplementationHeaderContext = SchematicOtherwiseFrameImplementationHeaderContext(_ctx, getState())
		try enterRule(_localctx, 1304, EDIF300Parser.RULE_schematicOtherwiseFrameImplementationHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6660)
		 	try match(EDIF300Parser.Tokens.T__527.rawValue)
		 	setState(6662)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__523.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6661)
		 		try schematicOtherwiseFrameBorder()

		 	}

		 	setState(6664)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortAcPowerContext: ParserRuleContext {
			open
			func schematicPortAcPowerRecommendedFrequency() -> [SchematicPortAcPowerRecommendedFrequencyContext] {
				return getRuleContexts(SchematicPortAcPowerRecommendedFrequencyContext.self)
			}
			open
			func schematicPortAcPowerRecommendedFrequency(_ i: Int) -> SchematicPortAcPowerRecommendedFrequencyContext? {
				return getRuleContext(SchematicPortAcPowerRecommendedFrequencyContext.self, i)
			}
			open
			func schematicPortAcPowerRecommendedVoltageRms() -> [SchematicPortAcPowerRecommendedVoltageRmsContext] {
				return getRuleContexts(SchematicPortAcPowerRecommendedVoltageRmsContext.self)
			}
			open
			func schematicPortAcPowerRecommendedVoltageRms(_ i: Int) -> SchematicPortAcPowerRecommendedVoltageRmsContext? {
				return getRuleContext(SchematicPortAcPowerRecommendedVoltageRmsContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortAcPower
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortAcPower(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortAcPower(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortAcPower(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortAcPower(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortAcPower() throws -> SchematicPortAcPowerContext {
		var _localctx: SchematicPortAcPowerContext = SchematicPortAcPowerContext(_ctx, getState())
		try enterRule(_localctx, 1306, EDIF300Parser.RULE_schematicPortAcPower)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6666)
		 	try match(EDIF300Parser.Tokens.T__528.rawValue)
		 	setState(6671)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__529.rawValue || _la == EDIF300Parser.Tokens.T__530.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6669)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__529:
		 			setState(6667)
		 			try schematicPortAcPowerRecommendedFrequency()

		 			break

		 		case .T__530:
		 			setState(6668)
		 			try schematicPortAcPowerRecommendedVoltageRms()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6673)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6674)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortAcPowerRecommendedFrequencyContext: ParserRuleContext {
			open
			func frequencyValue() -> FrequencyValueContext? {
				return getRuleContext(FrequencyValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortAcPowerRecommendedFrequency
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortAcPowerRecommendedFrequency(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortAcPowerRecommendedFrequency(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortAcPowerRecommendedFrequency(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortAcPowerRecommendedFrequency(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortAcPowerRecommendedFrequency() throws -> SchematicPortAcPowerRecommendedFrequencyContext {
		var _localctx: SchematicPortAcPowerRecommendedFrequencyContext = SchematicPortAcPowerRecommendedFrequencyContext(_ctx, getState())
		try enterRule(_localctx, 1308, EDIF300Parser.RULE_schematicPortAcPowerRecommendedFrequency)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6676)
		 	try match(EDIF300Parser.Tokens.T__529.rawValue)
		 	setState(6677)
		 	try frequencyValue()
		 	setState(6678)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortAcPowerRecommendedVoltageRmsContext: ParserRuleContext {
			open
			func voltageValue() -> VoltageValueContext? {
				return getRuleContext(VoltageValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortAcPowerRecommendedVoltageRms
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortAcPowerRecommendedVoltageRms(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortAcPowerRecommendedVoltageRms(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortAcPowerRecommendedVoltageRms(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortAcPowerRecommendedVoltageRms(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortAcPowerRecommendedVoltageRms() throws -> SchematicPortAcPowerRecommendedVoltageRmsContext {
		var _localctx: SchematicPortAcPowerRecommendedVoltageRmsContext = SchematicPortAcPowerRecommendedVoltageRmsContext(_ctx, getState())
		try enterRule(_localctx, 1310, EDIF300Parser.RULE_schematicPortAcPowerRecommendedVoltageRms)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6680)
		 	try match(EDIF300Parser.Tokens.T__530.rawValue)
		 	setState(6681)
		 	try voltageValue()
		 	setState(6682)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortAnalogContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortAnalog
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortAnalog(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortAnalog(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortAnalog(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortAnalog(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortAnalog() throws -> SchematicPortAnalogContext {
		var _localctx: SchematicPortAnalogContext = SchematicPortAnalogContext(_ctx, getState())
		try enterRule(_localctx, 1312, EDIF300Parser.RULE_schematicPortAnalog)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6684)
		 	try match(EDIF300Parser.Tokens.T__531.rawValue)
		 	setState(6685)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortAttributesContext: ParserRuleContext {
			open
			func ieeeStandard() -> [IeeeStandardContext] {
				return getRuleContexts(IeeeStandardContext.self)
			}
			open
			func ieeeStandard(_ i: Int) -> IeeeStandardContext? {
				return getRuleContext(IeeeStandardContext.self, i)
			}
			open
			func schematicPortAcPower() -> [SchematicPortAcPowerContext] {
				return getRuleContexts(SchematicPortAcPowerContext.self)
			}
			open
			func schematicPortAcPower(_ i: Int) -> SchematicPortAcPowerContext? {
				return getRuleContext(SchematicPortAcPowerContext.self, i)
			}
			open
			func schematicPortAnalog() -> [SchematicPortAnalogContext] {
				return getRuleContexts(SchematicPortAnalogContext.self)
			}
			open
			func schematicPortAnalog(_ i: Int) -> SchematicPortAnalogContext? {
				return getRuleContext(SchematicPortAnalogContext.self, i)
			}
			open
			func schematicPortChassisGround() -> [SchematicPortChassisGroundContext] {
				return getRuleContexts(SchematicPortChassisGroundContext.self)
			}
			open
			func schematicPortChassisGround(_ i: Int) -> SchematicPortChassisGroundContext? {
				return getRuleContext(SchematicPortChassisGroundContext.self, i)
			}
			open
			func schematicPortClock() -> [SchematicPortClockContext] {
				return getRuleContexts(SchematicPortClockContext.self)
			}
			open
			func schematicPortClock(_ i: Int) -> SchematicPortClockContext? {
				return getRuleContext(SchematicPortClockContext.self, i)
			}
			open
			func schematicPortDcPower() -> [SchematicPortDcPowerContext] {
				return getRuleContexts(SchematicPortDcPowerContext.self)
			}
			open
			func schematicPortDcPower(_ i: Int) -> SchematicPortDcPowerContext? {
				return getRuleContext(SchematicPortDcPowerContext.self, i)
			}
			open
			func schematicPortEarthGround() -> [SchematicPortEarthGroundContext] {
				return getRuleContexts(SchematicPortEarthGroundContext.self)
			}
			open
			func schematicPortEarthGround(_ i: Int) -> SchematicPortEarthGroundContext? {
				return getRuleContext(SchematicPortEarthGroundContext.self, i)
			}
			open
			func schematicPortGround() -> [SchematicPortGroundContext] {
				return getRuleContexts(SchematicPortGroundContext.self)
			}
			open
			func schematicPortGround(_ i: Int) -> SchematicPortGroundContext? {
				return getRuleContext(SchematicPortGroundContext.self, i)
			}
			open
			func schematicPortNonLogical() -> [SchematicPortNonLogicalContext] {
				return getRuleContexts(SchematicPortNonLogicalContext.self)
			}
			open
			func schematicPortNonLogical(_ i: Int) -> SchematicPortNonLogicalContext? {
				return getRuleContext(SchematicPortNonLogicalContext.self, i)
			}
			open
			func schematicPortOpenCollector() -> [SchematicPortOpenCollectorContext] {
				return getRuleContexts(SchematicPortOpenCollectorContext.self)
			}
			open
			func schematicPortOpenCollector(_ i: Int) -> SchematicPortOpenCollectorContext? {
				return getRuleContext(SchematicPortOpenCollectorContext.self, i)
			}
			open
			func schematicPortOpenEmitter() -> [SchematicPortOpenEmitterContext] {
				return getRuleContexts(SchematicPortOpenEmitterContext.self)
			}
			open
			func schematicPortOpenEmitter(_ i: Int) -> SchematicPortOpenEmitterContext? {
				return getRuleContext(SchematicPortOpenEmitterContext.self, i)
			}
			open
			func schematicPortPower() -> [SchematicPortPowerContext] {
				return getRuleContexts(SchematicPortPowerContext.self)
			}
			open
			func schematicPortPower(_ i: Int) -> SchematicPortPowerContext? {
				return getRuleContext(SchematicPortPowerContext.self, i)
			}
			open
			func schematicPortThreeState() -> [SchematicPortThreeStateContext] {
				return getRuleContexts(SchematicPortThreeStateContext.self)
			}
			open
			func schematicPortThreeState(_ i: Int) -> SchematicPortThreeStateContext? {
				return getRuleContext(SchematicPortThreeStateContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortAttributes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortAttributes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortAttributes(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortAttributes(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortAttributes(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortAttributes() throws -> SchematicPortAttributesContext {
		var _localctx: SchematicPortAttributesContext = SchematicPortAttributesContext(_ctx, getState())
		try enterRule(_localctx, 1314, EDIF300Parser.RULE_schematicPortAttributes)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6687)
		 	try match(EDIF300Parser.Tokens.T__532.rawValue)
		 	setState(6703)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__214.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__528.rawValue,EDIF300Parser.Tokens.T__531.rawValue,EDIF300Parser.Tokens.T__533.rawValue,EDIF300Parser.Tokens.T__534.rawValue,EDIF300Parser.Tokens.T__535.rawValue,EDIF300Parser.Tokens.T__537.rawValue,EDIF300Parser.Tokens.T__538.rawValue,EDIF300Parser.Tokens.T__539.rawValue,EDIF300Parser.Tokens.T__540.rawValue,EDIF300Parser.Tokens.T__541.rawValue,EDIF300Parser.Tokens.T__542.rawValue,EDIF300Parser.Tokens.T__544.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 529)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6701)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__214:
		 			setState(6688)
		 			try ieeeStandard()

		 			break

		 		case .T__528:
		 			setState(6689)
		 			try schematicPortAcPower()

		 			break

		 		case .T__531:
		 			setState(6690)
		 			try schematicPortAnalog()

		 			break

		 		case .T__533:
		 			setState(6691)
		 			try schematicPortChassisGround()

		 			break

		 		case .T__534:
		 			setState(6692)
		 			try schematicPortClock()

		 			break

		 		case .T__535:
		 			setState(6693)
		 			try schematicPortDcPower()

		 			break

		 		case .T__537:
		 			setState(6694)
		 			try schematicPortEarthGround()

		 			break

		 		case .T__538:
		 			setState(6695)
		 			try schematicPortGround()

		 			break

		 		case .T__539:
		 			setState(6696)
		 			try schematicPortNonLogical()

		 			break

		 		case .T__540:
		 			setState(6697)
		 			try schematicPortOpenCollector()

		 			break

		 		case .T__541:
		 			setState(6698)
		 			try schematicPortOpenEmitter()

		 			break

		 		case .T__542:
		 			setState(6699)
		 			try schematicPortPower()

		 			break

		 		case .T__544:
		 			setState(6700)
		 			try schematicPortThreeState()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6705)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6706)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortChassisGroundContext: ParserRuleContext {
			open
			func schematicPortAnalog() -> SchematicPortAnalogContext? {
				return getRuleContext(SchematicPortAnalogContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortChassisGround
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortChassisGround(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortChassisGround(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortChassisGround(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortChassisGround(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortChassisGround() throws -> SchematicPortChassisGroundContext {
		var _localctx: SchematicPortChassisGroundContext = SchematicPortChassisGroundContext(_ctx, getState())
		try enterRule(_localctx, 1316, EDIF300Parser.RULE_schematicPortChassisGround)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6708)
		 	try match(EDIF300Parser.Tokens.T__533.rawValue)
		 	setState(6710)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__531.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6709)
		 		try schematicPortAnalog()

		 	}

		 	setState(6712)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortClockContext: ParserRuleContext {
			open
			func ieeeStandard() -> IeeeStandardContext? {
				return getRuleContext(IeeeStandardContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortClock
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortClock(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortClock(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortClock(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortClock(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortClock() throws -> SchematicPortClockContext {
		var _localctx: SchematicPortClockContext = SchematicPortClockContext(_ctx, getState())
		try enterRule(_localctx, 1318, EDIF300Parser.RULE_schematicPortClock)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6714)
		 	try match(EDIF300Parser.Tokens.T__534.rawValue)
		 	setState(6716)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__214.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6715)
		 		try ieeeStandard()

		 	}

		 	setState(6718)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortDcPowerContext: ParserRuleContext {
			open
			func schematicPortAnalog() -> [SchematicPortAnalogContext] {
				return getRuleContexts(SchematicPortAnalogContext.self)
			}
			open
			func schematicPortAnalog(_ i: Int) -> SchematicPortAnalogContext? {
				return getRuleContext(SchematicPortAnalogContext.self, i)
			}
			open
			func schematicPortDcPowerRecommendedVoltage() -> [SchematicPortDcPowerRecommendedVoltageContext] {
				return getRuleContexts(SchematicPortDcPowerRecommendedVoltageContext.self)
			}
			open
			func schematicPortDcPowerRecommendedVoltage(_ i: Int) -> SchematicPortDcPowerRecommendedVoltageContext? {
				return getRuleContext(SchematicPortDcPowerRecommendedVoltageContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortDcPower
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortDcPower(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortDcPower(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortDcPower(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortDcPower(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortDcPower() throws -> SchematicPortDcPowerContext {
		var _localctx: SchematicPortDcPowerContext = SchematicPortDcPowerContext(_ctx, getState())
		try enterRule(_localctx, 1320, EDIF300Parser.RULE_schematicPortDcPower)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6720)
		 	try match(EDIF300Parser.Tokens.T__535.rawValue)
		 	setState(6725)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__531.rawValue || _la == EDIF300Parser.Tokens.T__536.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6723)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__531:
		 			setState(6721)
		 			try schematicPortAnalog()

		 			break

		 		case .T__536:
		 			setState(6722)
		 			try schematicPortDcPowerRecommendedVoltage()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6727)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6728)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortDcPowerRecommendedVoltageContext: ParserRuleContext {
			open
			func voltageValue() -> VoltageValueContext? {
				return getRuleContext(VoltageValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortDcPowerRecommendedVoltage
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortDcPowerRecommendedVoltage(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortDcPowerRecommendedVoltage(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortDcPowerRecommendedVoltage(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortDcPowerRecommendedVoltage(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortDcPowerRecommendedVoltage() throws -> SchematicPortDcPowerRecommendedVoltageContext {
		var _localctx: SchematicPortDcPowerRecommendedVoltageContext = SchematicPortDcPowerRecommendedVoltageContext(_ctx, getState())
		try enterRule(_localctx, 1322, EDIF300Parser.RULE_schematicPortDcPowerRecommendedVoltage)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6730)
		 	try match(EDIF300Parser.Tokens.T__536.rawValue)
		 	setState(6731)
		 	try voltageValue()
		 	setState(6732)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortEarthGroundContext: ParserRuleContext {
			open
			func schematicPortAnalog() -> SchematicPortAnalogContext? {
				return getRuleContext(SchematicPortAnalogContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortEarthGround
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortEarthGround(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortEarthGround(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortEarthGround(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortEarthGround(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortEarthGround() throws -> SchematicPortEarthGroundContext {
		var _localctx: SchematicPortEarthGroundContext = SchematicPortEarthGroundContext(_ctx, getState())
		try enterRule(_localctx, 1324, EDIF300Parser.RULE_schematicPortEarthGround)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6734)
		 	try match(EDIF300Parser.Tokens.T__537.rawValue)
		 	setState(6736)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__531.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6735)
		 		try schematicPortAnalog()

		 	}

		 	setState(6738)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortGroundContext: ParserRuleContext {
			open
			func schematicPortAnalog() -> SchematicPortAnalogContext? {
				return getRuleContext(SchematicPortAnalogContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortGround
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortGround(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortGround(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortGround(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortGround(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortGround() throws -> SchematicPortGroundContext {
		var _localctx: SchematicPortGroundContext = SchematicPortGroundContext(_ctx, getState())
		try enterRule(_localctx, 1326, EDIF300Parser.RULE_schematicPortGround)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6740)
		 	try match(EDIF300Parser.Tokens.T__538.rawValue)
		 	setState(6742)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__531.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6741)
		 		try schematicPortAnalog()

		 	}

		 	setState(6744)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortNonLogicalContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortNonLogical
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortNonLogical(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortNonLogical(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortNonLogical(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortNonLogical(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortNonLogical() throws -> SchematicPortNonLogicalContext {
		var _localctx: SchematicPortNonLogicalContext = SchematicPortNonLogicalContext(_ctx, getState())
		try enterRule(_localctx, 1328, EDIF300Parser.RULE_schematicPortNonLogical)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6746)
		 	try match(EDIF300Parser.Tokens.T__539.rawValue)
		 	setState(6747)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortOpenCollectorContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortOpenCollector
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortOpenCollector(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortOpenCollector(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortOpenCollector(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortOpenCollector(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortOpenCollector() throws -> SchematicPortOpenCollectorContext {
		var _localctx: SchematicPortOpenCollectorContext = SchematicPortOpenCollectorContext(_ctx, getState())
		try enterRule(_localctx, 1330, EDIF300Parser.RULE_schematicPortOpenCollector)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6749)
		 	try match(EDIF300Parser.Tokens.T__540.rawValue)
		 	setState(6750)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortOpenEmitterContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortOpenEmitter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortOpenEmitter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortOpenEmitter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortOpenEmitter(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortOpenEmitter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortOpenEmitter() throws -> SchematicPortOpenEmitterContext {
		var _localctx: SchematicPortOpenEmitterContext = SchematicPortOpenEmitterContext(_ctx, getState())
		try enterRule(_localctx, 1332, EDIF300Parser.RULE_schematicPortOpenEmitter)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6752)
		 	try match(EDIF300Parser.Tokens.T__541.rawValue)
		 	setState(6753)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortPowerContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortPower
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortPower(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortPower(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortPower(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortPower(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortPower() throws -> SchematicPortPowerContext {
		var _localctx: SchematicPortPowerContext = SchematicPortPowerContext(_ctx, getState())
		try enterRule(_localctx, 1334, EDIF300Parser.RULE_schematicPortPower)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6755)
		 	try match(EDIF300Parser.Tokens.T__542.rawValue)
		 	setState(6756)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortStyleContext: ParserRuleContext {
			open
			func narrowPort() -> NarrowPortContext? {
				return getRuleContext(NarrowPortContext.self, 0)
			}
			open
			func widePort() -> WidePortContext? {
				return getRuleContext(WidePortContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortStyle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortStyle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortStyle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortStyle(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortStyle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortStyle() throws -> SchematicPortStyleContext {
		var _localctx: SchematicPortStyleContext = SchematicPortStyleContext(_ctx, getState())
		try enterRule(_localctx, 1336, EDIF300Parser.RULE_schematicPortStyle)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6758)
		 	try match(EDIF300Parser.Tokens.T__543.rawValue)
		 	setState(6761)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__349:
		 		setState(6759)
		 		try narrowPort()

		 		break

		 	case .T__661:
		 		setState(6760)
		 		try widePort()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(6763)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicPortThreeStateContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicPortThreeState
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicPortThreeState(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicPortThreeState(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicPortThreeState(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicPortThreeState(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicPortThreeState() throws -> SchematicPortThreeStateContext {
		var _localctx: SchematicPortThreeStateContext = SchematicPortThreeStateContext(_ctx, getState())
		try enterRule(_localctx, 1338, EDIF300Parser.RULE_schematicPortThreeState)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6765)
		 	try match(EDIF300Parser.Tokens.T__544.rawValue)
		 	setState(6766)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicRequiredDefaultsContext: ParserRuleContext {
			open
			func schematicMetric() -> SchematicMetricContext? {
				return getRuleContext(SchematicMetricContext.self, 0)
			}
			open
			func fontRef() -> FontRefContext? {
				return getRuleContext(FontRefContext.self, 0)
			}
			open
			func textHeight() -> TextHeightContext? {
				return getRuleContext(TextHeightContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicRequiredDefaults
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicRequiredDefaults(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicRequiredDefaults(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicRequiredDefaults(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicRequiredDefaults(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicRequiredDefaults() throws -> SchematicRequiredDefaultsContext {
		var _localctx: SchematicRequiredDefaultsContext = SchematicRequiredDefaultsContext(_ctx, getState())
		try enterRule(_localctx, 1340, EDIF300Parser.RULE_schematicRequiredDefaults)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6768)
		 	try match(EDIF300Parser.Tokens.T__545.rawValue)
		 	setState(6769)
		 	try schematicMetric()
		 	setState(6770)
		 	try fontRef()
		 	setState(6771)
		 	try textHeight()
		 	setState(6772)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicRipperImplementationContext: ParserRuleContext {
			open
			func implementationNameDef() -> ImplementationNameDefContext? {
				return getRuleContext(ImplementationNameDefContext.self, 0)
			}
			open
			func schematicRipperTemplateRef() -> SchematicRipperTemplateRefContext? {
				return getRuleContext(SchematicRipperTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicRipperImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicRipperImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicRipperImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicRipperImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicRipperImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicRipperImplementation() throws -> SchematicRipperImplementationContext {
		var _localctx: SchematicRipperImplementationContext = SchematicRipperImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1342, EDIF300Parser.RULE_schematicRipperImplementation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6774)
		 	try match(EDIF300Parser.Tokens.T__546.rawValue)
		 	setState(6775)
		 	try implementationNameDef()
		 	setState(6776)
		 	try schematicRipperTemplateRef()
		 	setState(6777)
		 	try transform()
		 	setState(6786)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__442.rawValue,EDIF300Parser.Tokens.T__443.rawValue,EDIF300Parser.Tokens.T__444.rawValue,EDIF300Parser.Tokens.T__448.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 443)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6784)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__221:
		 			setState(6778)
		 			try implementationNameDisplay()

		 			break

		 		case .T__346:
		 			setState(6779)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(6780)
		 			try property()

		 			break

		 		case .T__443:
		 			setState(6781)
		 			try propertyDisplay()

		 			break

		 		case .T__444:
		 			setState(6782)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6783)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6788)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6789)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicRipperImplementationRefContext: ParserRuleContext {
			open
			func implementationNameRef() -> ImplementationNameRefContext? {
				return getRuleContext(ImplementationNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicRipperImplementationRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicRipperImplementationRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicRipperImplementationRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicRipperImplementationRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicRipperImplementationRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicRipperImplementationRef() throws -> SchematicRipperImplementationRefContext {
		var _localctx: SchematicRipperImplementationRefContext = SchematicRipperImplementationRefContext(_ctx, getState())
		try enterRule(_localctx, 1344, EDIF300Parser.RULE_schematicRipperImplementationRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6791)
		 	try match(EDIF300Parser.Tokens.T__547.rawValue)
		 	setState(6792)
		 	try implementationNameRef()
		 	setState(6793)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicRipperTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func ripperHotspot() -> [RipperHotspotContext] {
				return getRuleContexts(RipperHotspotContext.self)
			}
			open
			func ripperHotspot(_ i: Int) -> RipperHotspotContext? {
				return getRuleContext(RipperHotspotContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicRipperTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicRipperTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicRipperTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicRipperTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicRipperTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicRipperTemplate() throws -> SchematicRipperTemplateContext {
		var _localctx: SchematicRipperTemplateContext = SchematicRipperTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1346, EDIF300Parser.RULE_schematicRipperTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6795)
		 	try match(EDIF300Parser.Tokens.T__548.rawValue)
		 	setState(6796)
		 	try libraryObjectNameDef()
		 	setState(6797)
		 	try schematicTemplateHeader()
		 	setState(6807)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue || _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__443.rawValue,EDIF300Parser.Tokens.T__463.rawValue,EDIF300Parser.Tokens.T__474.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 444)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(6805)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6798)
		 			try annotate()

		 			break

		 		case .T__62:
		 			setState(6799)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6800)
		 			try figure()

		 			break

		 		case .T__221:
		 			setState(6801)
		 			try implementationNameDisplay()

		 			break

		 		case .T__443:
		 			setState(6802)
		 			try propertyDisplay()

		 			break

		 		case .T__463:
		 			setState(6803)
		 			try ripperHotspot()

		 			break

		 		case .T__474:
		 			setState(6804)
		 			try schematicComplexFigure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6809)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6810)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicRipperTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicRipperTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicRipperTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicRipperTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicRipperTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicRipperTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicRipperTemplateRef() throws -> SchematicRipperTemplateRefContext {
		var _localctx: SchematicRipperTemplateRefContext = SchematicRipperTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1348, EDIF300Parser.RULE_schematicRipperTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6812)
		 	try match(EDIF300Parser.Tokens.T__549.rawValue)
		 	setState(6813)
		 	try libraryObjectNameRef()
		 	setState(6815)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6814)
		 		try libraryRef()

		 	}

		 	setState(6817)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSubBusContext: ParserRuleContext {
			open
			func interconnectNameDef() -> InterconnectNameDefContext? {
				return getRuleContext(InterconnectNameDefContext.self, 0)
			}
			open
			func schematicSubInterconnectHeader() -> SchematicSubInterconnectHeaderContext? {
				return getRuleContext(SchematicSubInterconnectHeaderContext.self, 0)
			}
			open
			func schematicBusJoined() -> SchematicBusJoinedContext? {
				return getRuleContext(SchematicBusJoinedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func schematicBusDetails() -> [SchematicBusDetailsContext] {
				return getRuleContexts(SchematicBusDetailsContext.self)
			}
			open
			func schematicBusDetails(_ i: Int) -> SchematicBusDetailsContext? {
				return getRuleContext(SchematicBusDetailsContext.self, i)
			}
			open
			func schematicBusSlice() -> [SchematicBusSliceContext] {
				return getRuleContexts(SchematicBusSliceContext.self)
			}
			open
			func schematicBusSlice(_ i: Int) -> SchematicBusSliceContext? {
				return getRuleContext(SchematicBusSliceContext.self, i)
			}
			open
			func schematicInterconnectAttributeDisplay() -> [SchematicInterconnectAttributeDisplayContext] {
				return getRuleContexts(SchematicInterconnectAttributeDisplayContext.self)
			}
			open
			func schematicInterconnectAttributeDisplay(_ i: Int) -> SchematicInterconnectAttributeDisplayContext? {
				return getRuleContext(SchematicInterconnectAttributeDisplayContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSubBus
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSubBus(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSubBus(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSubBus(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSubBus(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSubBus() throws -> SchematicSubBusContext {
		var _localctx: SchematicSubBusContext = SchematicSubBusContext(_ctx, getState())
		try enterRule(_localctx, 1350, EDIF300Parser.RULE_schematicSubBus)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6819)
		 	try match(EDIF300Parser.Tokens.T__550.rawValue)
		 	setState(6820)
		 	try interconnectNameDef()
		 	setState(6821)
		 	try schematicSubInterconnectHeader()
		 	setState(6822)
		 	try schematicBusJoined()
		 	setState(6830)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__470.rawValue,EDIF300Parser.Tokens.T__473.rawValue,EDIF300Parser.Tokens.T__496.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 471)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6828)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(6823)
		 			try comment()

		 			break

		 		case .T__470:
		 			setState(6824)
		 			try schematicBusDetails()

		 			break

		 		case .T__473:
		 			setState(6825)
		 			try schematicBusSlice()

		 			break

		 		case .T__496:
		 			setState(6826)
		 			try schematicInterconnectAttributeDisplay()

		 			break

		 		case .T__642:
		 			setState(6827)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6832)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6833)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSubBusSetContext: ParserRuleContext {
			open
			func schematicSubBus() -> [SchematicSubBusContext] {
				return getRuleContexts(SchematicSubBusContext.self)
			}
			open
			func schematicSubBus(_ i: Int) -> SchematicSubBusContext? {
				return getRuleContext(SchematicSubBusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSubBusSet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSubBusSet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSubBusSet(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSubBusSet(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSubBusSet(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSubBusSet() throws -> SchematicSubBusSetContext {
		var _localctx: SchematicSubBusSetContext = SchematicSubBusSetContext(_ctx, getState())
		try enterRule(_localctx, 1352, EDIF300Parser.RULE_schematicSubBusSet)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6835)
		 	try match(EDIF300Parser.Tokens.T__551.rawValue)
		 	setState(6839)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__550.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6836)
		 		try schematicSubBus()


		 		setState(6841)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6842)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSubInterconnectHeaderContext: ParserRuleContext {
			open
			func criticality() -> [CriticalityContext] {
				return getRuleContexts(CriticalityContext.self)
			}
			open
			func criticality(_ i: Int) -> CriticalityContext? {
				return getRuleContext(CriticalityContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func interconnectDelay() -> [InterconnectDelayContext] {
				return getRuleContexts(InterconnectDelayContext.self)
			}
			open
			func interconnectDelay(_ i: Int) -> InterconnectDelayContext? {
				return getRuleContext(InterconnectDelayContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSubInterconnectHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSubInterconnectHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSubInterconnectHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSubInterconnectHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSubInterconnectHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSubInterconnectHeader() throws -> SchematicSubInterconnectHeaderContext {
		var _localctx: SchematicSubInterconnectHeaderContext = SchematicSubInterconnectHeaderContext(_ctx, getState())
		try enterRule(_localctx, 1354, EDIF300Parser.RULE_schematicSubInterconnectHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6844)
		 	try match(EDIF300Parser.Tokens.T__552.rawValue)
		 	setState(6852)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__97.rawValue || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__261.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6850)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__97:
		 			setState(6845)
		 			try criticality()

		 			break

		 		case .T__132:
		 			setState(6846)
		 			try documentation()

		 			break

		 		case .T__261:
		 			setState(6847)
		 			try interconnectDelay()

		 			break

		 		case .T__346:
		 			setState(6848)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(6849)
		 			try property()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6854)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6855)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSubNetContext: ParserRuleContext {
			open
			func interconnectNameDef() -> InterconnectNameDefContext? {
				return getRuleContext(InterconnectNameDefContext.self, 0)
			}
			open
			func schematicSubInterconnectHeader() -> SchematicSubInterconnectHeaderContext? {
				return getRuleContext(SchematicSubInterconnectHeaderContext.self, 0)
			}
			open
			func schematicNetJoined() -> SchematicNetJoinedContext? {
				return getRuleContext(SchematicNetJoinedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func schematicInterconnectAttributeDisplay() -> [SchematicInterconnectAttributeDisplayContext] {
				return getRuleContexts(SchematicInterconnectAttributeDisplayContext.self)
			}
			open
			func schematicInterconnectAttributeDisplay(_ i: Int) -> SchematicInterconnectAttributeDisplayContext? {
				return getRuleContext(SchematicInterconnectAttributeDisplayContext.self, i)
			}
			open
			func schematicNetDetails() -> [SchematicNetDetailsContext] {
				return getRuleContexts(SchematicNetDetailsContext.self)
			}
			open
			func schematicNetDetails(_ i: Int) -> SchematicNetDetailsContext? {
				return getRuleContext(SchematicNetDetailsContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSubNet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSubNet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSubNet(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSubNet(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSubNet(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSubNet() throws -> SchematicSubNetContext {
		var _localctx: SchematicSubNetContext = SchematicSubNetContext(_ctx, getState())
		try enterRule(_localctx, 1356, EDIF300Parser.RULE_schematicSubNet)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6857)
		 	try match(EDIF300Parser.Tokens.T__553.rawValue)
		 	setState(6858)
		 	try interconnectNameDef()
		 	setState(6859)
		 	try schematicSubInterconnectHeader()
		 	setState(6860)
		 	try schematicNetJoined()
		 	setState(6867)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__496.rawValue || _la == EDIF300Parser.Tokens.T__512.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6865)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(6861)
		 			try comment()

		 			break

		 		case .T__496:
		 			setState(6862)
		 			try schematicInterconnectAttributeDisplay()

		 			break

		 		case .T__512:
		 			setState(6863)
		 			try schematicNetDetails()

		 			break

		 		case .T__642:
		 			setState(6864)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6869)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6870)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSubNetSetContext: ParserRuleContext {
			open
			func schematicSubNet() -> [SchematicSubNetContext] {
				return getRuleContexts(SchematicSubNetContext.self)
			}
			open
			func schematicSubNet(_ i: Int) -> SchematicSubNetContext? {
				return getRuleContext(SchematicSubNetContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSubNetSet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSubNetSet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSubNetSet(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSubNetSet(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSubNetSet(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSubNetSet() throws -> SchematicSubNetSetContext {
		var _localctx: SchematicSubNetSetContext = SchematicSubNetSetContext(_ctx, getState())
		try enterRule(_localctx, 1358, EDIF300Parser.RULE_schematicSubNetSet)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6872)
		 	try match(EDIF300Parser.Tokens.T__554.rawValue)
		 	setState(6876)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__553.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6873)
		 		try schematicSubNet()


		 		setState(6878)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6879)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSymbolContext: ParserRuleContext {
			open
			func viewNameDef() -> ViewNameDefContext? {
				return getRuleContext(ViewNameDefContext.self, 0)
			}
			open
			func schematicSymbolHeader() -> SchematicSymbolHeaderContext? {
				return getRuleContext(SchematicSymbolHeaderContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func cellNameDisplay() -> [CellNameDisplayContext] {
				return getRuleContexts(CellNameDisplayContext.self)
			}
			open
			func cellNameDisplay(_ i: Int) -> CellNameDisplayContext? {
				return getRuleContext(CellNameDisplayContext.self, i)
			}
			open
			func cellPropertyDisplay() -> [CellPropertyDisplayContext] {
				return getRuleContexts(CellPropertyDisplayContext.self)
			}
			open
			func cellPropertyDisplay(_ i: Int) -> CellPropertyDisplayContext? {
				return getRuleContext(CellPropertyDisplayContext.self, i)
			}
			open
			func clusterPropertyDisplay() -> [ClusterPropertyDisplayContext] {
				return getRuleContexts(ClusterPropertyDisplayContext.self)
			}
			open
			func clusterPropertyDisplay(_ i: Int) -> ClusterPropertyDisplayContext? {
				return getRuleContext(ClusterPropertyDisplayContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func designatorDisplay() -> [DesignatorDisplayContext] {
				return getRuleContexts(DesignatorDisplayContext.self)
			}
			open
			func designatorDisplay(_ i: Int) -> DesignatorDisplayContext? {
				return getRuleContext(DesignatorDisplayContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func instanceNameDisplay() -> [InstanceNameDisplayContext] {
				return getRuleContexts(InstanceNameDisplayContext.self)
			}
			open
			func instanceNameDisplay(_ i: Int) -> InstanceNameDisplayContext? {
				return getRuleContext(InstanceNameDisplayContext.self, i)
			}
			open
			func instanceNameGeneratorDisplay() -> [InstanceNameGeneratorDisplayContext] {
				return getRuleContexts(InstanceNameGeneratorDisplayContext.self)
			}
			open
			func instanceNameGeneratorDisplay(_ i: Int) -> InstanceNameGeneratorDisplayContext? {
				return getRuleContext(InstanceNameGeneratorDisplayContext.self, i)
			}
			open
			func instanceWidthDisplay() -> [InstanceWidthDisplayContext] {
				return getRuleContexts(InstanceWidthDisplayContext.self)
			}
			open
			func instanceWidthDisplay(_ i: Int) -> InstanceWidthDisplayContext? {
				return getRuleContext(InstanceWidthDisplayContext.self, i)
			}
			open
			func parameterDisplay() -> [ParameterDisplayContext] {
				return getRuleContexts(ParameterDisplayContext.self)
			}
			open
			func parameterDisplay(_ i: Int) -> ParameterDisplayContext? {
				return getRuleContext(ParameterDisplayContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
			open
			func schematicSymbolPortImplementation() -> [SchematicSymbolPortImplementationContext] {
				return getRuleContexts(SchematicSymbolPortImplementationContext.self)
			}
			open
			func schematicSymbolPortImplementation(_ i: Int) -> SchematicSymbolPortImplementationContext? {
				return getRuleContext(SchematicSymbolPortImplementationContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
			open
			func viewNameDisplay() -> [ViewNameDisplayContext] {
				return getRuleContexts(ViewNameDisplayContext.self)
			}
			open
			func viewNameDisplay(_ i: Int) -> ViewNameDisplayContext? {
				return getRuleContext(ViewNameDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSymbol
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSymbol(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSymbol(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSymbol(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSymbol(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSymbol() throws -> SchematicSymbolContext {
		var _localctx: SchematicSymbolContext = SchematicSymbolContext(_ctx, getState())
		try enterRule(_localctx, 1360, EDIF300Parser.RULE_schematicSymbol)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6881)
		 	try match(EDIF300Parser.Tokens.T__555.rawValue)
		 	setState(6882)
		 	try viewNameDef()
		 	setState(6883)
		 	try schematicSymbolHeader()
		 	setState(6904)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__7.rawValue,EDIF300Parser.Tokens.T__39.rawValue,EDIF300Parser.Tokens.T__40.rawValue,EDIF300Parser.Tokens.T__56.rawValue,EDIF300Parser.Tokens.T__61.rawValue,EDIF300Parser.Tokens.T__62.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__119.rawValue || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__221.rawValue,EDIF300Parser.Tokens.T__237.rawValue,EDIF300Parser.Tokens.T__239.rawValue,EDIF300Parser.Tokens.T__246.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 222)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__398.rawValue || _la == EDIF300Parser.Tokens.T__443.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__560.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue || _la == EDIF300Parser.Tokens.T__650.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6902)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6884)
		 			try annotate()

		 			break

		 		case .T__39:
		 			setState(6885)
		 			try cellNameDisplay()

		 			break

		 		case .T__40:
		 			setState(6886)
		 			try cellPropertyDisplay()

		 			break

		 		case .T__56:
		 			setState(6887)
		 			try clusterPropertyDisplay()

		 			break

		 		case .T__61:
		 			setState(6888)
		 			try comment()

		 			break

		 		case .T__62:
		 			setState(6889)
		 			try commentGraphics()

		 			break

		 		case .T__119:
		 			setState(6890)
		 			try designatorDisplay()

		 			break

		 		case .T__159:
		 			setState(6891)
		 			try figure()

		 			break

		 		case .T__221:
		 			setState(6892)
		 			try implementationNameDisplay()

		 			break

		 		case .T__237:
		 			setState(6893)
		 			try instanceNameDisplay()

		 			break

		 		case .T__239:
		 			setState(6894)
		 			try instanceNameGeneratorDisplay()

		 			break

		 		case .T__246:
		 			setState(6895)
		 			try instanceWidthDisplay()

		 			break

		 		case .T__398:
		 			setState(6896)
		 			try parameterDisplay()

		 			break

		 		case .T__443:
		 			setState(6897)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6898)
		 			try schematicComplexFigure()

		 			break

		 		case .T__560:
		 			setState(6899)
		 			try schematicSymbolPortImplementation()

		 			break

		 		case .T__642:
		 			setState(6900)
		 			try userData()

		 			break

		 		case .T__650:
		 			setState(6901)
		 			try viewNameDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6906)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6907)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSymbolBorderContext: ParserRuleContext {
			open
			func schematicSymbolBorderTemplateRef() -> SchematicSymbolBorderTemplateRefContext? {
				return getRuleContext(SchematicSymbolBorderTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSymbolBorder
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSymbolBorder(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSymbolBorder(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSymbolBorder(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSymbolBorder(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSymbolBorder() throws -> SchematicSymbolBorderContext {
		var _localctx: SchematicSymbolBorderContext = SchematicSymbolBorderContext(_ctx, getState())
		try enterRule(_localctx, 1362, EDIF300Parser.RULE_schematicSymbolBorder)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6909)
		 	try match(EDIF300Parser.Tokens.T__556.rawValue)
		 	setState(6910)
		 	try schematicSymbolBorderTemplateRef()
		 	setState(6911)
		 	try transform()
		 	setState(6916)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__444.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6914)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__444:
		 			setState(6912)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6913)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6918)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6919)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSymbolBorderTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func usableArea() -> UsableAreaContext? {
				return getRuleContext(UsableAreaContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSymbolBorderTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSymbolBorderTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSymbolBorderTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSymbolBorderTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSymbolBorderTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSymbolBorderTemplate() throws -> SchematicSymbolBorderTemplateContext {
		var _localctx: SchematicSymbolBorderTemplateContext = SchematicSymbolBorderTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1364, EDIF300Parser.RULE_schematicSymbolBorderTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6921)
		 	try match(EDIF300Parser.Tokens.T__557.rawValue)
		 	setState(6922)
		 	try libraryObjectNameDef()
		 	setState(6923)
		 	try schematicTemplateHeader()
		 	setState(6924)
		 	try usableArea()
		 	setState(6932)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__443.rawValue || _la == EDIF300Parser.Tokens.T__474.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6930)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6925)
		 			try annotate()

		 			break

		 		case .T__62:
		 			setState(6926)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6927)
		 			try figure()

		 			break

		 		case .T__443:
		 			setState(6928)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6929)
		 			try schematicComplexFigure()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6934)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6935)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSymbolBorderTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSymbolBorderTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSymbolBorderTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSymbolBorderTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSymbolBorderTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSymbolBorderTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSymbolBorderTemplateRef() throws -> SchematicSymbolBorderTemplateRefContext {
		var _localctx: SchematicSymbolBorderTemplateRefContext = SchematicSymbolBorderTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1366, EDIF300Parser.RULE_schematicSymbolBorderTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6937)
		 	try match(EDIF300Parser.Tokens.T__558.rawValue)
		 	setState(6938)
		 	try libraryObjectNameRef()
		 	setState(6940)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6939)
		 		try libraryRef()

		 	}

		 	setState(6942)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSymbolHeaderContext: ParserRuleContext {
			open
			func schematicUnits() -> SchematicUnitsContext? {
				return getRuleContext(SchematicUnitsContext.self, 0)
			}
			open
			func backgroundColor() -> [BackgroundColorContext] {
				return getRuleContexts(BackgroundColorContext.self)
			}
			open
			func backgroundColor(_ i: Int) -> BackgroundColorContext? {
				return getRuleContext(BackgroundColorContext.self, i)
			}
			open
			func derivedFrom() -> [DerivedFromContext] {
				return getRuleContexts(DerivedFromContext.self)
			}
			open
			func derivedFrom(_ i: Int) -> DerivedFromContext? {
				return getRuleContext(DerivedFromContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func originalBoundingBox() -> [OriginalBoundingBoxContext] {
				return getRuleContexts(OriginalBoundingBoxContext.self)
			}
			open
			func originalBoundingBox(_ i: Int) -> OriginalBoundingBoxContext? {
				return getRuleContext(OriginalBoundingBoxContext.self, i)
			}
			open
			func pageSize() -> [PageSizeContext] {
				return getRuleContexts(PageSizeContext.self)
			}
			open
			func pageSize(_ i: Int) -> PageSizeContext? {
				return getRuleContext(PageSizeContext.self, i)
			}
			open
			func previousVersion() -> [PreviousVersionContext] {
				return getRuleContexts(PreviousVersionContext.self)
			}
			open
			func previousVersion(_ i: Int) -> PreviousVersionContext? {
				return getRuleContext(PreviousVersionContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func schematicSymbolBorder() -> [SchematicSymbolBorderContext] {
				return getRuleContexts(SchematicSymbolBorderContext.self)
			}
			open
			func schematicSymbolBorder(_ i: Int) -> SchematicSymbolBorderContext? {
				return getRuleContext(SchematicSymbolBorderContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSymbolHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSymbolHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSymbolHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSymbolHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSymbolHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSymbolHeader() throws -> SchematicSymbolHeaderContext {
		var _localctx: SchematicSymbolHeaderContext = SchematicSymbolHeaderContext(_ctx, getState())
		try enterRule(_localctx, 1368, EDIF300Parser.RULE_schematicSymbolHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6944)
		 	try match(EDIF300Parser.Tokens.T__559.rawValue)
		 	setState(6945)
		 	try schematicUnits()
		 	setState(6958)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__14.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__116.rawValue || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__346.rawValue,EDIF300Parser.Tokens.T__368.rawValue,EDIF300Parser.Tokens.T__390.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 347)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__439.rawValue || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__556.rawValue || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6956)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__14:
		 			setState(6946)
		 			try backgroundColor()

		 			break

		 		case .T__116:
		 			setState(6947)
		 			try derivedFrom()

		 			break

		 		case .T__132:
		 			setState(6948)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(6949)
		 			try nameInformation()

		 			break

		 		case .T__368:
		 			setState(6950)
		 			try originalBoundingBox()

		 			break

		 		case .T__390:
		 			setState(6951)
		 			try pageSize()

		 			break

		 		case .T__439:
		 			setState(6952)
		 			try previousVersion()

		 			break

		 		case .T__442:
		 			setState(6953)
		 			try property()

		 			break

		 		case .T__556:
		 			setState(6954)
		 			try schematicSymbolBorder()

		 			break

		 		case .T__597:
		 			setState(6955)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6960)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6961)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSymbolPortImplementationContext: ParserRuleContext {
			open
			func symbolPortImplementationNameDef() -> SymbolPortImplementationNameDefContext? {
				return getRuleContext(SymbolPortImplementationNameDefContext.self, 0)
			}
			open
			func portRef() -> PortRefContext? {
				return getRuleContext(PortRefContext.self, 0)
			}
			open
			func schematicSymbolPortTemplateRef() -> SchematicSymbolPortTemplateRefContext? {
				return getRuleContext(SchematicSymbolPortTemplateRefContext.self, 0)
			}
			open
			func transform() -> TransformContext? {
				return getRuleContext(TransformContext.self, 0)
			}
			open
			func portAttributeDisplay() -> [PortAttributeDisplayContext] {
				return getRuleContexts(PortAttributeDisplayContext.self)
			}
			open
			func portAttributeDisplay(_ i: Int) -> PortAttributeDisplayContext? {
				return getRuleContext(PortAttributeDisplayContext.self, i)
			}
			open
			func propertyDisplayOverride() -> [PropertyDisplayOverrideContext] {
				return getRuleContexts(PropertyDisplayOverrideContext.self)
			}
			open
			func propertyDisplayOverride(_ i: Int) -> PropertyDisplayOverrideContext? {
				return getRuleContext(PropertyDisplayOverrideContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSymbolPortImplementation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSymbolPortImplementation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSymbolPortImplementation(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSymbolPortImplementation(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSymbolPortImplementation(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSymbolPortImplementation() throws -> SchematicSymbolPortImplementationContext {
		var _localctx: SchematicSymbolPortImplementationContext = SchematicSymbolPortImplementationContext(_ctx, getState())
		try enterRule(_localctx, 1370, EDIF300Parser.RULE_schematicSymbolPortImplementation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6963)
		 	try match(EDIF300Parser.Tokens.T__560.rawValue)
		 	setState(6964)
		 	try symbolPortImplementationNameDef()
		 	setState(6965)
		 	try portRef()
		 	setState(6966)
		 	try schematicSymbolPortTemplateRef()
		 	setState(6967)
		 	try transform()
		 	setState(6973)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__416.rawValue,EDIF300Parser.Tokens.T__444.rawValue,EDIF300Parser.Tokens.T__448.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 417)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(6971)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__416:
		 			setState(6968)
		 			try portAttributeDisplay()

		 			break

		 		case .T__444:
		 			setState(6969)
		 			try propertyDisplayOverride()

		 			break

		 		case .T__448:
		 			setState(6970)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(6975)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6976)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSymbolPortImplementationRefContext: ParserRuleContext {
			open
			func symbolPortImplementationNameRef() -> SymbolPortImplementationNameRefContext? {
				return getRuleContext(SymbolPortImplementationNameRefContext.self, 0)
			}
			open
			func schematicInstanceImplementationRef() -> SchematicInstanceImplementationRefContext? {
				return getRuleContext(SchematicInstanceImplementationRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSymbolPortImplementationRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSymbolPortImplementationRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSymbolPortImplementationRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSymbolPortImplementationRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSymbolPortImplementationRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSymbolPortImplementationRef() throws -> SchematicSymbolPortImplementationRefContext {
		var _localctx: SchematicSymbolPortImplementationRefContext = SchematicSymbolPortImplementationRefContext(_ctx, getState())
		try enterRule(_localctx, 1372, EDIF300Parser.RULE_schematicSymbolPortImplementationRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6978)
		 	try match(EDIF300Parser.Tokens.T__561.rawValue)
		 	setState(6979)
		 	try symbolPortImplementationNameRef()
		 	setState(6980)
		 	try schematicInstanceImplementationRef()
		 	setState(6981)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSymbolPortTemplateContext: ParserRuleContext {
			open
			func libraryObjectNameDef() -> LibraryObjectNameDefContext? {
				return getRuleContext(LibraryObjectNameDefContext.self, 0)
			}
			open
			func schematicTemplateHeader() -> SchematicTemplateHeaderContext? {
				return getRuleContext(SchematicTemplateHeaderContext.self, 0)
			}
			open
			func hotspot() -> HotspotContext? {
				return getRuleContext(HotspotContext.self, 0)
			}
			open
			func portDirectionIndicator() -> PortDirectionIndicatorContext? {
				return getRuleContext(PortDirectionIndicatorContext.self, 0)
			}
			open
			func annotate() -> [AnnotateContext] {
				return getRuleContexts(AnnotateContext.self)
			}
			open
			func annotate(_ i: Int) -> AnnotateContext? {
				return getRuleContext(AnnotateContext.self, i)
			}
			open
			func commentGraphics() -> [CommentGraphicsContext] {
				return getRuleContexts(CommentGraphicsContext.self)
			}
			open
			func commentGraphics(_ i: Int) -> CommentGraphicsContext? {
				return getRuleContext(CommentGraphicsContext.self, i)
			}
			open
			func figure() -> [FigureContext] {
				return getRuleContexts(FigureContext.self)
			}
			open
			func figure(_ i: Int) -> FigureContext? {
				return getRuleContext(FigureContext.self, i)
			}
			open
			func implementationNameDisplay() -> [ImplementationNameDisplayContext] {
				return getRuleContexts(ImplementationNameDisplayContext.self)
			}
			open
			func implementationNameDisplay(_ i: Int) -> ImplementationNameDisplayContext? {
				return getRuleContext(ImplementationNameDisplayContext.self, i)
			}
			open
			func portAttributeDisplay() -> [PortAttributeDisplayContext] {
				return getRuleContexts(PortAttributeDisplayContext.self)
			}
			open
			func portAttributeDisplay(_ i: Int) -> PortAttributeDisplayContext? {
				return getRuleContext(PortAttributeDisplayContext.self, i)
			}
			open
			func propertyDisplay() -> [PropertyDisplayContext] {
				return getRuleContexts(PropertyDisplayContext.self)
			}
			open
			func propertyDisplay(_ i: Int) -> PropertyDisplayContext? {
				return getRuleContext(PropertyDisplayContext.self, i)
			}
			open
			func schematicComplexFigure() -> [SchematicComplexFigureContext] {
				return getRuleContexts(SchematicComplexFigureContext.self)
			}
			open
			func schematicComplexFigure(_ i: Int) -> SchematicComplexFigureContext? {
				return getRuleContext(SchematicComplexFigureContext.self, i)
			}
			open
			func schematicPortAttributes() -> [SchematicPortAttributesContext] {
				return getRuleContexts(SchematicPortAttributesContext.self)
			}
			open
			func schematicPortAttributes(_ i: Int) -> SchematicPortAttributesContext? {
				return getRuleContext(SchematicPortAttributesContext.self, i)
			}
			open
			func schematicPortStyle() -> [SchematicPortStyleContext] {
				return getRuleContexts(SchematicPortStyleContext.self)
			}
			open
			func schematicPortStyle(_ i: Int) -> SchematicPortStyleContext? {
				return getRuleContext(SchematicPortStyleContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSymbolPortTemplate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSymbolPortTemplate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSymbolPortTemplate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSymbolPortTemplate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSymbolPortTemplate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSymbolPortTemplate() throws -> SchematicSymbolPortTemplateContext {
		var _localctx: SchematicSymbolPortTemplateContext = SchematicSymbolPortTemplateContext(_ctx, getState())
		try enterRule(_localctx, 1374, EDIF300Parser.RULE_schematicSymbolPortTemplate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6983)
		 	try match(EDIF300Parser.Tokens.T__562.rawValue)
		 	setState(6984)
		 	try libraryObjectNameDef()
		 	setState(6985)
		 	try schematicTemplateHeader()
		 	setState(6986)
		 	try hotspot()
		 	setState(6987)
		 	try portDirectionIndicator()
		 	setState(6999)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__7.rawValue || _la == EDIF300Parser.Tokens.T__62.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__159.rawValue || _la == EDIF300Parser.Tokens.T__221.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__416.rawValue,EDIF300Parser.Tokens.T__443.rawValue,EDIF300Parser.Tokens.T__474.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 417)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__532.rawValue || _la == EDIF300Parser.Tokens.T__543.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(6997)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__7:
		 			setState(6988)
		 			try annotate()

		 			break

		 		case .T__62:
		 			setState(6989)
		 			try commentGraphics()

		 			break

		 		case .T__159:
		 			setState(6990)
		 			try figure()

		 			break

		 		case .T__221:
		 			setState(6991)
		 			try implementationNameDisplay()

		 			break

		 		case .T__416:
		 			setState(6992)
		 			try portAttributeDisplay()

		 			break

		 		case .T__443:
		 			setState(6993)
		 			try propertyDisplay()

		 			break

		 		case .T__474:
		 			setState(6994)
		 			try schematicComplexFigure()

		 			break

		 		case .T__532:
		 			setState(6995)
		 			try schematicPortAttributes()

		 			break

		 		case .T__543:
		 			setState(6996)
		 			try schematicPortStyle()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7001)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7002)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSymbolPortTemplateRefContext: ParserRuleContext {
			open
			func libraryObjectNameRef() -> LibraryObjectNameRefContext? {
				return getRuleContext(LibraryObjectNameRefContext.self, 0)
			}
			open
			func libraryRef() -> LibraryRefContext? {
				return getRuleContext(LibraryRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSymbolPortTemplateRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSymbolPortTemplateRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSymbolPortTemplateRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSymbolPortTemplateRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSymbolPortTemplateRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSymbolPortTemplateRef() throws -> SchematicSymbolPortTemplateRefContext {
		var _localctx: SchematicSymbolPortTemplateRefContext = SchematicSymbolPortTemplateRefContext(_ctx, getState())
		try enterRule(_localctx, 1376, EDIF300Parser.RULE_schematicSymbolPortTemplateRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7004)
		 	try match(EDIF300Parser.Tokens.T__563.rawValue)
		 	setState(7005)
		 	try libraryObjectNameRef()
		 	setState(7007)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__313.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7006)
		 		try libraryRef()

		 	}

		 	setState(7009)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicSymbolRefContext: ParserRuleContext {
			open
			func viewNameRef() -> ViewNameRefContext? {
				return getRuleContext(ViewNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicSymbolRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicSymbolRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicSymbolRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicSymbolRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicSymbolRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicSymbolRef() throws -> SchematicSymbolRefContext {
		var _localctx: SchematicSymbolRefContext = SchematicSymbolRefContext(_ctx, getState())
		try enterRule(_localctx, 1378, EDIF300Parser.RULE_schematicSymbolRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7011)
		 	try match(EDIF300Parser.Tokens.T__564.rawValue)
		 	setState(7012)
		 	try viewNameRef()
		 	setState(7013)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicTemplateHeaderContext: ParserRuleContext {
			open
			func schematicUnits() -> SchematicUnitsContext? {
				return getRuleContext(SchematicUnitsContext.self, 0)
			}
			open
			func backgroundColor() -> [BackgroundColorContext] {
				return getRuleContexts(BackgroundColorContext.self)
			}
			open
			func backgroundColor(_ i: Int) -> BackgroundColorContext? {
				return getRuleContext(BackgroundColorContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func originalBoundingBox() -> [OriginalBoundingBoxContext] {
				return getRuleContexts(OriginalBoundingBoxContext.self)
			}
			open
			func originalBoundingBox(_ i: Int) -> OriginalBoundingBoxContext? {
				return getRuleContext(OriginalBoundingBoxContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicTemplateHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicTemplateHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicTemplateHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicTemplateHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicTemplateHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicTemplateHeader() throws -> SchematicTemplateHeaderContext {
		var _localctx: SchematicTemplateHeaderContext = SchematicTemplateHeaderContext(_ctx, getState())
		try enterRule(_localctx, 1380, EDIF300Parser.RULE_schematicTemplateHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7015)
		 	try match(EDIF300Parser.Tokens.T__565.rawValue)
		 	setState(7016)
		 	try schematicUnits()
		 	setState(7025)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__14.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue || _la == EDIF300Parser.Tokens.T__368.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7023)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__14:
		 			setState(7017)
		 			try backgroundColor()

		 			break

		 		case .T__132:
		 			setState(7018)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(7019)
		 			try nameInformation()

		 			break

		 		case .T__368:
		 			setState(7020)
		 			try originalBoundingBox()

		 			break

		 		case .T__442:
		 			setState(7021)
		 			try property()

		 			break

		 		case .T__597:
		 			setState(7022)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7027)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7028)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicUnitsContext: ParserRuleContext {
			open
			func schematicMetric() -> [SchematicMetricContext] {
				return getRuleContexts(SchematicMetricContext.self)
			}
			open
			func schematicMetric(_ i: Int) -> SchematicMetricContext? {
				return getRuleContext(SchematicMetricContext.self, i)
			}
			open
			func setAngle() -> [SetAngleContext] {
				return getRuleContexts(SetAngleContext.self)
			}
			open
			func setAngle(_ i: Int) -> SetAngleContext? {
				return getRuleContext(SetAngleContext.self, i)
			}
			open
			func setCapacitance() -> [SetCapacitanceContext] {
				return getRuleContexts(SetCapacitanceContext.self)
			}
			open
			func setCapacitance(_ i: Int) -> SetCapacitanceContext? {
				return getRuleContext(SetCapacitanceContext.self, i)
			}
			open
			func setFrequency() -> [SetFrequencyContext] {
				return getRuleContexts(SetFrequencyContext.self)
			}
			open
			func setFrequency(_ i: Int) -> SetFrequencyContext? {
				return getRuleContext(SetFrequencyContext.self, i)
			}
			open
			func setTime() -> [SetTimeContext] {
				return getRuleContexts(SetTimeContext.self)
			}
			open
			func setTime(_ i: Int) -> SetTimeContext? {
				return getRuleContext(SetTimeContext.self, i)
			}
			open
			func setVoltage() -> [SetVoltageContext] {
				return getRuleContexts(SetVoltageContext.self)
			}
			open
			func setVoltage(_ i: Int) -> SetVoltageContext? {
				return getRuleContext(SetVoltageContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicUnits() throws -> SchematicUnitsContext {
		var _localctx: SchematicUnitsContext = SchematicUnitsContext(_ctx, getState())
		try enterRule(_localctx, 1382, EDIF300Parser.RULE_schematicUnits)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7030)
		 	try match(EDIF300Parser.Tokens.T__566.rawValue)
		 	setState(7039)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__510.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__575.rawValue,EDIF300Parser.Tokens.T__576.rawValue,EDIF300Parser.Tokens.T__579.rawValue,EDIF300Parser.Tokens.T__580.rawValue,EDIF300Parser.Tokens.T__581.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 576)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(7037)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__510:
		 			setState(7031)
		 			try schematicMetric()

		 			break

		 		case .T__575:
		 			setState(7032)
		 			try setAngle()

		 			break

		 		case .T__576:
		 			setState(7033)
		 			try setCapacitance()

		 			break

		 		case .T__579:
		 			setState(7034)
		 			try setFrequency()

		 			break

		 		case .T__580:
		 			setState(7035)
		 			try setTime()

		 			break

		 		case .T__581:
		 			setState(7036)
		 			try setVoltage()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7041)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7042)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicViewContext: ParserRuleContext {
			open
			func viewNameDef() -> ViewNameDefContext? {
				return getRuleContext(ViewNameDefContext.self, 0)
			}
			open
			func schematicViewHeader() -> SchematicViewHeaderContext? {
				return getRuleContext(SchematicViewHeaderContext.self, 0)
			}
			open
			func logicalConnectivity() -> LogicalConnectivityContext? {
				return getRuleContext(LogicalConnectivityContext.self, 0)
			}
			open
			func schematicImplementation() -> SchematicImplementationContext? {
				return getRuleContext(SchematicImplementationContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicView
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicView(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicView(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicView(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicView(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicView() throws -> SchematicViewContext {
		var _localctx: SchematicViewContext = SchematicViewContext(_ctx, getState())
		try enterRule(_localctx, 1384, EDIF300Parser.RULE_schematicView)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7044)
		 	try match(EDIF300Parser.Tokens.T__567.rawValue)
		 	setState(7045)
		 	try viewNameDef()
		 	setState(7046)
		 	try schematicViewHeader()
		 	setState(7047)
		 	try logicalConnectivity()
		 	setState(7048)
		 	try schematicImplementation()
		 	setState(7053)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7051)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(7049)
		 			try comment()

		 			break

		 		case .T__642:
		 			setState(7050)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7055)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7056)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicViewHeaderContext: ParserRuleContext {
			open
			func schematicUnits() -> SchematicUnitsContext? {
				return getRuleContext(SchematicUnitsContext.self, 0)
			}
			open
			func derivedFrom() -> [DerivedFromContext] {
				return getRuleContexts(DerivedFromContext.self)
			}
			open
			func derivedFrom(_ i: Int) -> DerivedFromContext? {
				return getRuleContext(DerivedFromContext.self, i)
			}
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func previousVersion() -> [PreviousVersionContext] {
				return getRuleContexts(PreviousVersionContext.self)
			}
			open
			func previousVersion(_ i: Int) -> PreviousVersionContext? {
				return getRuleContext(PreviousVersionContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func status() -> [StatusContext] {
				return getRuleContexts(StatusContext.self)
			}
			open
			func status(_ i: Int) -> StatusContext? {
				return getRuleContext(StatusContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicViewHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicViewHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicViewHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicViewHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicViewHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicViewHeader() throws -> SchematicViewHeaderContext {
		var _localctx: SchematicViewHeaderContext = SchematicViewHeaderContext(_ctx, getState())
		try enterRule(_localctx, 1386, EDIF300Parser.RULE_schematicViewHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7058)
		 	try match(EDIF300Parser.Tokens.T__568.rawValue)
		 	setState(7059)
		 	try schematicUnits()
		 	setState(7068)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__116.rawValue || _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__439.rawValue || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__597.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7066)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__116:
		 			setState(7060)
		 			try derivedFrom()

		 			break

		 		case .T__132:
		 			setState(7061)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(7062)
		 			try nameInformation()

		 			break

		 		case .T__439:
		 			setState(7063)
		 			try previousVersion()

		 			break

		 		case .T__442:
		 			setState(7064)
		 			try property()

		 			break

		 		case .T__597:
		 			setState(7065)
		 			try status()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7070)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7071)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicWireAffinityContext: ParserRuleContext {
			open
			func narrowWire() -> NarrowWireContext? {
				return getRuleContext(NarrowWireContext.self, 0)
			}
			open
			func wideWire() -> WideWireContext? {
				return getRuleContext(WideWireContext.self, 0)
			}
			open
			func unrestricted() -> UnrestrictedContext? {
				return getRuleContext(UnrestrictedContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicWireAffinity
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicWireAffinity(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicWireAffinity(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicWireAffinity(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicWireAffinity(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicWireAffinity() throws -> SchematicWireAffinityContext {
		var _localctx: SchematicWireAffinityContext = SchematicWireAffinityContext(_ctx, getState())
		try enterRule(_localctx, 1388, EDIF300Parser.RULE_schematicWireAffinity)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7073)
		 	try match(EDIF300Parser.Tokens.T__569.rawValue)
		 	setState(7077)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__350:
		 		setState(7074)
		 		try narrowWire()

		 		break

		 	case .T__662:
		 		setState(7075)
		 		try wideWire()

		 		break

		 	case .T__636:
		 		setState(7076)
		 		try unrestricted()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(7079)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SchematicWireStyleContext: ParserRuleContext {
			open
			func narrowWire() -> NarrowWireContext? {
				return getRuleContext(NarrowWireContext.self, 0)
			}
			open
			func wideWire() -> WideWireContext? {
				return getRuleContext(WideWireContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_schematicWireStyle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSchematicWireStyle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSchematicWireStyle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSchematicWireStyle(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSchematicWireStyle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func schematicWireStyle() throws -> SchematicWireStyleContext {
		var _localctx: SchematicWireStyleContext = SchematicWireStyleContext(_ctx, getState())
		try enterRule(_localctx, 1390, EDIF300Parser.RULE_schematicWireStyle)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7081)
		 	try match(EDIF300Parser.Tokens.T__570.rawValue)
		 	setState(7084)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__350:
		 		setState(7082)
		 		try narrowWire()

		 		break

		 	case .T__662:
		 		setState(7083)
		 		try wideWire()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(7086)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SecondContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_second
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSecond(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSecond(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSecond(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSecond(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func second() throws -> SecondContext {
		var _localctx: SecondContext = SecondContext(_ctx, getState())
		try enterRule(_localctx, 1392, EDIF300Parser.RULE_second)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7088)
		 	try match(EDIF300Parser.Tokens.T__571.rawValue)
		 	setState(7089)
		 	try unitExponent()
		 	setState(7090)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SecondIntegerExpressionContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_secondIntegerExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSecondIntegerExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSecondIntegerExpression(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSecondIntegerExpression(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSecondIntegerExpression(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func secondIntegerExpression() throws -> SecondIntegerExpressionContext {
		var _localctx: SecondIntegerExpressionContext = SecondIntegerExpressionContext(_ctx, getState())
		try enterRule(_localctx, 1394, EDIF300Parser.RULE_secondIntegerExpression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7092)
		 	try integerExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SecondNumberContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_secondNumber
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSecondNumber(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSecondNumber(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSecondNumber(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSecondNumber(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func secondNumber() throws -> SecondNumberContext {
		var _localctx: SecondNumberContext = SecondNumberContext(_ctx, getState())
		try enterRule(_localctx, 1396, EDIF300Parser.RULE_secondNumber)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7094)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SecondStringExpressionContext: ParserRuleContext {
			open
			func stringExpression() -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_secondStringExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSecondStringExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSecondStringExpression(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSecondStringExpression(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSecondStringExpression(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func secondStringExpression() throws -> SecondStringExpressionContext {
		var _localctx: SecondStringExpressionContext = SecondStringExpressionContext(_ctx, getState())
		try enterRule(_localctx, 1398, EDIF300Parser.RULE_secondStringExpression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7096)
		 	try stringExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SectionContext: ParserRuleContext {
			open
			func sectionNameDef() -> SectionNameDefContext? {
				return getRuleContext(SectionNameDefContext.self, 0)
			}
			open
			func sectionTitle() -> SectionTitleContext? {
				return getRuleContext(SectionTitleContext.self, 0)
			}
			open
			func diagram() -> [DiagramContext] {
				return getRuleContexts(DiagramContext.self)
			}
			open
			func diagram(_ i: Int) -> DiagramContext? {
				return getRuleContext(DiagramContext.self, i)
			}
			open
			func section() -> [SectionContext] {
				return getRuleContexts(SectionContext.self)
			}
			open
			func section(_ i: Int) -> SectionContext? {
				return getRuleContext(SectionContext.self, i)
			}
			open
			func stringValue() -> [StringValueContext] {
				return getRuleContexts(StringValueContext.self)
			}
			open
			func stringValue(_ i: Int) -> StringValueContext? {
				return getRuleContext(StringValueContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_section
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSection(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSection(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSection(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func section() throws -> SectionContext {
		var _localctx: SectionContext = SectionContext(_ctx, getState())
		try enterRule(_localctx, 1400, EDIF300Parser.RULE_section)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7098)
		 	try match(EDIF300Parser.Tokens.T__572.rawValue)
		 	setState(7099)
		 	try sectionNameDef()
		 	setState(7100)
		 	try sectionTitle()
		 	setState(7106)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__126.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__572.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.STRING_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7104)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__126:
		 			setState(7101)
		 			try diagram()

		 			break

		 		case .T__572:
		 			setState(7102)
		 			try section()

		 			break

		 		case .STRING_LITERAL:
		 			setState(7103)
		 			try stringValue()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7108)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7109)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SectionNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_sectionNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSectionNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSectionNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSectionNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSectionNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sectionNameDef() throws -> SectionNameDefContext {
		var _localctx: SectionNameDefContext = SectionNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1402, EDIF300Parser.RULE_sectionNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7111)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SectionTitleContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_sectionTitle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSectionTitle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSectionTitle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSectionTitle(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSectionTitle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sectionTitle() throws -> SectionTitleContext {
		var _localctx: SectionTitleContext = SectionTitleContext(_ctx, getState())
		try enterRule(_localctx, 1404, EDIF300Parser.RULE_sectionTitle)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7113)
		 	try match(EDIF300Parser.Tokens.T__573.rawValue)
		 	setState(7114)
		 	try stringToken()
		 	setState(7115)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SequenceContext: ParserRuleContext {
			open
			func fromInteger() -> FromIntegerContext? {
				return getRuleContext(FromIntegerContext.self, 0)
			}
			open
			func toInteger() -> ToIntegerContext? {
				return getRuleContext(ToIntegerContext.self, 0)
			}
			open
			func step() -> StepContext? {
				return getRuleContext(StepContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_sequence
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSequence(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSequence(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSequence(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSequence(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func sequence() throws -> SequenceContext {
		var _localctx: SequenceContext = SequenceContext(_ctx, getState())
		try enterRule(_localctx, 1406, EDIF300Parser.RULE_sequence)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7117)
		 	try match(EDIF300Parser.Tokens.T__574.rawValue)
		 	setState(7118)
		 	try fromInteger()
		 	setState(7119)
		 	try toInteger()
		 	setState(7121)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__598.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7120)
		 		try step()

		 	}

		 	setState(7123)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetAngleContext: ParserRuleContext {
			open
			func unitRef() -> UnitRefContext? {
				return getRuleContext(UnitRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_setAngle
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSetAngle(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSetAngle(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSetAngle(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSetAngle(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setAngle() throws -> SetAngleContext {
		var _localctx: SetAngleContext = SetAngleContext(_ctx, getState())
		try enterRule(_localctx, 1408, EDIF300Parser.RULE_setAngle)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7125)
		 	try match(EDIF300Parser.Tokens.T__575.rawValue)
		 	setState(7126)
		 	try unitRef()
		 	setState(7127)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetCapacitanceContext: ParserRuleContext {
			open
			func unitRef() -> UnitRefContext? {
				return getRuleContext(UnitRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_setCapacitance
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSetCapacitance(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSetCapacitance(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSetCapacitance(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSetCapacitance(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setCapacitance() throws -> SetCapacitanceContext {
		var _localctx: SetCapacitanceContext = SetCapacitanceContext(_ctx, getState())
		try enterRule(_localctx, 1410, EDIF300Parser.RULE_setCapacitance)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7129)
		 	try match(EDIF300Parser.Tokens.T__576.rawValue)
		 	setState(7130)
		 	try unitRef()
		 	setState(7131)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetCurrentContext: ParserRuleContext {
			open
			func unitRef() -> UnitRefContext? {
				return getRuleContext(UnitRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_setCurrent
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSetCurrent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSetCurrent(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSetCurrent(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSetCurrent(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setCurrent() throws -> SetCurrentContext {
		var _localctx: SetCurrentContext = SetCurrentContext(_ctx, getState())
		try enterRule(_localctx, 1412, EDIF300Parser.RULE_setCurrent)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7133)
		 	try match(EDIF300Parser.Tokens.T__577.rawValue)
		 	setState(7134)
		 	try unitRef()
		 	setState(7135)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetDistanceContext: ParserRuleContext {
			open
			func unitRef() -> UnitRefContext? {
				return getRuleContext(UnitRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_setDistance
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSetDistance(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSetDistance(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSetDistance(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSetDistance(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setDistance() throws -> SetDistanceContext {
		var _localctx: SetDistanceContext = SetDistanceContext(_ctx, getState())
		try enterRule(_localctx, 1414, EDIF300Parser.RULE_setDistance)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7137)
		 	try match(EDIF300Parser.Tokens.T__578.rawValue)
		 	setState(7138)
		 	try unitRef()
		 	setState(7139)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetFrequencyContext: ParserRuleContext {
			open
			func unitRef() -> UnitRefContext? {
				return getRuleContext(UnitRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_setFrequency
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSetFrequency(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSetFrequency(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSetFrequency(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSetFrequency(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setFrequency() throws -> SetFrequencyContext {
		var _localctx: SetFrequencyContext = SetFrequencyContext(_ctx, getState())
		try enterRule(_localctx, 1416, EDIF300Parser.RULE_setFrequency)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7141)
		 	try match(EDIF300Parser.Tokens.T__579.rawValue)
		 	setState(7142)
		 	try unitRef()
		 	setState(7143)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetTimeContext: ParserRuleContext {
			open
			func unitRef() -> UnitRefContext? {
				return getRuleContext(UnitRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_setTime
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSetTime(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSetTime(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSetTime(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSetTime(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setTime() throws -> SetTimeContext {
		var _localctx: SetTimeContext = SetTimeContext(_ctx, getState())
		try enterRule(_localctx, 1418, EDIF300Parser.RULE_setTime)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7145)
		 	try match(EDIF300Parser.Tokens.T__580.rawValue)
		 	setState(7146)
		 	try unitRef()
		 	setState(7147)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetVoltageContext: ParserRuleContext {
			open
			func unitRef() -> UnitRefContext? {
				return getRuleContext(UnitRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_setVoltage
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSetVoltage(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSetVoltage(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSetVoltage(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSetVoltage(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func setVoltage() throws -> SetVoltageContext {
		var _localctx: SetVoltageContext = SetVoltageContext(_ctx, getState())
		try enterRule(_localctx, 1420, EDIF300Parser.RULE_setVoltage)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7149)
		 	try match(EDIF300Parser.Tokens.T__581.rawValue)
		 	setState(7150)
		 	try unitRef()
		 	setState(7151)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ShapeContext: ParserRuleContext {
			open
			func curve() -> CurveContext? {
				return getRuleContext(CurveContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_shape
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterShape(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitShape(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitShape(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitShape(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func shape() throws -> ShapeContext {
		var _localctx: ShapeContext = ShapeContext(_ctx, getState())
		try enterRule(_localctx, 1422, EDIF300Parser.RULE_shape)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7153)
		 	try match(EDIF300Parser.Tokens.T__582.rawValue)
		 	setState(7154)
		 	try curve()
		 	setState(7155)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SiemensContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_siemens
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSiemens(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSiemens(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSiemens(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSiemens(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func siemens() throws -> SiemensContext {
		var _localctx: SiemensContext = SiemensContext(_ctx, getState())
		try enterRule(_localctx, 1424, EDIF300Parser.RULE_siemens)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7157)
		 	try match(EDIF300Parser.Tokens.T__583.rawValue)
		 	setState(7158)
		 	try unitExponent()
		 	setState(7159)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalContext: ParserRuleContext {
			open
			func signalNameDef() -> SignalNameDefContext? {
				return getRuleContext(SignalNameDefContext.self, 0)
			}
			open
			func signalJoined() -> SignalJoinedContext? {
				return getRuleContext(SignalJoinedContext.self, 0)
			}
			open
			func connectivityTagGenerator() -> [ConnectivityTagGeneratorContext] {
				return getRuleContexts(ConnectivityTagGeneratorContext.self)
			}
			open
			func connectivityTagGenerator(_ i: Int) -> ConnectivityTagGeneratorContext? {
				return getRuleContext(ConnectivityTagGeneratorContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func signalWidth() -> [SignalWidthContext] {
				return getRuleContexts(SignalWidthContext.self)
			}
			open
			func signalWidth(_ i: Int) -> SignalWidthContext? {
				return getRuleContext(SignalWidthContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signal
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignal(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignal(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignal(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignal(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signal() throws -> SignalContext {
		var _localctx: SignalContext = SignalContext(_ctx, getState())
		try enterRule(_localctx, 1426, EDIF300Parser.RULE_signal)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7161)
		 	try match(EDIF300Parser.Tokens.T__584.rawValue)
		 	setState(7162)
		 	try signalNameDef()
		 	setState(7163)
		 	try signalJoined()
		 	setState(7170)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__85.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__596.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7168)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__85:
		 			setState(7164)
		 			try connectivityTagGenerator()

		 			break

		 		case .T__346:
		 			setState(7165)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(7166)
		 			try property()

		 			break

		 		case .T__596:
		 			setState(7167)
		 			try signalWidth()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7172)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7173)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalAnnotateContext: ParserRuleContext {
			open
			func extendSignalDef() -> ExtendSignalDefContext? {
				return getRuleContext(ExtendSignalDefContext.self, 0)
			}
			open
			func extendSignalMemberDef() -> ExtendSignalMemberDefContext? {
				return getRuleContext(ExtendSignalMemberDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalAnnotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalAnnotate() throws -> SignalAnnotateContext {
		var _localctx: SignalAnnotateContext = SignalAnnotateContext(_ctx, getState())
		try enterRule(_localctx, 1428, EDIF300Parser.RULE_signalAnnotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7175)
		 	try match(EDIF300Parser.Tokens.T__585.rawValue)
		 	setState(7178)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .IDENTIFIER:
		 		setState(7176)
		 		try extendSignalDef()

		 		break

		 	case .T__593:
		 		setState(7177)
		 		try extendSignalMemberDef()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(7185)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7183)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(7180)
		 			try comment()

		 			break

		 		case .T__442:
		 			setState(7181)
		 			try property()

		 			break

		 		case .T__448:
		 			setState(7182)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7187)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7188)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalGroupContext: ParserRuleContext {
			open
			func signalGroupNameDef() -> SignalGroupNameDefContext? {
				return getRuleContext(SignalGroupNameDefContext.self, 0)
			}
			open
			func signalList() -> SignalListContext? {
				return getRuleContext(SignalListContext.self, 0)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalGroup
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalGroup(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalGroup(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalGroup(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalGroup(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalGroup() throws -> SignalGroupContext {
		var _localctx: SignalGroupContext = SignalGroupContext(_ctx, getState())
		try enterRule(_localctx, 1430, EDIF300Parser.RULE_signalGroup)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7190)
		 	try match(EDIF300Parser.Tokens.T__586.rawValue)
		 	setState(7191)
		 	try signalGroupNameDef()
		 	setState(7192)
		 	try signalList()
		 	setState(7197)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7195)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__442:
		 			setState(7193)
		 			try property()

		 			break

		 		case .T__346:
		 			setState(7194)
		 			try nameInformation()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7199)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7200)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalGroupAnnotateContext: ParserRuleContext {
			open
			func extendSignalGroupDef() -> ExtendSignalGroupDefContext? {
				return getRuleContext(ExtendSignalGroupDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalGroupAnnotate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalGroupAnnotate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalGroupAnnotate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalGroupAnnotate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalGroupAnnotate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalGroupAnnotate() throws -> SignalGroupAnnotateContext {
		var _localctx: SignalGroupAnnotateContext = SignalGroupAnnotateContext(_ctx, getState())
		try enterRule(_localctx, 1432, EDIF300Parser.RULE_signalGroupAnnotate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7202)
		 	try match(EDIF300Parser.Tokens.T__587.rawValue)
		 	setState(7203)
		 	try extendSignalGroupDef()
		 	setState(7209)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7207)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(7204)
		 			try comment()

		 			break

		 		case .T__442:
		 			setState(7205)
		 			try property()

		 			break

		 		case .T__448:
		 			setState(7206)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7211)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7212)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalGroupNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalGroupNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalGroupNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalGroupNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalGroupNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalGroupNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalGroupNameCaseSensitive() throws -> SignalGroupNameCaseSensitiveContext {
		var _localctx: SignalGroupNameCaseSensitiveContext = SignalGroupNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 1434, EDIF300Parser.RULE_signalGroupNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7214)
		 	try match(EDIF300Parser.Tokens.T__588.rawValue)
		 	setState(7215)
		 	try booleanToken()
		 	setState(7216)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalGroupNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalGroupNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalGroupNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalGroupNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalGroupNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalGroupNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalGroupNameDef() throws -> SignalGroupNameDefContext {
		var _localctx: SignalGroupNameDefContext = SignalGroupNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1436, EDIF300Parser.RULE_signalGroupNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7218)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalGroupNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalGroupNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalGroupNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalGroupNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalGroupNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalGroupNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalGroupNameRef() throws -> SignalGroupNameRefContext {
		var _localctx: SignalGroupNameRefContext = SignalGroupNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1438, EDIF300Parser.RULE_signalGroupNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7220)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalGroupRefContext: ParserRuleContext {
			open
			func signalGroupNameRef() -> SignalGroupNameRefContext? {
				return getRuleContext(SignalGroupNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalGroupRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalGroupRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalGroupRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalGroupRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalGroupRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalGroupRef() throws -> SignalGroupRefContext {
		var _localctx: SignalGroupRefContext = SignalGroupRefContext(_ctx, getState())
		try enterRule(_localctx, 1440, EDIF300Parser.RULE_signalGroupRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7222)
		 	try match(EDIF300Parser.Tokens.T__589.rawValue)
		 	setState(7223)
		 	try signalGroupNameRef()
		 	setState(7224)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalIndexValueContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalIndexValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalIndexValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalIndexValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalIndexValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalIndexValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalIndexValue() throws -> SignalIndexValueContext {
		var _localctx: SignalIndexValueContext = SignalIndexValueContext(_ctx, getState())
		try enterRule(_localctx, 1442, EDIF300Parser.RULE_signalIndexValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7226)
		 	try match(EDIF300Parser.Tokens.T__590.rawValue)
		 	setState(7227)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalJoinedContext: ParserRuleContext {
			open
			func globalPortRef() -> [GlobalPortRefContext] {
				return getRuleContexts(GlobalPortRefContext.self)
			}
			open
			func globalPortRef(_ i: Int) -> GlobalPortRefContext? {
				return getRuleContext(GlobalPortRefContext.self, i)
			}
			open
			func portInstanceRef() -> [PortInstanceRefContext] {
				return getRuleContexts(PortInstanceRefContext.self)
			}
			open
			func portInstanceRef(_ i: Int) -> PortInstanceRefContext? {
				return getRuleContext(PortInstanceRefContext.self, i)
			}
			open
			func portMemberRef() -> [PortMemberRefContext] {
				return getRuleContexts(PortMemberRefContext.self)
			}
			open
			func portMemberRef(_ i: Int) -> PortMemberRefContext? {
				return getRuleContext(PortMemberRefContext.self, i)
			}
			open
			func portRef() -> [PortRefContext] {
				return getRuleContexts(PortRefContext.self)
			}
			open
			func portRef(_ i: Int) -> PortRefContext? {
				return getRuleContext(PortRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalJoined
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalJoined(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalJoined(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalJoined(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalJoined(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalJoined() throws -> SignalJoinedContext {
		var _localctx: SignalJoinedContext = SignalJoinedContext(_ctx, getState())
		try enterRule(_localctx, 1444, EDIF300Parser.RULE_signalJoined)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7229)
		 	try match(EDIF300Parser.Tokens.T__591.rawValue)
		 	setState(7236)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__203.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__422.rawValue,EDIF300Parser.Tokens.T__428.rawValue,EDIF300Parser.Tokens.T__436.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 423)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(7234)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__203:
		 			setState(7230)
		 			try globalPortRef()

		 			break

		 		case .T__422:
		 			setState(7231)
		 			try portInstanceRef()

		 			break

		 		case .T__428:
		 			setState(7232)
		 			try portMemberRef()

		 			break

		 		case .T__436:
		 			setState(7233)
		 			try portRef()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7238)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7239)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalListContext: ParserRuleContext {
			open
			func signalGroupRef() -> [SignalGroupRefContext] {
				return getRuleContexts(SignalGroupRefContext.self)
			}
			open
			func signalGroupRef(_ i: Int) -> SignalGroupRefContext? {
				return getRuleContext(SignalGroupRefContext.self, i)
			}
			open
			func signalRef() -> [SignalRefContext] {
				return getRuleContexts(SignalRefContext.self)
			}
			open
			func signalRef(_ i: Int) -> SignalRefContext? {
				return getRuleContext(SignalRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalList
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalList(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalList(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalList(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalList(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalList() throws -> SignalListContext {
		var _localctx: SignalListContext = SignalListContext(_ctx, getState())
		try enterRule(_localctx, 1446, EDIF300Parser.RULE_signalList)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7241)
		 	try match(EDIF300Parser.Tokens.T__592.rawValue)
		 	setState(7246)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__589.rawValue || _la == EDIF300Parser.Tokens.T__595.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7244)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__589:
		 			setState(7242)
		 			try signalGroupRef()

		 			break

		 		case .T__595:
		 			setState(7243)
		 			try signalRef()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7248)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7249)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalMemberRefContext: ParserRuleContext {
			open
			func signalNameRef() -> SignalNameRefContext? {
				return getRuleContext(SignalNameRefContext.self, 0)
			}
			open
			func indexValue() -> IndexValueContext? {
				return getRuleContext(IndexValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalMemberRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalMemberRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalMemberRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalMemberRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalMemberRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalMemberRef() throws -> SignalMemberRefContext {
		var _localctx: SignalMemberRefContext = SignalMemberRefContext(_ctx, getState())
		try enterRule(_localctx, 1448, EDIF300Parser.RULE_signalMemberRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7251)
		 	try match(EDIF300Parser.Tokens.T__593.rawValue)
		 	setState(7252)
		 	try signalNameRef()
		 	setState(7253)
		 	try indexValue()
		 	setState(7254)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalNameCaseSensitive() throws -> SignalNameCaseSensitiveContext {
		var _localctx: SignalNameCaseSensitiveContext = SignalNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 1450, EDIF300Parser.RULE_signalNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7256)
		 	try match(EDIF300Parser.Tokens.T__594.rawValue)
		 	setState(7257)
		 	try booleanToken()
		 	setState(7258)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalNameDef() throws -> SignalNameDefContext {
		var _localctx: SignalNameDefContext = SignalNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1452, EDIF300Parser.RULE_signalNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7260)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalNameRef() throws -> SignalNameRefContext {
		var _localctx: SignalNameRefContext = SignalNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1454, EDIF300Parser.RULE_signalNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7262)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalRefContext: ParserRuleContext {
			open
			func signalNameRef() -> SignalNameRefContext? {
				return getRuleContext(SignalNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalRef() throws -> SignalRefContext {
		var _localctx: SignalRefContext = SignalRefContext(_ctx, getState())
		try enterRule(_localctx, 1456, EDIF300Parser.RULE_signalRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7264)
		 	try match(EDIF300Parser.Tokens.T__595.rawValue)
		 	setState(7265)
		 	try signalNameRef()
		 	setState(7266)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalWidthContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_signalWidth
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSignalWidth(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSignalWidth(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSignalWidth(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSignalWidth(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func signalWidth() throws -> SignalWidthContext {
		var _localctx: SignalWidthContext = SignalWidthContext(_ctx, getState())
		try enterRule(_localctx, 1458, EDIF300Parser.RULE_signalWidth)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7268)
		 	try match(EDIF300Parser.Tokens.T__596.rawValue)
		 	setState(7269)
		 	try integerExpression()
		 	setState(7270)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SimpleNameContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_simpleName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSimpleName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSimpleName(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSimpleName(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSimpleName(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func simpleName() throws -> SimpleNameContext {
		var _localctx: SimpleNameContext = SimpleNameContext(_ctx, getState())
		try enterRule(_localctx, 1460, EDIF300Parser.RULE_simpleName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7272)
		 	try stringToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StartPointContext: ParserRuleContext {
			open
			func pointValue() -> PointValueContext? {
				return getRuleContext(PointValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_startPoint
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStartPoint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStartPoint(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStartPoint(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStartPoint(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func startPoint() throws -> StartPointContext {
		var _localctx: StartPointContext = StartPointContext(_ctx, getState())
		try enterRule(_localctx, 1462, EDIF300Parser.RULE_startPoint)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7274)
		 	try pointValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StatusContext: ParserRuleContext {
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func copyright() -> [CopyrightContext] {
				return getRuleContexts(CopyrightContext.self)
			}
			open
			func copyright(_ i: Int) -> CopyrightContext? {
				return getRuleContext(CopyrightContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
			open
			func written() -> [WrittenContext] {
				return getRuleContexts(WrittenContext.self)
			}
			open
			func written(_ i: Int) -> WrittenContext? {
				return getRuleContext(WrittenContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_status
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStatus(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStatus(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStatus(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStatus(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func status() throws -> StatusContext {
		var _localctx: StatusContext = StatusContext(_ctx, getState())
		try enterRule(_localctx, 1464, EDIF300Parser.RULE_status)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7276)
		 	try match(EDIF300Parser.Tokens.T__597.rawValue)
		 	setState(7283)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue || _la == EDIF300Parser.Tokens.T__93.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue || _la == EDIF300Parser.Tokens.T__663.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7281)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(7277)
		 			try comment()

		 			break

		 		case .T__93:
		 			setState(7278)
		 			try copyright()

		 			break

		 		case .T__642:
		 			setState(7279)
		 			try userData()

		 			break

		 		case .T__663:
		 			setState(7280)
		 			try written()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7285)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7286)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StepContext: ParserRuleContext {
			open
			func integerValue() -> IntegerValueContext? {
				return getRuleContext(IntegerValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_step
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStep(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStep(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStep(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStep(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func step() throws -> StepContext {
		var _localctx: StepContext = StepContext(_ctx, getState())
		try enterRule(_localctx, 1466, EDIF300Parser.RULE_step)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7288)
		 	try match(EDIF300Parser.Tokens.T__598.rawValue)
		 	setState(7289)
		 	try integerValue()
		 	setState(7290)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringContext: ParserRuleContext {
			open
			func stringExpression() -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_string
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterString(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitString(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitString(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitString(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func string() throws -> StringContext {
		var _localctx: StringContext = StringContext(_ctx, getState())
		try enterRule(_localctx, 1468, EDIF300Parser.RULE_string)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7292)
		 	try match(EDIF300Parser.Tokens.T__599.rawValue)
		 	setState(7293)
		 	try stringExpression()
		 	setState(7294)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringConcatenateContext: ParserRuleContext {
			open
			func stringExpression() -> [StringExpressionContext] {
				return getRuleContexts(StringExpressionContext.self)
			}
			open
			func stringExpression(_ i: Int) -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringConcatenate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringConcatenate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringConcatenate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringConcatenate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringConcatenate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringConcatenate() throws -> StringConcatenateContext {
		var _localctx: StringConcatenateContext = StringConcatenateContext(_ctx, getState())
		try enterRule(_localctx, 1470, EDIF300Parser.RULE_stringConcatenate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7296)
		 	try match(EDIF300Parser.Tokens.T__600.rawValue)
		 	setState(7300)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__111.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__600.rawValue,EDIF300Parser.Tokens.T__602.rawValue,EDIF300Parser.Tokens.T__607.rawValue,EDIF300Parser.Tokens.T__608.rawValue,EDIF300Parser.Tokens.T__609.rawValue,EDIF300Parser.Tokens.T__611.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 601)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.STRING_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7297)
		 		try stringExpression()


		 		setState(7302)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7303)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringConstantContext: ParserRuleContext {
			open
			func constantNameDef() -> ConstantNameDefContext? {
				return getRuleContext(ConstantNameDefContext.self, 0)
			}
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringConstant
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringConstant(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringConstant(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringConstant(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringConstant(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringConstant() throws -> StringConstantContext {
		var _localctx: StringConstantContext = StringConstantContext(_ctx, getState())
		try enterRule(_localctx, 1472, EDIF300Parser.RULE_stringConstant)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7305)
		 	try match(EDIF300Parser.Tokens.T__601.rawValue)
		 	setState(7306)
		 	try constantNameDef()
		 	setState(7307)
		 	try stringToken()
		 	setState(7308)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringConstantRefContext: ParserRuleContext {
			open
			func constantNameRef() -> ConstantNameRefContext? {
				return getRuleContext(ConstantNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringConstantRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringConstantRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringConstantRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringConstantRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringConstantRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringConstantRef() throws -> StringConstantRefContext {
		var _localctx: StringConstantRefContext = StringConstantRefContext(_ctx, getState())
		try enterRule(_localctx, 1474, EDIF300Parser.RULE_stringConstantRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7310)
		 	try match(EDIF300Parser.Tokens.T__602.rawValue)
		 	setState(7311)
		 	try constantNameRef()
		 	setState(7312)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringEqualContext: ParserRuleContext {
			open
			func firstStringExpression() -> FirstStringExpressionContext? {
				return getRuleContext(FirstStringExpressionContext.self, 0)
			}
			open
			func secondStringExpression() -> SecondStringExpressionContext? {
				return getRuleContext(SecondStringExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringEqual
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringEqual(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringEqual(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringEqual(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringEqual(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringEqual() throws -> StringEqualContext {
		var _localctx: StringEqualContext = StringEqualContext(_ctx, getState())
		try enterRule(_localctx, 1476, EDIF300Parser.RULE_stringEqual)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7314)
		 	try match(EDIF300Parser.Tokens.T__603.rawValue)
		 	setState(7315)
		 	try firstStringExpression()
		 	setState(7316)
		 	try secondStringExpression()
		 	setState(7317)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringExpressionContext: ParserRuleContext {
			open
			func stringParameterRef() -> StringParameterRefContext? {
				return getRuleContext(StringParameterRefContext.self, 0)
			}
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
			open
			func stringConstantRef() -> StringConstantRefContext? {
				return getRuleContext(StringConstantRefContext.self, 0)
			}
			open
			func stringConcatenate() -> StringConcatenateContext? {
				return getRuleContext(StringConcatenateContext.self, 0)
			}
			open
			func substring() -> SubstringContext? {
				return getRuleContext(SubstringContext.self, 0)
			}
			open
			func decimalToString() -> DecimalToStringContext? {
				return getRuleContext(DecimalToStringContext.self, 0)
			}
			open
			func stringPrefix() -> StringPrefixContext? {
				return getRuleContext(StringPrefixContext.self, 0)
			}
			open
			func stringSuffix() -> StringSuffixContext? {
				return getRuleContext(StringSuffixContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringExpression(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringExpression(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringExpression(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringExpression() throws -> StringExpressionContext {
		var _localctx: StringExpressionContext = StringExpressionContext(_ctx, getState())
		try enterRule(_localctx, 1478, EDIF300Parser.RULE_stringExpression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7327)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__607:
		 		setState(7319)
		 		try stringParameterRef()

		 		break

		 	case .STRING_LITERAL:
		 		setState(7320)
		 		try stringToken()

		 		break

		 	case .T__602:
		 		setState(7321)
		 		try stringConstantRef()

		 		break

		 	case .T__600:
		 		setState(7322)
		 		try stringConcatenate()

		 		break

		 	case .T__611:
		 		setState(7323)
		 		try substring()

		 		break

		 	case .T__111:
		 		setState(7324)
		 		try decimalToString()

		 		break

		 	case .T__608:
		 		setState(7325)
		 		try stringPrefix()

		 		break

		 	case .T__609:
		 		setState(7326)
		 		try stringSuffix()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringLengthContext: ParserRuleContext {
			open
			func stringExpression() -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringLength
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringLength(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringLength(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringLength(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringLength(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringLength() throws -> StringLengthContext {
		var _localctx: StringLengthContext = StringLengthContext(_ctx, getState())
		try enterRule(_localctx, 1480, EDIF300Parser.RULE_stringLength)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7329)
		 	try match(EDIF300Parser.Tokens.T__604.rawValue)
		 	setState(7330)
		 	try stringExpression()
		 	setState(7331)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringParameterContext: ParserRuleContext {
			open
			func parameterNameDef() -> ParameterNameDefContext? {
				return getRuleContext(ParameterNameDefContext.self, 0)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func string() -> [StringContext] {
				return getRuleContexts(StringContext.self)
			}
			open
			func string(_ i: Int) -> StringContext? {
				return getRuleContext(StringContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringParameter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringParameter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringParameter(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringParameter(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringParameter(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringParameter() throws -> StringParameterContext {
		var _localctx: StringParameterContext = StringParameterContext(_ctx, getState())
		try enterRule(_localctx, 1482, EDIF300Parser.RULE_stringParameter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7333)
		 	try match(EDIF300Parser.Tokens.T__605.rawValue)
		 	setState(7334)
		 	try parameterNameDef()
		 	setState(7339)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__599.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7337)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__346:
		 			setState(7335)
		 			try nameInformation()

		 			break

		 		case .T__599:
		 			setState(7336)
		 			try string()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7341)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7342)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringParameterAssignContext: ParserRuleContext {
			open
			func parameterNameRef() -> ParameterNameRefContext? {
				return getRuleContext(ParameterNameRefContext.self, 0)
			}
			open
			func stringExpression() -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringParameterAssign
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringParameterAssign(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringParameterAssign(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringParameterAssign(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringParameterAssign(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringParameterAssign() throws -> StringParameterAssignContext {
		var _localctx: StringParameterAssignContext = StringParameterAssignContext(_ctx, getState())
		try enterRule(_localctx, 1484, EDIF300Parser.RULE_stringParameterAssign)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7344)
		 	try match(EDIF300Parser.Tokens.T__606.rawValue)
		 	setState(7345)
		 	try parameterNameRef()
		 	setState(7346)
		 	try stringExpression()
		 	setState(7347)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringParameterRefContext: ParserRuleContext {
			open
			func parameterNameRef() -> ParameterNameRefContext? {
				return getRuleContext(ParameterNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringParameterRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringParameterRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringParameterRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringParameterRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringParameterRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringParameterRef() throws -> StringParameterRefContext {
		var _localctx: StringParameterRefContext = StringParameterRefContext(_ctx, getState())
		try enterRule(_localctx, 1486, EDIF300Parser.RULE_stringParameterRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7349)
		 	try match(EDIF300Parser.Tokens.T__607.rawValue)
		 	setState(7350)
		 	try parameterNameRef()
		 	setState(7351)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringPrefixContext: ParserRuleContext {
			open
			func stringExpression() -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, 0)
			}
			open
			func substringLength() -> SubstringLengthContext? {
				return getRuleContext(SubstringLengthContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringPrefix
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringPrefix(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringPrefix(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringPrefix(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringPrefix(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringPrefix() throws -> StringPrefixContext {
		var _localctx: StringPrefixContext = StringPrefixContext(_ctx, getState())
		try enterRule(_localctx, 1488, EDIF300Parser.RULE_stringPrefix)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7353)
		 	try match(EDIF300Parser.Tokens.T__608.rawValue)
		 	setState(7354)
		 	try stringExpression()
		 	setState(7355)
		 	try substringLength()
		 	setState(7356)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringSuffixContext: ParserRuleContext {
			open
			func stringExpression() -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, 0)
			}
			open
			func substringOffset() -> SubstringOffsetContext? {
				return getRuleContext(SubstringOffsetContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringSuffix
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringSuffix(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringSuffix(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringSuffix(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringSuffix(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringSuffix() throws -> StringSuffixContext {
		var _localctx: StringSuffixContext = StringSuffixContext(_ctx, getState())
		try enterRule(_localctx, 1490, EDIF300Parser.RULE_stringSuffix)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7358)
		 	try match(EDIF300Parser.Tokens.T__609.rawValue)
		 	setState(7359)
		 	try stringExpression()
		 	setState(7360)
		 	try substringOffset()
		 	setState(7361)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringValueContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringValue() throws -> StringValueContext {
		var _localctx: StringValueContext = StringValueContext(_ctx, getState())
		try enterRule(_localctx, 1492, EDIF300Parser.RULE_stringValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7363)
		 	try stringToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StrongContext: ParserRuleContext {
			open
			func logicNameRef() -> LogicNameRefContext? {
				return getRuleContext(LogicNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_strong
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStrong(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStrong(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStrong(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStrong(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func strong() throws -> StrongContext {
		var _localctx: StrongContext = StrongContext(_ctx, getState())
		try enterRule(_localctx, 1494, EDIF300Parser.RULE_strong)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7365)
		 	try match(EDIF300Parser.Tokens.T__610.rawValue)
		 	setState(7366)
		 	try logicNameRef()
		 	setState(7367)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubIssueContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_subIssue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSubIssue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSubIssue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSubIssue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSubIssue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subIssue() throws -> SubIssueContext {
		var _localctx: SubIssueContext = SubIssueContext(_ctx, getState())
		try enterRule(_localctx, 1496, EDIF300Parser.RULE_subIssue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7369)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubstringContext: ParserRuleContext {
			open
			func stringExpression() -> StringExpressionContext? {
				return getRuleContext(StringExpressionContext.self, 0)
			}
			open
			func substringLength() -> SubstringLengthContext? {
				return getRuleContext(SubstringLengthContext.self, 0)
			}
			open
			func substringOffset() -> SubstringOffsetContext? {
				return getRuleContext(SubstringOffsetContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_substring
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSubstring(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSubstring(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSubstring(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSubstring(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func substring() throws -> SubstringContext {
		var _localctx: SubstringContext = SubstringContext(_ctx, getState())
		try enterRule(_localctx, 1498, EDIF300Parser.RULE_substring)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7371)
		 	try match(EDIF300Parser.Tokens.T__611.rawValue)
		 	setState(7372)
		 	try stringExpression()
		 	setState(7373)
		 	try substringLength()
		 	setState(7374)
		 	try substringOffset()
		 	setState(7375)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubstringLengthContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_substringLength
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSubstringLength(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSubstringLength(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSubstringLength(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSubstringLength(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func substringLength() throws -> SubstringLengthContext {
		var _localctx: SubstringLengthContext = SubstringLengthContext(_ctx, getState())
		try enterRule(_localctx, 1500, EDIF300Parser.RULE_substringLength)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7377)
		 	try integerExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubstringOffsetContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_substringOffset
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSubstringOffset(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSubstringOffset(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSubstringOffset(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSubstringOffset(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func substringOffset() throws -> SubstringOffsetContext {
		var _localctx: SubstringOffsetContext = SubstringOffsetContext(_ctx, getState())
		try enterRule(_localctx, 1502, EDIF300Parser.RULE_substringOffset)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7379)
		 	try integerExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubtrahendContext: ParserRuleContext {
			open
			func integerExpression() -> IntegerExpressionContext? {
				return getRuleContext(IntegerExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_subtrahend
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSubtrahend(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSubtrahend(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSubtrahend(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSubtrahend(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func subtrahend() throws -> SubtrahendContext {
		var _localctx: SubtrahendContext = SubtrahendContext(_ctx, getState())
		try enterRule(_localctx, 1504, EDIF300Parser.RULE_subtrahend)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7381)
		 	try integerExpression()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolicLayoutUnitsContext: ParserRuleContext {
			open
			func setAngle() -> [SetAngleContext] {
				return getRuleContexts(SetAngleContext.self)
			}
			open
			func setAngle(_ i: Int) -> SetAngleContext? {
				return getRuleContext(SetAngleContext.self, i)
			}
			open
			func setCapacitance() -> [SetCapacitanceContext] {
				return getRuleContexts(SetCapacitanceContext.self)
			}
			open
			func setCapacitance(_ i: Int) -> SetCapacitanceContext? {
				return getRuleContext(SetCapacitanceContext.self, i)
			}
			open
			func setDistance() -> [SetDistanceContext] {
				return getRuleContexts(SetDistanceContext.self)
			}
			open
			func setDistance(_ i: Int) -> SetDistanceContext? {
				return getRuleContext(SetDistanceContext.self, i)
			}
			open
			func setTime() -> [SetTimeContext] {
				return getRuleContexts(SetTimeContext.self)
			}
			open
			func setTime(_ i: Int) -> SetTimeContext? {
				return getRuleContext(SetTimeContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_symbolicLayoutUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSymbolicLayoutUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSymbolicLayoutUnits(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSymbolicLayoutUnits(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSymbolicLayoutUnits(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolicLayoutUnits() throws -> SymbolicLayoutUnitsContext {
		var _localctx: SymbolicLayoutUnitsContext = SymbolicLayoutUnitsContext(_ctx, getState())
		try enterRule(_localctx, 1506, EDIF300Parser.RULE_symbolicLayoutUnits)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7383)
		 	try match(EDIF300Parser.Tokens.T__612.rawValue)
		 	setState(7390)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__575.rawValue,EDIF300Parser.Tokens.T__576.rawValue,EDIF300Parser.Tokens.T__578.rawValue,EDIF300Parser.Tokens.T__580.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 576)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(7388)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__575:
		 			setState(7384)
		 			try setAngle()

		 			break

		 		case .T__576:
		 			setState(7385)
		 			try setCapacitance()

		 			break

		 		case .T__578:
		 			setState(7386)
		 			try setDistance()

		 			break

		 		case .T__580:
		 			setState(7387)
		 			try setTime()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7392)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7393)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolicLayoutViewContext: ParserRuleContext {
			open
			func viewNameDef() -> ViewNameDefContext? {
				return getRuleContext(ViewNameDefContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
			open
			func nameInformation() -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_symbolicLayoutView
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSymbolicLayoutView(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSymbolicLayoutView(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSymbolicLayoutView(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSymbolicLayoutView(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolicLayoutView() throws -> SymbolicLayoutViewContext {
		var _localctx: SymbolicLayoutViewContext = SymbolicLayoutViewContext(_ctx, getState())
		try enterRule(_localctx, 1508, EDIF300Parser.RULE_symbolicLayoutView)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7395)
		 	try match(EDIF300Parser.Tokens.T__613.rawValue)
		 	setState(7396)
		 	try viewNameDef()
		 	setState(7401)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,605,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(7399)
		 			try _errHandler.sync(self)
		 			switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .T__61:
		 				setState(7397)
		 				try comment()

		 				break

		 			case .T__642:
		 				setState(7398)
		 				try userData()

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 	 
		 		}
		 		setState(7403)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,605,_ctx)
		 	}
		 	setState(7405)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__346.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7404)
		 		try nameInformation()

		 	}

		 	setState(7411)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7409)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(7407)
		 			try comment()

		 			break

		 		case .T__642:
		 			setState(7408)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7413)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7414)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolPortImplementationNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_symbolPortImplementationNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSymbolPortImplementationNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSymbolPortImplementationNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSymbolPortImplementationNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSymbolPortImplementationNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolPortImplementationNameDef() throws -> SymbolPortImplementationNameDefContext {
		var _localctx: SymbolPortImplementationNameDefContext = SymbolPortImplementationNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1510, EDIF300Parser.RULE_symbolPortImplementationNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7416)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SymbolPortImplementationNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_symbolPortImplementationNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterSymbolPortImplementationNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitSymbolPortImplementationNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitSymbolPortImplementationNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitSymbolPortImplementationNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func symbolPortImplementationNameRef() throws -> SymbolPortImplementationNameRefContext {
		var _localctx: SymbolPortImplementationNameRefContext = SymbolPortImplementationNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1512, EDIF300Parser.RULE_symbolPortImplementationNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7418)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TechnologyContext: ParserRuleContext {
			open
			func physicalScaling() -> PhysicalScalingContext? {
				return getRuleContext(PhysicalScalingContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func figureGroup() -> [FigureGroupContext] {
				return getRuleContexts(FigureGroupContext.self)
			}
			open
			func figureGroup(_ i: Int) -> FigureGroupContext? {
				return getRuleContext(FigureGroupContext.self, i)
			}
			open
			func logicDefinitions() -> [LogicDefinitionsContext] {
				return getRuleContexts(LogicDefinitionsContext.self)
			}
			open
			func logicDefinitions(_ i: Int) -> LogicDefinitionsContext? {
				return getRuleContext(LogicDefinitionsContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_technology
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTechnology(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTechnology(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTechnology(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTechnology(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func technology() throws -> TechnologyContext {
		var _localctx: TechnologyContext = TechnologyContext(_ctx, getState())
		try enterRule(_localctx, 1514, EDIF300Parser.RULE_technology)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7420)
		 	try match(EDIF300Parser.Tokens.T__614.rawValue)
		 	setState(7421)
		 	try physicalScaling()
		 	setState(7428)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__160.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__319.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7426)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(7422)
		 			try comment()

		 			break

		 		case .T__160:
		 			setState(7423)
		 			try figureGroup()

		 			break

		 		case .T__319:
		 			setState(7424)
		 			try logicDefinitions()

		 			break

		 		case .T__642:
		 			setState(7425)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7430)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7431)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TextHeightContext: ParserRuleContext {
			open
			func lengthValue() -> LengthValueContext? {
				return getRuleContext(LengthValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_textHeight
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTextHeight(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTextHeight(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTextHeight(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTextHeight(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func textHeight() throws -> TextHeightContext {
		var _localctx: TextHeightContext = TextHeightContext(_ctx, getState())
		try enterRule(_localctx, 1516, EDIF300Parser.RULE_textHeight)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7433)
		 	try match(EDIF300Parser.Tokens.T__615.rawValue)
		 	setState(7434)
		 	try lengthValue()
		 	setState(7435)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ThroughPointContext: ParserRuleContext {
			open
			func numberPoint() -> NumberPointContext? {
				return getRuleContext(NumberPointContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_throughPoint
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterThroughPoint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitThroughPoint(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitThroughPoint(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitThroughPoint(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func throughPoint() throws -> ThroughPointContext {
		var _localctx: ThroughPointContext = ThroughPointContext(_ctx, getState())
		try enterRule(_localctx, 1518, EDIF300Parser.RULE_throughPoint)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7437)
		 	try numberPoint()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TimeContext: ParserRuleContext {
			open
			func hourNumber() -> HourNumberContext? {
				return getRuleContext(HourNumberContext.self, 0)
			}
			open
			func minuteNumber() -> MinuteNumberContext? {
				return getRuleContext(MinuteNumberContext.self, 0)
			}
			open
			func secondNumber() -> SecondNumberContext? {
				return getRuleContext(SecondNumberContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_time
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTime(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTime(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTime(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTime(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func time() throws -> TimeContext {
		var _localctx: TimeContext = TimeContext(_ctx, getState())
		try enterRule(_localctx, 1520, EDIF300Parser.RULE_time)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7439)
		 	try match(EDIF300Parser.Tokens.T__616.rawValue)
		 	setState(7440)
		 	try hourNumber()
		 	setState(7441)
		 	try minuteNumber()
		 	setState(7442)
		 	try secondNumber()
		 	setState(7443)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TimeDelayContext: ParserRuleContext {
			open
			func timeValue() -> TimeValueContext? {
				return getRuleContext(TimeValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_timeDelay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTimeDelay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTimeDelay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTimeDelay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTimeDelay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func timeDelay() throws -> TimeDelayContext {
		var _localctx: TimeDelayContext = TimeDelayContext(_ctx, getState())
		try enterRule(_localctx, 1522, EDIF300Parser.RULE_timeDelay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7445)
		 	try timeValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TimeIntervalContext: ParserRuleContext {
			open
			func event() -> [EventContext] {
				return getRuleContexts(EventContext.self)
			}
			open
			func event(_ i: Int) -> EventContext? {
				return getRuleContext(EventContext.self, i)
			}
			open
			func offsetEvent() -> [OffsetEventContext] {
				return getRuleContexts(OffsetEventContext.self)
			}
			open
			func offsetEvent(_ i: Int) -> OffsetEventContext? {
				return getRuleContext(OffsetEventContext.self, i)
			}
			open
			func duration() -> DurationContext? {
				return getRuleContext(DurationContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_timeInterval
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTimeInterval(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTimeInterval(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTimeInterval(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTimeInterval(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func timeInterval() throws -> TimeIntervalContext {
		var _localctx: TimeIntervalContext = TimeIntervalContext(_ctx, getState())
		try enterRule(_localctx, 1524, EDIF300Parser.RULE_timeInterval)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7447)
		 	try match(EDIF300Parser.Tokens.T__617.rawValue)
		 	setState(7450)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__153:
		 		setState(7448)
		 		try event()

		 		break

		 	case .T__363:
		 		setState(7449)
		 		try offsetEvent()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(7455)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__153:
		 		setState(7452)
		 		try event()

		 		break

		 	case .T__363:
		 		setState(7453)
		 		try offsetEvent()

		 		break

		 	case .T__144:
		 		setState(7454)
		 		try duration()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(7457)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TimeStampContext: ParserRuleContext {
			open
			func date() -> DateContext? {
				return getRuleContext(DateContext.self, 0)
			}
			open
			func time() -> TimeContext? {
				return getRuleContext(TimeContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_timeStamp
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTimeStamp(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTimeStamp(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTimeStamp(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTimeStamp(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func timeStamp() throws -> TimeStampContext {
		var _localctx: TimeStampContext = TimeStampContext(_ctx, getState())
		try enterRule(_localctx, 1526, EDIF300Parser.RULE_timeStamp)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7459)
		 	try match(EDIF300Parser.Tokens.T__618.rawValue)
		 	setState(7460)
		 	try date()
		 	setState(7461)
		 	try time()
		 	setState(7462)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TimeValueContext: ParserRuleContext {
			open
			func miNoMaxValue() -> MiNoMaxValueContext? {
				return getRuleContext(MiNoMaxValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_timeValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTimeValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTimeValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTimeValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTimeValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func timeValue() throws -> TimeValueContext {
		var _localctx: TimeValueContext = TimeValueContext(_ctx, getState())
		try enterRule(_localctx, 1528, EDIF300Parser.RULE_timeValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7464)
		 	try miNoMaxValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TimingContext: ParserRuleContext {
			open
			func timingNameDef() -> TimingNameDefContext? {
				return getRuleContext(TimingNameDefContext.self, 0)
			}
			open
			func derivation() -> DerivationContext? {
				return getRuleContext(DerivationContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func forbiddenEvent() -> [ForbiddenEventContext] {
				return getRuleContexts(ForbiddenEventContext.self)
			}
			open
			func forbiddenEvent(_ i: Int) -> ForbiddenEventContext? {
				return getRuleContext(ForbiddenEventContext.self, i)
			}
			open
			func pathDelay() -> [PathDelayContext] {
				return getRuleContexts(PathDelayContext.self)
			}
			open
			func pathDelay(_ i: Int) -> PathDelayContext? {
				return getRuleContext(PathDelayContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_timing
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTiming(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTiming(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTiming(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTiming(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func timing() throws -> TimingContext {
		var _localctx: TimingContext = TimingContext(_ctx, getState())
		try enterRule(_localctx, 1530, EDIF300Parser.RULE_timing)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7466)
		 	try match(EDIF300Parser.Tokens.T__619.rawValue)
		 	setState(7467)
		 	try timingNameDef()
		 	setState(7468)
		 	try derivation()
		 	setState(7476)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__175.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__402.rawValue || _la == EDIF300Parser.Tokens.T__442.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7474)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(7469)
		 			try comment()

		 			break

		 		case .T__175:
		 			setState(7470)
		 			try forbiddenEvent()

		 			break

		 		case .T__402:
		 			setState(7471)
		 			try pathDelay()

		 			break

		 		case .T__442:
		 			setState(7472)
		 			try property()

		 			break

		 		case .T__642:
		 			setState(7473)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7478)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7479)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TimingDisplayContext: ParserRuleContext {
			open
			func timingNameRef() -> TimingNameRefContext? {
				return getRuleContext(TimingNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_timingDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTimingDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTimingDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTimingDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTimingDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func timingDisplay() throws -> TimingDisplayContext {
		var _localctx: TimingDisplayContext = TimingDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1532, EDIF300Parser.RULE_timingDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7481)
		 	try match(EDIF300Parser.Tokens.T__620.rawValue)
		 	setState(7482)
		 	try timingNameRef()
		 	setState(7486)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7483)
		 		try display()


		 		setState(7488)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7489)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TimingNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_timingNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTimingNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTimingNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTimingNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTimingNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func timingNameDef() throws -> TimingNameDefContext {
		var _localctx: TimingNameDefContext = TimingNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1534, EDIF300Parser.RULE_timingNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7491)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TimingNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_timingNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTimingNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTimingNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTimingNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTimingNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func timingNameRef() throws -> TimingNameRefContext {
		var _localctx: TimingNameRefContext = TimingNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1536, EDIF300Parser.RULE_timingNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7493)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ToIntegerContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_toInteger
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterToInteger(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitToInteger(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitToInteger(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitToInteger(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func toInteger() throws -> ToIntegerContext {
		var _localctx: ToIntegerContext = ToIntegerContext(_ctx, getState())
		try enterRule(_localctx, 1538, EDIF300Parser.RULE_toInteger)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7495)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TopJustifyContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_topJustify
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTopJustify(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTopJustify(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTopJustify(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTopJustify(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func topJustify() throws -> TopJustifyContext {
		var _localctx: TopJustifyContext = TopJustifyContext(_ctx, getState())
		try enterRule(_localctx, 1540, EDIF300Parser.RULE_topJustify)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7497)
		 	try match(EDIF300Parser.Tokens.T__621.rawValue)
		 	setState(7498)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TotalPagesContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_totalPages
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTotalPages(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTotalPages(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTotalPages(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTotalPages(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func totalPages() throws -> TotalPagesContext {
		var _localctx: TotalPagesContext = TotalPagesContext(_ctx, getState())
		try enterRule(_localctx, 1542, EDIF300Parser.RULE_totalPages)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7500)
		 	try match(EDIF300Parser.Tokens.T__622.rawValue)
		 	setState(7501)
		 	try integerToken()
		 	setState(7502)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TotalPagesDisplayContext: ParserRuleContext {
			open
			func addDisplay() -> AddDisplayContext? {
				return getRuleContext(AddDisplayContext.self, 0)
			}
			open
			func replaceDisplay() -> ReplaceDisplayContext? {
				return getRuleContext(ReplaceDisplayContext.self, 0)
			}
			open
			func removeDisplay() -> RemoveDisplayContext? {
				return getRuleContext(RemoveDisplayContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_totalPagesDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTotalPagesDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTotalPagesDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTotalPagesDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTotalPagesDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func totalPagesDisplay() throws -> TotalPagesDisplayContext {
		var _localctx: TotalPagesDisplayContext = TotalPagesDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1544, EDIF300Parser.RULE_totalPagesDisplay)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7504)
		 	try match(EDIF300Parser.Tokens.T__623.rawValue)
		 	setState(7508)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__4:
		 		setState(7505)
		 		try addDisplay()

		 		break

		 	case .T__457:
		 		setState(7506)
		 		try replaceDisplay()

		 		break

		 	case .T__454:
		 		setState(7507)
		 		try removeDisplay()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(7510)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TransformContext: ParserRuleContext {
			open
			func origin() -> [OriginContext] {
				return getRuleContexts(OriginContext.self)
			}
			open
			func origin(_ i: Int) -> OriginContext? {
				return getRuleContext(OriginContext.self, i)
			}
			open
			func rotation() -> [RotationContext] {
				return getRuleContexts(RotationContext.self)
			}
			open
			func rotation(_ i: Int) -> RotationContext? {
				return getRuleContext(RotationContext.self, i)
			}
			open
			func scaleX() -> [ScaleXContext] {
				return getRuleContexts(ScaleXContext.self)
			}
			open
			func scaleX(_ i: Int) -> ScaleXContext? {
				return getRuleContext(ScaleXContext.self, i)
			}
			open
			func scaleY() -> [ScaleYContext] {
				return getRuleContexts(ScaleYContext.self)
			}
			open
			func scaleY(_ i: Int) -> ScaleYContext? {
				return getRuleContext(ScaleYContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_transform
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTransform(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTransform(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTransform(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTransform(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func transform() throws -> TransformContext {
		var _localctx: TransformContext = TransformContext(_ctx, getState())
		try enterRule(_localctx, 1546, EDIF300Parser.RULE_transform)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7512)
		 	try match(EDIF300Parser.Tokens.T__624.rawValue)
		 	setState(7519)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__367.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__465.rawValue,EDIF300Parser.Tokens.T__467.rawValue,EDIF300Parser.Tokens.T__468.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 466)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(7517)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__367:
		 			setState(7513)
		 			try origin()

		 			break

		 		case .T__465:
		 			setState(7514)
		 			try rotation()

		 			break

		 		case .T__467:
		 			setState(7515)
		 			try scaleX()

		 			break

		 		case .T__468:
		 			setState(7516)
		 			try scaleY()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7521)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7522)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TransitionContext: ParserRuleContext {
			open
			func previousLogicValue() -> PreviousLogicValueContext? {
				return getRuleContext(PreviousLogicValueContext.self, 0)
			}
			open
			func presentLogicValue() -> PresentLogicValueContext? {
				return getRuleContext(PresentLogicValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_transition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTransition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTransition(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTransition(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTransition(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func transition() throws -> TransitionContext {
		var _localctx: TransitionContext = TransitionContext(_ctx, getState())
		try enterRule(_localctx, 1548, EDIF300Parser.RULE_transition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7524)
		 	try match(EDIF300Parser.Tokens.T__625.rawValue)
		 	setState(7525)
		 	try previousLogicValue()
		 	setState(7526)
		 	try presentLogicValue()
		 	setState(7527)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EtrueContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_etrue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterEtrue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitEtrue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitEtrue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitEtrue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func etrue() throws -> EtrueContext {
		var _localctx: EtrueContext = EtrueContext(_ctx, getState())
		try enterRule(_localctx, 1550, EDIF300Parser.RULE_etrue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7529)
		 	try match(EDIF300Parser.Tokens.T__626.rawValue)
		 	setState(7530)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TruncateContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_truncate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTruncate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTruncate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTruncate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTruncate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func truncate() throws -> TruncateContext {
		var _localctx: TruncateContext = TruncateContext(_ctx, getState())
		try enterRule(_localctx, 1552, EDIF300Parser.RULE_truncate)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7532)
		 	try match(EDIF300Parser.Tokens.T__627.rawValue)
		 	setState(7533)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TypedValueContext: ParserRuleContext {
			open
			func eboolean() -> EbooleanContext? {
				return getRuleContext(EbooleanContext.self, 0)
			}
			open
			func integer() -> IntegerContext? {
				return getRuleContext(IntegerContext.self, 0)
			}
			open
			func miNoMax() -> MiNoMaxContext? {
				return getRuleContext(MiNoMaxContext.self, 0)
			}
			open
			func number() -> NumberContext? {
				return getRuleContext(NumberContext.self, 0)
			}
			open
			func point() -> PointContext? {
				return getRuleContext(PointContext.self, 0)
			}
			open
			func string() -> StringContext? {
				return getRuleContext(StringContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_typedValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTypedValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTypedValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTypedValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTypedValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func typedValue() throws -> TypedValueContext {
		var _localctx: TypedValueContext = TypedValueContext(_ctx, getState())
		try enterRule(_localctx, 1554, EDIF300Parser.RULE_typedValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7541)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__23:
		 		setState(7535)
		 		try eboolean()

		 		break

		 	case .T__247:
		 		setState(7536)
		 		try integer()

		 		break

		 	case .T__336:
		 		setState(7537)
		 		try miNoMax()

		 		break

		 	case .T__356:
		 		setState(7538)
		 		try number()

		 		break

		 	case .T__411:
		 		setState(7539)
		 		try point()

		 		break

		 	case .T__599:
		 		setState(7540)
		 		try string()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TypefaceContext: ParserRuleContext {
			open
			func fontFamily() -> FontFamilyContext? {
				return getRuleContext(FontFamilyContext.self, 0)
			}
			open
			func typefaceSuffix() -> TypefaceSuffixContext? {
				return getRuleContext(TypefaceSuffixContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_typeface
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTypeface(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTypeface(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTypeface(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTypeface(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func typeface() throws -> TypefaceContext {
		var _localctx: TypefaceContext = TypefaceContext(_ctx, getState())
		try enterRule(_localctx, 1556, EDIF300Parser.RULE_typeface)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7543)
		 	try match(EDIF300Parser.Tokens.T__628.rawValue)
		 	setState(7544)
		 	try fontFamily()
		 	setState(7546)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__629.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7545)
		 		try typefaceSuffix()

		 	}

		 	setState(7548)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TypefaceSuffixContext: ParserRuleContext {
			open
			func stringToken() -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_typefaceSuffix
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterTypefaceSuffix(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitTypefaceSuffix(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitTypefaceSuffix(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitTypefaceSuffix(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func typefaceSuffix() throws -> TypefaceSuffixContext {
		var _localctx: TypefaceSuffixContext = TypefaceSuffixContext(_ctx, getState())
		try enterRule(_localctx, 1558, EDIF300Parser.RULE_typefaceSuffix)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7550)
		 	try match(EDIF300Parser.Tokens.T__629.rawValue)
		 	setState(7551)
		 	try stringToken()
		 	setState(7552)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnconfiguredContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unconfigured
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnconfigured(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnconfigured(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnconfigured(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnconfigured(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unconfigured() throws -> UnconfiguredContext {
		var _localctx: UnconfiguredContext = UnconfiguredContext(_ctx, getState())
		try enterRule(_localctx, 1560, EDIF300Parser.RULE_unconfigured)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7554)
		 	try match(EDIF300Parser.Tokens.T__630.rawValue)
		 	setState(7555)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnconstrainedContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unconstrained
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnconstrained(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnconstrained(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnconstrained(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnconstrained(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unconstrained() throws -> UnconstrainedContext {
		var _localctx: UnconstrainedContext = UnconstrainedContext(_ctx, getState())
		try enterRule(_localctx, 1562, EDIF300Parser.RULE_unconstrained)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7557)
		 	try match(EDIF300Parser.Tokens.T__631.rawValue)
		 	setState(7558)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UndefinedContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_undefined
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUndefined(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUndefined(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUndefined(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUndefined(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func undefined() throws -> UndefinedContext {
		var _localctx: UndefinedContext = UndefinedContext(_ctx, getState())
		try enterRule(_localctx, 1564, EDIF300Parser.RULE_undefined)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7560)
		 	try match(EDIF300Parser.Tokens.T__632.rawValue)
		 	setState(7561)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnitContext: ParserRuleContext {
			open
			func unitNameDef() -> UnitNameDefContext? {
				return getRuleContext(UnitNameDefContext.self, 0)
			}
			open
			func numberOfNewUnits() -> NumberOfNewUnitsContext? {
				return getRuleContext(NumberOfNewUnitsContext.self, 0)
			}
			open
			func numberOfBasicUnits() -> NumberOfBasicUnitsContext? {
				return getRuleContext(NumberOfBasicUnitsContext.self, 0)
			}
			open
			func ampere() -> [AmpereContext] {
				return getRuleContexts(AmpereContext.self)
			}
			open
			func ampere(_ i: Int) -> AmpereContext? {
				return getRuleContext(AmpereContext.self, i)
			}
			open
			func candela() -> [CandelaContext] {
				return getRuleContexts(CandelaContext.self)
			}
			open
			func candela(_ i: Int) -> CandelaContext? {
				return getRuleContext(CandelaContext.self, i)
			}
			open
			func celsius() -> [CelsiusContext] {
				return getRuleContexts(CelsiusContext.self)
			}
			open
			func celsius(_ i: Int) -> CelsiusContext? {
				return getRuleContext(CelsiusContext.self, i)
			}
			open
			func coulomb() -> [CoulombContext] {
				return getRuleContexts(CoulombContext.self)
			}
			open
			func coulomb(_ i: Int) -> CoulombContext? {
				return getRuleContext(CoulombContext.self, i)
			}
			open
			func degree() -> [DegreeContext] {
				return getRuleContexts(DegreeContext.self)
			}
			open
			func degree(_ i: Int) -> DegreeContext? {
				return getRuleContext(DegreeContext.self, i)
			}
			open
			func fahrenheit() -> [FahrenheitContext] {
				return getRuleContexts(FahrenheitContext.self)
			}
			open
			func fahrenheit(_ i: Int) -> FahrenheitContext? {
				return getRuleContext(FahrenheitContext.self, i)
			}
			open
			func farad() -> [FaradContext] {
				return getRuleContexts(FaradContext.self)
			}
			open
			func farad(_ i: Int) -> FaradContext? {
				return getRuleContext(FaradContext.self, i)
			}
			open
			func henry() -> [HenryContext] {
				return getRuleContexts(HenryContext.self)
			}
			open
			func henry(_ i: Int) -> HenryContext? {
				return getRuleContext(HenryContext.self, i)
			}
			open
			func hertz() -> [HertzContext] {
				return getRuleContexts(HertzContext.self)
			}
			open
			func hertz(_ i: Int) -> HertzContext? {
				return getRuleContext(HertzContext.self, i)
			}
			open
			func joule() -> [JouleContext] {
				return getRuleContexts(JouleContext.self)
			}
			open
			func joule(_ i: Int) -> JouleContext? {
				return getRuleContext(JouleContext.self, i)
			}
			open
			func kelvin() -> [KelvinContext] {
				return getRuleContexts(KelvinContext.self)
			}
			open
			func kelvin(_ i: Int) -> KelvinContext? {
				return getRuleContext(KelvinContext.self, i)
			}
			open
			func kilogram() -> [KilogramContext] {
				return getRuleContexts(KilogramContext.self)
			}
			open
			func kilogram(_ i: Int) -> KilogramContext? {
				return getRuleContext(KilogramContext.self, i)
			}
			open
			func meter() -> [MeterContext] {
				return getRuleContexts(MeterContext.self)
			}
			open
			func meter(_ i: Int) -> MeterContext? {
				return getRuleContext(MeterContext.self, i)
			}
			open
			func mole() -> [MoleContext] {
				return getRuleContexts(MoleContext.self)
			}
			open
			func mole(_ i: Int) -> MoleContext? {
				return getRuleContext(MoleContext.self, i)
			}
			open
			func ohm() -> [OhmContext] {
				return getRuleContexts(OhmContext.self)
			}
			open
			func ohm(_ i: Int) -> OhmContext? {
				return getRuleContext(OhmContext.self, i)
			}
			open
			func radian() -> [RadianContext] {
				return getRuleContexts(RadianContext.self)
			}
			open
			func radian(_ i: Int) -> RadianContext? {
				return getRuleContext(RadianContext.self, i)
			}
			open
			func second() -> [SecondContext] {
				return getRuleContexts(SecondContext.self)
			}
			open
			func second(_ i: Int) -> SecondContext? {
				return getRuleContext(SecondContext.self, i)
			}
			open
			func siemens() -> [SiemensContext] {
				return getRuleContexts(SiemensContext.self)
			}
			open
			func siemens(_ i: Int) -> SiemensContext? {
				return getRuleContext(SiemensContext.self, i)
			}
			open
			func volt() -> [VoltContext] {
				return getRuleContexts(VoltContext.self)
			}
			open
			func volt(_ i: Int) -> VoltContext? {
				return getRuleContext(VoltContext.self, i)
			}
			open
			func watt() -> [WattContext] {
				return getRuleContexts(WattContext.self)
			}
			open
			func watt(_ i: Int) -> WattContext? {
				return getRuleContext(WattContext.self, i)
			}
			open
			func weber() -> [WeberContext] {
				return getRuleContexts(WeberContext.self)
			}
			open
			func weber(_ i: Int) -> WeberContext? {
				return getRuleContext(WeberContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unit
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnit(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnit(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnit(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnit(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unit() throws -> UnitContext {
		var _localctx: UnitContext = UnitContext(_ctx, getState())
		try enterRule(_localctx, 1566, EDIF300Parser.RULE_unit)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7563)
		 	try match(EDIF300Parser.Tokens.T__633.rawValue)
		 	setState(7564)
		 	try unitNameDef()
		 	setState(7565)
		 	try numberOfNewUnits()
		 	setState(7566)
		 	try numberOfBasicUnits()
		 	setState(7590)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__5.rawValue,EDIF300Parser.Tokens.T__35.rawValue,EDIF300Parser.Tokens.T__44.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__96.rawValue,EDIF300Parser.Tokens.T__114.rawValue,EDIF300Parser.Tokens.T__156.rawValue,EDIF300Parser.Tokens.T__158.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 97)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__205.rawValue || _la == EDIF300Parser.Tokens.T__206.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__278.rawValue,EDIF300Parser.Tokens.T__301.rawValue,EDIF300Parser.Tokens.T__303.rawValue,EDIF300Parser.Tokens.T__332.rawValue,EDIF300Parser.Tokens.T__339.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 279)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__364.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__451.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__571.rawValue || _la == EDIF300Parser.Tokens.T__583.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__655.rawValue,EDIF300Parser.Tokens.T__657.rawValue,EDIF300Parser.Tokens.T__660.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 656)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(7588)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__5:
		 			setState(7567)
		 			try ampere()

		 			break

		 		case .T__35:
		 			setState(7568)
		 			try candela()

		 			break

		 		case .T__44:
		 			setState(7569)
		 			try celsius()

		 			break

		 		case .T__96:
		 			setState(7570)
		 			try coulomb()

		 			break

		 		case .T__114:
		 			setState(7571)
		 			try degree()

		 			break

		 		case .T__156:
		 			setState(7572)
		 			try fahrenheit()

		 			break

		 		case .T__158:
		 			setState(7573)
		 			try farad()

		 			break

		 		case .T__205:
		 			setState(7574)
		 			try henry()

		 			break

		 		case .T__206:
		 			setState(7575)
		 			try hertz()

		 			break

		 		case .T__278:
		 			setState(7576)
		 			try joule()

		 			break

		 		case .T__301:
		 			setState(7577)
		 			try kelvin()

		 			break

		 		case .T__303:
		 			setState(7578)
		 			try kilogram()

		 			break

		 		case .T__332:
		 			setState(7579)
		 			try meter()

		 			break

		 		case .T__339:
		 			setState(7580)
		 			try mole()

		 			break

		 		case .T__364:
		 			setState(7581)
		 			try ohm()

		 			break

		 		case .T__451:
		 			setState(7582)
		 			try radian()

		 			break

		 		case .T__571:
		 			setState(7583)
		 			try second()

		 			break

		 		case .T__583:
		 			setState(7584)
		 			try siemens()

		 			break

		 		case .T__655:
		 			setState(7585)
		 			try volt()

		 			break

		 		case .T__657:
		 			setState(7586)
		 			try watt()

		 			break

		 		case .T__660:
		 			setState(7587)
		 			try weber()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7592)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7593)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnitDefinitionsContext: ParserRuleContext {
			open
			func unit() -> [UnitContext] {
				return getRuleContexts(UnitContext.self)
			}
			open
			func unit(_ i: Int) -> UnitContext? {
				return getRuleContext(UnitContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unitDefinitions
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnitDefinitions(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnitDefinitions(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnitDefinitions(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnitDefinitions(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unitDefinitions() throws -> UnitDefinitionsContext {
		var _localctx: UnitDefinitionsContext = UnitDefinitionsContext(_ctx, getState())
		try enterRule(_localctx, 1568, EDIF300Parser.RULE_unitDefinitions)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7595)
		 	try match(EDIF300Parser.Tokens.T__634.rawValue)
		 	setState(7599)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__633.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7596)
		 		try unit()


		 		setState(7601)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7602)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnitExponentContext: ParserRuleContext {
			open
			func scaledInteger() -> ScaledIntegerContext? {
				return getRuleContext(ScaledIntegerContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unitExponent
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnitExponent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnitExponent(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnitExponent(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnitExponent(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unitExponent() throws -> UnitExponentContext {
		var _localctx: UnitExponentContext = UnitExponentContext(_ctx, getState())
		try enterRule(_localctx, 1570, EDIF300Parser.RULE_unitExponent)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7604)
		 	try scaledInteger()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnitNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unitNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnitNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnitNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnitNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnitNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unitNameDef() throws -> UnitNameDefContext {
		var _localctx: UnitNameDefContext = UnitNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1572, EDIF300Parser.RULE_unitNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7606)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnitNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unitNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnitNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnitNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnitNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnitNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unitNameRef() throws -> UnitNameRefContext {
		var _localctx: UnitNameRefContext = UnitNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1574, EDIF300Parser.RULE_unitNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7608)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnitRefContext: ParserRuleContext {
			open
			func unitNameRef() -> UnitNameRefContext? {
				return getRuleContext(UnitNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unitRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnitRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnitRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnitRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnitRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unitRef() throws -> UnitRefContext {
		var _localctx: UnitRefContext = UnitRefContext(_ctx, getState())
		try enterRule(_localctx, 1576, EDIF300Parser.RULE_unitRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7610)
		 	try match(EDIF300Parser.Tokens.T__635.rawValue)
		 	setState(7611)
		 	try unitNameRef()
		 	setState(7612)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnrestrictedContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unrestricted
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnrestricted(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnrestricted(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnrestricted(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnrestricted(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unrestricted() throws -> UnrestrictedContext {
		var _localctx: UnrestrictedContext = UnrestrictedContext(_ctx, getState())
		try enterRule(_localctx, 1578, EDIF300Parser.RULE_unrestricted)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7614)
		 	try match(EDIF300Parser.Tokens.T__636.rawValue)
		 	setState(7615)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnspecifiedContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unspecified
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnspecified(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnspecified(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnspecified(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnspecified(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unspecified() throws -> UnspecifiedContext {
		var _localctx: UnspecifiedContext = UnspecifiedContext(_ctx, getState())
		try enterRule(_localctx, 1580, EDIF300Parser.RULE_unspecified)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7617)
		 	try match(EDIF300Parser.Tokens.T__637.rawValue)
		 	setState(7618)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnspecifiedDirectionPortContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unspecifiedDirectionPort
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnspecifiedDirectionPort(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnspecifiedDirectionPort(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnspecifiedDirectionPort(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnspecifiedDirectionPort(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unspecifiedDirectionPort() throws -> UnspecifiedDirectionPortContext {
		var _localctx: UnspecifiedDirectionPortContext = UnspecifiedDirectionPortContext(_ctx, getState())
		try enterRule(_localctx, 1582, EDIF300Parser.RULE_unspecifiedDirectionPort)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7620)
		 	try match(EDIF300Parser.Tokens.T__638.rawValue)
		 	setState(7621)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UntypedContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_untyped
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUntyped(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUntyped(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUntyped(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUntyped(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func untyped() throws -> UntypedContext {
		var _localctx: UntypedContext = UntypedContext(_ctx, getState())
		try enterRule(_localctx, 1584, EDIF300Parser.RULE_untyped)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7623)
		 	try match(EDIF300Parser.Tokens.T__639.rawValue)
		 	setState(7624)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnusedContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_unused
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUnused(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUnused(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUnused(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUnused(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func unused() throws -> UnusedContext {
		var _localctx: UnusedContext = UnusedContext(_ctx, getState())
		try enterRule(_localctx, 1586, EDIF300Parser.RULE_unused)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7626)
		 	try match(EDIF300Parser.Tokens.T__640.rawValue)
		 	setState(7627)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UsableAreaContext: ParserRuleContext {
			open
			func rectangle() -> [RectangleContext] {
				return getRuleContexts(RectangleContext.self)
			}
			open
			func rectangle(_ i: Int) -> RectangleContext? {
				return getRuleContext(RectangleContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_usableArea
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUsableArea(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUsableArea(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUsableArea(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUsableArea(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func usableArea() throws -> UsableAreaContext {
		var _localctx: UsableAreaContext = UsableAreaContext(_ctx, getState())
		try enterRule(_localctx, 1588, EDIF300Parser.RULE_usableArea)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7629)
		 	try match(EDIF300Parser.Tokens.T__641.rawValue)
		 	setState(7633)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__453.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7630)
		 		try rectangle()


		 		setState(7635)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7636)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UserDataContext: ParserRuleContext {
			open
			func userDataTag() -> UserDataTagContext? {
				return getRuleContext(UserDataTagContext.self, 0)
			}
			open
			func IDENTIFIER() -> [TerminalNode] {
				return getTokens(EDIF300Parser.Tokens.IDENTIFIER.rawValue)
			}
			open
			func IDENTIFIER(_ i:Int) -> TerminalNode? {
				return getToken(EDIF300Parser.Tokens.IDENTIFIER.rawValue, i)
			}
			open
			func integerToken() -> [IntegerTokenContext] {
				return getRuleContexts(IntegerTokenContext.self)
			}
			open
			func integerToken(_ i: Int) -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, i)
			}
			open
			func stringToken() -> [StringTokenContext] {
				return getRuleContexts(StringTokenContext.self)
			}
			open
			func stringToken(_ i: Int) -> StringTokenContext? {
				return getRuleContext(StringTokenContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_userData
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUserData(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUserData(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUserData(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUserData(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func userData() throws -> UserDataContext {
		var _localctx: UserDataContext = UserDataContext(_ctx, getState())
		try enterRule(_localctx, 1590, EDIF300Parser.RULE_userData)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7638)
		 	try match(EDIF300Parser.Tokens.T__642.rawValue)
		 	setState(7639)
		 	try userDataTag()
		 	setState(7646)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__642.rawValue,EDIF300Parser.Tokens.IDENTIFIER.rawValue,EDIF300Parser.Tokens.STRING_LITERAL.rawValue,EDIF300Parser.Tokens.DECIMAL_LITERAL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 643)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(7644)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .IDENTIFIER:
		 			setState(7640)
		 			try match(EDIF300Parser.Tokens.IDENTIFIER.rawValue)

		 			break

		 		case .DECIMAL_LITERAL:
		 			setState(7641)
		 			try integerToken()

		 			break

		 		case .STRING_LITERAL:
		 			setState(7642)
		 			try stringToken()

		 			break

		 		case .T__642:
		 			setState(7643)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7648)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7649)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UserDataTagContext: ParserRuleContext {
			open
			func IDENTIFIER() -> TerminalNode? {
				return getToken(EDIF300Parser.Tokens.IDENTIFIER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_userDataTag
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterUserDataTag(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitUserDataTag(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitUserDataTag(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitUserDataTag(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func userDataTag() throws -> UserDataTagContext {
		var _localctx: UserDataTagContext = UserDataTagContext(_ctx, getState())
		try enterRule(_localctx, 1592, EDIF300Parser.RULE_userDataTag)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7651)
		 	try match(EDIF300Parser.Tokens.IDENTIFIER.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class VersionContext: ParserRuleContext {
			open
			func stringValue() -> StringValueContext? {
				return getRuleContext(StringValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_version
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterVersion(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitVersion(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitVersion(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitVersion(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func version() throws -> VersionContext {
		var _localctx: VersionContext = VersionContext(_ctx, getState())
		try enterRule(_localctx, 1594, EDIF300Parser.RULE_version)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7653)
		 	try match(EDIF300Parser.Tokens.T__643.rawValue)
		 	setState(7654)
		 	try stringValue()
		 	setState(7655)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class VerticalJustificationContext: ParserRuleContext {
			open
			func bottomJustify() -> BottomJustifyContext? {
				return getRuleContext(BottomJustifyContext.self, 0)
			}
			open
			func baselineJustify() -> BaselineJustifyContext? {
				return getRuleContext(BaselineJustifyContext.self, 0)
			}
			open
			func middleJustify() -> MiddleJustifyContext? {
				return getRuleContext(MiddleJustifyContext.self, 0)
			}
			open
			func caplineJustify() -> CaplineJustifyContext? {
				return getRuleContext(CaplineJustifyContext.self, 0)
			}
			open
			func topJustify() -> TopJustifyContext? {
				return getRuleContext(TopJustifyContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_verticalJustification
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterVerticalJustification(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitVerticalJustification(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitVerticalJustification(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitVerticalJustification(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func verticalJustification() throws -> VerticalJustificationContext {
		var _localctx: VerticalJustificationContext = VerticalJustificationContext(_ctx, getState())
		try enterRule(_localctx, 1596, EDIF300Parser.RULE_verticalJustification)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7657)
		 	try match(EDIF300Parser.Tokens.T__644.rawValue)
		 	setState(7663)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__33:
		 		setState(7658)
		 		try bottomJustify()

		 		break

		 	case .T__15:
		 		setState(7659)
		 		try baselineJustify()

		 		break

		 	case .T__333:
		 		setState(7660)
		 		try middleJustify()

		 		break

		 	case .T__36:
		 		setState(7661)
		 		try caplineJustify()

		 		break

		 	case .T__621:
		 		setState(7662)
		 		try topJustify()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(7665)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewGroupContext: ParserRuleContext {
			open
			func viewGroupNameDef() -> ViewGroupNameDefContext? {
				return getRuleContext(ViewGroupNameDefContext.self, 0)
			}
			open
			func viewGroupHeader() -> ViewGroupHeaderContext? {
				return getRuleContext(ViewGroupHeaderContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
			open
			func viewGroupRef() -> [ViewGroupRefContext] {
				return getRuleContexts(ViewGroupRefContext.self)
			}
			open
			func viewGroupRef(_ i: Int) -> ViewGroupRefContext? {
				return getRuleContext(ViewGroupRefContext.self, i)
			}
			open
			func viewRef() -> [ViewRefContext] {
				return getRuleContexts(ViewRefContext.self)
			}
			open
			func viewRef(_ i: Int) -> ViewRefContext? {
				return getRuleContext(ViewRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewGroup
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewGroup(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewGroup(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewGroup(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewGroup(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewGroup() throws -> ViewGroupContext {
		var _localctx: ViewGroupContext = ViewGroupContext(_ctx, getState())
		try enterRule(_localctx, 1598, EDIF300Parser.RULE_viewGroup)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7667)
		 	try match(EDIF300Parser.Tokens.T__645.rawValue)
		 	setState(7668)
		 	try viewGroupNameDef()
		 	setState(7669)
		 	try viewGroupHeader()
		 	setState(7676)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__642.rawValue,EDIF300Parser.Tokens.T__648.rawValue,EDIF300Parser.Tokens.T__653.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 643)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(7674)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(7670)
		 			try comment()

		 			break

		 		case .T__642:
		 			setState(7671)
		 			try userData()

		 			break

		 		case .T__648:
		 			setState(7672)
		 			try viewGroupRef()

		 			break

		 		case .T__653:
		 			setState(7673)
		 			try viewRef()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7678)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7679)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewGroupHeaderContext: ParserRuleContext {
			open
			func documentation() -> [DocumentationContext] {
				return getRuleContexts(DocumentationContext.self)
			}
			open
			func documentation(_ i: Int) -> DocumentationContext? {
				return getRuleContext(DocumentationContext.self, i)
			}
			open
			func nameInformation() -> [NameInformationContext] {
				return getRuleContexts(NameInformationContext.self)
			}
			open
			func nameInformation(_ i: Int) -> NameInformationContext? {
				return getRuleContext(NameInformationContext.self, i)
			}
			open
			func property() -> [PropertyContext] {
				return getRuleContexts(PropertyContext.self)
			}
			open
			func property(_ i: Int) -> PropertyContext? {
				return getRuleContext(PropertyContext.self, i)
			}
			open
			func reason() -> [ReasonContext] {
				return getRuleContexts(ReasonContext.self)
			}
			open
			func reason(_ i: Int) -> ReasonContext? {
				return getRuleContext(ReasonContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewGroupHeader
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewGroupHeader(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewGroupHeader(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewGroupHeader(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewGroupHeader(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewGroupHeader() throws -> ViewGroupHeaderContext {
		var _localctx: ViewGroupHeaderContext = ViewGroupHeaderContext(_ctx, getState())
		try enterRule(_localctx, 1600, EDIF300Parser.RULE_viewGroupHeader)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7681)
		 	try match(EDIF300Parser.Tokens.T__646.rawValue)
		 	setState(7688)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__132.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__346.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__442.rawValue || _la == EDIF300Parser.Tokens.T__452.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7686)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__132:
		 			setState(7682)
		 			try documentation()

		 			break

		 		case .T__346:
		 			setState(7683)
		 			try nameInformation()

		 			break

		 		case .T__442:
		 			setState(7684)
		 			try property()

		 			break

		 		case .T__452:
		 			setState(7685)
		 			try reason()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7690)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7691)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewGroupNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewGroupNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewGroupNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewGroupNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewGroupNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewGroupNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewGroupNameCaseSensitive() throws -> ViewGroupNameCaseSensitiveContext {
		var _localctx: ViewGroupNameCaseSensitiveContext = ViewGroupNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 1602, EDIF300Parser.RULE_viewGroupNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7693)
		 	try match(EDIF300Parser.Tokens.T__647.rawValue)
		 	setState(7694)
		 	try booleanToken()
		 	setState(7695)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewGroupNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewGroupNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewGroupNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewGroupNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewGroupNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewGroupNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewGroupNameDef() throws -> ViewGroupNameDefContext {
		var _localctx: ViewGroupNameDefContext = ViewGroupNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1604, EDIF300Parser.RULE_viewGroupNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7697)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewGroupNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewGroupNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewGroupNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewGroupNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewGroupNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewGroupNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewGroupNameRef() throws -> ViewGroupNameRefContext {
		var _localctx: ViewGroupNameRefContext = ViewGroupNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1606, EDIF300Parser.RULE_viewGroupNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7699)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewGroupRefContext: ParserRuleContext {
			open
			func viewGroupNameRef() -> ViewGroupNameRefContext? {
				return getRuleContext(ViewGroupNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewGroupRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewGroupRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewGroupRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewGroupRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewGroupRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewGroupRef() throws -> ViewGroupRefContext {
		var _localctx: ViewGroupRefContext = ViewGroupRefContext(_ctx, getState())
		try enterRule(_localctx, 1608, EDIF300Parser.RULE_viewGroupRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7701)
		 	try match(EDIF300Parser.Tokens.T__648.rawValue)
		 	setState(7702)
		 	try viewGroupNameRef()
		 	setState(7703)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewNameCaseSensitiveContext: ParserRuleContext {
			open
			func booleanToken() -> BooleanTokenContext? {
				return getRuleContext(BooleanTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewNameCaseSensitive
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewNameCaseSensitive(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewNameCaseSensitive(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewNameCaseSensitive(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewNameCaseSensitive(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewNameCaseSensitive() throws -> ViewNameCaseSensitiveContext {
		var _localctx: ViewNameCaseSensitiveContext = ViewNameCaseSensitiveContext(_ctx, getState())
		try enterRule(_localctx, 1610, EDIF300Parser.RULE_viewNameCaseSensitive)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7705)
		 	try match(EDIF300Parser.Tokens.T__649.rawValue)
		 	setState(7706)
		 	try booleanToken()
		 	setState(7707)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewNameDefContext: ParserRuleContext {
			open
			func nameDef() -> NameDefContext? {
				return getRuleContext(NameDefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewNameDef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewNameDef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewNameDef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewNameDef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewNameDef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewNameDef() throws -> ViewNameDefContext {
		var _localctx: ViewNameDefContext = ViewNameDefContext(_ctx, getState())
		try enterRule(_localctx, 1612, EDIF300Parser.RULE_viewNameDef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7709)
		 	try nameDef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewNameDisplayContext: ParserRuleContext {
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func displayNameOverride() -> [DisplayNameOverrideContext] {
				return getRuleContexts(DisplayNameOverrideContext.self)
			}
			open
			func displayNameOverride(_ i: Int) -> DisplayNameOverrideContext? {
				return getRuleContext(DisplayNameOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewNameDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewNameDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewNameDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewNameDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewNameDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewNameDisplay() throws -> ViewNameDisplayContext {
		var _localctx: ViewNameDisplayContext = ViewNameDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1614, EDIF300Parser.RULE_viewNameDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7711)
		 	try match(EDIF300Parser.Tokens.T__650.rawValue)
		 	setState(7716)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue || _la == EDIF300Parser.Tokens.T__131.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7714)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(7712)
		 			try display()

		 			break

		 		case .T__131:
		 			setState(7713)
		 			try displayNameOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7718)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7719)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewNameRefContext: ParserRuleContext {
			open
			func nameRef() -> NameRefContext? {
				return getRuleContext(NameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewNameRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewNameRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewNameRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewNameRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewNameRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewNameRef() throws -> ViewNameRefContext {
		var _localctx: ViewNameRefContext = ViewNameRefContext(_ctx, getState())
		try enterRule(_localctx, 1616, EDIF300Parser.RULE_viewNameRef)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7721)
		 	try nameRef()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewPropertyDisplayContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func display() -> [DisplayContext] {
				return getRuleContexts(DisplayContext.self)
			}
			open
			func display(_ i: Int) -> DisplayContext? {
				return getRuleContext(DisplayContext.self, i)
			}
			open
			func propertyNameDisplay() -> [PropertyNameDisplayContext] {
				return getRuleContexts(PropertyNameDisplayContext.self)
			}
			open
			func propertyNameDisplay(_ i: Int) -> PropertyNameDisplayContext? {
				return getRuleContext(PropertyNameDisplayContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewPropertyDisplay
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewPropertyDisplay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewPropertyDisplay(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewPropertyDisplay(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewPropertyDisplay(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewPropertyDisplay() throws -> ViewPropertyDisplayContext {
		var _localctx: ViewPropertyDisplayContext = ViewPropertyDisplayContext(_ctx, getState())
		try enterRule(_localctx, 1618, EDIF300Parser.RULE_viewPropertyDisplay)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7723)
		 	try match(EDIF300Parser.Tokens.T__651.rawValue)
		 	setState(7724)
		 	try propertyNameRef()
		 	setState(7729)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__128.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__447.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7727)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__128:
		 			setState(7725)
		 			try display()

		 			break

		 		case .T__447:
		 			setState(7726)
		 			try propertyNameDisplay()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7731)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7732)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewPropertyOverrideContext: ParserRuleContext {
			open
			func propertyNameRef() -> PropertyNameRefContext? {
				return getRuleContext(PropertyNameRefContext.self, 0)
			}
			open
			func typedValue() -> TypedValueContext? {
				return getRuleContext(TypedValueContext.self, 0)
			}
			open
			func untyped() -> UntypedContext? {
				return getRuleContext(UntypedContext.self, 0)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func fixed() -> [FixedContext] {
				return getRuleContexts(FixedContext.self)
			}
			open
			func fixed(_ i: Int) -> FixedContext? {
				return getRuleContext(FixedContext.self, i)
			}
			open
			func propertyOverride() -> [PropertyOverrideContext] {
				return getRuleContexts(PropertyOverrideContext.self)
			}
			open
			func propertyOverride(_ i: Int) -> PropertyOverrideContext? {
				return getRuleContext(PropertyOverrideContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewPropertyOverride
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewPropertyOverride(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewPropertyOverride(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewPropertyOverride(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewPropertyOverride(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewPropertyOverride() throws -> ViewPropertyOverrideContext {
		var _localctx: ViewPropertyOverrideContext = ViewPropertyOverrideContext(_ctx, getState())
		try enterRule(_localctx, 1620, EDIF300Parser.RULE_viewPropertyOverride)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7734)
		 	try match(EDIF300Parser.Tokens.T__652.rawValue)
		 	setState(7735)
		 	try propertyNameRef()
		 	setState(7738)
		 	try _errHandler.sync(self)
		 	switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .T__23:fallthrough
		 	case .T__247:fallthrough
		 	case .T__336:fallthrough
		 	case .T__356:fallthrough
		 	case .T__411:fallthrough
		 	case .T__599:
		 		setState(7736)
		 		try typedValue()

		 		break

		 	case .T__639:
		 		setState(7737)
		 		try untyped()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(7745)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__165.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__448.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7743)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__61:
		 			setState(7740)
		 			try comment()

		 			break

		 		case .T__165:
		 			setState(7741)
		 			try fixed()

		 			break

		 		case .T__448:
		 			setState(7742)
		 			try propertyOverride()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7747)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7748)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ViewRefContext: ParserRuleContext {
			open
			func viewNameRef() -> ViewNameRefContext? {
				return getRuleContext(ViewNameRefContext.self, 0)
			}
			open
			func clusterRef() -> ClusterRefContext? {
				return getRuleContext(ClusterRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_viewRef
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterViewRef(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitViewRef(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitViewRef(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitViewRef(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func viewRef() throws -> ViewRefContext {
		var _localctx: ViewRefContext = ViewRefContext(_ctx, getState())
		try enterRule(_localctx, 1622, EDIF300Parser.RULE_viewRef)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7750)
		 	try match(EDIF300Parser.Tokens.T__653.rawValue)
		 	setState(7751)
		 	try viewNameRef()
		 	setState(7753)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.T__59.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7752)
		 		try clusterRef()

		 	}

		 	setState(7755)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class VisibleContext: ParserRuleContext {
			open
			func booleanValue() -> BooleanValueContext? {
				return getRuleContext(BooleanValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_visible
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterVisible(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitVisible(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitVisible(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitVisible(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func visible() throws -> VisibleContext {
		var _localctx: VisibleContext = VisibleContext(_ctx, getState())
		try enterRule(_localctx, 1624, EDIF300Parser.RULE_visible)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7757)
		 	try match(EDIF300Parser.Tokens.T__654.rawValue)
		 	setState(7758)
		 	try booleanValue()
		 	setState(7759)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class VoltContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_volt
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterVolt(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitVolt(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitVolt(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitVolt(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func volt() throws -> VoltContext {
		var _localctx: VoltContext = VoltContext(_ctx, getState())
		try enterRule(_localctx, 1626, EDIF300Parser.RULE_volt)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7761)
		 	try match(EDIF300Parser.Tokens.T__655.rawValue)
		 	setState(7762)
		 	try unitExponent()
		 	setState(7763)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class VoltageMapContext: ParserRuleContext {
			open
			func voltageValue() -> VoltageValueContext? {
				return getRuleContext(VoltageValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_voltageMap
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterVoltageMap(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitVoltageMap(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitVoltageMap(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitVoltageMap(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func voltageMap() throws -> VoltageMapContext {
		var _localctx: VoltageMapContext = VoltageMapContext(_ctx, getState())
		try enterRule(_localctx, 1628, EDIF300Parser.RULE_voltageMap)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7765)
		 	try match(EDIF300Parser.Tokens.T__656.rawValue)
		 	setState(7766)
		 	try voltageValue()
		 	setState(7767)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class VoltageValueContext: ParserRuleContext {
			open
			func miNoMaxValue() -> MiNoMaxValueContext? {
				return getRuleContext(MiNoMaxValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_voltageValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterVoltageValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitVoltageValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitVoltageValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitVoltageValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func voltageValue() throws -> VoltageValueContext {
		var _localctx: VoltageValueContext = VoltageValueContext(_ctx, getState())
		try enterRule(_localctx, 1630, EDIF300Parser.RULE_voltageValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7769)
		 	try miNoMaxValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WattContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_watt
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterWatt(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitWatt(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitWatt(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitWatt(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func watt() throws -> WattContext {
		var _localctx: WattContext = WattContext(_ctx, getState())
		try enterRule(_localctx, 1632, EDIF300Parser.RULE_watt)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7771)
		 	try match(EDIF300Parser.Tokens.T__657.rawValue)
		 	setState(7772)
		 	try unitExponent()
		 	setState(7773)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WeakContext: ParserRuleContext {
			open
			func logicNameRef() -> LogicNameRefContext? {
				return getRuleContext(LogicNameRefContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_weak
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterWeak(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitWeak(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitWeak(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitWeak(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func weak() throws -> WeakContext {
		var _localctx: WeakContext = WeakContext(_ctx, getState())
		try enterRule(_localctx, 1634, EDIF300Parser.RULE_weak)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7775)
		 	try match(EDIF300Parser.Tokens.T__658.rawValue)
		 	setState(7776)
		 	try logicNameRef()
		 	setState(7777)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WeakJoinedContext: ParserRuleContext {
			open
			func interfaceJoined() -> [InterfaceJoinedContext] {
				return getRuleContexts(InterfaceJoinedContext.self)
			}
			open
			func interfaceJoined(_ i: Int) -> InterfaceJoinedContext? {
				return getRuleContext(InterfaceJoinedContext.self, i)
			}
			open
			func portRef() -> [PortRefContext] {
				return getRuleContexts(PortRefContext.self)
			}
			open
			func portRef(_ i: Int) -> PortRefContext? {
				return getRuleContext(PortRefContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_weakJoined
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterWeakJoined(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitWeakJoined(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitWeakJoined(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitWeakJoined(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func weakJoined() throws -> WeakJoinedContext {
		var _localctx: WeakJoinedContext = WeakJoinedContext(_ctx, getState())
		try enterRule(_localctx, 1636, EDIF300Parser.RULE_weakJoined)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7779)
		 	try match(EDIF300Parser.Tokens.T__659.rawValue)
		 	setState(7784)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__270.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__436.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7782)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__270:
		 			setState(7780)
		 			try interfaceJoined()

		 			break

		 		case .T__436:
		 			setState(7781)
		 			try portRef()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7786)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7787)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WeberContext: ParserRuleContext {
			open
			func unitExponent() -> UnitExponentContext? {
				return getRuleContext(UnitExponentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_weber
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterWeber(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitWeber(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitWeber(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitWeber(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func weber() throws -> WeberContext {
		var _localctx: WeberContext = WeberContext(_ctx, getState())
		try enterRule(_localctx, 1638, EDIF300Parser.RULE_weber)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7789)
		 	try match(EDIF300Parser.Tokens.T__660.rawValue)
		 	setState(7790)
		 	try unitExponent()
		 	setState(7791)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WidePortContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_widePort
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterWidePort(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitWidePort(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitWidePort(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitWidePort(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func widePort() throws -> WidePortContext {
		var _localctx: WidePortContext = WidePortContext(_ctx, getState())
		try enterRule(_localctx, 1640, EDIF300Parser.RULE_widePort)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7793)
		 	try match(EDIF300Parser.Tokens.T__661.rawValue)
		 	setState(7794)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WideWireContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_wideWire
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterWideWire(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitWideWire(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitWideWire(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitWideWire(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func wideWire() throws -> WideWireContext {
		var _localctx: WideWireContext = WideWireContext(_ctx, getState())
		try enterRule(_localctx, 1642, EDIF300Parser.RULE_wideWire)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7796)
		 	try match(EDIF300Parser.Tokens.T__662.rawValue)
		 	setState(7797)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WrittenContext: ParserRuleContext {
			open
			func timeStamp() -> TimeStampContext? {
				return getRuleContext(TimeStampContext.self, 0)
			}
			open
			func author() -> [AuthorContext] {
				return getRuleContexts(AuthorContext.self)
			}
			open
			func author(_ i: Int) -> AuthorContext? {
				return getRuleContext(AuthorContext.self, i)
			}
			open
			func comment() -> [CommentContext] {
				return getRuleContexts(CommentContext.self)
			}
			open
			func comment(_ i: Int) -> CommentContext? {
				return getRuleContext(CommentContext.self, i)
			}
			open
			func dataOrigin() -> [DataOriginContext] {
				return getRuleContexts(DataOriginContext.self)
			}
			open
			func dataOrigin(_ i: Int) -> DataOriginContext? {
				return getRuleContext(DataOriginContext.self, i)
			}
			open
			func program() -> [ProgramContext] {
				return getRuleContexts(ProgramContext.self)
			}
			open
			func program(_ i: Int) -> ProgramContext? {
				return getRuleContext(ProgramContext.self, i)
			}
			open
			func userData() -> [UserDataContext] {
				return getRuleContexts(UserDataContext.self)
			}
			open
			func userData(_ i: Int) -> UserDataContext? {
				return getRuleContext(UserDataContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_written
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterWritten(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitWritten(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitWritten(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitWritten(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func written() throws -> WrittenContext {
		var _localctx: WrittenContext = WrittenContext(_ctx, getState())
		try enterRule(_localctx, 1644, EDIF300Parser.RULE_written)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7799)
		 	try match(EDIF300Parser.Tokens.T__663.rawValue)
		 	setState(7800)
		 	try timeStamp()
		 	setState(7808)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == EDIF300Parser.Tokens.T__13.rawValue || _la == EDIF300Parser.Tokens.T__61.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__101.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__441.rawValue
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__642.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7806)
		 		try _errHandler.sync(self)
		 		switch (EDIF300Parser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .T__13:
		 			setState(7801)
		 			try author()

		 			break

		 		case .T__61:
		 			setState(7802)
		 			try comment()

		 			break

		 		case .T__101:
		 			setState(7803)
		 			try dataOrigin()

		 			break

		 		case .T__441:
		 			setState(7804)
		 			try program()

		 			break

		 		case .T__642:
		 			setState(7805)
		 			try userData()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		setState(7810)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7811)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class XCoordinateContext: ParserRuleContext {
			open
			func integerValue() -> IntegerValueContext? {
				return getRuleContext(IntegerValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_xCoordinate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterXCoordinate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitXCoordinate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitXCoordinate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitXCoordinate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func xCoordinate() throws -> XCoordinateContext {
		var _localctx: XCoordinateContext = XCoordinateContext(_ctx, getState())
		try enterRule(_localctx, 1646, EDIF300Parser.RULE_xCoordinate)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7813)
		 	try integerValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class XNumberValueContext: ParserRuleContext {
			open
			func numberValue() -> NumberValueContext? {
				return getRuleContext(NumberValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_xNumberValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterXNumberValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitXNumberValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitXNumberValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitXNumberValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func xNumberValue() throws -> XNumberValueContext {
		var _localctx: XNumberValueContext = XNumberValueContext(_ctx, getState())
		try enterRule(_localctx, 1648, EDIF300Parser.RULE_xNumberValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7815)
		 	try numberValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class XorContext: ParserRuleContext {
			open
			func booleanExpression() -> [BooleanExpressionContext] {
				return getRuleContexts(BooleanExpressionContext.self)
			}
			open
			func booleanExpression(_ i: Int) -> BooleanExpressionContext? {
				return getRuleContext(BooleanExpressionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_xor
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterXor(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitXor(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitXor(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitXor(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func xor() throws -> XorContext {
		var _localctx: XorContext = XorContext(_ctx, getState())
		try enterRule(_localctx, 1650, EDIF300Parser.RULE_xor)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7817)
		 	try match(EDIF300Parser.Tokens.T__664.rawValue)
		 	setState(7821)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__6.rawValue,EDIF300Parser.Tokens.T__25.rawValue,EDIF300Parser.Tokens.T__29.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__157.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__250.rawValue,EDIF300Parser.Tokens.T__307.rawValue,EDIF300Parser.Tokens.T__308.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 251)
		 	          }()
		 	          testSet = testSet || _la == EDIF300Parser.Tokens.T__354.rawValue || _la == EDIF300Parser.Tokens.T__366.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, EDIF300Parser.Tokens.T__603.rawValue,EDIF300Parser.Tokens.T__626.rawValue,EDIF300Parser.Tokens.T__664.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 604)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(7818)
		 		try booleanExpression()


		 		setState(7823)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7824)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class YCoordinateContext: ParserRuleContext {
			open
			func integerValue() -> IntegerValueContext? {
				return getRuleContext(IntegerValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_yCoordinate
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterYCoordinate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitYCoordinate(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitYCoordinate(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitYCoordinate(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func yCoordinate() throws -> YCoordinateContext {
		var _localctx: YCoordinateContext = YCoordinateContext(_ctx, getState())
		try enterRule(_localctx, 1652, EDIF300Parser.RULE_yCoordinate)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7826)
		 	try integerValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class YearContext: ParserRuleContext {
			open
			func yearNumber() -> [YearNumberContext] {
				return getRuleContexts(YearNumberContext.self)
			}
			open
			func yearNumber(_ i: Int) -> YearNumberContext? {
				return getRuleContext(YearNumberContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_year
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterYear(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitYear(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitYear(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitYear(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func year() throws -> YearContext {
		var _localctx: YearContext = YearContext(_ctx, getState())
		try enterRule(_localctx, 1654, EDIF300Parser.RULE_year)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7828)
		 	try match(EDIF300Parser.Tokens.T__665.rawValue)
		 	setState(7832)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == EDIF300Parser.Tokens.DECIMAL_LITERAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(7829)
		 		try yearNumber()


		 		setState(7834)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(7835)
		 	try match(EDIF300Parser.Tokens.T__1.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class YearNumberContext: ParserRuleContext {
			open
			func integerToken() -> IntegerTokenContext? {
				return getRuleContext(IntegerTokenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_yearNumber
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterYearNumber(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitYearNumber(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitYearNumber(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitYearNumber(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func yearNumber() throws -> YearNumberContext {
		var _localctx: YearNumberContext = YearNumberContext(_ctx, getState())
		try enterRule(_localctx, 1656, EDIF300Parser.RULE_yearNumber)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7837)
		 	try integerToken()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class YNumberValueContext: ParserRuleContext {
			open
			func numberValue() -> NumberValueContext? {
				return getRuleContext(NumberValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_yNumberValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterYNumberValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitYNumberValue(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitYNumberValue(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitYNumberValue(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func yNumberValue() throws -> YNumberValueContext {
		var _localctx: YNumberValueContext = YNumberValueContext(_ctx, getState())
		try enterRule(_localctx, 1658, EDIF300Parser.RULE_yNumberValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7839)
		 	try numberValue()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntegerTokenContext: ParserRuleContext {
			open
			func DECIMAL_LITERAL() -> TerminalNode? {
				return getToken(EDIF300Parser.Tokens.DECIMAL_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_integerToken
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterIntegerToken(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitIntegerToken(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitIntegerToken(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitIntegerToken(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func integerToken() throws -> IntegerTokenContext {
		var _localctx: IntegerTokenContext = IntegerTokenContext(_ctx, getState())
		try enterRule(_localctx, 1660, EDIF300Parser.RULE_integerToken)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7841)
		 	try match(EDIF300Parser.Tokens.DECIMAL_LITERAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringTokenContext: ParserRuleContext {
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(EDIF300Parser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return EDIF300Parser.RULE_stringToken
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.enterStringToken(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? EDIF300Listener {
				listener.exitStringToken(self)
			}
		}
		override open
		func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if let visitor = visitor as? EDIF300Visitor {
			    return visitor.visitStringToken(self)
			}
			else if let visitor = visitor as? EDIF300BaseVisitor {
			    return visitor.visitStringToken(self)
			}
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	 open func stringToken() throws -> StringTokenContext {
		var _localctx: StringTokenContext = StringTokenContext(_ctx, getState())
		try enterRule(_localctx, 1662, EDIF300Parser.RULE_stringToken)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7843)
		 	try match(EDIF300Parser.Tokens.STRING_LITERAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}


	public
	static let _serializedATN = EDIF300ParserATN().jsonString

	public
	static let _ATN = ATNDeserializer().deserializeFromJson(_serializedATN)
}