// Generated from ./grammars-v4/tsql/tsql.g4 by ANTLR 4.7
import Antlr4

open class tsqlParser: Parser {

	internal static var _decisionToDFA: [DFA] = {
          var decisionToDFA = [DFA]()
          let length = tsqlParser._ATN.getNumberOfDecisions()
          for i in 0..<length {
            decisionToDFA.append(DFA(tsqlParser._ATN.getDecisionState(i)!, i))
           }
           return decisionToDFA
     }()
	internal static let _sharedContextCache: PredictionContextCache = PredictionContextCache()
	public enum Tokens: Int {
		case EOF = -1, T__0 = 1, T__1 = 2, T__2 = 3, T__3 = 4, T__4 = 5, T__5 = 6, 
                 T__6 = 7, T__7 = 8, T__8 = 9, T__9 = 10, T__10 = 11, T__11 = 12, 
                 T__12 = 13, T__13 = 14, T__14 = 15, T__15 = 16, ADD = 17, 
                 ALL = 18, ALTER = 19, AND = 20, ANY = 21, APPEND = 22, 
                 AS = 23, ASC = 24, ASYMMETRIC = 25, AUTHORIZATION = 26, 
                 BACKUP = 27, BEGIN = 28, BETWEEN = 29, BREAK = 30, BROWSE = 31, 
                 BULK = 32, BY = 33, CALLED = 34, CASCADE = 35, CASE = 36, 
                 CERTIFICATE = 37, CHANGETABLE = 38, CHANGES = 39, CHECK = 40, 
                 CHECKPOINT = 41, CLOSE = 42, CLUSTERED = 43, COALESCE = 44, 
                 COLLATE = 45, COLUMN = 46, COMMIT = 47, COMPUTE = 48, CONSTRAINT = 49, 
                 CONTAINMENT = 50, CONTAINS = 51, CONTAINSTABLE = 52, CONTINUE = 53, 
                 CONTRACT = 54, CONVERSATION = 55, CONVERT = 56, CREATE = 57, 
                 CROSS = 58, CURRENT = 59, CURRENT_DATE = 60, CURRENT_TIME = 61, 
                 CURRENT_TIMESTAMP = 62, CURRENT_USER = 63, CURSOR = 64, 
                 DATA_COMPRESSION = 65, DATABASE = 66, DBCC = 67, DEALLOCATE = 68, 
                 DECLARE = 69, DEFAULT = 70, DELETE = 71, DENY = 72, DESC = 73, 
                 DISK = 74, DISTINCT = 75, DISTRIBUTED = 76, DOUBLE = 77, 
                 DROP = 78, DUMP = 79, ELSE = 80, END = 81, ERRLVL = 82, 
                 ESCAPE = 83, ERROR = 84, EVENTDATA = 85, EXCEPT = 86, EXECUTE = 87, 
                 EXISTS = 88, EXIT = 89, EXTERNAL = 90, FETCH = 91, FILE = 92, 
                 FILENAME = 93, FILLFACTOR = 94, FOR = 95, FORCESEEK = 96, 
                 FOREIGN = 97, FREETEXT = 98, FREETEXTTABLE = 99, FROM = 100, 
                 FULL = 101, FUNCTION = 102, GET = 103, GOTO = 104, GRANT = 105, 
                 GROUP = 106, HAVING = 107, IDENTITY = 108, IDENTITYCOL = 109, 
                 IDENTITY_INSERT = 110, IF = 111, IN = 112, INCLUDE = 113, 
                 INDEX = 114, INNER = 115, INSERT = 116, INSTEAD = 117, 
                 INTERSECT = 118, INTO = 119, IS = 120, ISNULL = 121, JOIN = 122, 
                 KEY = 123, KILL = 124, LEFT = 125, LIFETIME = 126, LIKE = 127, 
                 LINENO = 128, LOAD = 129, LOG = 130, MATCHED = 131, MERGE = 132, 
                 NATIONAL = 133, NOCHECK = 134, NONCLUSTERED = 135, NONE = 136, 
                 NOT = 137, NULL = 138, NULLIF = 139, OF = 140, OFF = 141, 
                 OFFSETS = 142, ON = 143, OPEN = 144, OPENDATASOURCE = 145, 
                 OPENQUERY = 146, OPENROWSET = 147, OPENXML = 148, OPTION = 149, 
                 OR = 150, ORDER = 151, OUTER = 152, OVER = 153, PAGE = 154, 
                 PARTIAL = 155, PASSWORD = 156, PERCENT = 157, PIVOT = 158, 
                 PLAN = 159, PRECISION = 160, PRIMARY = 161, PRINT = 162, 
                 PROC = 163, PROCEDURE = 164, PUBLIC = 165, RAISERROR = 166, 
                 RAW = 167, READ = 168, READTEXT = 169, RECONFIGURE = 170, 
                 REFERENCES = 171, RELATED_CONVERSATION = 172, RELATED_CONVERSATION_GROUP = 173, 
                 REPLICATION = 174, RESTORE = 175, RESTRICT = 176, RETURN = 177, 
                 RETURNS = 178, REVERT = 179, REVOKE = 180, RIGHT = 181, 
                 ROLLBACK = 182, ROWCOUNT = 183, ROWGUIDCOL = 184, RULE = 185, 
                 SAVE = 186, SCHEMA = 187, SECURITYAUDIT = 188, SELECT = 189, 
                 SEMANTICKEYPHRASETABLE = 190, SEMANTICSIMILARITYDETAILSTABLE = 191, 
                 SEMANTICSIMILARITYTABLE = 192, SERVER = 193, SERVICE = 194, 
                 SESSION_USER = 195, SET = 196, SETUSER = 197, SHUTDOWN = 198, 
                 SOME = 199, SOURCE = 200, STATISTICS = 201, SYSTEM_USER = 202, 
                 TABLE = 203, TABLESAMPLE = 204, TARGET = 205, TEXTSIZE = 206, 
                 THEN = 207, TO = 208, TOP = 209, TRAN = 210, TRANSACTION = 211, 
                 TRIGGER = 212, TRUNCATE = 213, TSEQUAL = 214, UNION = 215, 
                 UNIQUE = 216, UNPIVOT = 217, UPDATE = 218, UPDATETEXT = 219, 
                 USE = 220, USER = 221, VALUES = 222, VARYING = 223, VIEW = 224, 
                 WAITFOR = 225, WHEN = 226, WHERE = 227, WHILE = 228, WITH = 229, 
                 WITHIN = 230, WRITETEXT = 231, ABSOLUTE = 232, ACTION = 233, 
                 ACTIVE = 234, ACTIVATION = 235, AFTER = 236, ALGORITHM = 237, 
                 ALLOWED = 238, ALLOW_SNAPSHOT_ISOLATION = 239, ANSI_NULLS = 240, 
                 ANSI_NULL_DEFAULT = 241, ANSI_PADDING = 242, ANSI_WARNINGS = 243, 
                 APPLY = 244, ARITHABORT = 245, ASSEMBLY = 246, AUTO = 247, 
                 AUTO_CLEANUP = 248, AUTO_CLOSE = 249, AUTO_CREATE_STATISTICS = 250, 
                 AUTO_SHRINK = 251, AUTO_UPDATE_STATISTICS = 252, AUTO_UPDATE_STATISTICS_ASYNC = 253, 
                 AVG = 254, BINARY_BASE64 = 255, BINARY_CHECKSUM = 256, 
                 BULK_LOGGED = 257, CALLER = 258, CAST = 259, CATCH = 260, 
                 CHANGE_RETENTION = 261, CHANGE_TRACKING = 262, CHECKSUM = 263, 
                 CHECKSUM_AGG = 264, CLEANUP = 265, COLLECTION = 266, COMMITTED = 267, 
                 COMPATIBILITY_LEVEL = 268, CONCAT = 269, CONCAT_NULL_YIELDS_NULL = 270, 
                 CONTENT = 271, CONTROL = 272, COOKIE = 273, COUNT = 274, 
                 COUNT_BIG = 275, CREATE_NEW = 276, CREATION_DISPOSITION = 277, 
                 CURSOR_CLOSE_ON_COMMIT = 278, CURSOR_DEFAULT = 279, DATEADD = 280, 
                 DATEDIFF = 281, DATENAME = 282, DATEPART = 283, DATE_CORRELATION_OPTIMIZATION = 284, 
                 DAYS = 285, DB_CHAINING = 286, DECRYPTION = 287, DEFAULT_FULLTEXT_LANGUAGE = 288, 
                 DEFAULT_LANGUAGE = 289, DELAY = 290, DELAYED_DURABILITY = 291, 
                 DELETED = 292, DENSE_RANK = 293, DIALOG = 294, DIRECTORY_NAME = 295, 
                 DISABLE = 296, DISABLED = 297, DISABLE_BROKER = 298, DOCUMENT = 299, 
                 DYNAMIC = 300, EMERGENCY = 301, EMPTY = 302, ENABLE_BROKER = 303, 
                 ENCRYPTION = 304, ERROR_BROKER_CONVERSATIONS = 305, EXECUTABLE = 306, 
                 EXPAND = 307, EXPIRY_DATE = 308, EXPLICIT = 309, FAST = 310, 
                 FAST_FORWARD = 311, FILEGROUP = 312, FILEGROWTH = 313, 
                 FILESTREAM = 314, FIRST = 315, FOLLOWING = 316, FORCE = 317, 
                 FORCED = 318, FORWARD_ONLY = 319, FULLSCAN = 320, GB = 321, 
                 GETDATE = 322, GETUTCDATE = 323, GLOBAL = 324, GO = 325, 
                 GROUPING = 326, GROUPING_ID = 327, HADR = 328, HASH = 329, 
                 HONOR_BROKER_PRIORITY = 330, HOURS = 331, IDENTITY_VALUE = 332, 
                 IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX = 333, IMMEDIATE = 334, 
                 IMPERSONATE = 335, INCREMENTAL = 336, INITIATOR = 337, 
                 INPUT = 338, INSENSITIVE = 339, INSERTED = 340, ISOLATION = 341, 
                 KB = 342, KEEP = 343, KEEPFIXED = 344, KEYSET = 345, KEYS = 346, 
                 KEY_SOURCE = 347, LAST = 348, LEVEL = 349, LOB_COMPACTION = 350, 
                 LOCAL = 351, LOCK_ESCALATION = 352, LOGIN = 353, LOOP = 354, 
                 MARK = 355, MASTER_KEY = 356, MAX = 357, MAX_QUEUE_READERS = 358, 
                 MAXDOP = 359, MAXRECURSION = 360, MAXSIZE = 361, MESSAGE = 362, 
                 MB = 363, MEMORY_OPTIMIZED_DATA = 364, MIN = 365, MINUTES = 366, 
                 MIN_ACTIVE_ROWVERSION = 367, MIXED_PAGE_ALLOCATION = 368, 
                 MODIFY = 369, MOVE = 370, MULTI_USER = 371, NAME = 372, 
                 NESTED_TRIGGERS = 373, NEW_BROKER = 374, NEXT = 375, NOCOUNT = 376, 
                 NOEXPAND = 377, NON_TRANSACTED_ACCESS = 378, NORECOMPUTE = 379, 
                 NO = 380, NO_WAIT = 381, NTILE = 382, NUMBER = 383, NUMERIC_ROUNDABORT = 384, 
                 OFFLINE = 385, OFFSET = 386, ONLINE = 387, ONLY = 388, 
                 OPEN_EXISTING = 389, OPTIMISTIC = 390, OPTIMIZE = 391, 
                 OUT = 392, OUTPUT = 393, OWNER = 394, PAGE_VERIFY = 395, 
                 PARAMETERIZATION = 396, PARTITION = 397, PATH = 398, POISON_MESSAGE_HANDLING = 399, 
                 PRECEDING = 400, PRIOR = 401, PRIVATE = 402, PRIVILEGES = 403, 
                 PROCEDURE_NAME = 404, PROVIDER = 405, PROVIDER_KEY_NAME = 406, 
                 QUEUE = 407, QUOTED_IDENTIFIER = 408, RANGE = 409, RANK = 410, 
                 READONLY = 411, READ_COMMITTED_SNAPSHOT = 412, READ_ONLY = 413, 
                 READ_WRITE = 414, REBUILD = 415, RECOMPILE = 416, RECEIVE = 417, 
                 RECOVERY = 418, RECURSIVE_TRIGGERS = 419, RELATIVE = 420, 
                 REORGANIZE = 421, REMOTE = 422, REPEATABLE = 423, RESTRICTED_USER = 424, 
                 RETENTION = 425, ROBUST = 426, ROOT = 427, ROW = 428, ROWGUID = 429, 
                 ROWS = 430, ROW_NUMBER = 431, SAMPLE = 432, SCHEMABINDING = 433, 
                 SCROLL = 434, SCROLL_LOCKS = 435, SECONDS = 436, SELF = 437, 
                 SEND = 438, SENT = 439, SERIALIZABLE = 440, SETERROR = 441, 
                 SHOWPLAN = 442, SIMPLE = 443, SINGLE_USER = 444, SIZE = 445, 
                 SNAPSHOT = 446, SPATIAL_WINDOW_MAX_CELLS = 447, START_DATE = 448, 
                 STATIC = 449, STATS_STREAM = 450, STATUS = 451, STDEV = 452, 
                 STDEVP = 453, SUBJECT = 454, STUFF = 455, SUM = 456, SYMMETRIC = 457, 
                 TAKE = 458, TARGET_RECOVERY_TIME = 459, TB = 460, TEXTIMAGE_ON = 461, 
                 THROW = 462, TIES = 463, TIME = 464, TIMER = 465, TIMEOUT = 466, 
                 TORN_PAGE_DETECTION = 467, TRANSFORM_NOISE_WORDS = 468, 
                 TRUSTWORTHY = 469, TRY = 470, TWO_DIGIT_YEAR_CUTOFF = 471, 
                 TYPE = 472, TYPE_WARNING = 473, UNBOUNDED = 474, UNCOMMITTED = 475, 
                 UNKNOWN = 476, UNLIMITED = 477, USING = 478, VALIDATION = 479, 
                 VALID_XML = 480, VAR = 481, VARP = 482, VIEWS = 483, VIEW_METADATA = 484, 
                 WELL_FORMED_XML = 485, WORK = 486, XML = 487, XMLNAMESPACES = 488, 
                 DOLLAR_ACTION = 489, SPACE = 490, COMMENT = 491, LINE_COMMENT = 492, 
                 DOUBLE_QUOTE_ID = 493, SQUARE_BRACKET_ID = 494, LOCAL_ID = 495, 
                 DECIMAL = 496, ID = 497, STRING = 498, BINARY = 499, FLOAT = 500, 
                 REAL = 501, EQUAL = 502, GREATER = 503, LESS = 504, EXCLAMATION = 505, 
                 PLUS_ASSIGN = 506, MINUS_ASSIGN = 507, MULT_ASSIGN = 508, 
                 DIV_ASSIGN = 509, MOD_ASSIGN = 510, AND_ASSIGN = 511, XOR_ASSIGN = 512, 
                 OR_ASSIGN = 513, DOT = 514, UNDERLINE = 515, AT = 516, 
                 SHARP = 517, DOLLAR = 518, LR_BRACKET = 519, RR_BRACKET = 520, 
                 COMMA = 521, SEMI = 522, COLON = 523, STAR = 524, DIVIDE = 525, 
                 MODULE = 526, PLUS = 527, MINUS = 528, BIT_NOT = 529, BIT_OR = 530, 
                 BIT_AND = 531, BIT_XOR = 532
	}
	public static let RULE_tsql_file = 0, RULE_batch = 1, RULE_sql_clauses = 2, 
                   RULE_sql_clause = 3, RULE_dml_clause = 4, RULE_ddl_clause = 5, 
                   RULE_cfl_statement = 6, RULE_empty_statement = 7, RULE_another_statement = 8, 
                   RULE_create_queue = 9, RULE_queue_settings = 10, RULE_alter_queue = 11, 
                   RULE_queue_action = 12, RULE_queue_rebuild_options = 13, 
                   RULE_create_contract = 14, RULE_conversation_statement = 15, 
                   RULE_message_statement = 16, RULE_merge_statement = 17, 
                   RULE_merge_matched = 18, RULE_merge_not_matched = 19, 
                   RULE_delete_statement = 20, RULE_delete_statement_from = 21, 
                   RULE_insert_statement = 22, RULE_insert_statement_value = 23, 
                   RULE_receive_statement = 24, RULE_select_statement = 25, 
                   RULE_time = 26, RULE_update_statement = 27, RULE_output_clause = 28, 
                   RULE_output_dml_list_elem = 29, RULE_output_column_name = 30, 
                   RULE_create_database = 31, RULE_create_index = 32, RULE_create_or_alter_procedure = 33, 
                   RULE_create_or_alter_trigger = 34, RULE_dml_trigger = 35, 
                   RULE_dml_trigger_option = 36, RULE_dml_trigger_operation = 37, 
                   RULE_ddl_trigger = 38, RULE_ddl_trigger_operation = 39, 
                   RULE_create_or_alter_function = 40, RULE_func_body_returns_select = 41, 
                   RULE_func_body_returns_table = 42, RULE_func_body_returns_scalar = 43, 
                   RULE_procedure_param = 44, RULE_procedure_option = 45, 
                   RULE_function_option = 46, RULE_create_statistics = 47, 
                   RULE_create_table = 48, RULE_table_options = 49, RULE_table_option = 50, 
                   RULE_create_view = 51, RULE_view_attribute = 52, RULE_alter_table = 53, 
                   RULE_alter_database = 54, RULE_database_optionspec = 55, 
                   RULE_auto_option = 56, RULE_change_tracking_option = 57, 
                   RULE_change_tracking_option_list = 58, RULE_containment_option = 59, 
                   RULE_cursor_option = 60, RULE_date_correlation_optimization_option = 61, 
                   RULE_db_encryption_option = 62, RULE_db_state_option = 63, 
                   RULE_db_update_option = 64, RULE_db_user_access_option = 65, 
                   RULE_delayed_durability_option = 66, RULE_external_access_option = 67, 
                   RULE_hadr_options = 68, RULE_mixed_page_allocation_option = 69, 
                   RULE_parameterization_option = 70, RULE_recovery_option = 71, 
                   RULE_service_broker_option = 72, RULE_snapshot_option = 73, 
                   RULE_sql_option = 74, RULE_target_recovery_time_option = 75, 
                   RULE_termination = 76, RULE_drop_index = 77, RULE_drop_procedure = 78, 
                   RULE_drop_trigger = 79, RULE_drop_dml_trigger = 80, RULE_drop_ddl_trigger = 81, 
                   RULE_drop_function = 82, RULE_drop_statistics = 83, RULE_drop_table = 84, 
                   RULE_drop_view = 85, RULE_create_type = 86, RULE_drop_type = 87, 
                   RULE_rowset_function_limited = 88, RULE_openquery = 89, 
                   RULE_opendatasource = 90, RULE_declare_statement = 91, 
                   RULE_cursor_statement = 92, RULE_execute_statement = 93, 
                   RULE_execute_statement_arg = 94, RULE_execute_var_string = 95, 
                   RULE_security_statement = 96, RULE_create_certificate = 97, 
                   RULE_existing_keys = 98, RULE_private_key_options = 99, 
                   RULE_generate_new_keys = 100, RULE_date_options = 101, 
                   RULE_open_key = 102, RULE_close_key = 103, RULE_create_key = 104, 
                   RULE_key_options = 105, RULE_algorithm = 106, RULE_encryption_mechanism = 107, 
                   RULE_decryption_mechanism = 108, RULE_grant_permission = 109, 
                   RULE_set_statement = 110, RULE_transaction_statement = 111, 
                   RULE_go_statement = 112, RULE_use_statement = 113, RULE_dbcc_clause = 114, 
                   RULE_dbcc_options = 115, RULE_execute_clause = 116, RULE_declare_local = 117, 
                   RULE_table_type_definition = 118, RULE_xml_type_definition = 119, 
                   RULE_xml_schema_collection = 120, RULE_column_def_table_constraints = 121, 
                   RULE_column_def_table_constraint = 122, RULE_column_definition = 123, 
                   RULE_column_constraint = 124, RULE_table_constraint = 125, 
                   RULE_on_delete = 126, RULE_on_update = 127, RULE_index_options = 128, 
                   RULE_index_option = 129, RULE_declare_cursor = 130, RULE_declare_set_cursor_common = 131, 
                   RULE_declare_set_cursor_common_partial = 132, RULE_fetch_cursor = 133, 
                   RULE_set_special = 134, RULE_constant_LOCAL_ID = 135, 
                   RULE_expression = 136, RULE_constant_expression = 137, 
                   RULE_subquery = 138, RULE_with_expression = 139, RULE_common_table_expression = 140, 
                   RULE_update_elem = 141, RULE_search_condition_list = 142, 
                   RULE_search_condition = 143, RULE_search_condition_and = 144, 
                   RULE_search_condition_not = 145, RULE_predicate = 146, 
                   RULE_query_expression = 147, RULE_union = 148, RULE_query_specification = 149, 
                   RULE_top_clause = 150, RULE_top_percent = 151, RULE_top_count = 152, 
                   RULE_order_by_clause = 153, RULE_for_clause = 154, RULE_xml_common_directives = 155, 
                   RULE_order_by_expression = 156, RULE_group_by_item = 157, 
                   RULE_option_clause = 158, RULE_option = 159, RULE_optimize_for_arg = 160, 
                   RULE_select_list = 161, RULE_select_list_elem = 162, 
                   RULE_table_sources = 163, RULE_table_source = 164, RULE_table_source_item_joined = 165, 
                   RULE_table_source_item = 166, RULE_open_xml = 167, RULE_schema_declaration = 168, 
                   RULE_column_declaration = 169, RULE_change_table = 170, 
                   RULE_join_part = 171, RULE_pivot_clause = 172, RULE_unpivot_clause = 173, 
                   RULE_full_column_name_list = 174, RULE_table_name_with_hint = 175, 
                   RULE_rowset_function = 176, RULE_bulk_option = 177, RULE_derived_table = 178, 
                   RULE_function_call = 179, RULE_xml_data_type_methods = 180, 
                   RULE_value_method = 181, RULE_query_method = 182, RULE_exist_method = 183, 
                   RULE_modify_method = 184, RULE_nodes_method = 185, RULE_switch_section = 186, 
                   RULE_switch_search_condition_section = 187, RULE_as_table_alias = 188, 
                   RULE_table_alias = 189, RULE_with_table_hints = 190, 
                   RULE_insert_with_table_hints = 191, RULE_table_hint = 192, 
                   RULE_index_value = 193, RULE_column_alias_list = 194, 
                   RULE_column_alias = 195, RULE_table_value_constructor = 196, 
                   RULE_expression_list = 197, RULE_ranking_windowed_function = 198, 
                   RULE_aggregate_windowed_function = 199, RULE_all_distinct_expression = 200, 
                   RULE_over_clause = 201, RULE_row_or_range_clause = 202, 
                   RULE_window_frame_extent = 203, RULE_window_frame_bound = 204, 
                   RULE_window_frame_preceding = 205, RULE_window_frame_following = 206, 
                   RULE_create_database_option = 207, RULE_database_filestream_option = 208, 
                   RULE_database_file_spec = 209, RULE_file_group = 210, 
                   RULE_file_spec = 211, RULE_full_table_name = 212, RULE_table_name = 213, 
                   RULE_simple_name = 214, RULE_func_proc_name = 215, RULE_ddl_object = 216, 
                   RULE_full_column_name = 217, RULE_column_name_list_with_order = 218, 
                   RULE_column_name_list = 219, RULE_cursor_name = 220, 
                   RULE_on_off = 221, RULE_clustered = 222, RULE_null_notnull = 223, 
                   RULE_null_or_default = 224, RULE_scalar_function_name = 225, 
                   RULE_begin_conversation_timer = 226, RULE_begin_conversation_dialog = 227, 
                   RULE_contract_name = 228, RULE_service_name = 229, RULE_end_conversation = 230, 
                   RULE_waitfor_conversation = 231, RULE_get_conversation = 232, 
                   RULE_queue_id = 233, RULE_send_conversation = 234, RULE_data_type = 235, 
                   RULE_default_value = 236, RULE_constant = 237, RULE_sign = 238, 
                   RULE_id = 239, RULE_simple_id = 240, RULE_comparison_operator = 241, 
                   RULE_assignment_operator = 242, RULE_file_size = 243
	public static let ruleNames: [String] = [
		"tsql_file", "batch", "sql_clauses", "sql_clause", "dml_clause", "ddl_clause", 
		"cfl_statement", "empty_statement", "another_statement", "create_queue", 
		"queue_settings", "alter_queue", "queue_action", "queue_rebuild_options", 
		"create_contract", "conversation_statement", "message_statement", "merge_statement", 
		"merge_matched", "merge_not_matched", "delete_statement", "delete_statement_from", 
		"insert_statement", "insert_statement_value", "receive_statement", "select_statement", 
		"time", "update_statement", "output_clause", "output_dml_list_elem", "output_column_name", 
		"create_database", "create_index", "create_or_alter_procedure", "create_or_alter_trigger", 
		"dml_trigger", "dml_trigger_option", "dml_trigger_operation", "ddl_trigger", 
		"ddl_trigger_operation", "create_or_alter_function", "func_body_returns_select", 
		"func_body_returns_table", "func_body_returns_scalar", "procedure_param", 
		"procedure_option", "function_option", "create_statistics", "create_table", 
		"table_options", "table_option", "create_view", "view_attribute", "alter_table", 
		"alter_database", "database_optionspec", "auto_option", "change_tracking_option", 
		"change_tracking_option_list", "containment_option", "cursor_option", 
		"date_correlation_optimization_option", "db_encryption_option", "db_state_option", 
		"db_update_option", "db_user_access_option", "delayed_durability_option", 
		"external_access_option", "hadr_options", "mixed_page_allocation_option", 
		"parameterization_option", "recovery_option", "service_broker_option", 
		"snapshot_option", "sql_option", "target_recovery_time_option", "termination", 
		"drop_index", "drop_procedure", "drop_trigger", "drop_dml_trigger", "drop_ddl_trigger", 
		"drop_function", "drop_statistics", "drop_table", "drop_view", "create_type", 
		"drop_type", "rowset_function_limited", "openquery", "opendatasource", 
		"declare_statement", "cursor_statement", "execute_statement", "execute_statement_arg", 
		"execute_var_string", "security_statement", "create_certificate", "existing_keys", 
		"private_key_options", "generate_new_keys", "date_options", "open_key", 
		"close_key", "create_key", "key_options", "algorithm", "encryption_mechanism", 
		"decryption_mechanism", "grant_permission", "set_statement", "transaction_statement", 
		"go_statement", "use_statement", "dbcc_clause", "dbcc_options", "execute_clause", 
		"declare_local", "table_type_definition", "xml_type_definition", "xml_schema_collection", 
		"column_def_table_constraints", "column_def_table_constraint", "column_definition", 
		"column_constraint", "table_constraint", "on_delete", "on_update", "index_options", 
		"index_option", "declare_cursor", "declare_set_cursor_common", "declare_set_cursor_common_partial", 
		"fetch_cursor", "set_special", "constant_LOCAL_ID", "expression", "constant_expression", 
		"subquery", "with_expression", "common_table_expression", "update_elem", 
		"search_condition_list", "search_condition", "search_condition_and", "search_condition_not", 
		"predicate", "query_expression", "union", "query_specification", "top_clause", 
		"top_percent", "top_count", "order_by_clause", "for_clause", "xml_common_directives", 
		"order_by_expression", "group_by_item", "option_clause", "option", "optimize_for_arg", 
		"select_list", "select_list_elem", "table_sources", "table_source", "table_source_item_joined", 
		"table_source_item", "open_xml", "schema_declaration", "column_declaration", 
		"change_table", "join_part", "pivot_clause", "unpivot_clause", "full_column_name_list", 
		"table_name_with_hint", "rowset_function", "bulk_option", "derived_table", 
		"function_call", "xml_data_type_methods", "value_method", "query_method", 
		"exist_method", "modify_method", "nodes_method", "switch_section", "switch_search_condition_section", 
		"as_table_alias", "table_alias", "with_table_hints", "insert_with_table_hints", 
		"table_hint", "index_value", "column_alias_list", "column_alias", "table_value_constructor", 
		"expression_list", "ranking_windowed_function", "aggregate_windowed_function", 
		"all_distinct_expression", "over_clause", "row_or_range_clause", "window_frame_extent", 
		"window_frame_bound", "window_frame_preceding", "window_frame_following", 
		"create_database_option", "database_filestream_option", "database_file_spec", 
		"file_group", "file_spec", "full_table_name", "table_name", "simple_name", 
		"func_proc_name", "ddl_object", "full_column_name", "column_name_list_with_order", 
		"column_name_list", "cursor_name", "on_off", "clustered", "null_notnull", 
		"null_or_default", "scalar_function_name", "begin_conversation_timer", 
		"begin_conversation_dialog", "contract_name", "service_name", "end_conversation", 
		"waitfor_conversation", "get_conversation", "queue_id", "send_conversation", 
		"data_type", "default_value", "constant", "sign", "id", "simple_id", "comparison_operator", 
		"assignment_operator", "file_size"
	]

	private static let _LITERAL_NAMES: [String?] = [
		nil, "'DES'", "'TRIPLE_DES'", "'TRIPLE_DES_3KEY'", "'RC2'", "'RC4'", "'RC4_128'", 
		"'DESX'", "'AES_128'", "'AES_192'", "'AES_256'", "'.value('", "'.query('", 
		"'.exist('", "'.modify('", "'.nodes('", "'DESCRIPTION'", nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, nil, nil, nil, "'='", "'>'", "'<'", "'!'", "'+='", "'-='", 
		"'*='", "'/='", "'%='", "'&='", "'^='", "'|='", "'.'", "'_'", "'@'", "'#'", 
		"'$'", "'('", "')'", "','", "';'", "':'", "'*'", "'/'", "'%'", "'+'", 
		"'-'", "'~'", "'|'", "'&'", "'^'"
	]
	private static let _SYMBOLIC_NAMES: [String?] = [
		nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 
		nil, nil, nil, "ADD", "ALL", "ALTER", "AND", "ANY", "APPEND", "AS", "ASC", 
		"ASYMMETRIC", "AUTHORIZATION", "BACKUP", "BEGIN", "BETWEEN", "BREAK", 
		"BROWSE", "BULK", "BY", "CALLED", "CASCADE", "CASE", "CERTIFICATE", "CHANGETABLE", 
		"CHANGES", "CHECK", "CHECKPOINT", "CLOSE", "CLUSTERED", "COALESCE", "COLLATE", 
		"COLUMN", "COMMIT", "COMPUTE", "CONSTRAINT", "CONTAINMENT", "CONTAINS", 
		"CONTAINSTABLE", "CONTINUE", "CONTRACT", "CONVERSATION", "CONVERT", "CREATE", 
		"CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", 
		"CURRENT_USER", "CURSOR", "DATA_COMPRESSION", "DATABASE", "DBCC", "DEALLOCATE", 
		"DECLARE", "DEFAULT", "DELETE", "DENY", "DESC", "DISK", "DISTINCT", "DISTRIBUTED", 
		"DOUBLE", "DROP", "DUMP", "ELSE", "END", "ERRLVL", "ESCAPE", "ERROR", 
		"EVENTDATA", "EXCEPT", "EXECUTE", "EXISTS", "EXIT", "EXTERNAL", "FETCH", 
		"FILE", "FILENAME", "FILLFACTOR", "FOR", "FORCESEEK", "FOREIGN", "FREETEXT", 
		"FREETEXTTABLE", "FROM", "FULL", "FUNCTION", "GET", "GOTO", "GRANT", "GROUP", 
		"HAVING", "IDENTITY", "IDENTITYCOL", "IDENTITY_INSERT", "IF", "IN", "INCLUDE", 
		"INDEX", "INNER", "INSERT", "INSTEAD", "INTERSECT", "INTO", "IS", "ISNULL", 
		"JOIN", "KEY", "KILL", "LEFT", "LIFETIME", "LIKE", "LINENO", "LOAD", "LOG", 
		"MATCHED", "MERGE", "NATIONAL", "NOCHECK", "NONCLUSTERED", "NONE", "NOT", 
		"NULL", "NULLIF", "OF", "OFF", "OFFSETS", "ON", "OPEN", "OPENDATASOURCE", 
		"OPENQUERY", "OPENROWSET", "OPENXML", "OPTION", "OR", "ORDER", "OUTER", 
		"OVER", "PAGE", "PARTIAL", "PASSWORD", "PERCENT", "PIVOT", "PLAN", "PRECISION", 
		"PRIMARY", "PRINT", "PROC", "PROCEDURE", "PUBLIC", "RAISERROR", "RAW", 
		"READ", "READTEXT", "RECONFIGURE", "REFERENCES", "RELATED_CONVERSATION", 
		"RELATED_CONVERSATION_GROUP", "REPLICATION", "RESTORE", "RESTRICT", "RETURN", 
		"RETURNS", "REVERT", "REVOKE", "RIGHT", "ROLLBACK", "ROWCOUNT", "ROWGUIDCOL", 
		"RULE", "SAVE", "SCHEMA", "SECURITYAUDIT", "SELECT", "SEMANTICKEYPHRASETABLE", 
		"SEMANTICSIMILARITYDETAILSTABLE", "SEMANTICSIMILARITYTABLE", "SERVER", 
		"SERVICE", "SESSION_USER", "SET", "SETUSER", "SHUTDOWN", "SOME", "SOURCE", 
		"STATISTICS", "SYSTEM_USER", "TABLE", "TABLESAMPLE", "TARGET", "TEXTSIZE", 
		"THEN", "TO", "TOP", "TRAN", "TRANSACTION", "TRIGGER", "TRUNCATE", "TSEQUAL", 
		"UNION", "UNIQUE", "UNPIVOT", "UPDATE", "UPDATETEXT", "USE", "USER", "VALUES", 
		"VARYING", "VIEW", "WAITFOR", "WHEN", "WHERE", "WHILE", "WITH", "WITHIN", 
		"WRITETEXT", "ABSOLUTE", "ACTION", "ACTIVE", "ACTIVATION", "AFTER", "ALGORITHM", 
		"ALLOWED", "ALLOW_SNAPSHOT_ISOLATION", "ANSI_NULLS", "ANSI_NULL_DEFAULT", 
		"ANSI_PADDING", "ANSI_WARNINGS", "APPLY", "ARITHABORT", "ASSEMBLY", "AUTO", 
		"AUTO_CLEANUP", "AUTO_CLOSE", "AUTO_CREATE_STATISTICS", "AUTO_SHRINK", 
		"AUTO_UPDATE_STATISTICS", "AUTO_UPDATE_STATISTICS_ASYNC", "AVG", "BINARY_BASE64", 
		"BINARY_CHECKSUM", "BULK_LOGGED", "CALLER", "CAST", "CATCH", "CHANGE_RETENTION", 
		"CHANGE_TRACKING", "CHECKSUM", "CHECKSUM_AGG", "CLEANUP", "COLLECTION", 
		"COMMITTED", "COMPATIBILITY_LEVEL", "CONCAT", "CONCAT_NULL_YIELDS_NULL", 
		"CONTENT", "CONTROL", "COOKIE", "COUNT", "COUNT_BIG", "CREATE_NEW", "CREATION_DISPOSITION", 
		"CURSOR_CLOSE_ON_COMMIT", "CURSOR_DEFAULT", "DATEADD", "DATEDIFF", "DATENAME", 
		"DATEPART", "DATE_CORRELATION_OPTIMIZATION", "DAYS", "DB_CHAINING", "DECRYPTION", 
		"DEFAULT_FULLTEXT_LANGUAGE", "DEFAULT_LANGUAGE", "DELAY", "DELAYED_DURABILITY", 
		"DELETED", "DENSE_RANK", "DIALOG", "DIRECTORY_NAME", "DISABLE", "DISABLED", 
		"DISABLE_BROKER", "DOCUMENT", "DYNAMIC", "EMERGENCY", "EMPTY", "ENABLE_BROKER", 
		"ENCRYPTION", "ERROR_BROKER_CONVERSATIONS", "EXECUTABLE", "EXPAND", "EXPIRY_DATE", 
		"EXPLICIT", "FAST", "FAST_FORWARD", "FILEGROUP", "FILEGROWTH", "FILESTREAM", 
		"FIRST", "FOLLOWING", "FORCE", "FORCED", "FORWARD_ONLY", "FULLSCAN", "GB", 
		"GETDATE", "GETUTCDATE", "GLOBAL", "GO", "GROUPING", "GROUPING_ID", "HADR", 
		"HASH", "HONOR_BROKER_PRIORITY", "HOURS", "IDENTITY_VALUE", "IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX", 
		"IMMEDIATE", "IMPERSONATE", "INCREMENTAL", "INITIATOR", "INPUT", "INSENSITIVE", 
		"INSERTED", "ISOLATION", "KB", "KEEP", "KEEPFIXED", "KEYSET", "KEYS", 
		"KEY_SOURCE", "LAST", "LEVEL", "LOB_COMPACTION", "LOCAL", "LOCK_ESCALATION", 
		"LOGIN", "LOOP", "MARK", "MASTER_KEY", "MAX", "MAX_QUEUE_READERS", "MAXDOP", 
		"MAXRECURSION", "MAXSIZE", "MESSAGE", "MB", "MEMORY_OPTIMIZED_DATA", "MIN", 
		"MINUTES", "MIN_ACTIVE_ROWVERSION", "MIXED_PAGE_ALLOCATION", "MODIFY", 
		"MOVE", "MULTI_USER", "NAME", "NESTED_TRIGGERS", "NEW_BROKER", "NEXT", 
		"NOCOUNT", "NOEXPAND", "NON_TRANSACTED_ACCESS", "NORECOMPUTE", "NO", "NO_WAIT", 
		"NTILE", "NUMBER", "NUMERIC_ROUNDABORT", "OFFLINE", "OFFSET", "ONLINE", 
		"ONLY", "OPEN_EXISTING", "OPTIMISTIC", "OPTIMIZE", "OUT", "OUTPUT", "OWNER", 
		"PAGE_VERIFY", "PARAMETERIZATION", "PARTITION", "PATH", "POISON_MESSAGE_HANDLING", 
		"PRECEDING", "PRIOR", "PRIVATE", "PRIVILEGES", "PROCEDURE_NAME", "PROVIDER", 
		"PROVIDER_KEY_NAME", "QUEUE", "QUOTED_IDENTIFIER", "RANGE", "RANK", "READONLY", 
		"READ_COMMITTED_SNAPSHOT", "READ_ONLY", "READ_WRITE", "REBUILD", "RECOMPILE", 
		"RECEIVE", "RECOVERY", "RECURSIVE_TRIGGERS", "RELATIVE", "REORGANIZE", 
		"REMOTE", "REPEATABLE", "RESTRICTED_USER", "RETENTION", "ROBUST", "ROOT", 
		"ROW", "ROWGUID", "ROWS", "ROW_NUMBER", "SAMPLE", "SCHEMABINDING", "SCROLL", 
		"SCROLL_LOCKS", "SECONDS", "SELF", "SEND", "SENT", "SERIALIZABLE", "SETERROR", 
		"SHOWPLAN", "SIMPLE", "SINGLE_USER", "SIZE", "SNAPSHOT", "SPATIAL_WINDOW_MAX_CELLS", 
		"START_DATE", "STATIC", "STATS_STREAM", "STATUS", "STDEV", "STDEVP", "SUBJECT", 
		"STUFF", "SUM", "SYMMETRIC", "TAKE", "TARGET_RECOVERY_TIME", "TB", "TEXTIMAGE_ON", 
		"THROW", "TIES", "TIME", "TIMER", "TIMEOUT", "TORN_PAGE_DETECTION", "TRANSFORM_NOISE_WORDS", 
		"TRUSTWORTHY", "TRY", "TWO_DIGIT_YEAR_CUTOFF", "TYPE", "TYPE_WARNING", 
		"UNBOUNDED", "UNCOMMITTED", "UNKNOWN", "UNLIMITED", "USING", "VALIDATION", 
		"VALID_XML", "VAR", "VARP", "VIEWS", "VIEW_METADATA", "WELL_FORMED_XML", 
		"WORK", "XML", "XMLNAMESPACES", "DOLLAR_ACTION", "SPACE", "COMMENT", "LINE_COMMENT", 
		"DOUBLE_QUOTE_ID", "SQUARE_BRACKET_ID", "LOCAL_ID", "DECIMAL", "ID", "STRING", 
		"BINARY", "FLOAT", "REAL", "EQUAL", "GREATER", "LESS", "EXCLAMATION", 
		"PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", 
		"AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "DOT", "UNDERLINE", "AT", "SHARP", 
		"DOLLAR", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "COLON", "STAR", 
		"DIVIDE", "MODULE", "PLUS", "MINUS", "BIT_NOT", "BIT_OR", "BIT_AND", "BIT_XOR"
	]
	public static let VOCABULARY: Vocabulary = Vocabulary(_LITERAL_NAMES, _SYMBOLIC_NAMES)

	/**
	 * @deprecated Use {@link #VOCABULARY} instead.
	 */
	//@Deprecated
	public let tokenNames: [String?]? = {
	    let length = _SYMBOLIC_NAMES.count
	    var tokenNames = [String?](repeating: nil, count: length)
		for i in 0..<length {
			var name = VOCABULARY.getLiteralName(i)
			if name == nil {
				name = VOCABULARY.getSymbolicName(i)
			}
			if name == nil {
				name = "<INVALID>"
			}
			tokenNames[i] = name
		}
		return tokenNames
	}()

	override
	open func getTokenNames() -> [String?]? {
		return tokenNames
	}

	override
	open func getGrammarFileName() -> String { return "tsql.g4" }

	override
	open func getRuleNames() -> [String] { return tsqlParser.ruleNames }

	override
	open func getSerializedATN() -> String { return tsqlParser._serializedATN }

	override
	open func getATN() -> ATN { return tsqlParser._ATN }

	open override func getVocabulary() -> Vocabulary {
	    return tsqlParser.VOCABULARY
	}

	public override init(_ input:TokenStream)throws {
	    RuntimeMetaData.checkVersion("4.7", RuntimeMetaData.VERSION)
		try super.init(input)
		_interp = ParserATNSimulator(self,tsqlParser._ATN,tsqlParser._decisionToDFA, tsqlParser._sharedContextCache)
	}
	open class Tsql_fileContext:ParserRuleContext {
		open func EOF() -> TerminalNode? { return getToken(tsqlParser.Tokens.EOF.rawValue, 0) }
		open func batch() -> Array<BatchContext> {
			return getRuleContexts(BatchContext.self)
		}
		open func batch(_ i: Int) -> BatchContext? {
			return getRuleContext(BatchContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_tsql_file }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTsql_file(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTsql_file(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTsql_file(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTsql_file(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func tsql_file() throws -> Tsql_fileContext {
		var _localctx: Tsql_fileContext = Tsql_fileContext(_ctx, getState())
		try enterRule(_localctx, 0, tsqlParser.RULE_tsql_file)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(491)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, tsqlParser.Tokens.ALTER.rawValue,tsqlParser.Tokens.BEGIN.rawValue,tsqlParser.Tokens.BREAK.rawValue,tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.CLOSE.rawValue,tsqlParser.Tokens.COMMIT.rawValue,tsqlParser.Tokens.CONTINUE.rawValue,tsqlParser.Tokens.CREATE.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.DBCC.rawValue,tsqlParser.Tokens.DEALLOCATE.rawValue,tsqlParser.Tokens.DECLARE.rawValue,tsqlParser.Tokens.DELETE.rawValue,tsqlParser.Tokens.DROP.rawValue,tsqlParser.Tokens.END.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 19)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.EXECUTE.rawValue,tsqlParser.Tokens.FETCH.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue,tsqlParser.Tokens.GET.rawValue,tsqlParser.Tokens.GOTO.rawValue,tsqlParser.Tokens.GRANT.rawValue,tsqlParser.Tokens.IF.rawValue,tsqlParser.Tokens.INSERT.rawValue,tsqlParser.Tokens.MERGE.rawValue,tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.OPEN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 85)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PRINT.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAISERROR.rawValue,tsqlParser.Tokens.RAW.rawValue,tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.REVERT.rawValue,tsqlParser.Tokens.ROLLBACK.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SAVE.rawValue,tsqlParser.Tokens.SELECT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SET.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.TARGET.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 154)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.UPDATE.rawValue,tsqlParser.Tokens.USE.rawValue,tsqlParser.Tokens.WAITFOR.rawValue,tsqlParser.Tokens.WHILE.rawValue,tsqlParser.Tokens.WITH.rawValue,tsqlParser.Tokens.ABSOLUTE.rawValue,tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 218)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue,tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue,tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 290)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue,tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue,tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 354)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue,tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue,tsqlParser.Tokens.SEND.rawValue,tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 420)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue,tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.ID.rawValue,tsqlParser.Tokens.LR_BRACKET.rawValue,tsqlParser.Tokens.SEMI.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 484)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(488)
		 		try batch()


		 		setState(493)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(494)
		 	try match(tsqlParser.Tokens.EOF.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class BatchContext:ParserRuleContext {
		open func sql_clauses() -> Sql_clausesContext? {
			return getRuleContext(Sql_clausesContext.self,0)
		}
		open func go_statement() -> Array<Go_statementContext> {
			return getRuleContexts(Go_statementContext.self)
		}
		open func go_statement(_ i: Int) -> Go_statementContext? {
			return getRuleContext(Go_statementContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_batch }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterBatch(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitBatch(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitBatch(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitBatch(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func batch() throws -> BatchContext {
		var _localctx: BatchContext = BatchContext(_ctx, getState())
		try enterRule(_localctx, 2, tsqlParser.RULE_batch)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(496)
		 	try sql_clauses()
		 	setState(500)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.GO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(497)
		 		try go_statement()


		 		setState(502)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sql_clausesContext:ParserRuleContext {
		open func sql_clause() -> Array<Sql_clauseContext> {
			return getRuleContexts(Sql_clauseContext.self)
		}
		open func sql_clause(_ i: Int) -> Sql_clauseContext? {
			return getRuleContext(Sql_clauseContext.self,i)
		}
		open func SEMI() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.SEMI.rawValue) }
		open func SEMI(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.SEMI.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_sql_clauses }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSql_clauses(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSql_clauses(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSql_clauses(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSql_clauses(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sql_clauses() throws -> Sql_clausesContext {
		var _localctx: Sql_clausesContext = Sql_clausesContext(_ctx, getState())
		try enterRule(_localctx, 4, tsqlParser.RULE_sql_clauses)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(507); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(503)
		 			try sql_clause()
		 			setState(505)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,2,_ctx)) {
		 			case 1:
		 				setState(504)
		 				try match(tsqlParser.Tokens.SEMI.rawValue)

		 				break
		 			default: break
		 			}


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(509); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,3,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sql_clauseContext:ParserRuleContext {
		open func dml_clause() -> Dml_clauseContext? {
			return getRuleContext(Dml_clauseContext.self,0)
		}
		open func ddl_clause() -> Ddl_clauseContext? {
			return getRuleContext(Ddl_clauseContext.self,0)
		}
		open func cfl_statement() -> Cfl_statementContext? {
			return getRuleContext(Cfl_statementContext.self,0)
		}
		open func dbcc_clause() -> Dbcc_clauseContext? {
			return getRuleContext(Dbcc_clauseContext.self,0)
		}
		open func empty_statement() -> Empty_statementContext? {
			return getRuleContext(Empty_statementContext.self,0)
		}
		open func another_statement() -> Another_statementContext? {
			return getRuleContext(Another_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_sql_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSql_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSql_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSql_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSql_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sql_clause() throws -> Sql_clauseContext {
		var _localctx: Sql_clauseContext = Sql_clauseContext(_ctx, getState())
		try enterRule(_localctx, 6, tsqlParser.RULE_sql_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(517)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,4, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(511)
		 		try dml_clause()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(512)
		 		try ddl_clause()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(513)
		 		try cfl_statement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(514)
		 		try dbcc_clause()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(515)
		 		try empty_statement()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(516)
		 		try another_statement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_clauseContext:ParserRuleContext {
		open func merge_statement() -> Merge_statementContext? {
			return getRuleContext(Merge_statementContext.self,0)
		}
		open func delete_statement() -> Delete_statementContext? {
			return getRuleContext(Delete_statementContext.self,0)
		}
		open func insert_statement() -> Insert_statementContext? {
			return getRuleContext(Insert_statementContext.self,0)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func update_statement() -> Update_statementContext? {
			return getRuleContext(Update_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_dml_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDml_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDml_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDml_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDml_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_clause() throws -> Dml_clauseContext {
		var _localctx: Dml_clauseContext = Dml_clauseContext(_ctx, getState())
		try enterRule(_localctx, 8, tsqlParser.RULE_dml_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(524)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,5, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(519)
		 		try merge_statement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(520)
		 		try delete_statement()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(521)
		 		try insert_statement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(522)
		 		try select_statement()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(523)
		 		try update_statement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Ddl_clauseContext:ParserRuleContext {
		open func create_database() -> Create_databaseContext? {
			return getRuleContext(Create_databaseContext.self,0)
		}
		open func create_index() -> Create_indexContext? {
			return getRuleContext(Create_indexContext.self,0)
		}
		open func create_or_alter_procedure() -> Create_or_alter_procedureContext? {
			return getRuleContext(Create_or_alter_procedureContext.self,0)
		}
		open func create_or_alter_trigger() -> Create_or_alter_triggerContext? {
			return getRuleContext(Create_or_alter_triggerContext.self,0)
		}
		open func create_or_alter_function() -> Create_or_alter_functionContext? {
			return getRuleContext(Create_or_alter_functionContext.self,0)
		}
		open func create_statistics() -> Create_statisticsContext? {
			return getRuleContext(Create_statisticsContext.self,0)
		}
		open func create_table() -> Create_tableContext? {
			return getRuleContext(Create_tableContext.self,0)
		}
		open func create_type() -> Create_typeContext? {
			return getRuleContext(Create_typeContext.self,0)
		}
		open func create_view() -> Create_viewContext? {
			return getRuleContext(Create_viewContext.self,0)
		}
		open func alter_table() -> Alter_tableContext? {
			return getRuleContext(Alter_tableContext.self,0)
		}
		open func alter_database() -> Alter_databaseContext? {
			return getRuleContext(Alter_databaseContext.self,0)
		}
		open func drop_index() -> Drop_indexContext? {
			return getRuleContext(Drop_indexContext.self,0)
		}
		open func drop_procedure() -> Drop_procedureContext? {
			return getRuleContext(Drop_procedureContext.self,0)
		}
		open func drop_trigger() -> Drop_triggerContext? {
			return getRuleContext(Drop_triggerContext.self,0)
		}
		open func drop_function() -> Drop_functionContext? {
			return getRuleContext(Drop_functionContext.self,0)
		}
		open func drop_statistics() -> Drop_statisticsContext? {
			return getRuleContext(Drop_statisticsContext.self,0)
		}
		open func drop_table() -> Drop_tableContext? {
			return getRuleContext(Drop_tableContext.self,0)
		}
		open func drop_type() -> Drop_typeContext? {
			return getRuleContext(Drop_typeContext.self,0)
		}
		open func drop_view() -> Drop_viewContext? {
			return getRuleContext(Drop_viewContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_ddl_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDdl_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDdl_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDdl_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDdl_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func ddl_clause() throws -> Ddl_clauseContext {
		var _localctx: Ddl_clauseContext = Ddl_clauseContext(_ctx, getState())
		try enterRule(_localctx, 10, tsqlParser.RULE_ddl_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(545)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,6, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(526)
		 		try create_database()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(527)
		 		try create_index()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(528)
		 		try create_or_alter_procedure()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(529)
		 		try create_or_alter_trigger()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(530)
		 		try create_or_alter_function()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(531)
		 		try create_statistics()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(532)
		 		try create_table()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(533)
		 		try create_type()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(534)
		 		try create_view()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(535)
		 		try alter_table()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(536)
		 		try alter_database()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(537)
		 		try drop_index()

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(538)
		 		try drop_procedure()

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(539)
		 		try drop_trigger()

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(540)
		 		try drop_function()

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(541)
		 		try drop_statistics()

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(542)
		 		try drop_table()

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(543)
		 		try drop_type()

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(544)
		 		try drop_view()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cfl_statementContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_cfl_statement }
	 
		public  func copyFrom(_ ctx: Cfl_statementContext) {
			super.copyFrom(ctx)
		}
	}
	public  final class Waitfor_statementContext: Cfl_statementContext {
		open func WAITFOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.WAITFOR.rawValue, 0) }
		open func receive_statement() -> Receive_statementContext? {
			return getRuleContext(Receive_statementContext.self,0)
		}
		open func time() -> TimeContext? {
			return getRuleContext(TimeContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func DELAY() -> TerminalNode? { return getToken(tsqlParser.Tokens.DELAY.rawValue, 0) }
		open func TIME() -> TerminalNode? { return getToken(tsqlParser.Tokens.TIME.rawValue, 0) }
		open func TIMEOUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.TIMEOUT.rawValue, 0) }
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterWaitfor_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitWaitfor_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitWaitfor_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitWaitfor_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Print_statementContext: Cfl_statementContext {
		open func PRINT() -> TerminalNode? { return getToken(tsqlParser.Tokens.PRINT.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterPrint_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitPrint_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitPrint_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitPrint_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Continue_statementContext: Cfl_statementContext {
		open func CONTINUE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONTINUE.rawValue, 0) }
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterContinue_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitContinue_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitContinue_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitContinue_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class If_statementContext: Cfl_statementContext {
		open func IF() -> TerminalNode? { return getToken(tsqlParser.Tokens.IF.rawValue, 0) }
		open func search_condition() -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,0)
		}
		open func sql_clause() -> Array<Sql_clauseContext> {
			return getRuleContexts(Sql_clauseContext.self)
		}
		open func sql_clause(_ i: Int) -> Sql_clauseContext? {
			return getRuleContext(Sql_clauseContext.self,i)
		}
		open func ELSE() -> TerminalNode? { return getToken(tsqlParser.Tokens.ELSE.rawValue, 0) }
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterIf_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitIf_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitIf_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitIf_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Throw_statementContext: Cfl_statementContext {
		public var error_number: Token!
		public var message: Token!
		public var state: Token!
		open func THROW() -> TerminalNode? { return getToken(tsqlParser.Tokens.THROW.rawValue, 0) }
		open func DECIMAL() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.DECIMAL.rawValue) }
		open func DECIMAL(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.DECIMAL.rawValue, i)
		}
		open func LOCAL_ID() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.LOCAL_ID.rawValue) }
		open func LOCAL_ID(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, i)
		}
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterThrow_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitThrow_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitThrow_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitThrow_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Raiseerror_statementbContext: Cfl_statementContext {
		public var msg: Token!
		public var severity: Constant_LOCAL_IDContext!
		public var state: Constant_LOCAL_IDContext!
		open func RAISERROR() -> TerminalNode? { return getToken(tsqlParser.Tokens.RAISERROR.rawValue, 0) }
		open func constant_LOCAL_ID() -> Array<Constant_LOCAL_IDContext> {
			return getRuleContexts(Constant_LOCAL_IDContext.self)
		}
		open func constant_LOCAL_ID(_ i: Int) -> Constant_LOCAL_IDContext? {
			return getRuleContext(Constant_LOCAL_IDContext.self,i)
		}
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func LOG() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOG.rawValue, 0) }
		open func SETERROR() -> TerminalNode? { return getToken(tsqlParser.Tokens.SETERROR.rawValue, 0) }
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterRaiseerror_statementb(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitRaiseerror_statementb(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitRaiseerror_statementb(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitRaiseerror_statementb(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Try_catch_statementContext: Cfl_statementContext {
		public var try_clauses: Sql_clausesContext!
		public var catch_clauses: Sql_clausesContext!
		open func BEGIN() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.BEGIN.rawValue) }
		open func BEGIN(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.BEGIN.rawValue, i)
		}
		open func TRY() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.TRY.rawValue) }
		open func TRY(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.TRY.rawValue, i)
		}
		open func END() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.END.rawValue) }
		open func END(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.END.rawValue, i)
		}
		open func CATCH() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.CATCH.rawValue) }
		open func CATCH(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.CATCH.rawValue, i)
		}
		open func sql_clauses() -> Array<Sql_clausesContext> {
			return getRuleContexts(Sql_clausesContext.self)
		}
		open func sql_clauses(_ i: Int) -> Sql_clausesContext? {
			return getRuleContext(Sql_clausesContext.self,i)
		}
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTry_catch_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTry_catch_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTry_catch_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTry_catch_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class While_statementContext: Cfl_statementContext {
		open func WHILE() -> TerminalNode? { return getToken(tsqlParser.Tokens.WHILE.rawValue, 0) }
		open func search_condition() -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,0)
		}
		open func sql_clause() -> Sql_clauseContext? {
			return getRuleContext(Sql_clauseContext.self,0)
		}
		open func BREAK() -> TerminalNode? { return getToken(tsqlParser.Tokens.BREAK.rawValue, 0) }
		open func CONTINUE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONTINUE.rawValue, 0) }
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterWhile_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitWhile_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitWhile_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitWhile_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Block_statementContext: Cfl_statementContext {
		open func BEGIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.BEGIN.rawValue, 0) }
		open func END() -> TerminalNode? { return getToken(tsqlParser.Tokens.END.rawValue, 0) }
		open func sql_clauses() -> Sql_clausesContext? {
			return getRuleContext(Sql_clausesContext.self,0)
		}
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterBlock_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitBlock_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitBlock_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitBlock_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Break_statementContext: Cfl_statementContext {
		open func BREAK() -> TerminalNode? { return getToken(tsqlParser.Tokens.BREAK.rawValue, 0) }
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterBreak_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitBreak_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitBreak_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitBreak_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Goto_statementContext: Cfl_statementContext {
		open func GOTO() -> TerminalNode? { return getToken(tsqlParser.Tokens.GOTO.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterGoto_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitGoto_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitGoto_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitGoto_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Return_statementContext: Cfl_statementContext {
		open func RETURN() -> TerminalNode? { return getToken(tsqlParser.Tokens.RETURN.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		public init(_ ctx: Cfl_statementContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterReturn_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitReturn_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitReturn_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitReturn_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cfl_statement() throws -> Cfl_statementContext {
		var _localctx: Cfl_statementContext = Cfl_statementContext(_ctx, getState())
		try enterRule(_localctx, 12, tsqlParser.RULE_cfl_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(687)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,38, _ctx)) {
		 	case 1:
		 		_localctx =  Block_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(547)
		 		try match(tsqlParser.Tokens.BEGIN.rawValue)
		 		setState(549)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,7,_ctx)) {
		 		case 1:
		 			setState(548)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(552)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,8,_ctx)) {
		 		case 1:
		 			setState(551)
		 			try sql_clauses()

		 			break
		 		default: break
		 		}
		 		setState(554)
		 		try match(tsqlParser.Tokens.END.rawValue)
		 		setState(556)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,9,_ctx)) {
		 		case 1:
		 			setState(555)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		_localctx =  Break_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(558)
		 		try match(tsqlParser.Tokens.BREAK.rawValue)
		 		setState(560)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,10,_ctx)) {
		 		case 1:
		 			setState(559)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		_localctx =  Continue_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(562)
		 		try match(tsqlParser.Tokens.CONTINUE.rawValue)
		 		setState(564)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,11,_ctx)) {
		 		case 1:
		 			setState(563)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		_localctx =  Goto_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(566)
		 		try match(tsqlParser.Tokens.GOTO.rawValue)
		 		setState(567)
		 		try id()
		 		setState(569)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,12,_ctx)) {
		 		case 1:
		 			setState(568)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 5:
		 		_localctx =  Goto_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(571)
		 		try id()
		 		setState(572)
		 		try match(tsqlParser.Tokens.COLON.rawValue)
		 		setState(574)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,13,_ctx)) {
		 		case 1:
		 			setState(573)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 6:
		 		_localctx =  If_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(576)
		 		try match(tsqlParser.Tokens.IF.rawValue)
		 		setState(577)
		 		try search_condition()
		 		setState(578)
		 		try sql_clause()
		 		setState(581)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,14,_ctx)) {
		 		case 1:
		 			setState(579)
		 			try match(tsqlParser.Tokens.ELSE.rawValue)
		 			setState(580)
		 			try sql_clause()

		 			break
		 		default: break
		 		}
		 		setState(584)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,15,_ctx)) {
		 		case 1:
		 			setState(583)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 7:
		 		_localctx =  Return_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 7)
		 		setState(586)
		 		try match(tsqlParser.Tokens.RETURN.rawValue)
		 		setState(588)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,16,_ctx)) {
		 		case 1:
		 			setState(587)
		 			try expression(0)

		 			break
		 		default: break
		 		}
		 		setState(591)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,17,_ctx)) {
		 		case 1:
		 			setState(590)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 8:
		 		_localctx =  Throw_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 8)
		 		setState(593)
		 		try match(tsqlParser.Tokens.THROW.rawValue)
		 		setState(599)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.DECIMAL.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(594)
		 			_localctx.castdown(Throw_statementContext.self).error_number = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.DECIMAL.rawValue
		 			      return testSet
		 			 }())) {
		 				_localctx.castdown(Throw_statementContext.self).error_number = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(595)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(596)
		 			_localctx.castdown(Throw_statementContext.self).message = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.STRING.rawValue
		 			      return testSet
		 			 }())) {
		 				_localctx.castdown(Throw_statementContext.self).message = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(597)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(598)
		 			_localctx.castdown(Throw_statementContext.self).state = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.DECIMAL.rawValue
		 			      return testSet
		 			 }())) {
		 				_localctx.castdown(Throw_statementContext.self).state = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(602)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,19,_ctx)) {
		 		case 1:
		 			setState(601)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 9:
		 		_localctx =  Try_catch_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 9)
		 		setState(604)
		 		try match(tsqlParser.Tokens.BEGIN.rawValue)
		 		setState(605)
		 		try match(tsqlParser.Tokens.TRY.rawValue)
		 		setState(607)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,20,_ctx)) {
		 		case 1:
		 			setState(606)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(610)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,21,_ctx)) {
		 		case 1:
		 			setState(609)
		 			try {
		 					let assignmentValue = try sql_clauses()
		 					_localctx.castdown(Try_catch_statementContext.self).try_clauses = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(612)
		 		try match(tsqlParser.Tokens.END.rawValue)
		 		setState(613)
		 		try match(tsqlParser.Tokens.TRY.rawValue)
		 		setState(615)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.SEMI.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(614)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 		}

		 		setState(617)
		 		try match(tsqlParser.Tokens.BEGIN.rawValue)
		 		setState(618)
		 		try match(tsqlParser.Tokens.CATCH.rawValue)
		 		setState(620)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,23,_ctx)) {
		 		case 1:
		 			setState(619)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(623)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,24,_ctx)) {
		 		case 1:
		 			setState(622)
		 			try {
		 					let assignmentValue = try sql_clauses()
		 					_localctx.castdown(Try_catch_statementContext.self).catch_clauses = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(625)
		 		try match(tsqlParser.Tokens.END.rawValue)
		 		setState(626)
		 		try match(tsqlParser.Tokens.CATCH.rawValue)
		 		setState(628)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,25,_ctx)) {
		 		case 1:
		 			setState(627)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 10:
		 		_localctx =  Waitfor_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 10)
		 		setState(630)
		 		try match(tsqlParser.Tokens.WAITFOR.rawValue)
		 		setState(632)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,26,_ctx)) {
		 		case 1:
		 			setState(631)
		 			try receive_statement()

		 			break
		 		default: break
		 		}
		 		setState(635)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(634)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}

		 		setState(639)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,28,_ctx)) {
		 		case 1:
		 			setState(637)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == tsqlParser.Tokens.DELAY.rawValue
		 			          testSet = testSet || _la == tsqlParser.Tokens.TIME.rawValue || _la == tsqlParser.Tokens.TIMEOUT.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(638)
		 			try time()

		 			break
		 		default: break
		 		}
		 		setState(642)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,29,_ctx)) {
		 		case 1:
		 			setState(641)
		 			try expression(0)

		 			break
		 		default: break
		 		}
		 		setState(645)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,30,_ctx)) {
		 		case 1:
		 			setState(644)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 11:
		 		_localctx =  While_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 11)
		 		setState(647)
		 		try match(tsqlParser.Tokens.WHILE.rawValue)
		 		setState(648)
		 		try search_condition()
		 		setState(658)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,33, _ctx)) {
		 		case 1:
		 			setState(649)
		 			try sql_clause()

		 			break
		 		case 2:
		 			setState(650)
		 			try match(tsqlParser.Tokens.BREAK.rawValue)
		 			setState(652)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,31,_ctx)) {
		 			case 1:
		 				setState(651)
		 				try match(tsqlParser.Tokens.SEMI.rawValue)

		 				break
		 			default: break
		 			}

		 			break
		 		case 3:
		 			setState(654)
		 			try match(tsqlParser.Tokens.CONTINUE.rawValue)
		 			setState(656)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,32,_ctx)) {
		 			case 1:
		 				setState(655)
		 				try match(tsqlParser.Tokens.SEMI.rawValue)

		 				break
		 			default: break
		 			}

		 			break
		 		default: break
		 		}

		 		break
		 	case 12:
		 		_localctx =  Print_statementContext(_localctx);
		 		try enterOuterAlt(_localctx, 12)
		 		setState(660)
		 		try match(tsqlParser.Tokens.PRINT.rawValue)
		 		setState(661)
		 		try expression(0)
		 		setState(663)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,34,_ctx)) {
		 		case 1:
		 			setState(662)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 13:
		 		_localctx =  Raiseerror_statementbContext(_localctx);
		 		try enterOuterAlt(_localctx, 13)
		 		setState(665)
		 		try match(tsqlParser.Tokens.RAISERROR.rawValue)
		 		setState(666)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(667)
		 		_localctx.castdown(Raiseerror_statementbContext.self).msg = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.LOCAL_ID.rawValue,tsqlParser.Tokens.DECIMAL.rawValue,tsqlParser.Tokens.STRING.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 495)
		 		}()
		 		      return testSet
		 		 }())) {
		 			_localctx.castdown(Raiseerror_statementbContext.self).msg = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(668)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(669)
		 		try {
		 				let assignmentValue = try constant_LOCAL_ID()
		 				_localctx.castdown(Raiseerror_statementbContext.self).severity = assignmentValue
		 		     }()

		 		setState(670)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(671)
		 		try {
		 				let assignmentValue = try constant_LOCAL_ID()
		 				_localctx.castdown(Raiseerror_statementbContext.self).state = assignmentValue
		 		     }()

		 		setState(676)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(672)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(673)
		 			try constant_LOCAL_ID()


		 			setState(678)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(679)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(682)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,36,_ctx)) {
		 		case 1:
		 			setState(680)
		 			try match(tsqlParser.Tokens.WITH.rawValue)
		 			setState(681)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == tsqlParser.Tokens.LOG.rawValue
		 			          testSet = testSet || _la == tsqlParser.Tokens.SETERROR.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(685)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,37,_ctx)) {
		 		case 1:
		 			setState(684)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Empty_statementContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_empty_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterEmpty_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitEmpty_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitEmpty_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitEmpty_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func empty_statement() throws -> Empty_statementContext {
		var _localctx: Empty_statementContext = Empty_statementContext(_ctx, getState())
		try enterRule(_localctx, 14, tsqlParser.RULE_empty_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(689)
		 	try match(tsqlParser.Tokens.SEMI.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Another_statementContext:ParserRuleContext {
		open func declare_statement() -> Declare_statementContext? {
			return getRuleContext(Declare_statementContext.self,0)
		}
		open func cursor_statement() -> Cursor_statementContext? {
			return getRuleContext(Cursor_statementContext.self,0)
		}
		open func conversation_statement() -> Conversation_statementContext? {
			return getRuleContext(Conversation_statementContext.self,0)
		}
		open func create_contract() -> Create_contractContext? {
			return getRuleContext(Create_contractContext.self,0)
		}
		open func create_queue() -> Create_queueContext? {
			return getRuleContext(Create_queueContext.self,0)
		}
		open func alter_queue() -> Alter_queueContext? {
			return getRuleContext(Alter_queueContext.self,0)
		}
		open func execute_statement() -> Execute_statementContext? {
			return getRuleContext(Execute_statementContext.self,0)
		}
		open func message_statement() -> Message_statementContext? {
			return getRuleContext(Message_statementContext.self,0)
		}
		open func security_statement() -> Security_statementContext? {
			return getRuleContext(Security_statementContext.self,0)
		}
		open func set_statement() -> Set_statementContext? {
			return getRuleContext(Set_statementContext.self,0)
		}
		open func transaction_statement() -> Transaction_statementContext? {
			return getRuleContext(Transaction_statementContext.self,0)
		}
		open func use_statement() -> Use_statementContext? {
			return getRuleContext(Use_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_another_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterAnother_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitAnother_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitAnother_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitAnother_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func another_statement() throws -> Another_statementContext {
		var _localctx: Another_statementContext = Another_statementContext(_ctx, getState())
		try enterRule(_localctx, 16, tsqlParser.RULE_another_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(703)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,39, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(691)
		 		try declare_statement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(692)
		 		try cursor_statement()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(693)
		 		try conversation_statement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(694)
		 		try create_contract()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(695)
		 		try create_queue()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(696)
		 		try alter_queue()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(697)
		 		try execute_statement()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(698)
		 		try message_statement()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(699)
		 		try security_statement()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(700)
		 		try set_statement()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(701)
		 		try transaction_statement()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(702)
		 		try use_statement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_queueContext:ParserRuleContext {
		public var queue_name: IdContext!
		public var filegroup: IdContext!
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func QUEUE() -> TerminalNode? { return getToken(tsqlParser.Tokens.QUEUE.rawValue, 0) }
		open func full_table_name() -> Full_table_nameContext? {
			return getRuleContext(Full_table_nameContext.self,0)
		}
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func queue_settings() -> Queue_settingsContext? {
			return getRuleContext(Queue_settingsContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_queue }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_queue(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_queue(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_queue(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_queue(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_queue() throws -> Create_queueContext {
		var _localctx: Create_queueContext = Create_queueContext(_ctx, getState())
		try enterRule(_localctx, 18, tsqlParser.RULE_create_queue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(705)
		 	try match(tsqlParser.Tokens.CREATE.rawValue)
		 	setState(706)
		 	try match(tsqlParser.Tokens.QUEUE.rawValue)
		 	setState(709)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,40, _ctx)) {
		 	case 1:
		 		setState(707)
		 		try full_table_name()

		 		break
		 	case 2:
		 		setState(708)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Create_queueContext.self).queue_name = assignmentValue
		 		     }()


		 		break
		 	default: break
		 	}
		 	setState(712)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,41,_ctx)) {
		 	case 1:
		 		setState(711)
		 		try queue_settings()

		 		break
		 	default: break
		 	}
		 	setState(717)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ON:
		 	 	setState(714)
		 	 	try match(tsqlParser.Tokens.ON.rawValue)
		 	 	setState(715)
		 	 	try {
		 	 			let assignmentValue = try id()
		 	 			_localctx.castdown(Create_queueContext.self).filegroup = assignmentValue
		 	 	     }()


		 		break

		 	case .DEFAULT:
		 	 	setState(716)
		 	 	try match(tsqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	case .EOF:fallthrough
		 	case .ALTER:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BREAK:fallthrough
		 	case .CALLED:fallthrough
		 	case .CLOSE:fallthrough
		 	case .COMMIT:fallthrough
		 	case .CONTINUE:fallthrough
		 	case .CREATE:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .DBCC:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DECLARE:fallthrough
		 	case .DELETE:fallthrough
		 	case .DROP:fallthrough
		 	case .ELSE:fallthrough
		 	case .END:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .FETCH:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .GET:fallthrough
		 	case .GOTO:fallthrough
		 	case .GRANT:fallthrough
		 	case .IF:fallthrough
		 	case .INSERT:fallthrough
		 	case .MERGE:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .OPEN:fallthrough
		 	case .PAGE:fallthrough
		 	case .PRINT:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAISERROR:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .REVERT:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SAVE:fallthrough
		 	case .SELECT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SET:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .UPDATE:fallthrough
		 	case .USE:fallthrough
		 	case .WAITFOR:fallthrough
		 	case .WHILE:fallthrough
		 	case .WITH:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GO:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SEND:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .ID:fallthrough
		 	case .LR_BRACKET:fallthrough
		 	case .SEMI:
		 		break
		 	default:
		 		break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Queue_settingsContext:ParserRuleContext {
		public var max_readers: Token!
		public var user_name: Token!
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func STATUS() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.STATUS.rawValue) }
		open func STATUS(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.STATUS.rawValue, i)
		}
		open func EQUAL() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.EQUAL.rawValue) }
		open func EQUAL(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.EQUAL.rawValue, i)
		}
		open func RETENTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.RETENTION.rawValue, 0) }
		open func ACTIVATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ACTIVATION.rawValue, 0) }
		open func LR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.LR_BRACKET.rawValue, 0) }
		open func RR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.RR_BRACKET.rawValue, 0) }
		open func ON() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ON.rawValue) }
		open func ON(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ON.rawValue, i)
		}
		open func OFF() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.OFF.rawValue) }
		open func OFF(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.OFF.rawValue, i)
		}
		open func COMMA() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.COMMA.rawValue) }
		open func COMMA(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.COMMA.rawValue, i)
		}
		open func PROCEDURE_NAME() -> TerminalNode? { return getToken(tsqlParser.Tokens.PROCEDURE_NAME.rawValue, 0) }
		open func func_proc_name() -> Func_proc_nameContext? {
			return getRuleContext(Func_proc_nameContext.self,0)
		}
		open func MAX_QUEUE_READERS() -> TerminalNode? { return getToken(tsqlParser.Tokens.MAX_QUEUE_READERS.rawValue, 0) }
		open func EXECUTE() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXECUTE.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func POISON_MESSAGE_HANDLING() -> TerminalNode? { return getToken(tsqlParser.Tokens.POISON_MESSAGE_HANDLING.rawValue, 0) }
		open func DROP() -> TerminalNode? { return getToken(tsqlParser.Tokens.DROP.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func SELF() -> TerminalNode? { return getToken(tsqlParser.Tokens.SELF.rawValue, 0) }
		open func OWNER() -> TerminalNode? { return getToken(tsqlParser.Tokens.OWNER.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_queue_settings }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterQueue_settings(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitQueue_settings(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitQueue_settings(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitQueue_settings(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func queue_settings() throws -> Queue_settingsContext {
		var _localctx: Queue_settingsContext = Queue_settingsContext(_ctx, getState())
		try enterRule(_localctx, 20, tsqlParser.RULE_queue_settings)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(719)
		 	try match(tsqlParser.Tokens.WITH.rawValue)
		 	setState(726)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.STATUS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(720)
		 		try match(tsqlParser.Tokens.STATUS.rawValue)
		 		setState(721)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(722)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(724)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(723)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}


		 	}

		 	setState(734)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.RETENTION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(728)
		 		try match(tsqlParser.Tokens.RETENTION.rawValue)
		 		setState(729)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(730)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(732)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(731)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}


		 	}

		 	setState(790)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ACTIVATION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(736)
		 		try match(tsqlParser.Tokens.ACTIVATION.rawValue)
		 		setState(737)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(744)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,48,_ctx)) {
		 		case 1:
		 			setState(739)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(738)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)

		 			}

		 			setState(741)
		 			try match(tsqlParser.Tokens.STATUS.rawValue)
		 			setState(742)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(743)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(752)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,50,_ctx)) {
		 		case 1:
		 			setState(747)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(746)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)

		 			}

		 			setState(749)
		 			try match(tsqlParser.Tokens.PROCEDURE_NAME.rawValue)
		 			setState(750)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(751)
		 			try func_proc_name()

		 			break
		 		default: break
		 		}
		 		setState(760)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,52,_ctx)) {
		 		case 1:
		 			setState(755)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(754)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)

		 			}

		 			setState(757)
		 			try match(tsqlParser.Tokens.MAX_QUEUE_READERS.rawValue)
		 			setState(758)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(759)
		 			try {
		 					let assignmentValue = try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 					_localctx.castdown(Queue_settingsContext.self).max_readers = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(772)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,55,_ctx)) {
		 		case 1:
		 			setState(763)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(762)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)

		 			}

		 			setState(765)
		 			try match(tsqlParser.Tokens.EXECUTE.rawValue)
		 			setState(766)
		 			try match(tsqlParser.Tokens.AS.rawValue)
		 			setState(770)
		 			try _errHandler.sync(self)
		 			switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .SELF:
		 				setState(767)
		 				try match(tsqlParser.Tokens.SELF.rawValue)

		 				break

		 			case .STRING:
		 				setState(768)
		 				try {
		 						let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 						_localctx.castdown(Queue_settingsContext.self).user_name = assignmentValue
		 				     }()


		 				break

		 			case .OWNER:
		 				setState(769)
		 				try match(tsqlParser.Tokens.OWNER.rawValue)

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			break
		 		default: break
		 		}
		 		setState(781)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,57,_ctx)) {
		 		case 1:
		 			setState(775)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(774)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)

		 			}

		 			setState(777)
		 			try match(tsqlParser.Tokens.POISON_MESSAGE_HANDLING.rawValue)
		 			setState(778)
		 			try match(tsqlParser.Tokens.STATUS.rawValue)
		 			setState(779)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(780)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(787)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.DROP.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(784)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(783)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)

		 			}

		 			setState(786)
		 			try match(tsqlParser.Tokens.DROP.rawValue)

		 		}

		 		setState(789)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_queueContext:ParserRuleContext {
		public var queue_name: IdContext!
		open func ALTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALTER.rawValue, 0) }
		open func QUEUE() -> TerminalNode? { return getToken(tsqlParser.Tokens.QUEUE.rawValue, 0) }
		open func full_table_name() -> Full_table_nameContext? {
			return getRuleContext(Full_table_nameContext.self,0)
		}
		open func queue_settings() -> Queue_settingsContext? {
			return getRuleContext(Queue_settingsContext.self,0)
		}
		open func queue_action() -> Queue_actionContext? {
			return getRuleContext(Queue_actionContext.self,0)
		}
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_alter_queue }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterAlter_queue(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitAlter_queue(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitAlter_queue(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitAlter_queue(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_queue() throws -> Alter_queueContext {
		var _localctx: Alter_queueContext = Alter_queueContext(_ctx, getState())
		try enterRule(_localctx, 22, tsqlParser.RULE_alter_queue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(792)
		 	try match(tsqlParser.Tokens.ALTER.rawValue)
		 	setState(793)
		 	try match(tsqlParser.Tokens.QUEUE.rawValue)
		 	setState(796)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,61, _ctx)) {
		 	case 1:
		 		setState(794)
		 		try full_table_name()

		 		break
		 	case 2:
		 		setState(795)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Alter_queueContext.self).queue_name = assignmentValue
		 		     }()


		 		break
		 	default: break
		 	}
		 	setState(800)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .WITH:
		 		setState(798)
		 		try queue_settings()

		 		break
		 	case .MOVE:fallthrough
		 	case .REBUILD:fallthrough
		 	case .REORGANIZE:
		 		setState(799)
		 		try queue_action()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Queue_actionContext:ParserRuleContext {
		open func REBUILD() -> TerminalNode? { return getToken(tsqlParser.Tokens.REBUILD.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func LR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.LR_BRACKET.rawValue, 0) }
		open func queue_rebuild_options() -> Queue_rebuild_optionsContext? {
			return getRuleContext(Queue_rebuild_optionsContext.self,0)
		}
		open func RR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.RR_BRACKET.rawValue, 0) }
		open func REORGANIZE() -> TerminalNode? { return getToken(tsqlParser.Tokens.REORGANIZE.rawValue, 0) }
		open func LOB_COMPACTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOB_COMPACTION.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open func MOVE() -> TerminalNode? { return getToken(tsqlParser.Tokens.MOVE.rawValue, 0) }
		open func TO() -> TerminalNode? { return getToken(tsqlParser.Tokens.TO.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_queue_action }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterQueue_action(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitQueue_action(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitQueue_action(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitQueue_action(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func queue_action() throws -> Queue_actionContext {
		var _localctx: Queue_actionContext = Queue_actionContext(_ctx, getState())
		try enterRule(_localctx, 24, tsqlParser.RULE_queue_action)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(823)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .REBUILD:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(802)
		 		try match(tsqlParser.Tokens.REBUILD.rawValue)
		 		setState(808)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,63,_ctx)) {
		 		case 1:
		 			setState(803)
		 			try match(tsqlParser.Tokens.WITH.rawValue)
		 			setState(804)
		 			try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(805)
		 			try queue_rebuild_options()
		 			setState(806)
		 			try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}

		 		break

		 	case .REORGANIZE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(810)
		 		try match(tsqlParser.Tokens.REORGANIZE.rawValue)
		 		setState(815)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,64,_ctx)) {
		 		case 1:
		 			setState(811)
		 			try match(tsqlParser.Tokens.WITH.rawValue)
		 			setState(812)
		 			try match(tsqlParser.Tokens.LOB_COMPACTION.rawValue)
		 			setState(813)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(814)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}

		 		break

		 	case .MOVE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(817)
		 		try match(tsqlParser.Tokens.MOVE.rawValue)
		 		setState(818)
		 		try match(tsqlParser.Tokens.TO.rawValue)
		 		setState(821)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CALLED:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .ID:
		 			setState(819)
		 			try id()

		 			break

		 		case .DEFAULT:
		 			setState(820)
		 			try match(tsqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Queue_rebuild_optionsContext:ParserRuleContext {
		open func MAXDOP() -> TerminalNode? { return getToken(tsqlParser.Tokens.MAXDOP.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_queue_rebuild_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterQueue_rebuild_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitQueue_rebuild_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitQueue_rebuild_options(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitQueue_rebuild_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func queue_rebuild_options() throws -> Queue_rebuild_optionsContext {
		var _localctx: Queue_rebuild_optionsContext = Queue_rebuild_optionsContext(_ctx, getState())
		try enterRule(_localctx, 26, tsqlParser.RULE_queue_rebuild_options)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(825)
		 	try match(tsqlParser.Tokens.MAXDOP.rawValue)
		 	setState(826)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(827)
		 	try match(tsqlParser.Tokens.DECIMAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_contractContext:ParserRuleContext {
		public var owner_name: IdContext!
		public var message_type_name: IdContext!
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func CONTRACT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONTRACT.rawValue, 0) }
		open func contract_name() -> Contract_nameContext? {
			return getRuleContext(Contract_nameContext.self,0)
		}
		open func LR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.LR_BRACKET.rawValue, 0) }
		open func RR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.RR_BRACKET.rawValue, 0) }
		open func AUTHORIZATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTHORIZATION.rawValue, 0) }
		open func SENT() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.SENT.rawValue) }
		open func SENT(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.SENT.rawValue, i)
		}
		open func BY() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.BY.rawValue) }
		open func BY(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.BY.rawValue, i)
		}
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func INITIATOR() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.INITIATOR.rawValue) }
		open func INITIATOR(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.INITIATOR.rawValue, i)
		}
		open func TARGET() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.TARGET.rawValue) }
		open func TARGET(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.TARGET.rawValue, i)
		}
		open func ANY() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ANY.rawValue) }
		open func ANY(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ANY.rawValue, i)
		}
		open func DEFAULT() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.DEFAULT.rawValue) }
		open func DEFAULT(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.DEFAULT.rawValue, i)
		}
		open func COMMA() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.COMMA.rawValue) }
		open func COMMA(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.COMMA.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_contract }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_contract(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_contract(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_contract(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_contract(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_contract() throws -> Create_contractContext {
		var _localctx: Create_contractContext = Create_contractContext(_ctx, getState())
		try enterRule(_localctx, 28, tsqlParser.RULE_create_contract)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(829)
		 	try match(tsqlParser.Tokens.CREATE.rawValue)
		 	setState(830)
		 	try match(tsqlParser.Tokens.CONTRACT.rawValue)
		 	setState(831)
		 	try contract_name()
		 	setState(834)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.AUTHORIZATION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(832)
		 		try match(tsqlParser.Tokens.AUTHORIZATION.rawValue)
		 		setState(833)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Create_contractContext.self).owner_name = assignmentValue
		 		     }()


		 	}

		 	setState(836)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(847) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(839)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CALLED:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .ID:
		 			setState(837)
		 			try {
		 					let assignmentValue = try id()
		 					_localctx.castdown(Create_contractContext.self).message_type_name = assignmentValue
		 			     }()


		 			break

		 		case .DEFAULT:
		 			setState(838)
		 			try match(tsqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(841)
		 		try match(tsqlParser.Tokens.SENT.rawValue)
		 		setState(842)
		 		try match(tsqlParser.Tokens.BY.rawValue)
		 		setState(843)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.ANY.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.TARGET.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.INITIATOR.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(845)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(844)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}



		 		setState(849); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.DEFAULT.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 34)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue,tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.TARGET.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 142)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.ABSOLUTE.rawValue,tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 232)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue,tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 296)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue,tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 360)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue,tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 426)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 493)
		 	          }()
		 	      return testSet
		 	 }())
		 	setState(851)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Conversation_statementContext:ParserRuleContext {
		open func begin_conversation_timer() -> Begin_conversation_timerContext? {
			return getRuleContext(Begin_conversation_timerContext.self,0)
		}
		open func begin_conversation_dialog() -> Begin_conversation_dialogContext? {
			return getRuleContext(Begin_conversation_dialogContext.self,0)
		}
		open func end_conversation() -> End_conversationContext? {
			return getRuleContext(End_conversationContext.self,0)
		}
		open func get_conversation() -> Get_conversationContext? {
			return getRuleContext(Get_conversationContext.self,0)
		}
		open func send_conversation() -> Send_conversationContext? {
			return getRuleContext(Send_conversationContext.self,0)
		}
		open func waitfor_conversation() -> Waitfor_conversationContext? {
			return getRuleContext(Waitfor_conversationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_conversation_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterConversation_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitConversation_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitConversation_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitConversation_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func conversation_statement() throws -> Conversation_statementContext {
		var _localctx: Conversation_statementContext = Conversation_statementContext(_ctx, getState())
		try enterRule(_localctx, 30, tsqlParser.RULE_conversation_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(859)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,71, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(853)
		 		try begin_conversation_timer()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(854)
		 		try begin_conversation_dialog()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(855)
		 		try end_conversation()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(856)
		 		try get_conversation()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(857)
		 		try send_conversation()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(858)
		 		try waitfor_conversation()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Message_statementContext:ParserRuleContext {
		public var message_type_name: IdContext!
		public var owner_name: IdContext!
		public var schema_collection_name: IdContext!
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func MESSAGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.MESSAGE.rawValue, 0) }
		open func TYPE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TYPE.rawValue, 0) }
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func VALIDATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.VALIDATION.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func AUTHORIZATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTHORIZATION.rawValue, 0) }
		open func NONE() -> TerminalNode? { return getToken(tsqlParser.Tokens.NONE.rawValue, 0) }
		open func EMPTY() -> TerminalNode? { return getToken(tsqlParser.Tokens.EMPTY.rawValue, 0) }
		open func WELL_FORMED_XML() -> TerminalNode? { return getToken(tsqlParser.Tokens.WELL_FORMED_XML.rawValue, 0) }
		open func VALID_XML() -> TerminalNode? { return getToken(tsqlParser.Tokens.VALID_XML.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func SCHEMA() -> TerminalNode? { return getToken(tsqlParser.Tokens.SCHEMA.rawValue, 0) }
		open func COLLECTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.COLLECTION.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_message_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterMessage_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitMessage_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitMessage_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitMessage_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func message_statement() throws -> Message_statementContext {
		var _localctx: Message_statementContext = Message_statementContext(_ctx, getState())
		try enterRule(_localctx, 32, tsqlParser.RULE_message_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(861)
		 	try match(tsqlParser.Tokens.CREATE.rawValue)
		 	setState(862)
		 	try match(tsqlParser.Tokens.MESSAGE.rawValue)
		 	setState(863)
		 	try match(tsqlParser.Tokens.TYPE.rawValue)
		 	setState(864)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(Message_statementContext.self).message_type_name = assignmentValue
		 	     }()

		 	setState(867)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.AUTHORIZATION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(865)
		 		try match(tsqlParser.Tokens.AUTHORIZATION.rawValue)
		 		setState(866)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Message_statementContext.self).owner_name = assignmentValue
		 		     }()


		 	}

		 	setState(869)
		 	try match(tsqlParser.Tokens.VALIDATION.rawValue)
		 	setState(870)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(879)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NONE:
		 		setState(871)
		 		try match(tsqlParser.Tokens.NONE.rawValue)

		 		break

		 	case .EMPTY:
		 		setState(872)
		 		try match(tsqlParser.Tokens.EMPTY.rawValue)

		 		break

		 	case .WELL_FORMED_XML:
		 		setState(873)
		 		try match(tsqlParser.Tokens.WELL_FORMED_XML.rawValue)

		 		break

		 	case .VALID_XML:
		 		setState(874)
		 		try match(tsqlParser.Tokens.VALID_XML.rawValue)
		 		setState(875)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(876)
		 		try match(tsqlParser.Tokens.SCHEMA.rawValue)
		 		setState(877)
		 		try match(tsqlParser.Tokens.COLLECTION.rawValue)
		 		setState(878)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Message_statementContext.self).schema_collection_name = assignmentValue
		 		     }()


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_statementContext:ParserRuleContext {
		open func MERGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.MERGE.rawValue, 0) }
		open func ddl_object() -> Ddl_objectContext? {
			return getRuleContext(Ddl_objectContext.self,0)
		}
		open func USING() -> TerminalNode? { return getToken(tsqlParser.Tokens.USING.rawValue, 0) }
		open func table_sources() -> Table_sourcesContext? {
			return getRuleContext(Table_sourcesContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func search_condition() -> Array<Search_conditionContext> {
			return getRuleContexts(Search_conditionContext.self)
		}
		open func search_condition(_ i: Int) -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,i)
		}
		open func with_expression() -> With_expressionContext? {
			return getRuleContext(With_expressionContext.self,0)
		}
		open func TOP() -> TerminalNode? { return getToken(tsqlParser.Tokens.TOP.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func INTO() -> TerminalNode? { return getToken(tsqlParser.Tokens.INTO.rawValue, 0) }
		open func insert_with_table_hints() -> Insert_with_table_hintsContext? {
			return getRuleContext(Insert_with_table_hintsContext.self,0)
		}
		open func as_table_alias() -> As_table_aliasContext? {
			return getRuleContext(As_table_aliasContext.self,0)
		}
		open func WHEN() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.WHEN.rawValue) }
		open func WHEN(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.WHEN.rawValue, i)
		}
		open func MATCHED() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.MATCHED.rawValue) }
		open func MATCHED(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.MATCHED.rawValue, i)
		}
		open func THEN() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.THEN.rawValue) }
		open func THEN(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.THEN.rawValue, i)
		}
		open func merge_matched() -> Array<Merge_matchedContext> {
			return getRuleContexts(Merge_matchedContext.self)
		}
		open func merge_matched(_ i: Int) -> Merge_matchedContext? {
			return getRuleContext(Merge_matchedContext.self,i)
		}
		open func NOT() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.NOT.rawValue) }
		open func NOT(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.NOT.rawValue, i)
		}
		open func merge_not_matched() -> Merge_not_matchedContext? {
			return getRuleContext(Merge_not_matchedContext.self,0)
		}
		open func BY() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.BY.rawValue) }
		open func BY(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.BY.rawValue, i)
		}
		open func SOURCE() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.SOURCE.rawValue) }
		open func SOURCE(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.SOURCE.rawValue, i)
		}
		open func output_clause() -> Output_clauseContext? {
			return getRuleContext(Output_clauseContext.self,0)
		}
		open func option_clause() -> Option_clauseContext? {
			return getRuleContext(Option_clauseContext.self,0)
		}
		open func PERCENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.PERCENT.rawValue, 0) }
		open func AND() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.AND.rawValue) }
		open func AND(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.AND.rawValue, i)
		}
		open func TARGET() -> TerminalNode? { return getToken(tsqlParser.Tokens.TARGET.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_merge_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterMerge_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitMerge_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitMerge_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitMerge_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_statement() throws -> Merge_statementContext {
		var _localctx: Merge_statementContext = Merge_statementContext(_ctx, getState())
		try enterRule(_localctx, 34, tsqlParser.RULE_merge_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(882)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(881)
		 		try with_expression()

		 	}

		 	setState(884)
		 	try match(tsqlParser.Tokens.MERGE.rawValue)
		 	setState(892)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.TOP.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(885)
		 		try match(tsqlParser.Tokens.TOP.rawValue)
		 		setState(886)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(887)
		 		try expression(0)
		 		setState(888)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(890)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.PERCENT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(889)
		 			try match(tsqlParser.Tokens.PERCENT.rawValue)

		 		}


		 	}

		 	setState(895)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(894)
		 		try match(tsqlParser.Tokens.INTO.rawValue)

		 	}

		 	setState(897)
		 	try ddl_object()
		 	setState(899)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(898)
		 		try insert_with_table_hints()

		 	}

		 	setState(902)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,79,_ctx)) {
		 	case 1:
		 		setState(901)
		 		try as_table_alias()

		 		break
		 	default: break
		 	}
		 	setState(904)
		 	try match(tsqlParser.Tokens.USING.rawValue)
		 	setState(905)
		 	try table_sources()
		 	setState(906)
		 	try match(tsqlParser.Tokens.ON.rawValue)
		 	setState(907)
		 	try search_condition()
		 	setState(918)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,81,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(908)
		 			try match(tsqlParser.Tokens.WHEN.rawValue)
		 			setState(909)
		 			try match(tsqlParser.Tokens.MATCHED.rawValue)
		 			setState(912)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.AND.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(910)
		 				try match(tsqlParser.Tokens.AND.rawValue)
		 				setState(911)
		 				try search_condition()

		 			}

		 			setState(914)
		 			try match(tsqlParser.Tokens.THEN.rawValue)
		 			setState(915)
		 			try merge_matched()

		 	 
		 		}
		 		setState(920)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,81,_ctx)
		 	}
		 	setState(934)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,84,_ctx)) {
		 	case 1:
		 		setState(921)
		 		try match(tsqlParser.Tokens.WHEN.rawValue)
		 		setState(922)
		 		try match(tsqlParser.Tokens.NOT.rawValue)
		 		setState(923)
		 		try match(tsqlParser.Tokens.MATCHED.rawValue)
		 		setState(926)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.BY.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(924)
		 			try match(tsqlParser.Tokens.BY.rawValue)
		 			setState(925)
		 			try match(tsqlParser.Tokens.TARGET.rawValue)

		 		}

		 		setState(930)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.AND.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(928)
		 			try match(tsqlParser.Tokens.AND.rawValue)
		 			setState(929)
		 			try search_condition()

		 		}

		 		setState(932)
		 		try match(tsqlParser.Tokens.THEN.rawValue)
		 		setState(933)
		 		try merge_not_matched()

		 		break
		 	default: break
		 	}
		 	setState(949)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WHEN.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(936)
		 		try match(tsqlParser.Tokens.WHEN.rawValue)
		 		setState(937)
		 		try match(tsqlParser.Tokens.NOT.rawValue)
		 		setState(938)
		 		try match(tsqlParser.Tokens.MATCHED.rawValue)
		 		setState(939)
		 		try match(tsqlParser.Tokens.BY.rawValue)
		 		setState(940)
		 		try match(tsqlParser.Tokens.SOURCE.rawValue)
		 		setState(943)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.AND.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(941)
		 			try match(tsqlParser.Tokens.AND.rawValue)
		 			setState(942)
		 			try search_condition()

		 		}

		 		setState(945)
		 		try match(tsqlParser.Tokens.THEN.rawValue)
		 		setState(946)
		 		try merge_matched()


		 		setState(951)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(953)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.OUTPUT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(952)
		 		try output_clause()

		 	}

		 	setState(956)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.OPTION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(955)
		 		try option_clause()

		 	}

		 	setState(958)
		 	try match(tsqlParser.Tokens.SEMI.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_matchedContext:ParserRuleContext {
		open func UPDATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func SET() -> TerminalNode? { return getToken(tsqlParser.Tokens.SET.rawValue, 0) }
		open func update_elem() -> Array<Update_elemContext> {
			return getRuleContexts(Update_elemContext.self)
		}
		open func update_elem(_ i: Int) -> Update_elemContext? {
			return getRuleContext(Update_elemContext.self,i)
		}
		open func DELETE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DELETE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_merge_matched }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterMerge_matched(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitMerge_matched(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitMerge_matched(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitMerge_matched(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_matched() throws -> Merge_matchedContext {
		var _localctx: Merge_matchedContext = Merge_matchedContext(_ctx, getState())
		try enterRule(_localctx, 36, tsqlParser.RULE_merge_matched)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(971)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .UPDATE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(960)
		 		try match(tsqlParser.Tokens.UPDATE.rawValue)
		 		setState(961)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(962)
		 		try update_elem()
		 		setState(967)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(963)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(964)
		 			try update_elem()


		 			setState(969)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break

		 	case .DELETE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(970)
		 		try match(tsqlParser.Tokens.DELETE.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Merge_not_matchedContext:ParserRuleContext {
		open func INSERT() -> TerminalNode? { return getToken(tsqlParser.Tokens.INSERT.rawValue, 0) }
		open func table_value_constructor() -> Table_value_constructorContext? {
			return getRuleContext(Table_value_constructorContext.self,0)
		}
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open func VALUES() -> TerminalNode? { return getToken(tsqlParser.Tokens.VALUES.rawValue, 0) }
		open func column_name_list() -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_merge_not_matched }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterMerge_not_matched(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitMerge_not_matched(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitMerge_not_matched(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitMerge_not_matched(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func merge_not_matched() throws -> Merge_not_matchedContext {
		var _localctx: Merge_not_matchedContext = Merge_not_matchedContext(_ctx, getState())
		try enterRule(_localctx, 38, tsqlParser.RULE_merge_not_matched)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(973)
		 	try match(tsqlParser.Tokens.INSERT.rawValue)
		 	setState(978)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LR_BRACKET.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(974)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(975)
		 		try column_name_list()
		 		setState(976)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(983)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .VALUES:
		 		setState(980)
		 		try table_value_constructor()

		 		break

		 	case .DEFAULT:
		 		setState(981)
		 		try match(tsqlParser.Tokens.DEFAULT.rawValue)
		 		setState(982)
		 		try match(tsqlParser.Tokens.VALUES.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Delete_statementContext:ParserRuleContext {
		public var cursor_var: Token!
		open func DELETE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DELETE.rawValue, 0) }
		open func delete_statement_from() -> Delete_statement_fromContext? {
			return getRuleContext(Delete_statement_fromContext.self,0)
		}
		open func with_expression() -> With_expressionContext? {
			return getRuleContext(With_expressionContext.self,0)
		}
		open func TOP() -> TerminalNode? { return getToken(tsqlParser.Tokens.TOP.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func FROM() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.FROM.rawValue) }
		open func FROM(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.FROM.rawValue, i)
		}
		open func insert_with_table_hints() -> Insert_with_table_hintsContext? {
			return getRuleContext(Insert_with_table_hintsContext.self,0)
		}
		open func output_clause() -> Output_clauseContext? {
			return getRuleContext(Output_clauseContext.self,0)
		}
		open func table_sources() -> Table_sourcesContext? {
			return getRuleContext(Table_sourcesContext.self,0)
		}
		open func WHERE() -> TerminalNode? { return getToken(tsqlParser.Tokens.WHERE.rawValue, 0) }
		open func for_clause() -> For_clauseContext? {
			return getRuleContext(For_clauseContext.self,0)
		}
		open func option_clause() -> Option_clauseContext? {
			return getRuleContext(Option_clauseContext.self,0)
		}
		open func search_condition() -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,0)
		}
		open func CURRENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CURRENT.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OF.rawValue, 0) }
		open func PERCENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.PERCENT.rawValue, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func GLOBAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.GLOBAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_delete_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDelete_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDelete_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDelete_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDelete_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func delete_statement() throws -> Delete_statementContext {
		var _localctx: Delete_statementContext = Delete_statementContext(_ctx, getState())
		try enterRule(_localctx, 40, tsqlParser.RULE_delete_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(986)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(985)
		 		try with_expression()

		 	}

		 	setState(988)
		 	try match(tsqlParser.Tokens.DELETE.rawValue)
		 	setState(996)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.TOP.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(989)
		 		try match(tsqlParser.Tokens.TOP.rawValue)
		 		setState(990)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(991)
		 		try expression(0)
		 		setState(992)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(994)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.PERCENT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(993)
		 			try match(tsqlParser.Tokens.PERCENT.rawValue)

		 		}


		 	}

		 	setState(999)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.FROM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(998)
		 		try match(tsqlParser.Tokens.FROM.rawValue)

		 	}

		 	setState(1001)
		 	try delete_statement_from()
		 	setState(1003)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,97,_ctx)) {
		 	case 1:
		 		setState(1002)
		 		try insert_with_table_hints()

		 		break
		 	default: break
		 	}
		 	setState(1006)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,98,_ctx)) {
		 	case 1:
		 		setState(1005)
		 		try output_clause()

		 		break
		 	default: break
		 	}
		 	setState(1010)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.FROM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1008)
		 		try match(tsqlParser.Tokens.FROM.rawValue)
		 		setState(1009)
		 		try table_sources()

		 	}

		 	setState(1025)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WHERE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1012)
		 		try match(tsqlParser.Tokens.WHERE.rawValue)
		 		setState(1023)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CALLED:fallthrough
		 		case .CASE:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CONVERT:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .EXISTS:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .IDENTITY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NOT:fallthrough
		 		case .NULL:fallthrough
		 		case .NULLIF:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .OVER:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .RIGHT:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .BINARY_CHECKSUM:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DATEADD:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATENAME:fallthrough
		 		case .DATEPART:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GETDATE:fallthrough
		 		case .GETUTCDATE:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MIN_ACTIVE_ROWVERSION:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .STUFF:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .LOCAL_ID:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .ID:fallthrough
		 		case .STRING:fallthrough
		 		case .BINARY:fallthrough
		 		case .FLOAT:fallthrough
		 		case .REAL:fallthrough
		 		case .DOLLAR:fallthrough
		 		case .LR_BRACKET:fallthrough
		 		case .PLUS:fallthrough
		 		case .MINUS:fallthrough
		 		case .BIT_NOT:
		 			setState(1013)
		 			try search_condition()

		 			break

		 		case .CURRENT:
		 			setState(1014)
		 			try match(tsqlParser.Tokens.CURRENT.rawValue)
		 			setState(1015)
		 			try match(tsqlParser.Tokens.OF.rawValue)
		 			setState(1021)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,101, _ctx)) {
		 			case 1:
		 				setState(1017)
		 				try _errHandler.sync(self)
		 				switch (try getInterpreter().adaptivePredict(_input,100,_ctx)) {
		 				case 1:
		 					setState(1016)
		 					try match(tsqlParser.Tokens.GLOBAL.rawValue)

		 					break
		 				default: break
		 				}
		 				setState(1019)
		 				try cursor_name()

		 				break
		 			case 2:
		 				setState(1020)
		 				try {
		 						let assignmentValue = try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 						_localctx.castdown(Delete_statementContext.self).cursor_var = assignmentValue
		 				     }()


		 				break
		 			default: break
		 			}

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 	}

		 	setState(1028)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1027)
		 		try for_clause()

		 	}

		 	setState(1031)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.OPTION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1030)
		 		try option_clause()

		 	}

		 	setState(1034)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,106,_ctx)) {
		 	case 1:
		 		setState(1033)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Delete_statement_fromContext:ParserRuleContext {
		public var table_var: Token!
		open func table_alias() -> Table_aliasContext? {
			return getRuleContext(Table_aliasContext.self,0)
		}
		open func ddl_object() -> Ddl_objectContext? {
			return getRuleContext(Ddl_objectContext.self,0)
		}
		open func rowset_function_limited() -> Rowset_function_limitedContext? {
			return getRuleContext(Rowset_function_limitedContext.self,0)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_delete_statement_from }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDelete_statement_from(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDelete_statement_from(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDelete_statement_from(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDelete_statement_from(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func delete_statement_from() throws -> Delete_statement_fromContext {
		var _localctx: Delete_statement_fromContext = Delete_statement_fromContext(_ctx, getState())
		try enterRule(_localctx, 42, tsqlParser.RULE_delete_statement_from)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1040)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,107, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1036)
		 		try table_alias()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1037)
		 		try ddl_object()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1038)
		 		try rowset_function_limited()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1039)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 				_localctx.castdown(Delete_statement_fromContext.self).table_var = assignmentValue
		 		     }()


		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Insert_statementContext:ParserRuleContext {
		open func INSERT() -> TerminalNode? { return getToken(tsqlParser.Tokens.INSERT.rawValue, 0) }
		open func insert_statement_value() -> Insert_statement_valueContext? {
			return getRuleContext(Insert_statement_valueContext.self,0)
		}
		open func ddl_object() -> Ddl_objectContext? {
			return getRuleContext(Ddl_objectContext.self,0)
		}
		open func rowset_function_limited() -> Rowset_function_limitedContext? {
			return getRuleContext(Rowset_function_limitedContext.self,0)
		}
		open func with_expression() -> With_expressionContext? {
			return getRuleContext(With_expressionContext.self,0)
		}
		open func TOP() -> TerminalNode? { return getToken(tsqlParser.Tokens.TOP.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func INTO() -> TerminalNode? { return getToken(tsqlParser.Tokens.INTO.rawValue, 0) }
		open func insert_with_table_hints() -> Insert_with_table_hintsContext? {
			return getRuleContext(Insert_with_table_hintsContext.self,0)
		}
		open func column_name_list() -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,0)
		}
		open func output_clause() -> Output_clauseContext? {
			return getRuleContext(Output_clauseContext.self,0)
		}
		open func for_clause() -> For_clauseContext? {
			return getRuleContext(For_clauseContext.self,0)
		}
		open func option_clause() -> Option_clauseContext? {
			return getRuleContext(Option_clauseContext.self,0)
		}
		open func PERCENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.PERCENT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_insert_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterInsert_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitInsert_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitInsert_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitInsert_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func insert_statement() throws -> Insert_statementContext {
		var _localctx: Insert_statementContext = Insert_statementContext(_ctx, getState())
		try enterRule(_localctx, 44, tsqlParser.RULE_insert_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1043)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1042)
		 		try with_expression()

		 	}

		 	setState(1045)
		 	try match(tsqlParser.Tokens.INSERT.rawValue)
		 	setState(1053)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.TOP.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1046)
		 		try match(tsqlParser.Tokens.TOP.rawValue)
		 		setState(1047)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1048)
		 		try expression(0)
		 		setState(1049)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(1051)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.PERCENT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1050)
		 			try match(tsqlParser.Tokens.PERCENT.rawValue)

		 		}


		 	}

		 	setState(1056)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1055)
		 		try match(tsqlParser.Tokens.INTO.rawValue)

		 	}

		 	setState(1060)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .LOCAL_ID:fallthrough
		 	case .ID:
		 		setState(1058)
		 		try ddl_object()

		 		break
		 	case .OPENDATASOURCE:fallthrough
		 	case .OPENQUERY:
		 		setState(1059)
		 		try rowset_function_limited()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1063)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,113,_ctx)) {
		 	case 1:
		 		setState(1062)
		 		try insert_with_table_hints()

		 		break
		 	default: break
		 	}
		 	setState(1069)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,114,_ctx)) {
		 	case 1:
		 		setState(1065)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1066)
		 		try column_name_list()
		 		setState(1067)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1072)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.OUTPUT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1071)
		 		try output_clause()

		 	}

		 	setState(1074)
		 	try insert_statement_value()
		 	setState(1076)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1075)
		 		try for_clause()

		 	}

		 	setState(1079)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.OPTION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1078)
		 		try option_clause()

		 	}

		 	setState(1082)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,118,_ctx)) {
		 	case 1:
		 		setState(1081)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Insert_statement_valueContext:ParserRuleContext {
		open func table_value_constructor() -> Table_value_constructorContext? {
			return getRuleContext(Table_value_constructorContext.self,0)
		}
		open func derived_table() -> Derived_tableContext? {
			return getRuleContext(Derived_tableContext.self,0)
		}
		open func execute_statement() -> Execute_statementContext? {
			return getRuleContext(Execute_statementContext.self,0)
		}
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open func VALUES() -> TerminalNode? { return getToken(tsqlParser.Tokens.VALUES.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_insert_statement_value }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterInsert_statement_value(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitInsert_statement_value(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitInsert_statement_value(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitInsert_statement_value(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func insert_statement_value() throws -> Insert_statement_valueContext {
		var _localctx: Insert_statement_valueContext = Insert_statement_valueContext(_ctx, getState())
		try enterRule(_localctx, 46, tsqlParser.RULE_insert_statement_value)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1089)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,119, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1084)
		 		try table_value_constructor()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1085)
		 		try derived_table()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1086)
		 		try execute_statement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1087)
		 		try match(tsqlParser.Tokens.DEFAULT.rawValue)
		 		setState(1088)
		 		try match(tsqlParser.Tokens.VALUES.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Receive_statementContext:ParserRuleContext {
		public var table_variable: IdContext!
		public var where: Search_conditionContext!
		open func RECEIVE() -> TerminalNode? { return getToken(tsqlParser.Tokens.RECEIVE.rawValue, 0) }
		open func FROM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FROM.rawValue, 0) }
		open func full_table_name() -> Full_table_nameContext? {
			return getRuleContext(Full_table_nameContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALL.rawValue, 0) }
		open func DISTINCT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DISTINCT.rawValue, 0) }
		open func top_clause() -> Top_clauseContext? {
			return getRuleContext(Top_clauseContext.self,0)
		}
		open func LOCAL_ID() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.LOCAL_ID.rawValue) }
		open func LOCAL_ID(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, i)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func INTO() -> TerminalNode? { return getToken(tsqlParser.Tokens.INTO.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func WHERE() -> TerminalNode? { return getToken(tsqlParser.Tokens.WHERE.rawValue, 0) }
		open func search_condition() -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_receive_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterReceive_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitReceive_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitReceive_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitReceive_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func receive_statement() throws -> Receive_statementContext {
		var _localctx: Receive_statementContext = Receive_statementContext(_ctx, getState())
		try enterRule(_localctx, 48, tsqlParser.RULE_receive_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1092)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LR_BRACKET.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1091)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)

		 	}

		 	setState(1094)
		 	try match(tsqlParser.Tokens.RECEIVE.rawValue)
		 	setState(1099)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ALL:
		 		setState(1095)
		 		try match(tsqlParser.Tokens.ALL.rawValue)

		 		break

		 	case .DISTINCT:
		 		setState(1096)
		 		try match(tsqlParser.Tokens.DISTINCT.rawValue)

		 		break

		 	case .TOP:
		 		setState(1097)
		 		try top_clause()

		 		break

		 	case .STAR:
		 		setState(1098)
		 		try match(tsqlParser.Tokens.STAR.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1109)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1101)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 		setState(1102)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1103)
		 		try expression(0)
		 		setState(1105)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1104)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}



		 		setState(1111)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1112)
		 	try match(tsqlParser.Tokens.FROM.rawValue)
		 	setState(1113)
		 	try full_table_name()
		 	setState(1119)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1114)
		 		try match(tsqlParser.Tokens.INTO.rawValue)
		 		setState(1115)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Receive_statementContext.self).table_variable = assignmentValue
		 		     }()

		 		setState(1116)
		 		try match(tsqlParser.Tokens.WHERE.rawValue)
		 		setState(1117)
		 		try {
		 				let assignmentValue = try search_condition()
		 				_localctx.castdown(Receive_statementContext.self).where = assignmentValue
		 		     }()



		 	}

		 	setState(1122)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.RR_BRACKET.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1121)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Select_statementContext:ParserRuleContext {
		open func query_expression() -> Query_expressionContext? {
			return getRuleContext(Query_expressionContext.self,0)
		}
		open func with_expression() -> With_expressionContext? {
			return getRuleContext(With_expressionContext.self,0)
		}
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func for_clause() -> For_clauseContext? {
			return getRuleContext(For_clauseContext.self,0)
		}
		open func option_clause() -> Option_clauseContext? {
			return getRuleContext(Option_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_select_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSelect_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSelect_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSelect_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSelect_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func select_statement() throws -> Select_statementContext {
		var _localctx: Select_statementContext = Select_statementContext(_ctx, getState())
		try enterRule(_localctx, 50, tsqlParser.RULE_select_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1125)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1124)
		 		try with_expression()

		 	}

		 	setState(1127)
		 	try query_expression()
		 	setState(1129)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,127,_ctx)) {
		 	case 1:
		 		setState(1128)
		 		try order_by_clause()

		 		break
		 	default: break
		 	}
		 	setState(1132)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,128,_ctx)) {
		 	case 1:
		 		setState(1131)
		 		try for_clause()

		 		break
		 	default: break
		 	}
		 	setState(1135)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,129,_ctx)) {
		 	case 1:
		 		setState(1134)
		 		try option_clause()

		 		break
		 	default: break
		 	}
		 	setState(1138)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,130,_ctx)) {
		 	case 1:
		 		setState(1137)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class TimeContext:ParserRuleContext {
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func constant() -> ConstantContext? {
			return getRuleContext(ConstantContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_time }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTime(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTime(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTime(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTime(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func time() throws -> TimeContext {
		var _localctx: TimeContext = TimeContext(_ctx, getState())
		try enterRule(_localctx, 52, tsqlParser.RULE_time)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1142)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LOCAL_ID:
		 		setState(1140)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 		break
		 	case .DECIMAL:fallthrough
		 	case .STRING:fallthrough
		 	case .BINARY:fallthrough
		 	case .FLOAT:fallthrough
		 	case .REAL:fallthrough
		 	case .DOLLAR:fallthrough
		 	case .PLUS:fallthrough
		 	case .MINUS:
		 		setState(1141)
		 		try constant()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Update_statementContext:ParserRuleContext {
		public var cursor_var: Token!
		open func UPDATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func SET() -> TerminalNode? { return getToken(tsqlParser.Tokens.SET.rawValue, 0) }
		open func update_elem() -> Array<Update_elemContext> {
			return getRuleContexts(Update_elemContext.self)
		}
		open func update_elem(_ i: Int) -> Update_elemContext? {
			return getRuleContext(Update_elemContext.self,i)
		}
		open func ddl_object() -> Ddl_objectContext? {
			return getRuleContext(Ddl_objectContext.self,0)
		}
		open func rowset_function_limited() -> Rowset_function_limitedContext? {
			return getRuleContext(Rowset_function_limitedContext.self,0)
		}
		open func with_expression() -> With_expressionContext? {
			return getRuleContext(With_expressionContext.self,0)
		}
		open func TOP() -> TerminalNode? { return getToken(tsqlParser.Tokens.TOP.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func with_table_hints() -> With_table_hintsContext? {
			return getRuleContext(With_table_hintsContext.self,0)
		}
		open func output_clause() -> Output_clauseContext? {
			return getRuleContext(Output_clauseContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FROM.rawValue, 0) }
		open func table_sources() -> Table_sourcesContext? {
			return getRuleContext(Table_sourcesContext.self,0)
		}
		open func WHERE() -> TerminalNode? { return getToken(tsqlParser.Tokens.WHERE.rawValue, 0) }
		open func for_clause() -> For_clauseContext? {
			return getRuleContext(For_clauseContext.self,0)
		}
		open func option_clause() -> Option_clauseContext? {
			return getRuleContext(Option_clauseContext.self,0)
		}
		open func search_condition_list() -> Search_condition_listContext? {
			return getRuleContext(Search_condition_listContext.self,0)
		}
		open func CURRENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CURRENT.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OF.rawValue, 0) }
		open func PERCENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.PERCENT.rawValue, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func GLOBAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.GLOBAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_update_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterUpdate_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitUpdate_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitUpdate_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitUpdate_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func update_statement() throws -> Update_statementContext {
		var _localctx: Update_statementContext = Update_statementContext(_ctx, getState())
		try enterRule(_localctx, 54, tsqlParser.RULE_update_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1145)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1144)
		 		try with_expression()

		 	}

		 	setState(1147)
		 	try match(tsqlParser.Tokens.UPDATE.rawValue)
		 	setState(1155)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.TOP.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1148)
		 		try match(tsqlParser.Tokens.TOP.rawValue)
		 		setState(1149)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1150)
		 		try expression(0)
		 		setState(1151)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(1153)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.PERCENT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1152)
		 			try match(tsqlParser.Tokens.PERCENT.rawValue)

		 		}


		 	}

		 	setState(1159)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .LOCAL_ID:fallthrough
		 	case .ID:
		 		setState(1157)
		 		try ddl_object()

		 		break
		 	case .OPENDATASOURCE:fallthrough
		 	case .OPENQUERY:
		 		setState(1158)
		 		try rowset_function_limited()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1162)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.LR_BRACKET.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1161)
		 		try with_table_hints()

		 	}

		 	setState(1164)
		 	try match(tsqlParser.Tokens.SET.rawValue)
		 	setState(1165)
		 	try update_elem()
		 	setState(1170)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1166)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(1167)
		 		try update_elem()


		 		setState(1172)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1174)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,138,_ctx)) {
		 	case 1:
		 		setState(1173)
		 		try output_clause()

		 		break
		 	default: break
		 	}
		 	setState(1178)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.FROM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1176)
		 		try match(tsqlParser.Tokens.FROM.rawValue)
		 		setState(1177)
		 		try table_sources()

		 	}

		 	setState(1193)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WHERE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1180)
		 		try match(tsqlParser.Tokens.WHERE.rawValue)
		 		setState(1191)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CALLED:fallthrough
		 		case .CASE:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CONVERT:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .EXISTS:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .IDENTITY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NOT:fallthrough
		 		case .NULL:fallthrough
		 		case .NULLIF:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .OVER:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .RIGHT:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .BINARY_CHECKSUM:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DATEADD:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATENAME:fallthrough
		 		case .DATEPART:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GETDATE:fallthrough
		 		case .GETUTCDATE:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MIN_ACTIVE_ROWVERSION:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .STUFF:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .LOCAL_ID:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .ID:fallthrough
		 		case .STRING:fallthrough
		 		case .BINARY:fallthrough
		 		case .FLOAT:fallthrough
		 		case .REAL:fallthrough
		 		case .DOLLAR:fallthrough
		 		case .LR_BRACKET:fallthrough
		 		case .PLUS:fallthrough
		 		case .MINUS:fallthrough
		 		case .BIT_NOT:
		 			setState(1181)
		 			try search_condition_list()

		 			break

		 		case .CURRENT:
		 			setState(1182)
		 			try match(tsqlParser.Tokens.CURRENT.rawValue)
		 			setState(1183)
		 			try match(tsqlParser.Tokens.OF.rawValue)
		 			setState(1189)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,141, _ctx)) {
		 			case 1:
		 				setState(1185)
		 				try _errHandler.sync(self)
		 				switch (try getInterpreter().adaptivePredict(_input,140,_ctx)) {
		 				case 1:
		 					setState(1184)
		 					try match(tsqlParser.Tokens.GLOBAL.rawValue)

		 					break
		 				default: break
		 				}
		 				setState(1187)
		 				try cursor_name()

		 				break
		 			case 2:
		 				setState(1188)
		 				try {
		 						let assignmentValue = try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 						_localctx.castdown(Update_statementContext.self).cursor_var = assignmentValue
		 				     }()


		 				break
		 			default: break
		 			}

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 	}

		 	setState(1196)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1195)
		 		try for_clause()

		 	}

		 	setState(1199)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.OPTION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1198)
		 		try option_clause()

		 	}

		 	setState(1202)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,146,_ctx)) {
		 	case 1:
		 		setState(1201)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Output_clauseContext:ParserRuleContext {
		open func OUTPUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.OUTPUT.rawValue, 0) }
		open func output_dml_list_elem() -> Array<Output_dml_list_elemContext> {
			return getRuleContexts(Output_dml_list_elemContext.self)
		}
		open func output_dml_list_elem(_ i: Int) -> Output_dml_list_elemContext? {
			return getRuleContext(Output_dml_list_elemContext.self,i)
		}
		open func INTO() -> TerminalNode? { return getToken(tsqlParser.Tokens.INTO.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func column_name_list() -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_output_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOutput_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOutput_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOutput_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOutput_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func output_clause() throws -> Output_clauseContext {
		var _localctx: Output_clauseContext = Output_clauseContext(_ctx, getState())
		try enterRule(_localctx, 56, tsqlParser.RULE_output_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1204)
		 	try match(tsqlParser.Tokens.OUTPUT.rawValue)
		 	setState(1205)
		 	try output_dml_list_elem()
		 	setState(1210)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1206)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(1207)
		 		try output_dml_list_elem()


		 		setState(1212)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1224)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1213)
		 		try match(tsqlParser.Tokens.INTO.rawValue)
		 		setState(1216)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .LOCAL_ID:
		 			setState(1214)
		 			try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 			break
		 		case .CALLED:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .ID:
		 			setState(1215)
		 			try table_name()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1222)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,149,_ctx)) {
		 		case 1:
		 			setState(1218)
		 			try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(1219)
		 			try column_name_list()
		 			setState(1220)
		 			try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Output_dml_list_elemContext:ParserRuleContext {
		open func output_column_name() -> Output_column_nameContext? {
			return getRuleContext(Output_column_nameContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_output_dml_list_elem }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOutput_dml_list_elem(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOutput_dml_list_elem(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOutput_dml_list_elem(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOutput_dml_list_elem(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func output_dml_list_elem() throws -> Output_dml_list_elemContext {
		var _localctx: Output_dml_list_elemContext = Output_dml_list_elemContext(_ctx, getState())
		try enterRule(_localctx, 58, tsqlParser.RULE_output_dml_list_elem)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1228)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,151, _ctx)) {
		 	case 1:
		 		setState(1226)
		 		try output_column_name()

		 		break
		 	case 2:
		 		setState(1227)
		 		try expression(0)

		 		break
		 	default: break
		 	}
		 	setState(1234)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,153,_ctx)) {
		 	case 1:
		 		setState(1231)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1230)
		 			try match(tsqlParser.Tokens.AS.rawValue)

		 		}

		 		setState(1233)
		 		try column_alias()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Output_column_nameContext:ParserRuleContext {
		open func DELETED() -> TerminalNode? { return getToken(tsqlParser.Tokens.DELETED.rawValue, 0) }
		open func INSERTED() -> TerminalNode? { return getToken(tsqlParser.Tokens.INSERTED.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func DOLLAR_ACTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.DOLLAR_ACTION.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_output_column_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOutput_column_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOutput_column_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOutput_column_name(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOutput_column_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func output_column_name() throws -> Output_column_nameContext {
		var _localctx: Output_column_nameContext = Output_column_nameContext(_ctx, getState())
		try enterRule(_localctx, 60, tsqlParser.RULE_output_column_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1247)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1239)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,154, _ctx)) {
		 		case 1:
		 			setState(1236)
		 			try match(tsqlParser.Tokens.DELETED.rawValue)

		 			break
		 		case 2:
		 			setState(1237)
		 			try match(tsqlParser.Tokens.INSERTED.rawValue)

		 			break
		 		case 3:
		 			setState(1238)
		 			try table_name()

		 			break
		 		default: break
		 		}
		 		setState(1241)
		 		try match(tsqlParser.Tokens.DOT.rawValue)
		 		setState(1244)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .STAR:
		 			setState(1242)
		 			try match(tsqlParser.Tokens.STAR.rawValue)

		 			break
		 		case .CALLED:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .ID:
		 			setState(1243)
		 			try id()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .DOLLAR_ACTION:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1246)
		 		try match(tsqlParser.Tokens.DOLLAR_ACTION.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_databaseContext:ParserRuleContext {
		public var database: IdContext!
		public var collation_name: IdContext!
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATABASE.rawValue, 0) }
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func CONTAINMENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONTAINMENT.rawValue, 0) }
		open func ON() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ON.rawValue) }
		open func ON(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ON.rawValue, i)
		}
		open func database_file_spec() -> Array<Database_file_specContext> {
			return getRuleContexts(Database_file_specContext.self)
		}
		open func database_file_spec(_ i: Int) -> Database_file_specContext? {
			return getRuleContext(Database_file_specContext.self,i)
		}
		open func LOG() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOG.rawValue, 0) }
		open func COLLATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.COLLATE.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func create_database_option() -> Array<Create_database_optionContext> {
			return getRuleContexts(Create_database_optionContext.self)
		}
		open func create_database_option(_ i: Int) -> Create_database_optionContext? {
			return getRuleContext(Create_database_optionContext.self,i)
		}
		open func NONE() -> TerminalNode? { return getToken(tsqlParser.Tokens.NONE.rawValue, 0) }
		open func PARTIAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.PARTIAL.rawValue, 0) }
		open func PRIMARY() -> TerminalNode? { return getToken(tsqlParser.Tokens.PRIMARY.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_database }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_database(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_database(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_database(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_database(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_database() throws -> Create_databaseContext {
		var _localctx: Create_databaseContext = Create_databaseContext(_ctx, getState())
		try enterRule(_localctx, 62, tsqlParser.RULE_create_database)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1249)
		 	try match(tsqlParser.Tokens.CREATE.rawValue)
		 	setState(1250)
		 	try match(tsqlParser.Tokens.DATABASE.rawValue)

		 	setState(1251)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(Create_databaseContext.self).database = assignmentValue
		 	     }()


		 	setState(1255)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.CONTAINMENT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1252)
		 		try match(tsqlParser.Tokens.CONTAINMENT.rawValue)
		 		setState(1253)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1254)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.NONE.rawValue || _la == tsqlParser.Tokens.PARTIAL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(1269)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1257)
		 		try match(tsqlParser.Tokens.ON.rawValue)
		 		setState(1259)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.PRIMARY.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1258)
		 			try match(tsqlParser.Tokens.PRIMARY.rawValue)

		 		}

		 		setState(1261)
		 		try database_file_spec()
		 		setState(1266)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1262)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1263)
		 			try database_file_spec()


		 			setState(1268)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(1281)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LOG.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1271)
		 		try match(tsqlParser.Tokens.LOG.rawValue)
		 		setState(1272)
		 		try match(tsqlParser.Tokens.ON.rawValue)
		 		setState(1273)
		 		try database_file_spec()
		 		setState(1278)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1274)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1275)
		 			try database_file_spec()


		 			setState(1280)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(1285)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COLLATE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1283)
		 		try match(tsqlParser.Tokens.COLLATE.rawValue)
		 		setState(1284)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Create_databaseContext.self).collation_name = assignmentValue
		 		     }()


		 	}

		 	setState(1296)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,165,_ctx)) {
		 	case 1:
		 		setState(1287)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1288)
		 		try create_database_option()
		 		setState(1293)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1289)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1290)
		 			try create_database_option()


		 			setState(1295)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_indexContext:ParserRuleContext {
		public var where: Search_conditionContext!
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func INDEX() -> TerminalNode? { return getToken(tsqlParser.Tokens.INDEX.rawValue, 0) }
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func ON() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ON.rawValue) }
		open func ON(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ON.rawValue, i)
		}
		open func table_name_with_hint() -> Table_name_with_hintContext? {
			return getRuleContext(Table_name_with_hintContext.self,0)
		}
		open func column_name_list_with_order() -> Column_name_list_with_orderContext? {
			return getRuleContext(Column_name_list_with_orderContext.self,0)
		}
		open func UNIQUE() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNIQUE.rawValue, 0) }
		open func clustered() -> ClusteredContext? {
			return getRuleContext(ClusteredContext.self,0)
		}
		open func INCLUDE() -> TerminalNode? { return getToken(tsqlParser.Tokens.INCLUDE.rawValue, 0) }
		open func column_name_list() -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,0)
		}
		open func WHERE() -> TerminalNode? { return getToken(tsqlParser.Tokens.WHERE.rawValue, 0) }
		open func index_options() -> Index_optionsContext? {
			return getRuleContext(Index_optionsContext.self,0)
		}
		open func search_condition() -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_index }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_index(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_index(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_index(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_index(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_index() throws -> Create_indexContext {
		var _localctx: Create_indexContext = Create_indexContext(_ctx, getState())
		try enterRule(_localctx, 64, tsqlParser.RULE_create_index)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1298)
		 	try match(tsqlParser.Tokens.CREATE.rawValue)
		 	setState(1300)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.UNIQUE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1299)
		 		try match(tsqlParser.Tokens.UNIQUE.rawValue)

		 	}

		 	setState(1303)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.CLUSTERED.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.NONCLUSTERED.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1302)
		 		try clustered()

		 	}

		 	setState(1305)
		 	try match(tsqlParser.Tokens.INDEX.rawValue)
		 	setState(1306)
		 	try id()
		 	setState(1307)
		 	try match(tsqlParser.Tokens.ON.rawValue)
		 	setState(1308)
		 	try table_name_with_hint()
		 	setState(1309)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(1310)
		 	try column_name_list_with_order()
		 	setState(1311)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(1317)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.INCLUDE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1312)
		 		try match(tsqlParser.Tokens.INCLUDE.rawValue)
		 		setState(1313)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1314)
		 		try column_name_list()
		 		setState(1315)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(1321)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WHERE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1319)
		 		try match(tsqlParser.Tokens.WHERE.rawValue)
		 		setState(1320)
		 		try {
		 				let assignmentValue = try search_condition()
		 				_localctx.castdown(Create_indexContext.self).where = assignmentValue
		 		     }()


		 	}

		 	setState(1324)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,170,_ctx)) {
		 	case 1:
		 		setState(1323)
		 		try index_options()

		 		break
		 	default: break
		 	}
		 	setState(1328)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ON.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1326)
		 		try match(tsqlParser.Tokens.ON.rawValue)
		 		setState(1327)
		 		try id()

		 	}

		 	setState(1331)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,172,_ctx)) {
		 	case 1:
		 		setState(1330)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_or_alter_procedureContext:ParserRuleContext {
		public var proc: Token!
		open func func_proc_name() -> Func_proc_nameContext? {
			return getRuleContext(Func_proc_nameContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func sql_clauses() -> Sql_clausesContext? {
			return getRuleContext(Sql_clausesContext.self,0)
		}
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func ALTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALTER.rawValue, 0) }
		open func PROC() -> TerminalNode? { return getToken(tsqlParser.Tokens.PROC.rawValue, 0) }
		open func PROCEDURE() -> TerminalNode? { return getToken(tsqlParser.Tokens.PROCEDURE.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func procedure_param() -> Array<Procedure_paramContext> {
			return getRuleContexts(Procedure_paramContext.self)
		}
		open func procedure_param(_ i: Int) -> Procedure_paramContext? {
			return getRuleContext(Procedure_paramContext.self,i)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func procedure_option() -> Array<Procedure_optionContext> {
			return getRuleContexts(Procedure_optionContext.self)
		}
		open func procedure_option(_ i: Int) -> Procedure_optionContext? {
			return getRuleContext(Procedure_optionContext.self,i)
		}
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func REPLICATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.REPLICATION.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_or_alter_procedure }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_or_alter_procedure(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_or_alter_procedure(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_or_alter_procedure(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_or_alter_procedure(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_or_alter_procedure() throws -> Create_or_alter_procedureContext {
		var _localctx: Create_or_alter_procedureContext = Create_or_alter_procedureContext(_ctx, getState())
		try enterRule(_localctx, 66, tsqlParser.RULE_create_or_alter_procedure)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1333)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ALTER.rawValue || _la == tsqlParser.Tokens.CREATE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1334)
		 	_localctx.castdown(Create_or_alter_procedureContext.self).proc = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.PROC.rawValue || _la == tsqlParser.Tokens.PROCEDURE.rawValue
		 	      return testSet
		 	 }())) {
		 		_localctx.castdown(Create_or_alter_procedureContext.self).proc = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1335)
		 	try func_proc_name()
		 	setState(1338)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.SEMI.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1336)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)
		 		setState(1337)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 	}

		 	setState(1354)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.LR_BRACKET.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1341)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.LR_BRACKET.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1340)
		 			try match(tsqlParser.Tokens.LR_BRACKET.rawValue)

		 		}

		 		setState(1343)
		 		try procedure_param()
		 		setState(1348)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1344)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1345)
		 			try procedure_param()


		 			setState(1350)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1352)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.RR_BRACKET.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1351)
		 			try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		}


		 	}

		 	setState(1365)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1356)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1357)
		 		try procedure_option()
		 		setState(1362)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1358)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1359)
		 			try procedure_option()


		 			setState(1364)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(1369)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.FOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1367)
		 		try match(tsqlParser.Tokens.FOR.rawValue)
		 		setState(1368)
		 		try match(tsqlParser.Tokens.REPLICATION.rawValue)

		 	}

		 	setState(1371)
		 	try match(tsqlParser.Tokens.AS.rawValue)
		 	setState(1372)
		 	try sql_clauses()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_or_alter_triggerContext:ParserRuleContext {
		open func dml_trigger() -> Dml_triggerContext? {
			return getRuleContext(Dml_triggerContext.self,0)
		}
		open func ddl_trigger() -> Ddl_triggerContext? {
			return getRuleContext(Ddl_triggerContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_or_alter_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_or_alter_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_or_alter_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_or_alter_trigger(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_or_alter_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_or_alter_trigger() throws -> Create_or_alter_triggerContext {
		var _localctx: Create_or_alter_triggerContext = Create_or_alter_triggerContext(_ctx, getState())
		try enterRule(_localctx, 68, tsqlParser.RULE_create_or_alter_trigger)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1376)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,181, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1374)
		 		try dml_trigger()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1375)
		 		try ddl_trigger()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_triggerContext:ParserRuleContext {
		open func TRIGGER() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRIGGER.rawValue, 0) }
		open func simple_name() -> Simple_nameContext? {
			return getRuleContext(Simple_nameContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func dml_trigger_operation() -> Array<Dml_trigger_operationContext> {
			return getRuleContexts(Dml_trigger_operationContext.self)
		}
		open func dml_trigger_operation(_ i: Int) -> Dml_trigger_operationContext? {
			return getRuleContext(Dml_trigger_operationContext.self,i)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func sql_clauses() -> Sql_clausesContext? {
			return getRuleContext(Sql_clausesContext.self,0)
		}
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func ALTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALTER.rawValue, 0) }
		open func FOR() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.FOR.rawValue) }
		open func FOR(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.FOR.rawValue, i)
		}
		open func AFTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.AFTER.rawValue, 0) }
		open func INSTEAD() -> TerminalNode? { return getToken(tsqlParser.Tokens.INSTEAD.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OF.rawValue, 0) }
		open func WITH() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.WITH.rawValue) }
		open func WITH(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.WITH.rawValue, i)
		}
		open func dml_trigger_option() -> Array<Dml_trigger_optionContext> {
			return getRuleContexts(Dml_trigger_optionContext.self)
		}
		open func dml_trigger_option(_ i: Int) -> Dml_trigger_optionContext? {
			return getRuleContext(Dml_trigger_optionContext.self,i)
		}
		open func APPEND() -> TerminalNode? { return getToken(tsqlParser.Tokens.APPEND.rawValue, 0) }
		open func NOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NOT.rawValue, 0) }
		open func REPLICATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.REPLICATION.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_dml_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDml_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDml_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDml_trigger(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDml_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_trigger() throws -> Dml_triggerContext {
		var _localctx: Dml_triggerContext = Dml_triggerContext(_ctx, getState())
		try enterRule(_localctx, 70, tsqlParser.RULE_dml_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1378)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ALTER.rawValue || _la == tsqlParser.Tokens.CREATE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1379)
		 	try match(tsqlParser.Tokens.TRIGGER.rawValue)
		 	setState(1380)
		 	try simple_name()
		 	setState(1381)
		 	try match(tsqlParser.Tokens.ON.rawValue)
		 	setState(1382)
		 	try table_name()
		 	setState(1392)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1383)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1384)
		 		try dml_trigger_option()
		 		setState(1389)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1385)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1386)
		 			try dml_trigger_option()


		 			setState(1391)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(1398)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FOR:
		 		setState(1394)
		 		try match(tsqlParser.Tokens.FOR.rawValue)

		 		break

		 	case .AFTER:
		 		setState(1395)
		 		try match(tsqlParser.Tokens.AFTER.rawValue)

		 		break

		 	case .INSTEAD:
		 		setState(1396)
		 		try match(tsqlParser.Tokens.INSTEAD.rawValue)
		 		setState(1397)
		 		try match(tsqlParser.Tokens.OF.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1400)
		 	try dml_trigger_operation()
		 	setState(1405)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1401)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(1402)
		 		try dml_trigger_operation()


		 		setState(1407)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1410)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1408)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1409)
		 		try match(tsqlParser.Tokens.APPEND.rawValue)

		 	}

		 	setState(1415)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.NOT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1412)
		 		try match(tsqlParser.Tokens.NOT.rawValue)
		 		setState(1413)
		 		try match(tsqlParser.Tokens.FOR.rawValue)
		 		setState(1414)
		 		try match(tsqlParser.Tokens.REPLICATION.rawValue)

		 	}

		 	setState(1417)
		 	try match(tsqlParser.Tokens.AS.rawValue)
		 	setState(1418)
		 	try sql_clauses()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_trigger_optionContext:ParserRuleContext {
		open func ENCRYPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ENCRYPTION.rawValue, 0) }
		open func execute_clause() -> Execute_clauseContext? {
			return getRuleContext(Execute_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_dml_trigger_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDml_trigger_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDml_trigger_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDml_trigger_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDml_trigger_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_trigger_option() throws -> Dml_trigger_optionContext {
		var _localctx: Dml_trigger_optionContext = Dml_trigger_optionContext(_ctx, getState())
		try enterRule(_localctx, 72, tsqlParser.RULE_dml_trigger_option)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1422)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ENCRYPTION:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1420)
		 		try match(tsqlParser.Tokens.ENCRYPTION.rawValue)

		 		break

		 	case .EXECUTE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1421)
		 		try execute_clause()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dml_trigger_operationContext:ParserRuleContext {
		open func INSERT() -> TerminalNode? { return getToken(tsqlParser.Tokens.INSERT.rawValue, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func DELETE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DELETE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_dml_trigger_operation }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDml_trigger_operation(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDml_trigger_operation(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDml_trigger_operation(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDml_trigger_operation(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dml_trigger_operation() throws -> Dml_trigger_operationContext {
		var _localctx: Dml_trigger_operationContext = Dml_trigger_operationContext(_ctx, getState())
		try enterRule(_localctx, 74, tsqlParser.RULE_dml_trigger_operation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1424)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.DELETE.rawValue || _la == tsqlParser.Tokens.INSERT.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.UPDATE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Ddl_triggerContext:ParserRuleContext {
		open func TRIGGER() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRIGGER.rawValue, 0) }
		open func simple_name() -> Simple_nameContext? {
			return getRuleContext(Simple_nameContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func ddl_trigger_operation() -> Ddl_trigger_operationContext? {
			return getRuleContext(Ddl_trigger_operationContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func sql_clauses() -> Sql_clausesContext? {
			return getRuleContext(Sql_clausesContext.self,0)
		}
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func ALTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALTER.rawValue, 0) }
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func AFTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.AFTER.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALL.rawValue, 0) }
		open func SERVER() -> TerminalNode? { return getToken(tsqlParser.Tokens.SERVER.rawValue, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATABASE.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func dml_trigger_option() -> Array<Dml_trigger_optionContext> {
			return getRuleContexts(Dml_trigger_optionContext.self)
		}
		open func dml_trigger_option(_ i: Int) -> Dml_trigger_optionContext? {
			return getRuleContext(Dml_trigger_optionContext.self,i)
		}
		open func dml_trigger_operation() -> Array<Dml_trigger_operationContext> {
			return getRuleContexts(Dml_trigger_operationContext.self)
		}
		open func dml_trigger_operation(_ i: Int) -> Dml_trigger_operationContext? {
			return getRuleContext(Dml_trigger_operationContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_ddl_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDdl_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDdl_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDdl_trigger(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDdl_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func ddl_trigger() throws -> Ddl_triggerContext {
		var _localctx: Ddl_triggerContext = Ddl_triggerContext(_ctx, getState())
		try enterRule(_localctx, 76, tsqlParser.RULE_ddl_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1426)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ALTER.rawValue || _la == tsqlParser.Tokens.CREATE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1427)
		 	try match(tsqlParser.Tokens.TRIGGER.rawValue)
		 	setState(1428)
		 	try simple_name()
		 	setState(1429)
		 	try match(tsqlParser.Tokens.ON.rawValue)
		 	setState(1433)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ALL:
		 		setState(1430)
		 		try match(tsqlParser.Tokens.ALL.rawValue)
		 		setState(1431)
		 		try match(tsqlParser.Tokens.SERVER.rawValue)

		 		break

		 	case .DATABASE:
		 		setState(1432)
		 		try match(tsqlParser.Tokens.DATABASE.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1444)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1435)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1436)
		 		try dml_trigger_option()
		 		setState(1441)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1437)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1438)
		 			try dml_trigger_option()


		 			setState(1443)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(1446)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.FOR.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.AFTER.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1447)
		 	try ddl_trigger_operation()
		 	setState(1452)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1448)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(1449)
		 		try dml_trigger_operation()


		 		setState(1454)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1455)
		 	try match(tsqlParser.Tokens.AS.rawValue)
		 	setState(1456)
		 	try sql_clauses()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Ddl_trigger_operationContext:ParserRuleContext {
		open func simple_id() -> Simple_idContext? {
			return getRuleContext(Simple_idContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_ddl_trigger_operation }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDdl_trigger_operation(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDdl_trigger_operation(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDdl_trigger_operation(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDdl_trigger_operation(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func ddl_trigger_operation() throws -> Ddl_trigger_operationContext {
		var _localctx: Ddl_trigger_operationContext = Ddl_trigger_operationContext(_ctx, getState())
		try enterRule(_localctx, 78, tsqlParser.RULE_ddl_trigger_operation)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1458)
		 	try simple_id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_or_alter_functionContext:ParserRuleContext {
		open func FUNCTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func func_proc_name() -> Func_proc_nameContext? {
			return getRuleContext(Func_proc_nameContext.self,0)
		}
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func ALTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALTER.rawValue, 0) }
		open func func_body_returns_select() -> Func_body_returns_selectContext? {
			return getRuleContext(Func_body_returns_selectContext.self,0)
		}
		open func func_body_returns_table() -> Func_body_returns_tableContext? {
			return getRuleContext(Func_body_returns_tableContext.self,0)
		}
		open func func_body_returns_scalar() -> Func_body_returns_scalarContext? {
			return getRuleContext(Func_body_returns_scalarContext.self,0)
		}
		open func procedure_param() -> Array<Procedure_paramContext> {
			return getRuleContexts(Procedure_paramContext.self)
		}
		open func procedure_param(_ i: Int) -> Procedure_paramContext? {
			return getRuleContext(Procedure_paramContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_or_alter_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_or_alter_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_or_alter_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_or_alter_function(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_or_alter_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_or_alter_function() throws -> Create_or_alter_functionContext {
		var _localctx: Create_or_alter_functionContext = Create_or_alter_functionContext(_ctx, getState())
		try enterRule(_localctx, 80, tsqlParser.RULE_create_or_alter_function)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1460)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ALTER.rawValue || _la == tsqlParser.Tokens.CREATE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1461)
		 	try match(tsqlParser.Tokens.FUNCTION.rawValue)
		 	setState(1462)
		 	try func_proc_name()
		 	setState(1476)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,194, _ctx)) {
		 	case 1:
		 		setState(1463)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1464)
		 		try procedure_param()
		 		setState(1469)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1465)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1466)
		 			try procedure_param()


		 			setState(1471)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1472)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)


		 		break
		 	case 2:
		 		setState(1474)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1475)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1481)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,195, _ctx)) {
		 	case 1:
		 		setState(1478)
		 		try func_body_returns_select()

		 		break
		 	case 2:
		 		setState(1479)
		 		try func_body_returns_table()

		 		break
		 	case 3:
		 		setState(1480)
		 		try func_body_returns_scalar()

		 		break
		 	default: break
		 	}
		 	setState(1484)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,196,_ctx)) {
		 	case 1:
		 		setState(1483)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Func_body_returns_selectContext:ParserRuleContext {
		open func RETURNS() -> TerminalNode? { return getToken(tsqlParser.Tokens.RETURNS.rawValue, 0) }
		open func TABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TABLE.rawValue, 0) }
		open func RETURN() -> TerminalNode? { return getToken(tsqlParser.Tokens.RETURN.rawValue, 0) }
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func function_option() -> Array<Function_optionContext> {
			return getRuleContexts(Function_optionContext.self)
		}
		open func function_option(_ i: Int) -> Function_optionContext? {
			return getRuleContext(Function_optionContext.self,i)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_func_body_returns_select }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFunc_body_returns_select(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFunc_body_returns_select(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFunc_body_returns_select(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFunc_body_returns_select(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func func_body_returns_select() throws -> Func_body_returns_selectContext {
		var _localctx: Func_body_returns_selectContext = Func_body_returns_selectContext(_ctx, getState())
		try enterRule(_localctx, 82, tsqlParser.RULE_func_body_returns_select)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1486)
		 	try match(tsqlParser.Tokens.RETURNS.rawValue)
		 	setState(1487)
		 	try match(tsqlParser.Tokens.TABLE.rawValue)
		 	setState(1497)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1488)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1489)
		 		try function_option()
		 		setState(1494)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1490)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1491)
		 			try function_option()


		 			setState(1496)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(1500)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1499)
		 		try match(tsqlParser.Tokens.AS.rawValue)

		 	}

		 	setState(1502)
		 	try match(tsqlParser.Tokens.RETURN.rawValue)
		 	setState(1503)
		 	try select_statement()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Func_body_returns_tableContext:ParserRuleContext {
		open func RETURNS() -> TerminalNode? { return getToken(tsqlParser.Tokens.RETURNS.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func table_type_definition() -> Table_type_definitionContext? {
			return getRuleContext(Table_type_definitionContext.self,0)
		}
		open func BEGIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.BEGIN.rawValue, 0) }
		open func RETURN() -> TerminalNode? { return getToken(tsqlParser.Tokens.RETURN.rawValue, 0) }
		open func END() -> TerminalNode? { return getToken(tsqlParser.Tokens.END.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func function_option() -> Array<Function_optionContext> {
			return getRuleContexts(Function_optionContext.self)
		}
		open func function_option(_ i: Int) -> Function_optionContext? {
			return getRuleContext(Function_optionContext.self,i)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func sql_clause() -> Array<Sql_clauseContext> {
			return getRuleContexts(Sql_clauseContext.self)
		}
		open func sql_clause(_ i: Int) -> Sql_clauseContext? {
			return getRuleContext(Sql_clauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_func_body_returns_table }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFunc_body_returns_table(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFunc_body_returns_table(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFunc_body_returns_table(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFunc_body_returns_table(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func func_body_returns_table() throws -> Func_body_returns_tableContext {
		var _localctx: Func_body_returns_tableContext = Func_body_returns_tableContext(_ctx, getState())
		try enterRule(_localctx, 84, tsqlParser.RULE_func_body_returns_table)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1505)
		 	try match(tsqlParser.Tokens.RETURNS.rawValue)
		 	setState(1506)
		 	try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 	setState(1507)
		 	try table_type_definition()
		 	setState(1517)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1508)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1509)
		 		try function_option()
		 		setState(1514)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1510)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1511)
		 			try function_option()


		 			setState(1516)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(1520)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1519)
		 		try match(tsqlParser.Tokens.AS.rawValue)

		 	}

		 	setState(1522)
		 	try match(tsqlParser.Tokens.BEGIN.rawValue)
		 	setState(1526)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,203,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1523)
		 			try sql_clause()

		 	 
		 		}
		 		setState(1528)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,203,_ctx)
		 	}
		 	setState(1529)
		 	try match(tsqlParser.Tokens.RETURN.rawValue)
		 	setState(1530)
		 	try match(tsqlParser.Tokens.END.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Func_body_returns_scalarContext:ParserRuleContext {
		public var ret: ExpressionContext!
		open func RETURNS() -> TerminalNode? { return getToken(tsqlParser.Tokens.RETURNS.rawValue, 0) }
		open func data_type() -> Data_typeContext? {
			return getRuleContext(Data_typeContext.self,0)
		}
		open func BEGIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.BEGIN.rawValue, 0) }
		open func RETURN() -> TerminalNode? { return getToken(tsqlParser.Tokens.RETURN.rawValue, 0) }
		open func END() -> TerminalNode? { return getToken(tsqlParser.Tokens.END.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func function_option() -> Array<Function_optionContext> {
			return getRuleContexts(Function_optionContext.self)
		}
		open func function_option(_ i: Int) -> Function_optionContext? {
			return getRuleContext(Function_optionContext.self,i)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func sql_clause() -> Array<Sql_clauseContext> {
			return getRuleContexts(Sql_clauseContext.self)
		}
		open func sql_clause(_ i: Int) -> Sql_clauseContext? {
			return getRuleContext(Sql_clauseContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_func_body_returns_scalar }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFunc_body_returns_scalar(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFunc_body_returns_scalar(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFunc_body_returns_scalar(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFunc_body_returns_scalar(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func func_body_returns_scalar() throws -> Func_body_returns_scalarContext {
		var _localctx: Func_body_returns_scalarContext = Func_body_returns_scalarContext(_ctx, getState())
		try enterRule(_localctx, 86, tsqlParser.RULE_func_body_returns_scalar)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1532)
		 	try match(tsqlParser.Tokens.RETURNS.rawValue)
		 	setState(1533)
		 	try data_type()
		 	setState(1543)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1534)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1535)
		 		try function_option()
		 		setState(1540)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1536)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1537)
		 			try function_option()


		 			setState(1542)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(1546)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1545)
		 		try match(tsqlParser.Tokens.AS.rawValue)

		 	}

		 	setState(1548)
		 	try match(tsqlParser.Tokens.BEGIN.rawValue)
		 	setState(1552)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,207,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1549)
		 			try sql_clause()

		 	 
		 		}
		 		setState(1554)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,207,_ctx)
		 	}
		 	setState(1555)
		 	try match(tsqlParser.Tokens.RETURN.rawValue)
		 	setState(1556)
		 	try {
		 			let assignmentValue = try expression(0)
		 			_localctx.castdown(Func_body_returns_scalarContext.self).ret = assignmentValue
		 	     }()

		 	setState(1558)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.SEMI.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1557)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 	}

		 	setState(1560)
		 	try match(tsqlParser.Tokens.END.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Procedure_paramContext:ParserRuleContext {
		public var default_val: Default_valueContext!
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func data_type() -> Data_typeContext? {
			return getRuleContext(Data_typeContext.self,0)
		}
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func VARYING() -> TerminalNode? { return getToken(tsqlParser.Tokens.VARYING.rawValue, 0) }
		open func default_value() -> Default_valueContext? {
			return getRuleContext(Default_valueContext.self,0)
		}
		open func OUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.OUT.rawValue, 0) }
		open func OUTPUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.OUTPUT.rawValue, 0) }
		open func READONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.READONLY.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_procedure_param }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterProcedure_param(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitProcedure_param(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitProcedure_param(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitProcedure_param(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedure_param() throws -> Procedure_paramContext {
		var _localctx: Procedure_paramContext = Procedure_paramContext(_ctx, getState())
		try enterRule(_localctx, 88, tsqlParser.RULE_procedure_param)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1562)
		 	try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 	setState(1566)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,209,_ctx)) {
		 	case 1:
		 		setState(1563)
		 		try id()
		 		setState(1564)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1569)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1568)
		 		try match(tsqlParser.Tokens.AS.rawValue)

		 	}

		 	setState(1571)
		 	try data_type()
		 	setState(1573)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.VARYING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1572)
		 		try match(tsqlParser.Tokens.VARYING.rawValue)

		 	}

		 	setState(1577)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.EQUAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1575)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1576)
		 		try {
		 				let assignmentValue = try default_value()
		 				_localctx.castdown(Procedure_paramContext.self).default_val = assignmentValue
		 		     }()


		 	}

		 	setState(1580)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.READONLY.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 392)
		 	}()
		 	      return testSet
		 	 }()) {
		 		setState(1579)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.READONLY.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 392)
		 		}()
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Procedure_optionContext:ParserRuleContext {
		open func ENCRYPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ENCRYPTION.rawValue, 0) }
		open func RECOMPILE() -> TerminalNode? { return getToken(tsqlParser.Tokens.RECOMPILE.rawValue, 0) }
		open func execute_clause() -> Execute_clauseContext? {
			return getRuleContext(Execute_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_procedure_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterProcedure_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitProcedure_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitProcedure_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitProcedure_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func procedure_option() throws -> Procedure_optionContext {
		var _localctx: Procedure_optionContext = Procedure_optionContext(_ctx, getState())
		try enterRule(_localctx, 90, tsqlParser.RULE_procedure_option)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1585)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ENCRYPTION:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1582)
		 		try match(tsqlParser.Tokens.ENCRYPTION.rawValue)

		 		break

		 	case .RECOMPILE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1583)
		 		try match(tsqlParser.Tokens.RECOMPILE.rawValue)

		 		break

		 	case .EXECUTE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1584)
		 		try execute_clause()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_optionContext:ParserRuleContext {
		open func ENCRYPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ENCRYPTION.rawValue, 0) }
		open func SCHEMABINDING() -> TerminalNode? { return getToken(tsqlParser.Tokens.SCHEMABINDING.rawValue, 0) }
		open func RETURNS() -> TerminalNode? { return getToken(tsqlParser.Tokens.RETURNS.rawValue, 0) }
		open func NULL() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.NULL.rawValue) }
		open func NULL(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.NULL.rawValue, i)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func INPUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.INPUT.rawValue, 0) }
		open func CALLED() -> TerminalNode? { return getToken(tsqlParser.Tokens.CALLED.rawValue, 0) }
		open func execute_clause() -> Execute_clauseContext? {
			return getRuleContext(Execute_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_function_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFunction_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFunction_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFunction_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFunction_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_option() throws -> Function_optionContext {
		var _localctx: Function_optionContext = Function_optionContext(_ctx, getState())
		try enterRule(_localctx, 92, tsqlParser.RULE_function_option)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1599)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ENCRYPTION:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1587)
		 		try match(tsqlParser.Tokens.ENCRYPTION.rawValue)

		 		break

		 	case .SCHEMABINDING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1588)
		 		try match(tsqlParser.Tokens.SCHEMABINDING.rawValue)

		 		break

		 	case .RETURNS:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1589)
		 		try match(tsqlParser.Tokens.RETURNS.rawValue)
		 		setState(1590)
		 		try match(tsqlParser.Tokens.NULL.rawValue)
		 		setState(1591)
		 		try match(tsqlParser.Tokens.ON.rawValue)
		 		setState(1592)
		 		try match(tsqlParser.Tokens.NULL.rawValue)
		 		setState(1593)
		 		try match(tsqlParser.Tokens.INPUT.rawValue)

		 		break

		 	case .CALLED:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1594)
		 		try match(tsqlParser.Tokens.CALLED.rawValue)
		 		setState(1595)
		 		try match(tsqlParser.Tokens.ON.rawValue)
		 		setState(1596)
		 		try match(tsqlParser.Tokens.NULL.rawValue)
		 		setState(1597)
		 		try match(tsqlParser.Tokens.INPUT.rawValue)

		 		break

		 	case .EXECUTE:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1598)
		 		try execute_clause()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_statisticsContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func STATISTICS() -> TerminalNode? { return getToken(tsqlParser.Tokens.STATISTICS.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func table_name_with_hint() -> Table_name_with_hintContext? {
			return getRuleContext(Table_name_with_hintContext.self,0)
		}
		open func column_name_list() -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func FULLSCAN() -> TerminalNode? { return getToken(tsqlParser.Tokens.FULLSCAN.rawValue, 0) }
		open func SAMPLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SAMPLE.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func STATS_STREAM() -> TerminalNode? { return getToken(tsqlParser.Tokens.STATS_STREAM.rawValue, 0) }
		open func PERCENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.PERCENT.rawValue, 0) }
		open func ROWS() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROWS.rawValue, 0) }
		open func NORECOMPUTE() -> TerminalNode? { return getToken(tsqlParser.Tokens.NORECOMPUTE.rawValue, 0) }
		open func INCREMENTAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.INCREMENTAL.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_statistics }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_statistics(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_statistics(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_statistics(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_statistics(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_statistics() throws -> Create_statisticsContext {
		var _localctx: Create_statisticsContext = Create_statisticsContext(_ctx, getState())
		try enterRule(_localctx, 94, tsqlParser.RULE_create_statistics)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1601)
		 	try match(tsqlParser.Tokens.CREATE.rawValue)
		 	setState(1602)
		 	try match(tsqlParser.Tokens.STATISTICS.rawValue)
		 	setState(1603)
		 	try id()
		 	setState(1604)
		 	try match(tsqlParser.Tokens.ON.rawValue)
		 	setState(1605)
		 	try table_name_with_hint()
		 	setState(1606)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(1607)
		 	try column_name_list()
		 	setState(1608)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(1627)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,219,_ctx)) {
		 	case 1:
		 		setState(1609)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1615)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .FULLSCAN:
		 			setState(1610)
		 			try match(tsqlParser.Tokens.FULLSCAN.rawValue)

		 			break

		 		case .SAMPLE:
		 			setState(1611)
		 			try match(tsqlParser.Tokens.SAMPLE.rawValue)
		 			setState(1612)
		 			try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 			setState(1613)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == tsqlParser.Tokens.PERCENT.rawValue
		 			          testSet = testSet || _la == tsqlParser.Tokens.ROWS.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break

		 		case .STATS_STREAM:
		 			setState(1614)
		 			try match(tsqlParser.Tokens.STATS_STREAM.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(1619)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,217,_ctx)) {
		 		case 1:
		 			setState(1617)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1618)
		 			try match(tsqlParser.Tokens.NORECOMPUTE.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(1625)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1621)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1622)
		 			try match(tsqlParser.Tokens.INCREMENTAL.rawValue)
		 			setState(1623)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(1624)
		 			try on_off()

		 		}


		 		break
		 	default: break
		 	}
		 	setState(1630)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,220,_ctx)) {
		 	case 1:
		 		setState(1629)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_tableContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func TABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TABLE.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func column_def_table_constraints() -> Column_def_table_constraintsContext? {
			return getRuleContext(Column_def_table_constraintsContext.self,0)
		}
		open func table_options() -> Array<Table_optionsContext> {
			return getRuleContexts(Table_optionsContext.self)
		}
		open func table_options(_ i: Int) -> Table_optionsContext? {
			return getRuleContext(Table_optionsContext.self,i)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func DEFAULT() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.DEFAULT.rawValue) }
		open func DEFAULT(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.DEFAULT.rawValue, i)
		}
		open func TEXTIMAGE_ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.TEXTIMAGE_ON.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_table }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_table(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_table(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_table(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_table(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_table() throws -> Create_tableContext {
		var _localctx: Create_tableContext = Create_tableContext(_ctx, getState())
		try enterRule(_localctx, 96, tsqlParser.RULE_create_table)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1632)
		 	try match(tsqlParser.Tokens.CREATE.rawValue)
		 	setState(1633)
		 	try match(tsqlParser.Tokens.TABLE.rawValue)
		 	setState(1634)
		 	try table_name()
		 	setState(1635)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(1636)
		 	try column_def_table_constraints()
		 	setState(1638)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1637)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)

		 	}

		 	setState(1640)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(1644)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,222,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1641)
		 			try table_options()

		 	 
		 		}
		 		setState(1646)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,222,_ctx)
		 	}
		 	setState(1650)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,223,_ctx)) {
		 	case 1:
		 		setState(1647)
		 		try match(tsqlParser.Tokens.ON.rawValue)
		 		setState(1648)
		 		try id()

		 		break
		 	case 2:
		 		setState(1649)
		 		try match(tsqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1655)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,224,_ctx)) {
		 	case 1:
		 		setState(1652)
		 		try match(tsqlParser.Tokens.TEXTIMAGE_ON.rawValue)
		 		setState(1653)
		 		try id()

		 		break
		 	case 2:
		 		setState(1654)
		 		try match(tsqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1658)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,225,_ctx)) {
		 	case 1:
		 		setState(1657)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_optionsContext:ParserRuleContext {
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func index_option() -> Array<Index_optionContext> {
			return getRuleContexts(Index_optionContext.self)
		}
		open func index_option(_ i: Int) -> Index_optionContext? {
			return getRuleContext(Index_optionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_options(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_options() throws -> Table_optionsContext {
		var _localctx: Table_optionsContext = Table_optionsContext(_ctx, getState())
		try enterRule(_localctx, 98, tsqlParser.RULE_table_options)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1660)
		 	try match(tsqlParser.Tokens.WITH.rawValue)
		 	setState(1661)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(1662)
		 	try index_option()
		 	setState(1667)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1663)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(1664)
		 		try index_option()


		 		setState(1669)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1670)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_optionContext:ParserRuleContext {
		open func simple_id() -> Array<Simple_idContext> {
			return getRuleContexts(Simple_idContext.self)
		}
		open func simple_id(_ i: Int) -> Simple_idContext? {
			return getRuleContext(Simple_idContext.self,i)
		}
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_option() throws -> Table_optionContext {
		var _localctx: Table_optionContext = Table_optionContext(_ctx, getState())
		try enterRule(_localctx, 100, tsqlParser.RULE_table_option)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1672)
		 	try simple_id()
		 	setState(1673)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(1677)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .ID:
		 		setState(1674)
		 		try simple_id()

		 		break
		 	case .OFF:fallthrough
		 	case .ON:
		 		setState(1675)
		 		try on_off()

		 		break

		 	case .DECIMAL:
		 		setState(1676)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_viewContext:ParserRuleContext {
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func VIEW() -> TerminalNode? { return getToken(tsqlParser.Tokens.VIEW.rawValue, 0) }
		open func simple_name() -> Simple_nameContext? {
			return getRuleContext(Simple_nameContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func column_name_list() -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,0)
		}
		open func WITH() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.WITH.rawValue) }
		open func WITH(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.WITH.rawValue, i)
		}
		open func view_attribute() -> Array<View_attributeContext> {
			return getRuleContexts(View_attributeContext.self)
		}
		open func view_attribute(_ i: Int) -> View_attributeContext? {
			return getRuleContext(View_attributeContext.self,i)
		}
		open func CHECK() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHECK.rawValue, 0) }
		open func OPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPTION.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_view }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_view(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_view(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_view(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_view(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_view() throws -> Create_viewContext {
		var _localctx: Create_viewContext = Create_viewContext(_ctx, getState())
		try enterRule(_localctx, 102, tsqlParser.RULE_create_view)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1679)
		 	try match(tsqlParser.Tokens.CREATE.rawValue)
		 	setState(1680)
		 	try match(tsqlParser.Tokens.VIEW.rawValue)
		 	setState(1681)
		 	try simple_name()
		 	setState(1686)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LR_BRACKET.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1682)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1683)
		 		try column_name_list()
		 		setState(1684)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(1697)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1688)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1689)
		 		try view_attribute()
		 		setState(1694)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1690)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(1691)
		 			try view_attribute()


		 			setState(1696)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(1699)
		 	try match(tsqlParser.Tokens.AS.rawValue)
		 	setState(1700)
		 	try select_statement()
		 	setState(1704)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,231,_ctx)) {
		 	case 1:
		 		setState(1701)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1702)
		 		try match(tsqlParser.Tokens.CHECK.rawValue)
		 		setState(1703)
		 		try match(tsqlParser.Tokens.OPTION.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1707)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,232,_ctx)) {
		 	case 1:
		 		setState(1706)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class View_attributeContext:ParserRuleContext {
		open func ENCRYPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ENCRYPTION.rawValue, 0) }
		open func SCHEMABINDING() -> TerminalNode? { return getToken(tsqlParser.Tokens.SCHEMABINDING.rawValue, 0) }
		open func VIEW_METADATA() -> TerminalNode? { return getToken(tsqlParser.Tokens.VIEW_METADATA.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_view_attribute }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterView_attribute(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitView_attribute(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitView_attribute(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitView_attribute(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func view_attribute() throws -> View_attributeContext {
		var _localctx: View_attributeContext = View_attributeContext(_ctx, getState())
		try enterRule(_localctx, 104, tsqlParser.RULE_view_attribute)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1709)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.ENCRYPTION.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.SCHEMABINDING.rawValue || _la == tsqlParser.Tokens.VIEW_METADATA.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_tableContext:ParserRuleContext {
		public var constraint: IdContext!
		public var fk: Column_name_listContext!
		public var pk: Column_name_listContext!
		open func ALTER() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ALTER.rawValue) }
		open func ALTER(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ALTER.rawValue, i)
		}
		open func TABLE() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.TABLE.rawValue) }
		open func TABLE(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.TABLE.rawValue, i)
		}
		open func table_name() -> Array<Table_nameContext> {
			return getRuleContexts(Table_nameContext.self)
		}
		open func table_name(_ i: Int) -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,i)
		}
		open func SET() -> TerminalNode? { return getToken(tsqlParser.Tokens.SET.rawValue, 0) }
		open func LOCK_ESCALATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCK_ESCALATION.rawValue, 0) }
		open func ADD() -> TerminalNode? { return getToken(tsqlParser.Tokens.ADD.rawValue, 0) }
		open func column_def_table_constraint() -> Column_def_table_constraintContext? {
			return getRuleContext(Column_def_table_constraintContext.self,0)
		}
		open func COLUMN() -> TerminalNode? { return getToken(tsqlParser.Tokens.COLUMN.rawValue, 0) }
		open func column_definition() -> Column_definitionContext? {
			return getRuleContext(Column_definitionContext.self,0)
		}
		open func DROP() -> TerminalNode? { return getToken(tsqlParser.Tokens.DROP.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func CONSTRAINT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONSTRAINT.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func CHECK() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHECK.rawValue, 0) }
		open func FOREIGN() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOREIGN.rawValue, 0) }
		open func KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEY.rawValue, 0) }
		open func REFERENCES() -> TerminalNode? { return getToken(tsqlParser.Tokens.REFERENCES.rawValue, 0) }
		open func REBUILD() -> TerminalNode? { return getToken(tsqlParser.Tokens.REBUILD.rawValue, 0) }
		open func table_options() -> Table_optionsContext? {
			return getRuleContext(Table_optionsContext.self,0)
		}
		open func AUTO() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTO.rawValue, 0) }
		open func DISABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DISABLE.rawValue, 0) }
		open func column_name_list() -> Array<Column_name_listContext> {
			return getRuleContexts(Column_name_listContext.self)
		}
		open func column_name_list(_ i: Int) -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_alter_table }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterAlter_table(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitAlter_table(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitAlter_table(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitAlter_table(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_table() throws -> Alter_tableContext {
		var _localctx: Alter_tableContext = Alter_tableContext(_ctx, getState())
		try enterRule(_localctx, 106, tsqlParser.RULE_alter_table)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1711)
		 	try match(tsqlParser.Tokens.ALTER.rawValue)
		 	setState(1712)
		 	try match(tsqlParser.Tokens.TABLE.rawValue)
		 	setState(1713)
		 	try table_name()
		 	setState(1752)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,233, _ctx)) {
		 	case 1:
		 		setState(1714)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(1715)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1716)
		 		try match(tsqlParser.Tokens.LOCK_ESCALATION.rawValue)
		 		setState(1717)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1718)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.TABLE.rawValue || _la == tsqlParser.Tokens.AUTO.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.DISABLE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1719)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 2:
		 		setState(1720)
		 		try match(tsqlParser.Tokens.ADD.rawValue)
		 		setState(1721)
		 		try column_def_table_constraint()

		 		break
		 	case 3:
		 		setState(1722)
		 		try match(tsqlParser.Tokens.ALTER.rawValue)
		 		setState(1723)
		 		try match(tsqlParser.Tokens.COLUMN.rawValue)
		 		setState(1724)
		 		try column_definition()

		 		break
		 	case 4:
		 		setState(1725)
		 		try match(tsqlParser.Tokens.DROP.rawValue)
		 		setState(1726)
		 		try match(tsqlParser.Tokens.COLUMN.rawValue)
		 		setState(1727)
		 		try id()

		 		break
		 	case 5:
		 		setState(1728)
		 		try match(tsqlParser.Tokens.DROP.rawValue)
		 		setState(1729)
		 		try match(tsqlParser.Tokens.CONSTRAINT.rawValue)
		 		setState(1730)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Alter_tableContext.self).constraint = assignmentValue
		 		     }()


		 		break
		 	case 6:
		 		setState(1731)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(1732)
		 		try match(tsqlParser.Tokens.CHECK.rawValue)
		 		setState(1733)
		 		try match(tsqlParser.Tokens.ADD.rawValue)
		 		setState(1734)
		 		try match(tsqlParser.Tokens.CONSTRAINT.rawValue)
		 		setState(1735)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Alter_tableContext.self).constraint = assignmentValue
		 		     }()

		 		setState(1736)
		 		try match(tsqlParser.Tokens.FOREIGN.rawValue)
		 		setState(1737)
		 		try match(tsqlParser.Tokens.KEY.rawValue)
		 		setState(1738)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1739)
		 		try {
		 				let assignmentValue = try column_name_list()
		 				_localctx.castdown(Alter_tableContext.self).fk = assignmentValue
		 		     }()

		 		setState(1740)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(1741)
		 		try match(tsqlParser.Tokens.REFERENCES.rawValue)
		 		setState(1742)
		 		try table_name()
		 		setState(1743)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1744)
		 		try {
		 				let assignmentValue = try column_name_list()
		 				_localctx.castdown(Alter_tableContext.self).pk = assignmentValue
		 		     }()

		 		setState(1745)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 7:
		 		setState(1747)
		 		try match(tsqlParser.Tokens.CHECK.rawValue)
		 		setState(1748)
		 		try match(tsqlParser.Tokens.CONSTRAINT.rawValue)
		 		setState(1749)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Alter_tableContext.self).constraint = assignmentValue
		 		     }()


		 		break
		 	case 8:
		 		setState(1750)
		 		try match(tsqlParser.Tokens.REBUILD.rawValue)
		 		setState(1751)
		 		try table_options()

		 		break
		 	default: break
		 	}
		 	setState(1755)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,234,_ctx)) {
		 	case 1:
		 		setState(1754)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Alter_databaseContext:ParserRuleContext {
		public var database: IdContext!
		public var new_name: IdContext!
		public var collation: IdContext!
		open func ALTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALTER.rawValue, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATABASE.rawValue, 0) }
		open func CURRENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CURRENT.rawValue, 0) }
		open func MODIFY() -> TerminalNode? { return getToken(tsqlParser.Tokens.MODIFY.rawValue, 0) }
		open func NAME() -> TerminalNode? { return getToken(tsqlParser.Tokens.NAME.rawValue, 0) }
		open func COLLATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.COLLATE.rawValue, 0) }
		open func SET() -> TerminalNode? { return getToken(tsqlParser.Tokens.SET.rawValue, 0) }
		open func database_optionspec() -> Database_optionspecContext? {
			return getRuleContext(Database_optionspecContext.self,0)
		}
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func termination() -> TerminationContext? {
			return getRuleContext(TerminationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_alter_database }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterAlter_database(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitAlter_database(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitAlter_database(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitAlter_database(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func alter_database() throws -> Alter_databaseContext {
		var _localctx: Alter_databaseContext = Alter_databaseContext(_ctx, getState())
		try enterRule(_localctx, 108, tsqlParser.RULE_alter_database)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1757)
		 	try match(tsqlParser.Tokens.ALTER.rawValue)
		 	setState(1758)
		 	try match(tsqlParser.Tokens.DATABASE.rawValue)
		 	setState(1761)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .ID:
		 		setState(1759)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Alter_databaseContext.self).database = assignmentValue
		 		     }()


		 		break

		 	case .CURRENT:
		 		setState(1760)
		 		try match(tsqlParser.Tokens.CURRENT.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1775)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .MODIFY:
		 		setState(1763)
		 		try match(tsqlParser.Tokens.MODIFY.rawValue)
		 		setState(1764)
		 		try match(tsqlParser.Tokens.NAME.rawValue)
		 		setState(1765)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1766)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Alter_databaseContext.self).new_name = assignmentValue
		 		     }()


		 		break

		 	case .COLLATE:
		 		setState(1767)
		 		try match(tsqlParser.Tokens.COLLATE.rawValue)
		 		setState(1768)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Alter_databaseContext.self).collation = assignmentValue
		 		     }()


		 		break

		 	case .SET:
		 		setState(1769)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(1770)
		 		try database_optionspec()
		 		setState(1773)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,236,_ctx)) {
		 		case 1:
		 			setState(1771)
		 			try match(tsqlParser.Tokens.WITH.rawValue)
		 			setState(1772)
		 			try termination()

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(1778)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,238,_ctx)) {
		 	case 1:
		 		setState(1777)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Database_optionspecContext:ParserRuleContext {
		open func auto_option() -> Auto_optionContext? {
			return getRuleContext(Auto_optionContext.self,0)
		}
		open func change_tracking_option() -> Change_tracking_optionContext? {
			return getRuleContext(Change_tracking_optionContext.self,0)
		}
		open func containment_option() -> Containment_optionContext? {
			return getRuleContext(Containment_optionContext.self,0)
		}
		open func cursor_option() -> Cursor_optionContext? {
			return getRuleContext(Cursor_optionContext.self,0)
		}
		open func date_correlation_optimization_option() -> Date_correlation_optimization_optionContext? {
			return getRuleContext(Date_correlation_optimization_optionContext.self,0)
		}
		open func db_encryption_option() -> Db_encryption_optionContext? {
			return getRuleContext(Db_encryption_optionContext.self,0)
		}
		open func db_state_option() -> Db_state_optionContext? {
			return getRuleContext(Db_state_optionContext.self,0)
		}
		open func db_update_option() -> Db_update_optionContext? {
			return getRuleContext(Db_update_optionContext.self,0)
		}
		open func db_user_access_option() -> Db_user_access_optionContext? {
			return getRuleContext(Db_user_access_optionContext.self,0)
		}
		open func delayed_durability_option() -> Delayed_durability_optionContext? {
			return getRuleContext(Delayed_durability_optionContext.self,0)
		}
		open func external_access_option() -> External_access_optionContext? {
			return getRuleContext(External_access_optionContext.self,0)
		}
		open func FILESTREAM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FILESTREAM.rawValue, 0) }
		open func database_filestream_option() -> Database_filestream_optionContext? {
			return getRuleContext(Database_filestream_optionContext.self,0)
		}
		open func hadr_options() -> Hadr_optionsContext? {
			return getRuleContext(Hadr_optionsContext.self,0)
		}
		open func mixed_page_allocation_option() -> Mixed_page_allocation_optionContext? {
			return getRuleContext(Mixed_page_allocation_optionContext.self,0)
		}
		open func parameterization_option() -> Parameterization_optionContext? {
			return getRuleContext(Parameterization_optionContext.self,0)
		}
		open func recovery_option() -> Recovery_optionContext? {
			return getRuleContext(Recovery_optionContext.self,0)
		}
		open func service_broker_option() -> Service_broker_optionContext? {
			return getRuleContext(Service_broker_optionContext.self,0)
		}
		open func snapshot_option() -> Snapshot_optionContext? {
			return getRuleContext(Snapshot_optionContext.self,0)
		}
		open func sql_option() -> Sql_optionContext? {
			return getRuleContext(Sql_optionContext.self,0)
		}
		open func target_recovery_time_option() -> Target_recovery_time_optionContext? {
			return getRuleContext(Target_recovery_time_optionContext.self,0)
		}
		open func termination() -> TerminationContext? {
			return getRuleContext(TerminationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_database_optionspec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDatabase_optionspec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDatabase_optionspec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDatabase_optionspec(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDatabase_optionspec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func database_optionspec() throws -> Database_optionspecContext {
		var _localctx: Database_optionspecContext = Database_optionspecContext(_ctx, getState())
		try enterRule(_localctx, 110, tsqlParser.RULE_database_optionspec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1802)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,239, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1780)
		 		try auto_option()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1781)
		 		try change_tracking_option()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1782)
		 		try containment_option()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1783)
		 		try cursor_option()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1784)
		 		try date_correlation_optimization_option()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1785)
		 		try db_encryption_option()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1786)
		 		try db_state_option()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1787)
		 		try db_update_option()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1788)
		 		try db_user_access_option()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1789)
		 		try delayed_durability_option()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1790)
		 		try external_access_option()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(1791)
		 		try match(tsqlParser.Tokens.FILESTREAM.rawValue)
		 		setState(1792)
		 		try database_filestream_option()

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(1793)
		 		try hadr_options()

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(1794)
		 		try mixed_page_allocation_option()

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(1795)
		 		try parameterization_option()

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(1796)
		 		try recovery_option()

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(1797)
		 		try service_broker_option()

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(1798)
		 		try snapshot_option()

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(1799)
		 		try sql_option()

		 		break
		 	case 20:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(1800)
		 		try target_recovery_time_option()

		 		break
		 	case 21:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(1801)
		 		try termination()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Auto_optionContext:ParserRuleContext {
		open func AUTO_CLOSE() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTO_CLOSE.rawValue, 0) }
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open func AUTO_CREATE_STATISTICS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTO_CREATE_STATISTICS.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open func ON() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ON.rawValue) }
		open func ON(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ON.rawValue, i)
		}
		open func INCREMENTAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.INCREMENTAL.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func AUTO_SHRINK() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTO_SHRINK.rawValue, 0) }
		open func AUTO_UPDATE_STATISTICS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTO_UPDATE_STATISTICS.rawValue, 0) }
		open func AUTO_UPDATE_STATISTICS_ASYNC() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTO_UPDATE_STATISTICS_ASYNC.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_auto_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterAuto_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitAuto_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitAuto_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitAuto_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func auto_option() throws -> Auto_optionContext {
		var _localctx: Auto_optionContext = Auto_optionContext(_ctx, getState())
		try enterRule(_localctx, 112, tsqlParser.RULE_auto_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1821)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .AUTO_CLOSE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1804)
		 		try match(tsqlParser.Tokens.AUTO_CLOSE.rawValue)
		 		setState(1805)
		 		try on_off()

		 		break

		 	case .AUTO_CREATE_STATISTICS:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1806)
		 		try match(tsqlParser.Tokens.AUTO_CREATE_STATISTICS.rawValue)
		 		setState(1807)
		 		try match(tsqlParser.Tokens.OFF.rawValue)

		 		break

		 	case .ON:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1808)
		 		try match(tsqlParser.Tokens.ON.rawValue)
		 		setState(1813)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .INCREMENTAL:
		 			setState(1809)
		 			try match(tsqlParser.Tokens.INCREMENTAL.rawValue)
		 			setState(1810)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(1811)
		 			try match(tsqlParser.Tokens.ON.rawValue)

		 			break

		 		case .OFF:
		 			setState(1812)
		 			try match(tsqlParser.Tokens.OFF.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .AUTO_SHRINK:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1815)
		 		try match(tsqlParser.Tokens.AUTO_SHRINK.rawValue)
		 		setState(1816)
		 		try on_off()

		 		break

		 	case .AUTO_UPDATE_STATISTICS:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1817)
		 		try match(tsqlParser.Tokens.AUTO_UPDATE_STATISTICS.rawValue)
		 		setState(1818)
		 		try on_off()

		 		break

		 	case .AUTO_UPDATE_STATISTICS_ASYNC:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1819)
		 		try match(tsqlParser.Tokens.AUTO_UPDATE_STATISTICS_ASYNC.rawValue)
		 		setState(1820)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Change_tracking_optionContext:ParserRuleContext {
		open func CHANGE_TRACKING() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHANGE_TRACKING.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func change_tracking_option_list() -> Array<Change_tracking_option_listContext> {
			return getRuleContexts(Change_tracking_option_listContext.self)
		}
		open func change_tracking_option_list(_ i: Int) -> Change_tracking_option_listContext? {
			return getRuleContext(Change_tracking_option_listContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_change_tracking_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterChange_tracking_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitChange_tracking_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitChange_tracking_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitChange_tracking_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func change_tracking_option() throws -> Change_tracking_optionContext {
		var _localctx: Change_tracking_optionContext = Change_tracking_optionContext(_ctx, getState())
		try enterRule(_localctx, 114, tsqlParser.RULE_change_tracking_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1823)
		 	try match(tsqlParser.Tokens.CHANGE_TRACKING.rawValue)
		 	setState(1824)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(1840)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .OFF:
		 		setState(1825)
		 		try match(tsqlParser.Tokens.OFF.rawValue)

		 		break

		 	case .ON:
		 		setState(1826)
		 		try match(tsqlParser.Tokens.ON.rawValue)
		 		setState(1837)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.AUTO_CLEANUP.rawValue || _la == tsqlParser.Tokens.CHANGE_RETENTION.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(1827)
		 			try change_tracking_option_list()
		 			setState(1832)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(1828)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)
		 				setState(1829)
		 				try change_tracking_option_list()


		 				setState(1834)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}


		 			setState(1839)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Change_tracking_option_listContext:ParserRuleContext {
		open func AUTO_CLEANUP() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTO_CLEANUP.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open func CHANGE_RETENTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHANGE_RETENTION.rawValue, 0) }
		open func DAYS() -> TerminalNode? { return getToken(tsqlParser.Tokens.DAYS.rawValue, 0) }
		open func HOURS() -> TerminalNode? { return getToken(tsqlParser.Tokens.HOURS.rawValue, 0) }
		open func MINUTES() -> TerminalNode? { return getToken(tsqlParser.Tokens.MINUTES.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_change_tracking_option_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterChange_tracking_option_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitChange_tracking_option_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitChange_tracking_option_list(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitChange_tracking_option_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func change_tracking_option_list() throws -> Change_tracking_option_listContext {
		var _localctx: Change_tracking_option_listContext = Change_tracking_option_listContext(_ctx, getState())
		try enterRule(_localctx, 116, tsqlParser.RULE_change_tracking_option_list)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1848)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .AUTO_CLEANUP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1842)
		 		try match(tsqlParser.Tokens.AUTO_CLEANUP.rawValue)
		 		setState(1843)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1844)
		 		try on_off()

		 		break

		 	case .CHANGE_RETENTION:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1845)
		 		try match(tsqlParser.Tokens.CHANGE_RETENTION.rawValue)
		 		setState(1846)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1847)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.DAYS.rawValue || _la == tsqlParser.Tokens.HOURS.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.MINUTES.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Containment_optionContext:ParserRuleContext {
		open func CONTAINMENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONTAINMENT.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func NONE() -> TerminalNode? { return getToken(tsqlParser.Tokens.NONE.rawValue, 0) }
		open func PARTIAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.PARTIAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_containment_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterContainment_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitContainment_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitContainment_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitContainment_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func containment_option() throws -> Containment_optionContext {
		var _localctx: Containment_optionContext = Containment_optionContext(_ctx, getState())
		try enterRule(_localctx, 118, tsqlParser.RULE_containment_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1850)
		 	try match(tsqlParser.Tokens.CONTAINMENT.rawValue)
		 	setState(1851)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(1852)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.NONE.rawValue || _la == tsqlParser.Tokens.PARTIAL.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_optionContext:ParserRuleContext {
		open func CURSOR_CLOSE_ON_COMMIT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CURSOR_CLOSE_ON_COMMIT.rawValue, 0) }
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open func CURSOR_DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CURSOR_DEFAULT.rawValue, 0) }
		open func LOCAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL.rawValue, 0) }
		open func GLOBAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.GLOBAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_cursor_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCursor_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCursor_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCursor_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCursor_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_option() throws -> Cursor_optionContext {
		var _localctx: Cursor_optionContext = Cursor_optionContext(_ctx, getState())
		try enterRule(_localctx, 120, tsqlParser.RULE_cursor_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1858)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CURSOR_CLOSE_ON_COMMIT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1854)
		 		try match(tsqlParser.Tokens.CURSOR_CLOSE_ON_COMMIT.rawValue)
		 		setState(1855)
		 		try on_off()

		 		break

		 	case .CURSOR_DEFAULT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1856)
		 		try match(tsqlParser.Tokens.CURSOR_DEFAULT.rawValue)
		 		setState(1857)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.GLOBAL.rawValue || _la == tsqlParser.Tokens.LOCAL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Date_correlation_optimization_optionContext:ParserRuleContext {
		open func DATE_CORRELATION_OPTIMIZATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATE_CORRELATION_OPTIMIZATION.rawValue, 0) }
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_date_correlation_optimization_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDate_correlation_optimization_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDate_correlation_optimization_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDate_correlation_optimization_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDate_correlation_optimization_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func date_correlation_optimization_option() throws -> Date_correlation_optimization_optionContext {
		var _localctx: Date_correlation_optimization_optionContext = Date_correlation_optimization_optionContext(_ctx, getState())
		try enterRule(_localctx, 122, tsqlParser.RULE_date_correlation_optimization_option)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1860)
		 	try match(tsqlParser.Tokens.DATE_CORRELATION_OPTIMIZATION.rawValue)
		 	setState(1861)
		 	try on_off()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Db_encryption_optionContext:ParserRuleContext {
		open func ENCRYPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ENCRYPTION.rawValue, 0) }
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_db_encryption_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDb_encryption_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDb_encryption_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDb_encryption_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDb_encryption_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func db_encryption_option() throws -> Db_encryption_optionContext {
		var _localctx: Db_encryption_optionContext = Db_encryption_optionContext(_ctx, getState())
		try enterRule(_localctx, 124, tsqlParser.RULE_db_encryption_option)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1863)
		 	try match(tsqlParser.Tokens.ENCRYPTION.rawValue)
		 	setState(1864)
		 	try on_off()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Db_state_optionContext:ParserRuleContext {
		open func ONLINE() -> TerminalNode? { return getToken(tsqlParser.Tokens.ONLINE.rawValue, 0) }
		open func OFFLINE() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFFLINE.rawValue, 0) }
		open func EMERGENCY() -> TerminalNode? { return getToken(tsqlParser.Tokens.EMERGENCY.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_db_state_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDb_state_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDb_state_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDb_state_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDb_state_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func db_state_option() throws -> Db_state_optionContext {
		var _localctx: Db_state_optionContext = Db_state_optionContext(_ctx, getState())
		try enterRule(_localctx, 126, tsqlParser.RULE_db_state_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1866)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.EMERGENCY.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.OFFLINE.rawValue || _la == tsqlParser.Tokens.ONLINE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Db_update_optionContext:ParserRuleContext {
		open func READ_ONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.READ_ONLY.rawValue, 0) }
		open func READ_WRITE() -> TerminalNode? { return getToken(tsqlParser.Tokens.READ_WRITE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_db_update_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDb_update_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDb_update_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDb_update_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDb_update_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func db_update_option() throws -> Db_update_optionContext {
		var _localctx: Db_update_optionContext = Db_update_optionContext(_ctx, getState())
		try enterRule(_localctx, 128, tsqlParser.RULE_db_update_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1868)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.READ_ONLY.rawValue || _la == tsqlParser.Tokens.READ_WRITE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Db_user_access_optionContext:ParserRuleContext {
		open func SINGLE_USER() -> TerminalNode? { return getToken(tsqlParser.Tokens.SINGLE_USER.rawValue, 0) }
		open func RESTRICTED_USER() -> TerminalNode? { return getToken(tsqlParser.Tokens.RESTRICTED_USER.rawValue, 0) }
		open func MULTI_USER() -> TerminalNode? { return getToken(tsqlParser.Tokens.MULTI_USER.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_db_user_access_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDb_user_access_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDb_user_access_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDb_user_access_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDb_user_access_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func db_user_access_option() throws -> Db_user_access_optionContext {
		var _localctx: Db_user_access_optionContext = Db_user_access_optionContext(_ctx, getState())
		try enterRule(_localctx, 130, tsqlParser.RULE_db_user_access_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1870)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.MULTI_USER.rawValue || _la == tsqlParser.Tokens.RESTRICTED_USER.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.SINGLE_USER.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Delayed_durability_optionContext:ParserRuleContext {
		open func DELAYED_DURABILITY() -> TerminalNode? { return getToken(tsqlParser.Tokens.DELAYED_DURABILITY.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func DISABLED() -> TerminalNode? { return getToken(tsqlParser.Tokens.DISABLED.rawValue, 0) }
		open func ALLOWED() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALLOWED.rawValue, 0) }
		open func FORCED() -> TerminalNode? { return getToken(tsqlParser.Tokens.FORCED.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_delayed_durability_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDelayed_durability_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDelayed_durability_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDelayed_durability_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDelayed_durability_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func delayed_durability_option() throws -> Delayed_durability_optionContext {
		var _localctx: Delayed_durability_optionContext = Delayed_durability_optionContext(_ctx, getState())
		try enterRule(_localctx, 132, tsqlParser.RULE_delayed_durability_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1872)
		 	try match(tsqlParser.Tokens.DELAYED_DURABILITY.rawValue)
		 	setState(1873)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(1874)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.ALLOWED.rawValue || _la == tsqlParser.Tokens.DISABLED.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.FORCED.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class External_access_optionContext:ParserRuleContext {
		open func DB_CHAINING() -> TerminalNode? { return getToken(tsqlParser.Tokens.DB_CHAINING.rawValue, 0) }
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open func TRUSTWORTHY() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRUSTWORTHY.rawValue, 0) }
		open func DEFAULT_LANGUAGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT_LANGUAGE.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func DEFAULT_FULLTEXT_LANGUAGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT_FULLTEXT_LANGUAGE.rawValue, 0) }
		open func NESTED_TRIGGERS() -> TerminalNode? { return getToken(tsqlParser.Tokens.NESTED_TRIGGERS.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func TRANSFORM_NOISE_WORDS() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRANSFORM_NOISE_WORDS.rawValue, 0) }
		open func TWO_DIGIT_YEAR_CUTOFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.TWO_DIGIT_YEAR_CUTOFF.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_external_access_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterExternal_access_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitExternal_access_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitExternal_access_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitExternal_access_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func external_access_option() throws -> External_access_optionContext {
		var _localctx: External_access_optionContext = External_access_optionContext(_ctx, getState())
		try enterRule(_localctx, 134, tsqlParser.RULE_external_access_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1901)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DB_CHAINING:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1876)
		 		try match(tsqlParser.Tokens.DB_CHAINING.rawValue)
		 		setState(1877)
		 		try on_off()

		 		break

		 	case .TRUSTWORTHY:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1878)
		 		try match(tsqlParser.Tokens.TRUSTWORTHY.rawValue)
		 		setState(1879)
		 		try on_off()

		 		break

		 	case .DEFAULT_LANGUAGE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1880)
		 		try match(tsqlParser.Tokens.DEFAULT_LANGUAGE.rawValue)
		 		setState(1881)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1884)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CALLED:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .ID:
		 			setState(1882)
		 			try id()

		 			break

		 		case .STRING:
		 			setState(1883)
		 			try match(tsqlParser.Tokens.STRING.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .DEFAULT_FULLTEXT_LANGUAGE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1886)
		 		try match(tsqlParser.Tokens.DEFAULT_FULLTEXT_LANGUAGE.rawValue)
		 		setState(1887)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1890)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CALLED:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .ID:
		 			setState(1888)
		 			try id()

		 			break

		 		case .STRING:
		 			setState(1889)
		 			try match(tsqlParser.Tokens.STRING.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .NESTED_TRIGGERS:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1892)
		 		try match(tsqlParser.Tokens.NESTED_TRIGGERS.rawValue)
		 		setState(1893)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1894)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .TRANSFORM_NOISE_WORDS:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1895)
		 		try match(tsqlParser.Tokens.TRANSFORM_NOISE_WORDS.rawValue)
		 		setState(1896)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1897)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .TWO_DIGIT_YEAR_CUTOFF:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1898)
		 		try match(tsqlParser.Tokens.TWO_DIGIT_YEAR_CUTOFF.rawValue)
		 		setState(1899)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1900)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Hadr_optionsContext:ParserRuleContext {
		open func ALTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALTER.rawValue, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATABASE.rawValue, 0) }
		open func SET() -> TerminalNode? { return getToken(tsqlParser.Tokens.SET.rawValue, 0) }
		open func HADR() -> TerminalNode? { return getToken(tsqlParser.Tokens.HADR.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_hadr_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterHadr_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitHadr_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitHadr_options(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitHadr_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func hadr_options() throws -> Hadr_optionsContext {
		var _localctx: Hadr_optionsContext = Hadr_optionsContext(_ctx, getState())
		try enterRule(_localctx, 136, tsqlParser.RULE_hadr_options)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1903)
		 	try match(tsqlParser.Tokens.ALTER.rawValue)
		 	setState(1904)
		 	try match(tsqlParser.Tokens.DATABASE.rawValue)
		 	setState(1905)
		 	try match(tsqlParser.Tokens.SET.rawValue)
		 	setState(1906)
		 	try match(tsqlParser.Tokens.HADR.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Mixed_page_allocation_optionContext:ParserRuleContext {
		open func MIXED_PAGE_ALLOCATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.MIXED_PAGE_ALLOCATION.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_mixed_page_allocation_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterMixed_page_allocation_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitMixed_page_allocation_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitMixed_page_allocation_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitMixed_page_allocation_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func mixed_page_allocation_option() throws -> Mixed_page_allocation_optionContext {
		var _localctx: Mixed_page_allocation_optionContext = Mixed_page_allocation_optionContext(_ctx, getState())
		try enterRule(_localctx, 138, tsqlParser.RULE_mixed_page_allocation_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1908)
		 	try match(tsqlParser.Tokens.MIXED_PAGE_ALLOCATION.rawValue)
		 	setState(1909)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Parameterization_optionContext:ParserRuleContext {
		open func PARAMETERIZATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.PARAMETERIZATION.rawValue, 0) }
		open func SIMPLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SIMPLE.rawValue, 0) }
		open func FORCED() -> TerminalNode? { return getToken(tsqlParser.Tokens.FORCED.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_parameterization_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterParameterization_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitParameterization_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitParameterization_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitParameterization_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func parameterization_option() throws -> Parameterization_optionContext {
		var _localctx: Parameterization_optionContext = Parameterization_optionContext(_ctx, getState())
		try enterRule(_localctx, 140, tsqlParser.RULE_parameterization_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1911)
		 	try match(tsqlParser.Tokens.PARAMETERIZATION.rawValue)
		 	setState(1912)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.FORCED.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.SIMPLE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Recovery_optionContext:ParserRuleContext {
		open func RECOVERY() -> TerminalNode? { return getToken(tsqlParser.Tokens.RECOVERY.rawValue, 0) }
		open func FULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.FULL.rawValue, 0) }
		open func BULK_LOGGED() -> TerminalNode? { return getToken(tsqlParser.Tokens.BULK_LOGGED.rawValue, 0) }
		open func SIMPLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SIMPLE.rawValue, 0) }
		open func TORN_PAGE_DETECTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.TORN_PAGE_DETECTION.rawValue, 0) }
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open func PAGE_VERIFY() -> TerminalNode? { return getToken(tsqlParser.Tokens.PAGE_VERIFY.rawValue, 0) }
		open func CHECKSUM() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHECKSUM.rawValue, 0) }
		open func NONE() -> TerminalNode? { return getToken(tsqlParser.Tokens.NONE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_recovery_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterRecovery_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitRecovery_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitRecovery_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitRecovery_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func recovery_option() throws -> Recovery_optionContext {
		var _localctx: Recovery_optionContext = Recovery_optionContext(_ctx, getState())
		try enterRule(_localctx, 142, tsqlParser.RULE_recovery_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1920)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .RECOVERY:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1914)
		 		try match(tsqlParser.Tokens.RECOVERY.rawValue)
		 		setState(1915)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.FULL.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.BULK_LOGGED.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.SIMPLE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .TORN_PAGE_DETECTION:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1916)
		 		try match(tsqlParser.Tokens.TORN_PAGE_DETECTION.rawValue)
		 		setState(1917)
		 		try on_off()

		 		break

		 	case .PAGE_VERIFY:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1918)
		 		try match(tsqlParser.Tokens.PAGE_VERIFY.rawValue)
		 		setState(1919)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.NONE.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.CHECKSUM.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.TORN_PAGE_DETECTION.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Service_broker_optionContext:ParserRuleContext {
		open func ENABLE_BROKER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ENABLE_BROKER.rawValue, 0) }
		open func DISABLE_BROKER() -> TerminalNode? { return getToken(tsqlParser.Tokens.DISABLE_BROKER.rawValue, 0) }
		open func NEW_BROKER() -> TerminalNode? { return getToken(tsqlParser.Tokens.NEW_BROKER.rawValue, 0) }
		open func ERROR_BROKER_CONVERSATIONS() -> TerminalNode? { return getToken(tsqlParser.Tokens.ERROR_BROKER_CONVERSATIONS.rawValue, 0) }
		open func HONOR_BROKER_PRIORITY() -> TerminalNode? { return getToken(tsqlParser.Tokens.HONOR_BROKER_PRIORITY.rawValue, 0) }
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_service_broker_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterService_broker_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitService_broker_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitService_broker_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitService_broker_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func service_broker_option() throws -> Service_broker_optionContext {
		var _localctx: Service_broker_optionContext = Service_broker_optionContext(_ctx, getState())
		try enterRule(_localctx, 144, tsqlParser.RULE_service_broker_option)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1928)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ENABLE_BROKER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1922)
		 		try match(tsqlParser.Tokens.ENABLE_BROKER.rawValue)

		 		break

		 	case .DISABLE_BROKER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1923)
		 		try match(tsqlParser.Tokens.DISABLE_BROKER.rawValue)

		 		break

		 	case .NEW_BROKER:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1924)
		 		try match(tsqlParser.Tokens.NEW_BROKER.rawValue)

		 		break

		 	case .ERROR_BROKER_CONVERSATIONS:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1925)
		 		try match(tsqlParser.Tokens.ERROR_BROKER_CONVERSATIONS.rawValue)

		 		break

		 	case .HONOR_BROKER_PRIORITY:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1926)
		 		try match(tsqlParser.Tokens.HONOR_BROKER_PRIORITY.rawValue)
		 		setState(1927)
		 		try on_off()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Snapshot_optionContext:ParserRuleContext {
		public var MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT: Token!
		open func ALLOW_SNAPSHOT_ISOLATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALLOW_SNAPSHOT_ISOLATION.rawValue, 0) }
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open func READ_COMMITTED_SNAPSHOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.READ_COMMITTED_SNAPSHOT.rawValue, 0) }
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_snapshot_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSnapshot_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSnapshot_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSnapshot_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSnapshot_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func snapshot_option() throws -> Snapshot_optionContext {
		var _localctx: Snapshot_optionContext = Snapshot_optionContext(_ctx, getState())
		try enterRule(_localctx, 146, tsqlParser.RULE_snapshot_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1935)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ALLOW_SNAPSHOT_ISOLATION:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1930)
		 		try match(tsqlParser.Tokens.ALLOW_SNAPSHOT_ISOLATION.rawValue)
		 		setState(1931)
		 		try on_off()

		 		break

		 	case .READ_COMMITTED_SNAPSHOT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1932)
		 		try match(tsqlParser.Tokens.READ_COMMITTED_SNAPSHOT.rawValue)
		 		setState(1933)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case .OFF:fallthrough
		 	case .ON:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1934)
		 		_localctx.castdown(Snapshot_optionContext.self).MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 			_localctx.castdown(Snapshot_optionContext.self).MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Sql_optionContext:ParserRuleContext {
		open func ANSI_NULL_DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.ANSI_NULL_DEFAULT.rawValue, 0) }
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open func ANSI_NULLS() -> TerminalNode? { return getToken(tsqlParser.Tokens.ANSI_NULLS.rawValue, 0) }
		open func ANSI_PADDING() -> TerminalNode? { return getToken(tsqlParser.Tokens.ANSI_PADDING.rawValue, 0) }
		open func ANSI_WARNINGS() -> TerminalNode? { return getToken(tsqlParser.Tokens.ANSI_WARNINGS.rawValue, 0) }
		open func ARITHABORT() -> TerminalNode? { return getToken(tsqlParser.Tokens.ARITHABORT.rawValue, 0) }
		open func COMPATIBILITY_LEVEL() -> TerminalNode? { return getToken(tsqlParser.Tokens.COMPATIBILITY_LEVEL.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func CONCAT_NULL_YIELDS_NULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue, 0) }
		open func NUMERIC_ROUNDABORT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NUMERIC_ROUNDABORT.rawValue, 0) }
		open func QUOTED_IDENTIFIER() -> TerminalNode? { return getToken(tsqlParser.Tokens.QUOTED_IDENTIFIER.rawValue, 0) }
		open func RECURSIVE_TRIGGERS() -> TerminalNode? { return getToken(tsqlParser.Tokens.RECURSIVE_TRIGGERS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_sql_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSql_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSql_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSql_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSql_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sql_option() throws -> Sql_optionContext {
		var _localctx: Sql_optionContext = Sql_optionContext(_ctx, getState())
		try enterRule(_localctx, 148, tsqlParser.RULE_sql_option)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1958)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ANSI_NULL_DEFAULT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1937)
		 		try match(tsqlParser.Tokens.ANSI_NULL_DEFAULT.rawValue)
		 		setState(1938)
		 		try on_off()

		 		break

		 	case .ANSI_NULLS:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1939)
		 		try match(tsqlParser.Tokens.ANSI_NULLS.rawValue)
		 		setState(1940)
		 		try on_off()

		 		break

		 	case .ANSI_PADDING:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1941)
		 		try match(tsqlParser.Tokens.ANSI_PADDING.rawValue)
		 		setState(1942)
		 		try on_off()

		 		break

		 	case .ANSI_WARNINGS:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1943)
		 		try match(tsqlParser.Tokens.ANSI_WARNINGS.rawValue)
		 		setState(1944)
		 		try on_off()

		 		break

		 	case .ARITHABORT:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1945)
		 		try match(tsqlParser.Tokens.ARITHABORT.rawValue)
		 		setState(1946)
		 		try on_off()

		 		break

		 	case .COMPATIBILITY_LEVEL:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1947)
		 		try match(tsqlParser.Tokens.COMPATIBILITY_LEVEL.rawValue)
		 		setState(1948)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(1949)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 		break

		 	case .CONCAT_NULL_YIELDS_NULL:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1950)
		 		try match(tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue)
		 		setState(1951)
		 		try on_off()

		 		break

		 	case .NUMERIC_ROUNDABORT:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1952)
		 		try match(tsqlParser.Tokens.NUMERIC_ROUNDABORT.rawValue)
		 		setState(1953)
		 		try on_off()

		 		break

		 	case .QUOTED_IDENTIFIER:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1954)
		 		try match(tsqlParser.Tokens.QUOTED_IDENTIFIER.rawValue)
		 		setState(1955)
		 		try on_off()

		 		break

		 	case .RECURSIVE_TRIGGERS:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1956)
		 		try match(tsqlParser.Tokens.RECURSIVE_TRIGGERS.rawValue)
		 		setState(1957)
		 		try on_off()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Target_recovery_time_optionContext:ParserRuleContext {
		open func TARGET_RECOVERY_TIME() -> TerminalNode? { return getToken(tsqlParser.Tokens.TARGET_RECOVERY_TIME.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func SECONDS() -> TerminalNode? { return getToken(tsqlParser.Tokens.SECONDS.rawValue, 0) }
		open func MINUTES() -> TerminalNode? { return getToken(tsqlParser.Tokens.MINUTES.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_target_recovery_time_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTarget_recovery_time_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTarget_recovery_time_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTarget_recovery_time_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTarget_recovery_time_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func target_recovery_time_option() throws -> Target_recovery_time_optionContext {
		var _localctx: Target_recovery_time_optionContext = Target_recovery_time_optionContext(_ctx, getState())
		try enterRule(_localctx, 150, tsqlParser.RULE_target_recovery_time_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1960)
		 	try match(tsqlParser.Tokens.TARGET_RECOVERY_TIME.rawValue)
		 	setState(1961)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(1962)
		 	try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 	setState(1963)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.MINUTES.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.SECONDS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class TerminationContext:ParserRuleContext {
		public var seconds: Token!
		open func ROLLBACK() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROLLBACK.rawValue, 0) }
		open func AFTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.AFTER.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func IMMEDIATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.IMMEDIATE.rawValue, 0) }
		open func NO_WAIT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NO_WAIT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_termination }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTermination(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTermination(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTermination(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTermination(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func termination() throws -> TerminationContext {
		var _localctx: TerminationContext = TerminationContext(_ctx, getState())
		try enterRule(_localctx, 152, tsqlParser.RULE_termination)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1971)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,254, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1965)
		 		try match(tsqlParser.Tokens.ROLLBACK.rawValue)
		 		setState(1966)
		 		try match(tsqlParser.Tokens.AFTER.rawValue)
		 		setState(1967)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 				_localctx.castdown(TerminationContext.self).seconds = assignmentValue
		 		     }()


		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1968)
		 		try match(tsqlParser.Tokens.ROLLBACK.rawValue)
		 		setState(1969)
		 		try match(tsqlParser.Tokens.IMMEDIATE.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1970)
		 		try match(tsqlParser.Tokens.NO_WAIT.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_indexContext:ParserRuleContext {
		public var schema: IdContext!
		public var table: IdContext!
		public var index_name: IdContext!
		open func DROP() -> TerminalNode? { return getToken(tsqlParser.Tokens.DROP.rawValue, 0) }
		open func INDEX() -> TerminalNode? { return getToken(tsqlParser.Tokens.INDEX.rawValue, 0) }
		open func IF() -> TerminalNode? { return getToken(tsqlParser.Tokens.IF.rawValue, 0) }
		open func EXISTS() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXISTS.rawValue, 0) }
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_drop_index }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDrop_index(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDrop_index(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDrop_index(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDrop_index(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_index() throws -> Drop_indexContext {
		var _localctx: Drop_indexContext = Drop_indexContext(_ctx, getState())
		try enterRule(_localctx, 154, tsqlParser.RULE_drop_index)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1973)
		 	try match(tsqlParser.Tokens.DROP.rawValue)
		 	setState(1974)
		 	try match(tsqlParser.Tokens.INDEX.rawValue)
		 	setState(1977)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.IF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1975)
		 		try match(tsqlParser.Tokens.IF.rawValue)
		 		setState(1976)
		 		try match(tsqlParser.Tokens.EXISTS.rawValue)

		 	}

		 	setState(1992)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,257, _ctx)) {
		 	case 1:
		 		setState(1982)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,256,_ctx)) {
		 		case 1:
		 			setState(1979)
		 			try {
		 					let assignmentValue = try id()
		 					_localctx.castdown(Drop_indexContext.self).schema = assignmentValue
		 			     }()


		 			setState(1980)
		 			try match(tsqlParser.Tokens.DOT.rawValue)

		 			break
		 		default: break
		 		}

		 		setState(1984)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Drop_indexContext.self).table = assignmentValue
		 		     }()


		 		setState(1985)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		setState(1986)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Drop_indexContext.self).index_name = assignmentValue
		 		     }()




		 		break
		 	case 2:
		 		setState(1988)
		 		try id()
		 		setState(1989)
		 		try match(tsqlParser.Tokens.ON.rawValue)
		 		setState(1990)
		 		try table_name()


		 		break
		 	default: break
		 	}
		 	setState(1995)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,258,_ctx)) {
		 	case 1:
		 		setState(1994)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_procedureContext:ParserRuleContext {
		public var proc: Token!
		open func DROP() -> TerminalNode? { return getToken(tsqlParser.Tokens.DROP.rawValue, 0) }
		open func func_proc_name() -> Array<Func_proc_nameContext> {
			return getRuleContexts(Func_proc_nameContext.self)
		}
		open func func_proc_name(_ i: Int) -> Func_proc_nameContext? {
			return getRuleContext(Func_proc_nameContext.self,i)
		}
		open func PROC() -> TerminalNode? { return getToken(tsqlParser.Tokens.PROC.rawValue, 0) }
		open func PROCEDURE() -> TerminalNode? { return getToken(tsqlParser.Tokens.PROCEDURE.rawValue, 0) }
		open func IF() -> TerminalNode? { return getToken(tsqlParser.Tokens.IF.rawValue, 0) }
		open func EXISTS() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXISTS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_drop_procedure }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDrop_procedure(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDrop_procedure(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDrop_procedure(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDrop_procedure(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_procedure() throws -> Drop_procedureContext {
		var _localctx: Drop_procedureContext = Drop_procedureContext(_ctx, getState())
		try enterRule(_localctx, 156, tsqlParser.RULE_drop_procedure)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1997)
		 	try match(tsqlParser.Tokens.DROP.rawValue)
		 	setState(1998)
		 	_localctx.castdown(Drop_procedureContext.self).proc = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.PROC.rawValue || _la == tsqlParser.Tokens.PROCEDURE.rawValue
		 	      return testSet
		 	 }())) {
		 		_localctx.castdown(Drop_procedureContext.self).proc = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2001)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.IF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(1999)
		 		try match(tsqlParser.Tokens.IF.rawValue)
		 		setState(2000)
		 		try match(tsqlParser.Tokens.EXISTS.rawValue)

		 	}

		 	setState(2003)
		 	try func_proc_name()
		 	setState(2008)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2004)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(2005)
		 		try func_proc_name()


		 		setState(2010)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2012)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,261,_ctx)) {
		 	case 1:
		 		setState(2011)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_triggerContext:ParserRuleContext {
		open func drop_dml_trigger() -> Drop_dml_triggerContext? {
			return getRuleContext(Drop_dml_triggerContext.self,0)
		}
		open func drop_ddl_trigger() -> Drop_ddl_triggerContext? {
			return getRuleContext(Drop_ddl_triggerContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_drop_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDrop_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDrop_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDrop_trigger(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDrop_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_trigger() throws -> Drop_triggerContext {
		var _localctx: Drop_triggerContext = Drop_triggerContext(_ctx, getState())
		try enterRule(_localctx, 158, tsqlParser.RULE_drop_trigger)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2016)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,262, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2014)
		 		try drop_dml_trigger()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2015)
		 		try drop_ddl_trigger()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_dml_triggerContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(tsqlParser.Tokens.DROP.rawValue, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRIGGER.rawValue, 0) }
		open func simple_name() -> Array<Simple_nameContext> {
			return getRuleContexts(Simple_nameContext.self)
		}
		open func simple_name(_ i: Int) -> Simple_nameContext? {
			return getRuleContext(Simple_nameContext.self,i)
		}
		open func IF() -> TerminalNode? { return getToken(tsqlParser.Tokens.IF.rawValue, 0) }
		open func EXISTS() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXISTS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_drop_dml_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDrop_dml_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDrop_dml_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDrop_dml_trigger(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDrop_dml_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_dml_trigger() throws -> Drop_dml_triggerContext {
		var _localctx: Drop_dml_triggerContext = Drop_dml_triggerContext(_ctx, getState())
		try enterRule(_localctx, 160, tsqlParser.RULE_drop_dml_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2018)
		 	try match(tsqlParser.Tokens.DROP.rawValue)
		 	setState(2019)
		 	try match(tsqlParser.Tokens.TRIGGER.rawValue)
		 	setState(2022)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.IF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2020)
		 		try match(tsqlParser.Tokens.IF.rawValue)
		 		setState(2021)
		 		try match(tsqlParser.Tokens.EXISTS.rawValue)

		 	}

		 	setState(2024)
		 	try simple_name()
		 	setState(2029)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2025)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(2026)
		 		try simple_name()


		 		setState(2031)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2033)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,265,_ctx)) {
		 	case 1:
		 		setState(2032)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_ddl_triggerContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(tsqlParser.Tokens.DROP.rawValue, 0) }
		open func TRIGGER() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRIGGER.rawValue, 0) }
		open func simple_name() -> Array<Simple_nameContext> {
			return getRuleContexts(Simple_nameContext.self)
		}
		open func simple_name(_ i: Int) -> Simple_nameContext? {
			return getRuleContext(Simple_nameContext.self,i)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATABASE.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALL.rawValue, 0) }
		open func SERVER() -> TerminalNode? { return getToken(tsqlParser.Tokens.SERVER.rawValue, 0) }
		open func IF() -> TerminalNode? { return getToken(tsqlParser.Tokens.IF.rawValue, 0) }
		open func EXISTS() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXISTS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_drop_ddl_trigger }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDrop_ddl_trigger(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDrop_ddl_trigger(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDrop_ddl_trigger(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDrop_ddl_trigger(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_ddl_trigger() throws -> Drop_ddl_triggerContext {
		var _localctx: Drop_ddl_triggerContext = Drop_ddl_triggerContext(_ctx, getState())
		try enterRule(_localctx, 162, tsqlParser.RULE_drop_ddl_trigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2035)
		 	try match(tsqlParser.Tokens.DROP.rawValue)
		 	setState(2036)
		 	try match(tsqlParser.Tokens.TRIGGER.rawValue)
		 	setState(2039)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.IF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2037)
		 		try match(tsqlParser.Tokens.IF.rawValue)
		 		setState(2038)
		 		try match(tsqlParser.Tokens.EXISTS.rawValue)

		 	}

		 	setState(2041)
		 	try simple_name()
		 	setState(2046)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2042)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(2043)
		 		try simple_name()


		 		setState(2048)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2049)
		 	try match(tsqlParser.Tokens.ON.rawValue)
		 	setState(2053)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DATABASE:
		 		setState(2050)
		 		try match(tsqlParser.Tokens.DATABASE.rawValue)

		 		break

		 	case .ALL:
		 		setState(2051)
		 		try match(tsqlParser.Tokens.ALL.rawValue)
		 		setState(2052)
		 		try match(tsqlParser.Tokens.SERVER.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2056)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,269,_ctx)) {
		 	case 1:
		 		setState(2055)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_functionContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(tsqlParser.Tokens.DROP.rawValue, 0) }
		open func FUNCTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.FUNCTION.rawValue, 0) }
		open func func_proc_name() -> Array<Func_proc_nameContext> {
			return getRuleContexts(Func_proc_nameContext.self)
		}
		open func func_proc_name(_ i: Int) -> Func_proc_nameContext? {
			return getRuleContext(Func_proc_nameContext.self,i)
		}
		open func IF() -> TerminalNode? { return getToken(tsqlParser.Tokens.IF.rawValue, 0) }
		open func EXISTS() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXISTS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_drop_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDrop_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDrop_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDrop_function(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDrop_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_function() throws -> Drop_functionContext {
		var _localctx: Drop_functionContext = Drop_functionContext(_ctx, getState())
		try enterRule(_localctx, 164, tsqlParser.RULE_drop_function)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2058)
		 	try match(tsqlParser.Tokens.DROP.rawValue)
		 	setState(2059)
		 	try match(tsqlParser.Tokens.FUNCTION.rawValue)
		 	setState(2062)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.IF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2060)
		 		try match(tsqlParser.Tokens.IF.rawValue)
		 		setState(2061)
		 		try match(tsqlParser.Tokens.EXISTS.rawValue)

		 	}

		 	setState(2064)
		 	try func_proc_name()
		 	setState(2069)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2065)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(2066)
		 		try func_proc_name()


		 		setState(2071)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2073)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,272,_ctx)) {
		 	case 1:
		 		setState(2072)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_statisticsContext:ParserRuleContext {
		public var name: IdContext!
		open func DROP() -> TerminalNode? { return getToken(tsqlParser.Tokens.DROP.rawValue, 0) }
		open func STATISTICS() -> TerminalNode? { return getToken(tsqlParser.Tokens.STATISTICS.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_drop_statistics }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDrop_statistics(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDrop_statistics(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDrop_statistics(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDrop_statistics(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_statistics() throws -> Drop_statisticsContext {
		var _localctx: Drop_statisticsContext = Drop_statisticsContext(_ctx, getState())
		try enterRule(_localctx, 166, tsqlParser.RULE_drop_statistics)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2075)
		 	try match(tsqlParser.Tokens.DROP.rawValue)
		 	setState(2076)
		 	try match(tsqlParser.Tokens.STATISTICS.rawValue)
		 	setState(2080)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,273,_ctx)) {
		 	case 1:
		 		setState(2077)
		 		try table_name()
		 		setState(2078)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(2082)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(Drop_statisticsContext.self).name = assignmentValue
		 	     }()

		 	setState(2083)
		 	try match(tsqlParser.Tokens.SEMI.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_tableContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(tsqlParser.Tokens.DROP.rawValue, 0) }
		open func TABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TABLE.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func IF() -> TerminalNode? { return getToken(tsqlParser.Tokens.IF.rawValue, 0) }
		open func EXISTS() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXISTS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_drop_table }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDrop_table(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDrop_table(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDrop_table(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDrop_table(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_table() throws -> Drop_tableContext {
		var _localctx: Drop_tableContext = Drop_tableContext(_ctx, getState())
		try enterRule(_localctx, 168, tsqlParser.RULE_drop_table)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2085)
		 	try match(tsqlParser.Tokens.DROP.rawValue)
		 	setState(2086)
		 	try match(tsqlParser.Tokens.TABLE.rawValue)
		 	setState(2089)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.IF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2087)
		 		try match(tsqlParser.Tokens.IF.rawValue)
		 		setState(2088)
		 		try match(tsqlParser.Tokens.EXISTS.rawValue)

		 	}

		 	setState(2091)
		 	try table_name()
		 	setState(2093)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,275,_ctx)) {
		 	case 1:
		 		setState(2092)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_viewContext:ParserRuleContext {
		open func DROP() -> TerminalNode? { return getToken(tsqlParser.Tokens.DROP.rawValue, 0) }
		open func VIEW() -> TerminalNode? { return getToken(tsqlParser.Tokens.VIEW.rawValue, 0) }
		open func simple_name() -> Array<Simple_nameContext> {
			return getRuleContexts(Simple_nameContext.self)
		}
		open func simple_name(_ i: Int) -> Simple_nameContext? {
			return getRuleContext(Simple_nameContext.self,i)
		}
		open func IF() -> TerminalNode? { return getToken(tsqlParser.Tokens.IF.rawValue, 0) }
		open func EXISTS() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXISTS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_drop_view }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDrop_view(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDrop_view(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDrop_view(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDrop_view(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_view() throws -> Drop_viewContext {
		var _localctx: Drop_viewContext = Drop_viewContext(_ctx, getState())
		try enterRule(_localctx, 170, tsqlParser.RULE_drop_view)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2095)
		 	try match(tsqlParser.Tokens.DROP.rawValue)
		 	setState(2096)
		 	try match(tsqlParser.Tokens.VIEW.rawValue)
		 	setState(2099)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.IF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2097)
		 		try match(tsqlParser.Tokens.IF.rawValue)
		 		setState(2098)
		 		try match(tsqlParser.Tokens.EXISTS.rawValue)

		 	}

		 	setState(2101)
		 	try simple_name()
		 	setState(2106)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2102)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(2103)
		 		try simple_name()


		 		setState(2108)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2110)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,278,_ctx)) {
		 	case 1:
		 		setState(2109)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_typeContext:ParserRuleContext {
		public var name: Simple_nameContext!
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func TYPE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TYPE.rawValue, 0) }
		open func simple_name() -> Simple_nameContext? {
			return getRuleContext(Simple_nameContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FROM.rawValue, 0) }
		open func data_type() -> Data_typeContext? {
			return getRuleContext(Data_typeContext.self,0)
		}
		open func default_value() -> Default_valueContext? {
			return getRuleContext(Default_valueContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func TABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TABLE.rawValue, 0) }
		open func LR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.LR_BRACKET.rawValue, 0) }
		open func column_def_table_constraints() -> Column_def_table_constraintsContext? {
			return getRuleContext(Column_def_table_constraintsContext.self,0)
		}
		open func RR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.RR_BRACKET.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_type(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_type() throws -> Create_typeContext {
		var _localctx: Create_typeContext = Create_typeContext(_ctx, getState())
		try enterRule(_localctx, 172, tsqlParser.RULE_create_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2112)
		 	try match(tsqlParser.Tokens.CREATE.rawValue)
		 	setState(2113)
		 	try match(tsqlParser.Tokens.TYPE.rawValue)
		 	setState(2114)
		 	try {
		 			let assignmentValue = try simple_name()
		 			_localctx.castdown(Create_typeContext.self).name = assignmentValue
		 	     }()

		 	setState(2119)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.FROM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2115)
		 		try match(tsqlParser.Tokens.FROM.rawValue)
		 		setState(2116)
		 		try data_type()
		 		setState(2117)
		 		try default_value()

		 	}

		 	setState(2127)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2121)
		 		try match(tsqlParser.Tokens.AS.rawValue)
		 		setState(2122)
		 		try match(tsqlParser.Tokens.TABLE.rawValue)
		 		setState(2123)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2124)
		 		try column_def_table_constraints()
		 		setState(2125)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Drop_typeContext:ParserRuleContext {
		public var name: Simple_nameContext!
		open func DROP() -> TerminalNode? { return getToken(tsqlParser.Tokens.DROP.rawValue, 0) }
		open func TYPE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TYPE.rawValue, 0) }
		open func simple_name() -> Simple_nameContext? {
			return getRuleContext(Simple_nameContext.self,0)
		}
		open func IF() -> TerminalNode? { return getToken(tsqlParser.Tokens.IF.rawValue, 0) }
		open func EXISTS() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXISTS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_drop_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDrop_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDrop_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDrop_type(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDrop_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func drop_type() throws -> Drop_typeContext {
		var _localctx: Drop_typeContext = Drop_typeContext(_ctx, getState())
		try enterRule(_localctx, 174, tsqlParser.RULE_drop_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2129)
		 	try match(tsqlParser.Tokens.DROP.rawValue)
		 	setState(2130)
		 	try match(tsqlParser.Tokens.TYPE.rawValue)
		 	setState(2133)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.IF.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2131)
		 		try match(tsqlParser.Tokens.IF.rawValue)
		 		setState(2132)
		 		try match(tsqlParser.Tokens.EXISTS.rawValue)

		 	}

		 	setState(2135)
		 	try {
		 			let assignmentValue = try simple_name()
		 			_localctx.castdown(Drop_typeContext.self).name = assignmentValue
		 	     }()


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Rowset_function_limitedContext:ParserRuleContext {
		open func openquery() -> OpenqueryContext? {
			return getRuleContext(OpenqueryContext.self,0)
		}
		open func opendatasource() -> OpendatasourceContext? {
			return getRuleContext(OpendatasourceContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_rowset_function_limited }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterRowset_function_limited(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitRowset_function_limited(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitRowset_function_limited(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitRowset_function_limited(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rowset_function_limited() throws -> Rowset_function_limitedContext {
		var _localctx: Rowset_function_limitedContext = Rowset_function_limitedContext(_ctx, getState())
		try enterRule(_localctx, 176, tsqlParser.RULE_rowset_function_limited)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2139)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .OPENQUERY:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2137)
		 		try openquery()

		 		break

		 	case .OPENDATASOURCE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2138)
		 		try opendatasource()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OpenqueryContext:ParserRuleContext {
		public var linked_server: IdContext!
		public var query: Token!
		open func OPENQUERY() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPENQUERY.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_openquery }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOpenquery(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOpenquery(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOpenquery(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOpenquery(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func openquery() throws -> OpenqueryContext {
		var _localctx: OpenqueryContext = OpenqueryContext(_ctx, getState())
		try enterRule(_localctx, 178, tsqlParser.RULE_openquery)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2141)
		 	try match(tsqlParser.Tokens.OPENQUERY.rawValue)
		 	setState(2142)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(2143)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(OpenqueryContext.self).linked_server = assignmentValue
		 	     }()

		 	setState(2144)
		 	try match(tsqlParser.Tokens.COMMA.rawValue)
		 	setState(2145)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(OpenqueryContext.self).query = assignmentValue
		 	     }()

		 	setState(2146)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OpendatasourceContext:ParserRuleContext {
		public var provider: Token!
		public var init: Token!
		public var database: IdContext!
		public var scheme: IdContext!
		public var table: IdContext!
		open func OPENDATASOURCE() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPENDATASOURCE.rawValue, 0) }
		open func STRING() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.STRING.rawValue) }
		open func STRING(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.STRING.rawValue, i)
		}
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_opendatasource }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOpendatasource(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOpendatasource(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOpendatasource(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOpendatasource(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func opendatasource() throws -> OpendatasourceContext {
		var _localctx: OpendatasourceContext = OpendatasourceContext(_ctx, getState())
		try enterRule(_localctx, 180, tsqlParser.RULE_opendatasource)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2148)
		 	try match(tsqlParser.Tokens.OPENDATASOURCE.rawValue)
		 	setState(2149)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(2150)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(OpendatasourceContext.self).provider = assignmentValue
		 	     }()

		 	setState(2151)
		 	try match(tsqlParser.Tokens.COMMA.rawValue)
		 	setState(2152)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(OpendatasourceContext.self).init = assignmentValue
		 	     }()

		 	setState(2153)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(2154)
		 	try match(tsqlParser.Tokens.DOT.rawValue)
		 	setState(2156)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 34)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue,tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.TARGET.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 142)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.ABSOLUTE.rawValue,tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 232)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue,tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 296)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue,tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 360)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue,tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 426)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 493)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2155)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(OpendatasourceContext.self).database = assignmentValue
		 		     }()


		 	}

		 	setState(2158)
		 	try match(tsqlParser.Tokens.DOT.rawValue)
		 	setState(2160)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 34)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue,tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.TARGET.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 142)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.ABSOLUTE.rawValue,tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 232)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue,tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 296)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue,tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 360)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue,tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 426)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 493)
		 	          }()
		 	      return testSet
		 	 }()) {
		 		setState(2159)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(OpendatasourceContext.self).scheme = assignmentValue
		 		     }()


		 	}

		 	setState(2162)
		 	try match(tsqlParser.Tokens.DOT.rawValue)

		 	setState(2163)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(OpendatasourceContext.self).table = assignmentValue
		 	     }()



		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Declare_statementContext:ParserRuleContext {
		public var xml_namespace_uri: Token!
		open func DECLARE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECLARE.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func table_type_definition() -> Table_type_definitionContext? {
			return getRuleContext(Table_type_definitionContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func declare_local() -> Array<Declare_localContext> {
			return getRuleContexts(Declare_localContext.self)
		}
		open func declare_local(_ i: Int) -> Declare_localContext? {
			return getRuleContext(Declare_localContext.self,i)
		}
		open func xml_type_definition() -> Xml_type_definitionContext? {
			return getRuleContext(Xml_type_definitionContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func XMLNAMESPACES() -> TerminalNode? { return getToken(tsqlParser.Tokens.XMLNAMESPACES.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_declare_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDeclare_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDeclare_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDeclare_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDeclare_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func declare_statement() throws -> Declare_statementContext {
		var _localctx: Declare_statementContext = Declare_statementContext(_ctx, getState())
		try enterRule(_localctx, 182, tsqlParser.RULE_declare_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2208)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,293, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2165)
		 		try match(tsqlParser.Tokens.DECLARE.rawValue)
		 		setState(2166)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 		setState(2168)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2167)
		 			try match(tsqlParser.Tokens.AS.rawValue)

		 		}

		 		setState(2170)
		 		try table_type_definition()
		 		setState(2172)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,286,_ctx)) {
		 		case 1:
		 			setState(2171)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2174)
		 		try match(tsqlParser.Tokens.DECLARE.rawValue)
		 		setState(2175)
		 		try declare_local()
		 		setState(2180)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2176)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(2177)
		 			try declare_local()


		 			setState(2182)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2184)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,288,_ctx)) {
		 		case 1:
		 			setState(2183)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2186)
		 		try match(tsqlParser.Tokens.DECLARE.rawValue)
		 		setState(2187)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 		setState(2189)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2188)
		 			try match(tsqlParser.Tokens.AS.rawValue)

		 		}

		 		setState(2191)
		 		try xml_type_definition()
		 		setState(2193)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,290,_ctx)) {
		 		case 1:
		 			setState(2192)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2195)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(2196)
		 		try match(tsqlParser.Tokens.XMLNAMESPACES.rawValue)
		 		setState(2197)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2198)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Declare_statementContext.self).xml_namespace_uri = assignmentValue
		 		     }()

		 		setState(2200)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2199)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}

		 		setState(2202)
		 		try match(tsqlParser.Tokens.AS.rawValue)
		 		setState(2203)
		 		try id()
		 		setState(2204)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(2206)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,292,_ctx)) {
		 		case 1:
		 			setState(2205)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_statementContext:ParserRuleContext {
		open func CLOSE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CLOSE.rawValue, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func GLOBAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.GLOBAL.rawValue, 0) }
		open func DEALLOCATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEALLOCATE.rawValue, 0) }
		open func declare_cursor() -> Declare_cursorContext? {
			return getRuleContext(Declare_cursorContext.self,0)
		}
		open func fetch_cursor() -> Fetch_cursorContext? {
			return getRuleContext(Fetch_cursorContext.self,0)
		}
		open func OPEN() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPEN.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_cursor_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCursor_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCursor_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCursor_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCursor_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_statement() throws -> Cursor_statementContext {
		var _localctx: Cursor_statementContext = Cursor_statementContext(_ctx, getState())
		try enterRule(_localctx, 184, tsqlParser.RULE_cursor_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2236)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CLOSE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2210)
		 		try match(tsqlParser.Tokens.CLOSE.rawValue)
		 		setState(2212)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,294,_ctx)) {
		 		case 1:
		 			setState(2211)
		 			try match(tsqlParser.Tokens.GLOBAL.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2214)
		 		try cursor_name()
		 		setState(2216)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,295,_ctx)) {
		 		case 1:
		 			setState(2215)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break

		 	case .DEALLOCATE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2218)
		 		try match(tsqlParser.Tokens.DEALLOCATE.rawValue)
		 		setState(2220)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,296,_ctx)) {
		 		case 1:
		 			setState(2219)
		 			try match(tsqlParser.Tokens.GLOBAL.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2222)
		 		try cursor_name()
		 		setState(2224)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,297,_ctx)) {
		 		case 1:
		 			setState(2223)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break

		 	case .DECLARE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2226)
		 		try declare_cursor()

		 		break

		 	case .FETCH:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2227)
		 		try fetch_cursor()

		 		break

		 	case .OPEN:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2228)
		 		try match(tsqlParser.Tokens.OPEN.rawValue)
		 		setState(2230)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,298,_ctx)) {
		 		case 1:
		 			setState(2229)
		 			try match(tsqlParser.Tokens.GLOBAL.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2232)
		 		try cursor_name()
		 		setState(2234)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,299,_ctx)) {
		 		case 1:
		 			setState(2233)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Execute_statementContext:ParserRuleContext {
		public var return_status: Token!
		open func EXECUTE() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXECUTE.rawValue, 0) }
		open func func_proc_name() -> Func_proc_nameContext? {
			return getRuleContext(Func_proc_nameContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func execute_statement_arg() -> Array<Execute_statement_argContext> {
			return getRuleContexts(Execute_statement_argContext.self)
		}
		open func execute_statement_arg(_ i: Int) -> Execute_statement_argContext? {
			return getRuleContext(Execute_statement_argContext.self,i)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func execute_var_string() -> Array<Execute_var_stringContext> {
			return getRuleContexts(Execute_var_stringContext.self)
		}
		open func execute_var_string(_ i: Int) -> Execute_var_stringContext? {
			return getRuleContext(Execute_var_stringContext.self,i)
		}
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func LOGIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOGIN.rawValue, 0) }
		open func USER() -> TerminalNode? { return getToken(tsqlParser.Tokens.USER.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_execute_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterExecute_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitExecute_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitExecute_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitExecute_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func execute_statement() throws -> Execute_statementContext {
		var _localctx: Execute_statementContext = Execute_statementContext(_ctx, getState())
		try enterRule(_localctx, 186, tsqlParser.RULE_execute_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2282)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,310, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2238)
		 		try match(tsqlParser.Tokens.EXECUTE.rawValue)
		 		setState(2241)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,301,_ctx)) {
		 		case 1:
		 			setState(2239)
		 			try {
		 					let assignmentValue = try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 					_localctx.castdown(Execute_statementContext.self).return_status = assignmentValue
		 			     }()

		 			setState(2240)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2245)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,302, _ctx)) {
		 		case 1:
		 			setState(2243)
		 			try func_proc_name()

		 			break
		 		case 2:
		 			setState(2244)
		 			try expression(0)

		 			break
		 		default: break
		 		}
		 		setState(2255)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,304,_ctx)) {
		 		case 1:
		 			setState(2247)
		 			try execute_statement_arg()
		 			setState(2252)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(2248)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)
		 				setState(2249)
		 				try execute_statement_arg()


		 				setState(2254)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}

		 			break
		 		default: break
		 		}
		 		setState(2258)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,305,_ctx)) {
		 		case 1:
		 			setState(2257)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2260)
		 		try match(tsqlParser.Tokens.EXECUTE.rawValue)
		 		setState(2261)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2262)
		 		try execute_var_string()
		 		setState(2267)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.PLUS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2263)
		 			try match(tsqlParser.Tokens.PLUS.rawValue)
		 			setState(2264)
		 			try execute_var_string()


		 			setState(2269)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2270)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(2277)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,308,_ctx)) {
		 		case 1:
		 			setState(2272)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(2271)
		 				try match(tsqlParser.Tokens.AS.rawValue)

		 			}

		 			setState(2274)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == tsqlParser.Tokens.USER.rawValue
		 			          testSet = testSet || _la == tsqlParser.Tokens.LOGIN.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(2275)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(2276)
		 			try match(tsqlParser.Tokens.STRING.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2280)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,309,_ctx)) {
		 		case 1:
		 			setState(2279)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Execute_statement_argContext:ParserRuleContext {
		public var parameter: Token!
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.NULL.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func constant_LOCAL_ID() -> Constant_LOCAL_IDContext? {
			return getRuleContext(Constant_LOCAL_IDContext.self,0)
		}
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func OUTPUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.OUTPUT.rawValue, 0) }
		open func OUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.OUT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_execute_statement_arg }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterExecute_statement_arg(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitExecute_statement_arg(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitExecute_statement_arg(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitExecute_statement_arg(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func execute_statement_arg() throws -> Execute_statement_argContext {
		var _localctx: Execute_statement_argContext = Execute_statement_argContext(_ctx, getState())
		try enterRule(_localctx, 188, tsqlParser.RULE_execute_statement_arg)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2286)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,311,_ctx)) {
		 	case 1:
		 		setState(2284)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 				_localctx.castdown(Execute_statement_argContext.self).parameter = assignmentValue
		 		     }()

		 		setState(2285)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(2297)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .LOCAL_ID:fallthrough
		 	case .DECIMAL:fallthrough
		 	case .ID:fallthrough
		 	case .STRING:fallthrough
		 	case .BINARY:fallthrough
		 	case .FLOAT:fallthrough
		 	case .REAL:fallthrough
		 	case .DOLLAR:fallthrough
		 	case .PLUS:fallthrough
		 	case .MINUS:
		 		setState(2290)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .LOCAL_ID:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .STRING:fallthrough
		 		case .BINARY:fallthrough
		 		case .FLOAT:fallthrough
		 		case .REAL:fallthrough
		 		case .DOLLAR:fallthrough
		 		case .PLUS:fallthrough
		 		case .MINUS:
		 			setState(2288)
		 			try constant_LOCAL_ID()

		 			break
		 		case .CALLED:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .ID:
		 			setState(2289)
		 			try id()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(2293)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,313,_ctx)) {
		 		case 1:
		 			setState(2292)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.OUT.rawValue || _la == tsqlParser.Tokens.OUTPUT.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}

		 		break

		 	case .DEFAULT:
		 		setState(2295)
		 		try match(tsqlParser.Tokens.DEFAULT.rawValue)

		 		break

		 	case .NULL:
		 		setState(2296)
		 		try match(tsqlParser.Tokens.NULL.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Execute_var_stringContext:ParserRuleContext {
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_execute_var_string }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterExecute_var_string(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitExecute_var_string(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitExecute_var_string(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitExecute_var_string(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func execute_var_string() throws -> Execute_var_stringContext {
		var _localctx: Execute_var_stringContext = Execute_var_stringContext(_ctx, getState())
		try enterRule(_localctx, 190, tsqlParser.RULE_execute_var_string)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2299)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.STRING.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Security_statementContext:ParserRuleContext {
		public var on_id: Table_nameContext!
		public var _id: IdContext!
		public var to_principal:Array<IdContext> = Array<IdContext>()
		public var as_principal: IdContext!
		open func execute_clause() -> Execute_clauseContext? {
			return getRuleContext(Execute_clauseContext.self,0)
		}
		open func GRANT() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.GRANT.rawValue) }
		open func GRANT(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.GRANT.rawValue, i)
		}
		open func TO() -> TerminalNode? { return getToken(tsqlParser.Tokens.TO.rawValue, 0) }
		open func ALL() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALL.rawValue, 0) }
		open func grant_permission() -> Grant_permissionContext? {
			return getRuleContext(Grant_permissionContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func OPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPTION.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func PRIVILEGES() -> TerminalNode? { return getToken(tsqlParser.Tokens.PRIVILEGES.rawValue, 0) }
		open func column_name_list() -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,0)
		}
		open func REVERT() -> TerminalNode? { return getToken(tsqlParser.Tokens.REVERT.rawValue, 0) }
		open func COOKIE() -> TerminalNode? { return getToken(tsqlParser.Tokens.COOKIE.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func open_key() -> Open_keyContext? {
			return getRuleContext(Open_keyContext.self,0)
		}
		open func close_key() -> Close_keyContext? {
			return getRuleContext(Close_keyContext.self,0)
		}
		open func create_key() -> Create_keyContext? {
			return getRuleContext(Create_keyContext.self,0)
		}
		open func create_certificate() -> Create_certificateContext? {
			return getRuleContext(Create_certificateContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_security_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSecurity_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSecurity_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSecurity_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSecurity_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func security_statement() throws -> Security_statementContext {
		var _localctx: Security_statementContext = Security_statementContext(_ctx, getState())
		try enterRule(_localctx, 192, tsqlParser.RULE_security_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2360)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,326, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2301)
		 		try execute_clause()
		 		setState(2303)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,315,_ctx)) {
		 		case 1:
		 			setState(2302)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2305)
		 		try match(tsqlParser.Tokens.GRANT.rawValue)
		 		setState(2317)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ALL:
		 			setState(2306)
		 			try match(tsqlParser.Tokens.ALL.rawValue)
		 			setState(2308)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.PRIVILEGES.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(2307)
		 				try match(tsqlParser.Tokens.PRIVILEGES.rawValue)

		 			}


		 			break
		 		case .ALTER:fallthrough
		 		case .CREATE:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .INSERT:fallthrough
		 		case .REFERENCES:fallthrough
		 		case .SELECT:fallthrough
		 		case .VIEW:fallthrough
		 		case .CONTROL:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .SHOWPLAN:fallthrough
		 		case .TAKE:
		 			setState(2310)
		 			try grant_permission()
		 			setState(2315)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.LR_BRACKET.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(2311)
		 				try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 				setState(2312)
		 				try column_name_list()
		 				setState(2313)
		 				try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 			}


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(2321)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2319)
		 			try match(tsqlParser.Tokens.ON.rawValue)
		 			setState(2320)
		 			try {
		 					let assignmentValue = try table_name()
		 					_localctx.castdown(Security_statementContext.self).on_id = assignmentValue
		 			     }()


		 		}

		 		setState(2323)
		 		try match(tsqlParser.Tokens.TO.rawValue)

		 		setState(2324)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Security_statementContext.self)._id = assignmentValue
		 		     }()

		 		_localctx.castdown(Security_statementContext.self).to_principal.append(_localctx.castdown(Security_statementContext.self)._id)

		 		setState(2329)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2325)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(2326)
		 			try {
		 					let assignmentValue = try id()
		 					_localctx.castdown(Security_statementContext.self)._id = assignmentValue
		 			     }()

		 			_localctx.castdown(Security_statementContext.self).to_principal.append(_localctx.castdown(Security_statementContext.self)._id)


		 			setState(2331)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2335)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,321,_ctx)) {
		 		case 1:
		 			setState(2332)
		 			try match(tsqlParser.Tokens.WITH.rawValue)
		 			setState(2333)
		 			try match(tsqlParser.Tokens.GRANT.rawValue)
		 			setState(2334)
		 			try match(tsqlParser.Tokens.OPTION.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2339)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2337)
		 			try match(tsqlParser.Tokens.AS.rawValue)
		 			setState(2338)
		 			try {
		 					let assignmentValue = try id()
		 					_localctx.castdown(Security_statementContext.self).as_principal = assignmentValue
		 			     }()


		 		}

		 		setState(2342)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,323,_ctx)) {
		 		case 1:
		 			setState(2341)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2344)
		 		try match(tsqlParser.Tokens.REVERT.rawValue)
		 		setState(2351)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,324,_ctx)) {
		 		case 1:
		 			setState(2345)
		 			try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2346)
		 			try match(tsqlParser.Tokens.WITH.rawValue)
		 			setState(2347)
		 			try match(tsqlParser.Tokens.COOKIE.rawValue)
		 			setState(2348)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(2349)
		 			try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 			setState(2350)
		 			try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2354)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,325,_ctx)) {
		 		case 1:
		 			setState(2353)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2356)
		 		try open_key()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2357)
		 		try close_key()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2358)
		 		try create_key()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2359)
		 		try create_certificate()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_certificateContext:ParserRuleContext {
		public var certificate_name: IdContext!
		public var user_name: IdContext!
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func CERTIFICATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CERTIFICATE.rawValue, 0) }
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func FROM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FROM.rawValue, 0) }
		open func existing_keys() -> Existing_keysContext? {
			return getRuleContext(Existing_keysContext.self,0)
		}
		open func generate_new_keys() -> Generate_new_keysContext? {
			return getRuleContext(Generate_new_keysContext.self,0)
		}
		open func AUTHORIZATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTHORIZATION.rawValue, 0) }
		open func ACTIVE() -> TerminalNode? { return getToken(tsqlParser.Tokens.ACTIVE.rawValue, 0) }
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func BEGIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.BEGIN.rawValue, 0) }
		open func DIALOG() -> TerminalNode? { return getToken(tsqlParser.Tokens.DIALOG.rawValue, 0) }
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_certificate }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_certificate(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_certificate(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_certificate(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_certificate(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_certificate() throws -> Create_certificateContext {
		var _localctx: Create_certificateContext = Create_certificateContext(_ctx, getState())
		try enterRule(_localctx, 194, tsqlParser.RULE_create_certificate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2362)
		 	try match(tsqlParser.Tokens.CREATE.rawValue)
		 	setState(2363)
		 	try match(tsqlParser.Tokens.CERTIFICATE.rawValue)
		 	setState(2364)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(Create_certificateContext.self).certificate_name = assignmentValue
		 	     }()

		 	setState(2367)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.AUTHORIZATION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2365)
		 		try match(tsqlParser.Tokens.AUTHORIZATION.rawValue)
		 		setState(2366)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Create_certificateContext.self).user_name = assignmentValue
		 		     }()


		 	}

		 	setState(2372)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FROM:
		 		setState(2369)
		 		try match(tsqlParser.Tokens.FROM.rawValue)
		 		setState(2370)
		 		try existing_keys()

		 		break
		 	case .WITH:fallthrough
		 	case .ENCRYPTION:
		 		setState(2371)
		 		try generate_new_keys()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2380)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ACTIVE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2374)
		 		try match(tsqlParser.Tokens.ACTIVE.rawValue)
		 		setState(2375)
		 		try match(tsqlParser.Tokens.FOR.rawValue)
		 		setState(2376)
		 		try match(tsqlParser.Tokens.BEGIN.rawValue)
		 		setState(2377)
		 		try match(tsqlParser.Tokens.DIALOG.rawValue)
		 		setState(2378)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2379)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Existing_keysContext:ParserRuleContext {
		public var assembly_name: IdContext!
		public var path_to_file: Token!
		open func ASSEMBLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.ASSEMBLY.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func FILE() -> TerminalNode? { return getToken(tsqlParser.Tokens.FILE.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func EXECUTABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXECUTABLE.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func PRIVATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.PRIVATE.rawValue, 0) }
		open func KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEY.rawValue, 0) }
		open func private_key_options() -> Private_key_optionsContext? {
			return getRuleContext(Private_key_optionsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_existing_keys }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterExisting_keys(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitExisting_keys(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitExisting_keys(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitExisting_keys(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func existing_keys() throws -> Existing_keysContext {
		var _localctx: Existing_keysContext = Existing_keysContext(_ctx, getState())
		try enterRule(_localctx, 196, tsqlParser.RULE_existing_keys)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2399)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ASSEMBLY:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2382)
		 		try match(tsqlParser.Tokens.ASSEMBLY.rawValue)
		 		setState(2383)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Existing_keysContext.self).assembly_name = assignmentValue
		 		     }()


		 		break
		 	case .FILE:fallthrough
		 	case .EXECUTABLE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2385)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.EXECUTABLE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2384)
		 			try match(tsqlParser.Tokens.EXECUTABLE.rawValue)

		 		}

		 		setState(2387)
		 		try match(tsqlParser.Tokens.FILE.rawValue)
		 		setState(2388)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2389)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Existing_keysContext.self).path_to_file = assignmentValue
		 		     }()

		 		setState(2397)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,331,_ctx)) {
		 		case 1:
		 			setState(2390)
		 			try match(tsqlParser.Tokens.WITH.rawValue)
		 			setState(2391)
		 			try match(tsqlParser.Tokens.PRIVATE.rawValue)
		 			setState(2392)
		 			try match(tsqlParser.Tokens.KEY.rawValue)
		 			setState(2393)
		 			try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2394)
		 			try private_key_options()
		 			setState(2395)
		 			try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Private_key_optionsContext:ParserRuleContext {
		public var path: Token!
		public var password: Token!
		open func FILE() -> TerminalNode? { return getToken(tsqlParser.Tokens.FILE.rawValue, 0) }
		open func BINARY() -> TerminalNode? { return getToken(tsqlParser.Tokens.BINARY.rawValue, 0) }
		open func STRING() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.STRING.rawValue) }
		open func STRING(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.STRING.rawValue, i)
		}
		open func BY() -> TerminalNode? { return getToken(tsqlParser.Tokens.BY.rawValue, 0) }
		open func PASSWORD() -> TerminalNode? { return getToken(tsqlParser.Tokens.PASSWORD.rawValue, 0) }
		open func DECRYPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECRYPTION.rawValue, 0) }
		open func ENCRYPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ENCRYPTION.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_private_key_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterPrivate_key_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitPrivate_key_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitPrivate_key_options(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitPrivate_key_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func private_key_options() throws -> Private_key_optionsContext {
		var _localctx: Private_key_optionsContext = Private_key_optionsContext(_ctx, getState())
		try enterRule(_localctx, 198, tsqlParser.RULE_private_key_options)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2401)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.FILE.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.BINARY.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2402)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(2403)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(Private_key_optionsContext.self).path = assignmentValue
		 	     }()

		 	setState(2410)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2404)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(2405)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.DECRYPTION.rawValue || _la == tsqlParser.Tokens.ENCRYPTION.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2406)
		 		try match(tsqlParser.Tokens.BY.rawValue)
		 		setState(2407)
		 		try match(tsqlParser.Tokens.PASSWORD.rawValue)
		 		setState(2408)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2409)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Private_key_optionsContext.self).password = assignmentValue
		 		     }()


		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Generate_new_keysContext:ParserRuleContext {
		public var password: Token!
		public var certificate_subject_name: Token!
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func SUBJECT() -> TerminalNode? { return getToken(tsqlParser.Tokens.SUBJECT.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func STRING() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.STRING.rawValue) }
		open func STRING(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.STRING.rawValue, i)
		}
		open func ENCRYPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ENCRYPTION.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(tsqlParser.Tokens.BY.rawValue, 0) }
		open func PASSWORD() -> TerminalNode? { return getToken(tsqlParser.Tokens.PASSWORD.rawValue, 0) }
		open func date_options() -> Array<Date_optionsContext> {
			return getRuleContexts(Date_optionsContext.self)
		}
		open func date_options(_ i: Int) -> Date_optionsContext? {
			return getRuleContext(Date_optionsContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_generate_new_keys }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterGenerate_new_keys(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitGenerate_new_keys(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitGenerate_new_keys(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitGenerate_new_keys(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func generate_new_keys() throws -> Generate_new_keysContext {
		var _localctx: Generate_new_keysContext = Generate_new_keysContext(_ctx, getState())
		try enterRule(_localctx, 200, tsqlParser.RULE_generate_new_keys)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2417)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ENCRYPTION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2412)
		 		try match(tsqlParser.Tokens.ENCRYPTION.rawValue)
		 		setState(2413)
		 		try match(tsqlParser.Tokens.BY.rawValue)
		 		setState(2414)
		 		try match(tsqlParser.Tokens.PASSWORD.rawValue)
		 		setState(2415)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2416)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Generate_new_keysContext.self).password = assignmentValue
		 		     }()


		 	}

		 	setState(2419)
		 	try match(tsqlParser.Tokens.WITH.rawValue)
		 	setState(2420)
		 	try match(tsqlParser.Tokens.SUBJECT.rawValue)
		 	setState(2421)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(2422)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(Generate_new_keysContext.self).certificate_subject_name = assignmentValue
		 	     }()

		 	setState(2427)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2423)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(2424)
		 		try date_options()


		 		setState(2429)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Date_optionsContext:ParserRuleContext {
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func START_DATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.START_DATE.rawValue, 0) }
		open func EXPIRY_DATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXPIRY_DATE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_date_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDate_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDate_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDate_options(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDate_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func date_options() throws -> Date_optionsContext {
		var _localctx: Date_optionsContext = Date_optionsContext(_ctx, getState())
		try enterRule(_localctx, 202, tsqlParser.RULE_date_options)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2430)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.EXPIRY_DATE.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.START_DATE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2431)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(2432)
		 	try match(tsqlParser.Tokens.STRING.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Open_keyContext:ParserRuleContext {
		public var key_name: IdContext!
		public var password: Token!
		open func OPEN() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPEN.rawValue, 0) }
		open func SYMMETRIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.SYMMETRIC.rawValue, 0) }
		open func KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEY.rawValue, 0) }
		open func DECRYPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECRYPTION.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(tsqlParser.Tokens.BY.rawValue, 0) }
		open func decryption_mechanism() -> Decryption_mechanismContext? {
			return getRuleContext(Decryption_mechanismContext.self,0)
		}
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func MASTER_KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.MASTER_KEY.rawValue, 0) }
		open func PASSWORD() -> TerminalNode? { return getToken(tsqlParser.Tokens.PASSWORD.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_open_key }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOpen_key(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOpen_key(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOpen_key(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOpen_key(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func open_key() throws -> Open_keyContext {
		var _localctx: Open_keyContext = Open_keyContext(_ctx, getState())
		try enterRule(_localctx, 204, tsqlParser.RULE_open_key)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2449)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,336, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2434)
		 		try match(tsqlParser.Tokens.OPEN.rawValue)
		 		setState(2435)
		 		try match(tsqlParser.Tokens.SYMMETRIC.rawValue)
		 		setState(2436)
		 		try match(tsqlParser.Tokens.KEY.rawValue)
		 		setState(2437)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Open_keyContext.self).key_name = assignmentValue
		 		     }()

		 		setState(2438)
		 		try match(tsqlParser.Tokens.DECRYPTION.rawValue)
		 		setState(2439)
		 		try match(tsqlParser.Tokens.BY.rawValue)
		 		setState(2440)
		 		try decryption_mechanism()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2442)
		 		try match(tsqlParser.Tokens.OPEN.rawValue)
		 		setState(2443)
		 		try match(tsqlParser.Tokens.MASTER_KEY.rawValue)
		 		setState(2444)
		 		try match(tsqlParser.Tokens.DECRYPTION.rawValue)
		 		setState(2445)
		 		try match(tsqlParser.Tokens.BY.rawValue)
		 		setState(2446)
		 		try match(tsqlParser.Tokens.PASSWORD.rawValue)
		 		setState(2447)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2448)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Open_keyContext.self).password = assignmentValue
		 		     }()


		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Close_keyContext:ParserRuleContext {
		public var key_name: IdContext!
		open func CLOSE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CLOSE.rawValue, 0) }
		open func SYMMETRIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.SYMMETRIC.rawValue, 0) }
		open func KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEY.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALL.rawValue, 0) }
		open func KEYS() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEYS.rawValue, 0) }
		open func MASTER_KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.MASTER_KEY.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_close_key }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterClose_key(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitClose_key(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitClose_key(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitClose_key(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func close_key() throws -> Close_keyContext {
		var _localctx: Close_keyContext = Close_keyContext(_ctx, getState())
		try enterRule(_localctx, 206, tsqlParser.RULE_close_key)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2461)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,337, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2451)
		 		try match(tsqlParser.Tokens.CLOSE.rawValue)
		 		setState(2452)
		 		try match(tsqlParser.Tokens.SYMMETRIC.rawValue)
		 		setState(2453)
		 		try match(tsqlParser.Tokens.KEY.rawValue)
		 		setState(2454)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Close_keyContext.self).key_name = assignmentValue
		 		     }()


		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2455)
		 		try match(tsqlParser.Tokens.CLOSE.rawValue)
		 		setState(2456)
		 		try match(tsqlParser.Tokens.ALL.rawValue)
		 		setState(2457)
		 		try match(tsqlParser.Tokens.SYMMETRIC.rawValue)
		 		setState(2458)
		 		try match(tsqlParser.Tokens.KEYS.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2459)
		 		try match(tsqlParser.Tokens.CLOSE.rawValue)
		 		setState(2460)
		 		try match(tsqlParser.Tokens.MASTER_KEY.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_keyContext:ParserRuleContext {
		public var password: Token!
		public var key_name: IdContext!
		public var user_name: IdContext!
		public var provider_name: IdContext!
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func MASTER_KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.MASTER_KEY.rawValue, 0) }
		open func ENCRYPTION() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ENCRYPTION.rawValue) }
		open func ENCRYPTION(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ENCRYPTION.rawValue, i)
		}
		open func BY() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.BY.rawValue) }
		open func BY(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.BY.rawValue, i)
		}
		open func PASSWORD() -> TerminalNode? { return getToken(tsqlParser.Tokens.PASSWORD.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func SYMMETRIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.SYMMETRIC.rawValue, 0) }
		open func KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEY.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func AUTHORIZATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTHORIZATION.rawValue, 0) }
		open func FROM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FROM.rawValue, 0) }
		open func PROVIDER() -> TerminalNode? { return getToken(tsqlParser.Tokens.PROVIDER.rawValue, 0) }
		open func key_options() -> Array<Key_optionsContext> {
			return getRuleContexts(Key_optionsContext.self)
		}
		open func key_options(_ i: Int) -> Key_optionsContext? {
			return getRuleContext(Key_optionsContext.self,i)
		}
		open func encryption_mechanism() -> Array<Encryption_mechanismContext> {
			return getRuleContexts(Encryption_mechanismContext.self)
		}
		open func encryption_mechanism(_ i: Int) -> Encryption_mechanismContext? {
			return getRuleContext(Encryption_mechanismContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_key }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_key(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_key(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_key(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_key(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_key() throws -> Create_keyContext {
		var _localctx: Create_keyContext = Create_keyContext(_ctx, getState())
		try enterRule(_localctx, 208, tsqlParser.RULE_create_key)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(2497)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,343, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2463)
		 		try match(tsqlParser.Tokens.CREATE.rawValue)
		 		setState(2464)
		 		try match(tsqlParser.Tokens.MASTER_KEY.rawValue)
		 		setState(2465)
		 		try match(tsqlParser.Tokens.ENCRYPTION.rawValue)
		 		setState(2466)
		 		try match(tsqlParser.Tokens.BY.rawValue)
		 		setState(2467)
		 		try match(tsqlParser.Tokens.PASSWORD.rawValue)
		 		setState(2468)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2469)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Create_keyContext.self).password = assignmentValue
		 		     }()


		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2470)
		 		try match(tsqlParser.Tokens.CREATE.rawValue)
		 		setState(2471)
		 		try match(tsqlParser.Tokens.SYMMETRIC.rawValue)
		 		setState(2472)
		 		try match(tsqlParser.Tokens.KEY.rawValue)
		 		setState(2473)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Create_keyContext.self).key_name = assignmentValue
		 		     }()

		 		setState(2476)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.AUTHORIZATION.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2474)
		 			try match(tsqlParser.Tokens.AUTHORIZATION.rawValue)
		 			setState(2475)
		 			try {
		 					let assignmentValue = try id()
		 					_localctx.castdown(Create_keyContext.self).user_name = assignmentValue
		 			     }()


		 		}

		 		setState(2481)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.FROM.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2478)
		 			try match(tsqlParser.Tokens.FROM.rawValue)
		 			setState(2479)
		 			try match(tsqlParser.Tokens.PROVIDER.rawValue)
		 			setState(2480)
		 			try {
		 					let assignmentValue = try id()
		 					_localctx.castdown(Create_keyContext.self).provider_name = assignmentValue
		 			     }()


		 		}

		 		setState(2483)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(2493); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(2488)
		 				try _errHandler.sync(self)
		 				switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 				case .ALGORITHM:fallthrough
		 				case .CREATION_DISPOSITION:fallthrough
		 				case .IDENTITY_VALUE:fallthrough
		 				case .KEY_SOURCE:fallthrough
		 				case .PROVIDER_KEY_NAME:
		 					setState(2484)
		 					try key_options()

		 					break

		 				case .ENCRYPTION:
		 					setState(2485)
		 					try match(tsqlParser.Tokens.ENCRYPTION.rawValue)
		 					setState(2486)
		 					try match(tsqlParser.Tokens.BY.rawValue)
		 					setState(2487)
		 					try encryption_mechanism()

		 					break
		 				default:
		 					throw try ANTLRException.recognition(e: NoViableAltException(self))
		 				}
		 				setState(2491)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (//closure
		 				 { () -> Bool in
		 				      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 				      return testSet
		 				 }()) {
		 					setState(2490)
		 					try match(tsqlParser.Tokens.COMMA.rawValue)

		 				}



		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(2495); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,342,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Key_optionsContext:ParserRuleContext {
		public var pass_phrase: Token!
		public var identity_phrase: Token!
		public var key_name_in_provider: Token!
		open func KEY_SOURCE() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEY_SOURCE.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func ALGORITHM() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALGORITHM.rawValue, 0) }
		open func algorithm() -> AlgorithmContext? {
			return getRuleContext(AlgorithmContext.self,0)
		}
		open func IDENTITY_VALUE() -> TerminalNode? { return getToken(tsqlParser.Tokens.IDENTITY_VALUE.rawValue, 0) }
		open func PROVIDER_KEY_NAME() -> TerminalNode? { return getToken(tsqlParser.Tokens.PROVIDER_KEY_NAME.rawValue, 0) }
		open func CREATION_DISPOSITION() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATION_DISPOSITION.rawValue, 0) }
		open func CREATE_NEW() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE_NEW.rawValue, 0) }
		open func OPEN_EXISTING() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPEN_EXISTING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_key_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterKey_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitKey_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitKey_options(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitKey_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func key_options() throws -> Key_optionsContext {
		var _localctx: Key_optionsContext = Key_optionsContext(_ctx, getState())
		try enterRule(_localctx, 210, tsqlParser.RULE_key_options)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2514)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .KEY_SOURCE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2499)
		 		try match(tsqlParser.Tokens.KEY_SOURCE.rawValue)
		 		setState(2500)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2501)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Key_optionsContext.self).pass_phrase = assignmentValue
		 		     }()


		 		break

		 	case .ALGORITHM:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2502)
		 		try match(tsqlParser.Tokens.ALGORITHM.rawValue)
		 		setState(2503)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2504)
		 		try algorithm()

		 		break

		 	case .IDENTITY_VALUE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2505)
		 		try match(tsqlParser.Tokens.IDENTITY_VALUE.rawValue)
		 		setState(2506)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2507)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Key_optionsContext.self).identity_phrase = assignmentValue
		 		     }()


		 		break

		 	case .PROVIDER_KEY_NAME:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2508)
		 		try match(tsqlParser.Tokens.PROVIDER_KEY_NAME.rawValue)
		 		setState(2509)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2510)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Key_optionsContext.self).key_name_in_provider = assignmentValue
		 		     }()


		 		break

		 	case .CREATION_DISPOSITION:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2511)
		 		try match(tsqlParser.Tokens.CREATION_DISPOSITION.rawValue)
		 		setState(2512)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2513)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.CREATE_NEW.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.OPEN_EXISTING.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class AlgorithmContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_algorithm }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterAlgorithm(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitAlgorithm(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitAlgorithm(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitAlgorithm(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func algorithm() throws -> AlgorithmContext {
		var _localctx: AlgorithmContext = AlgorithmContext(_ctx, getState())
		try enterRule(_localctx, 212, tsqlParser.RULE_algorithm)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2516)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, tsqlParser.Tokens.T__0.rawValue,tsqlParser.Tokens.T__1.rawValue,tsqlParser.Tokens.T__2.rawValue,tsqlParser.Tokens.T__3.rawValue,tsqlParser.Tokens.T__4.rawValue,tsqlParser.Tokens.T__5.rawValue,tsqlParser.Tokens.T__6.rawValue,tsqlParser.Tokens.T__7.rawValue,tsqlParser.Tokens.T__8.rawValue,tsqlParser.Tokens.T__9.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 0)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Encryption_mechanismContext:ParserRuleContext {
		public var certificate_name: IdContext!
		public var asym_key_name: IdContext!
		public var decrypting_Key_name: IdContext!
		open func CERTIFICATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CERTIFICATE.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func ASYMMETRIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.ASYMMETRIC.rawValue, 0) }
		open func KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEY.rawValue, 0) }
		open func SYMMETRIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.SYMMETRIC.rawValue, 0) }
		open func PASSWORD() -> TerminalNode? { return getToken(tsqlParser.Tokens.PASSWORD.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_encryption_mechanism }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterEncryption_mechanism(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitEncryption_mechanism(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitEncryption_mechanism(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitEncryption_mechanism(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func encryption_mechanism() throws -> Encryption_mechanismContext {
		var _localctx: Encryption_mechanismContext = Encryption_mechanismContext(_ctx, getState())
		try enterRule(_localctx, 214, tsqlParser.RULE_encryption_mechanism)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2529)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CERTIFICATE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2518)
		 		try match(tsqlParser.Tokens.CERTIFICATE.rawValue)
		 		setState(2519)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Encryption_mechanismContext.self).certificate_name = assignmentValue
		 		     }()


		 		break

		 	case .ASYMMETRIC:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2520)
		 		try match(tsqlParser.Tokens.ASYMMETRIC.rawValue)
		 		setState(2521)
		 		try match(tsqlParser.Tokens.KEY.rawValue)
		 		setState(2522)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Encryption_mechanismContext.self).asym_key_name = assignmentValue
		 		     }()


		 		break

		 	case .SYMMETRIC:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2523)
		 		try match(tsqlParser.Tokens.SYMMETRIC.rawValue)
		 		setState(2524)
		 		try match(tsqlParser.Tokens.KEY.rawValue)
		 		setState(2525)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Encryption_mechanismContext.self).decrypting_Key_name = assignmentValue
		 		     }()


		 		break

		 	case .PASSWORD:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2526)
		 		try match(tsqlParser.Tokens.PASSWORD.rawValue)
		 		setState(2527)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2528)
		 		try match(tsqlParser.Tokens.STRING.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Decryption_mechanismContext:ParserRuleContext {
		public var certificate_name: IdContext!
		public var asym_key_name: IdContext!
		public var decrypting_Key_name: IdContext!
		open func CERTIFICATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CERTIFICATE.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func PASSWORD() -> TerminalNode? { return getToken(tsqlParser.Tokens.PASSWORD.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func ASYMMETRIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.ASYMMETRIC.rawValue, 0) }
		open func KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEY.rawValue, 0) }
		open func SYMMETRIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.SYMMETRIC.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_decryption_mechanism }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDecryption_mechanism(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDecryption_mechanism(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDecryption_mechanism(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDecryption_mechanism(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func decryption_mechanism() throws -> Decryption_mechanismContext {
		var _localctx: Decryption_mechanismContext = Decryption_mechanismContext(_ctx, getState())
		try enterRule(_localctx, 216, tsqlParser.RULE_decryption_mechanism)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2554)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CERTIFICATE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2531)
		 		try match(tsqlParser.Tokens.CERTIFICATE.rawValue)
		 		setState(2532)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Decryption_mechanismContext.self).certificate_name = assignmentValue
		 		     }()

		 		setState(2537)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,346,_ctx)) {
		 		case 1:
		 			setState(2533)
		 			try match(tsqlParser.Tokens.WITH.rawValue)
		 			setState(2534)
		 			try match(tsqlParser.Tokens.PASSWORD.rawValue)
		 			setState(2535)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(2536)
		 			try match(tsqlParser.Tokens.STRING.rawValue)

		 			break
		 		default: break
		 		}

		 		break

		 	case .ASYMMETRIC:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2539)
		 		try match(tsqlParser.Tokens.ASYMMETRIC.rawValue)
		 		setState(2540)
		 		try match(tsqlParser.Tokens.KEY.rawValue)
		 		setState(2541)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Decryption_mechanismContext.self).asym_key_name = assignmentValue
		 		     }()

		 		setState(2546)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,347,_ctx)) {
		 		case 1:
		 			setState(2542)
		 			try match(tsqlParser.Tokens.WITH.rawValue)
		 			setState(2543)
		 			try match(tsqlParser.Tokens.PASSWORD.rawValue)
		 			setState(2544)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(2545)
		 			try match(tsqlParser.Tokens.STRING.rawValue)

		 			break
		 		default: break
		 		}

		 		break

		 	case .SYMMETRIC:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2548)
		 		try match(tsqlParser.Tokens.SYMMETRIC.rawValue)
		 		setState(2549)
		 		try match(tsqlParser.Tokens.KEY.rawValue)
		 		setState(2550)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Decryption_mechanismContext.self).decrypting_Key_name = assignmentValue
		 		     }()


		 		break

		 	case .PASSWORD:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2551)
		 		try match(tsqlParser.Tokens.PASSWORD.rawValue)
		 		setState(2552)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2553)
		 		try match(tsqlParser.Tokens.STRING.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Grant_permissionContext:ParserRuleContext {
		open func EXECUTE() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXECUTE.rawValue, 0) }
		open func VIEW() -> TerminalNode? { return getToken(tsqlParser.Tokens.VIEW.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func TAKE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TAKE.rawValue, 0) }
		open func CONTROL() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONTROL.rawValue, 0) }
		open func CREATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CREATE.rawValue, 0) }
		open func TABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TABLE.rawValue, 0) }
		open func SHOWPLAN() -> TerminalNode? { return getToken(tsqlParser.Tokens.SHOWPLAN.rawValue, 0) }
		open func IMPERSONATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.IMPERSONATE.rawValue, 0) }
		open func SELECT() -> TerminalNode? { return getToken(tsqlParser.Tokens.SELECT.rawValue, 0) }
		open func REFERENCES() -> TerminalNode? { return getToken(tsqlParser.Tokens.REFERENCES.rawValue, 0) }
		open func INSERT() -> TerminalNode? { return getToken(tsqlParser.Tokens.INSERT.rawValue, 0) }
		open func ALTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALTER.rawValue, 0) }
		open func DATABASE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATABASE.rawValue, 0) }
		open func ANY() -> TerminalNode? { return getToken(tsqlParser.Tokens.ANY.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_grant_permission }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterGrant_permission(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitGrant_permission(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitGrant_permission(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitGrant_permission(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func grant_permission() throws -> Grant_permissionContext {
		var _localctx: Grant_permissionContext = Grant_permissionContext(_ctx, getState())
		try enterRule(_localctx, 218, tsqlParser.RULE_grant_permission)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2582)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .EXECUTE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2556)
		 		try match(tsqlParser.Tokens.EXECUTE.rawValue)

		 		break

		 	case .VIEW:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2557)
		 		try match(tsqlParser.Tokens.VIEW.rawValue)
		 		setState(2558)
		 		try id()

		 		break

		 	case .TAKE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2559)
		 		try match(tsqlParser.Tokens.TAKE.rawValue)
		 		setState(2560)
		 		try id()

		 		break

		 	case .CONTROL:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2561)
		 		try match(tsqlParser.Tokens.CONTROL.rawValue)
		 		setState(2563)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 34)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue,tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.TARGET.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 142)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ABSOLUTE.rawValue,tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 232)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue,tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 296)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue,tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 360)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue,tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 426)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 493)
		 		          }()
		 		      return testSet
		 		 }()) {
		 			setState(2562)
		 			try id()

		 		}


		 		break

		 	case .CREATE:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2565)
		 		try match(tsqlParser.Tokens.CREATE.rawValue)
		 		setState(2566)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.TABLE.rawValue || _la == tsqlParser.Tokens.VIEW.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .SHOWPLAN:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2567)
		 		try match(tsqlParser.Tokens.SHOWPLAN.rawValue)

		 		break

		 	case .IMPERSONATE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2568)
		 		try match(tsqlParser.Tokens.IMPERSONATE.rawValue)

		 		break

		 	case .SELECT:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(2569)
		 		try match(tsqlParser.Tokens.SELECT.rawValue)

		 		break

		 	case .REFERENCES:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(2570)
		 		try match(tsqlParser.Tokens.REFERENCES.rawValue)

		 		break

		 	case .INSERT:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(2571)
		 		try match(tsqlParser.Tokens.INSERT.rawValue)

		 		break

		 	case .ALTER:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(2572)
		 		try match(tsqlParser.Tokens.ALTER.rawValue)
		 		setState(2580)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.ANY.rawValue || _la == tsqlParser.Tokens.CALLED.rawValue
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.DATABASE.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 65)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue,tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.TARGET.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 142)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ABSOLUTE.rawValue,tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 232)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue,tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 296)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue,tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 360)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue,tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 426)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 493)
		 		          }()
		 		      return testSet
		 		 }()) {
		 			setState(2574)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.ANY.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(2573)
		 				try match(tsqlParser.Tokens.ANY.rawValue)

		 			}

		 			setState(2578)
		 			try _errHandler.sync(self)
		 			switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .CALLED:fallthrough
		 			case .DATA_COMPRESSION:fallthrough
		 			case .EVENTDATA:fallthrough
		 			case .FILLFACTOR:fallthrough
		 			case .FORCESEEK:fallthrough
		 			case .OFFSETS:fallthrough
		 			case .PAGE:fallthrough
		 			case .PUBLIC:fallthrough
		 			case .RAW:fallthrough
		 			case .RETURN:fallthrough
		 			case .RETURNS:fallthrough
		 			case .ROWCOUNT:fallthrough
		 			case .SERVER:fallthrough
		 			case .SOURCE:fallthrough
		 			case .TARGET:fallthrough
		 			case .ABSOLUTE:fallthrough
		 			case .APPLY:fallthrough
		 			case .AUTO:fallthrough
		 			case .AVG:fallthrough
		 			case .CALLER:fallthrough
		 			case .CAST:fallthrough
		 			case .CATCH:fallthrough
		 			case .CHECKSUM_AGG:fallthrough
		 			case .COMMITTED:fallthrough
		 			case .CONCAT:fallthrough
		 			case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 			case .CONTROL:fallthrough
		 			case .COOKIE:fallthrough
		 			case .COUNT:fallthrough
		 			case .COUNT_BIG:fallthrough
		 			case .DELAY:fallthrough
		 			case .DELETED:fallthrough
		 			case .DENSE_RANK:fallthrough
		 			case .DISABLE:fallthrough
		 			case .DYNAMIC:fallthrough
		 			case .ENCRYPTION:fallthrough
		 			case .EXPAND:fallthrough
		 			case .FAST:fallthrough
		 			case .FAST_FORWARD:fallthrough
		 			case .FIRST:fallthrough
		 			case .FOLLOWING:fallthrough
		 			case .FORCE:fallthrough
		 			case .FORCED:fallthrough
		 			case .FORWARD_ONLY:fallthrough
		 			case .FULLSCAN:fallthrough
		 			case .GLOBAL:fallthrough
		 			case .GROUPING:fallthrough
		 			case .GROUPING_ID:fallthrough
		 			case .HASH:fallthrough
		 			case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 			case .IMPERSONATE:fallthrough
		 			case .INPUT:fallthrough
		 			case .INSENSITIVE:fallthrough
		 			case .INSERTED:fallthrough
		 			case .ISOLATION:fallthrough
		 			case .KEEP:fallthrough
		 			case .KEEPFIXED:fallthrough
		 			case .KEYSET:fallthrough
		 			case .LAST:fallthrough
		 			case .LEVEL:fallthrough
		 			case .LOCAL:fallthrough
		 			case .LOCK_ESCALATION:fallthrough
		 			case .LOGIN:fallthrough
		 			case .LOOP:fallthrough
		 			case .MARK:fallthrough
		 			case .MAX:fallthrough
		 			case .MAXDOP:fallthrough
		 			case .MAXRECURSION:fallthrough
		 			case .MIN:fallthrough
		 			case .MODIFY:fallthrough
		 			case .NAME:fallthrough
		 			case .NEXT:fallthrough
		 			case .NOCOUNT:fallthrough
		 			case .NOEXPAND:fallthrough
		 			case .NORECOMPUTE:fallthrough
		 			case .NTILE:fallthrough
		 			case .NUMBER:fallthrough
		 			case .OFFSET:fallthrough
		 			case .ONLINE:fallthrough
		 			case .ONLY:fallthrough
		 			case .OPTIMISTIC:fallthrough
		 			case .OPTIMIZE:fallthrough
		 			case .OUT:fallthrough
		 			case .OUTPUT:fallthrough
		 			case .OWNER:fallthrough
		 			case .PARAMETERIZATION:fallthrough
		 			case .PARTITION:fallthrough
		 			case .PATH:fallthrough
		 			case .PRECEDING:fallthrough
		 			case .PRIOR:fallthrough
		 			case .PRIVILEGES:fallthrough
		 			case .RANGE:fallthrough
		 			case .RANK:fallthrough
		 			case .READONLY:fallthrough
		 			case .READ_ONLY:fallthrough
		 			case .RECOMPILE:fallthrough
		 			case .RELATIVE:fallthrough
		 			case .REMOTE:fallthrough
		 			case .REPEATABLE:fallthrough
		 			case .ROBUST:fallthrough
		 			case .ROOT:fallthrough
		 			case .ROW:fallthrough
		 			case .ROWGUID:fallthrough
		 			case .ROWS:fallthrough
		 			case .ROW_NUMBER:fallthrough
		 			case .SAMPLE:fallthrough
		 			case .SCHEMABINDING:fallthrough
		 			case .SCROLL:fallthrough
		 			case .SCROLL_LOCKS:fallthrough
		 			case .SELF:fallthrough
		 			case .SERIALIZABLE:fallthrough
		 			case .SIMPLE:fallthrough
		 			case .SIZE:fallthrough
		 			case .SNAPSHOT:fallthrough
		 			case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 			case .STATIC:fallthrough
		 			case .STATS_STREAM:fallthrough
		 			case .STDEV:fallthrough
		 			case .STDEVP:fallthrough
		 			case .SUM:fallthrough
		 			case .TEXTIMAGE_ON:fallthrough
		 			case .THROW:fallthrough
		 			case .TIES:fallthrough
		 			case .TIME:fallthrough
		 			case .TRY:fallthrough
		 			case .TYPE:fallthrough
		 			case .TYPE_WARNING:fallthrough
		 			case .UNBOUNDED:fallthrough
		 			case .UNCOMMITTED:fallthrough
		 			case .UNKNOWN:fallthrough
		 			case .USING:fallthrough
		 			case .VAR:fallthrough
		 			case .VARP:fallthrough
		 			case .VIEWS:fallthrough
		 			case .VIEW_METADATA:fallthrough
		 			case .WORK:fallthrough
		 			case .XML:fallthrough
		 			case .XMLNAMESPACES:fallthrough
		 			case .DOUBLE_QUOTE_ID:fallthrough
		 			case .SQUARE_BRACKET_ID:fallthrough
		 			case .ID:
		 				setState(2576)
		 				try id()

		 				break

		 			case .DATABASE:
		 				setState(2577)
		 				try match(tsqlParser.Tokens.DATABASE.rawValue)

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Set_statementContext:ParserRuleContext {
		public var member_name: IdContext!
		open func SET() -> TerminalNode? { return getToken(tsqlParser.Tokens.SET.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func assignment_operator() -> Assignment_operatorContext? {
			return getRuleContext(Assignment_operatorContext.self,0)
		}
		open func CURSOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.CURSOR.rawValue, 0) }
		open func declare_set_cursor_common() -> Declare_set_cursor_commonContext? {
			return getRuleContext(Declare_set_cursor_commonContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func READ() -> TerminalNode? { return getToken(tsqlParser.Tokens.READ.rawValue, 0) }
		open func ONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.ONLY.rawValue, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OF.rawValue, 0) }
		open func column_name_list() -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,0)
		}
		open func set_special() -> Set_specialContext? {
			return getRuleContext(Set_specialContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_set_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSet_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSet_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSet_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSet_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func set_statement() throws -> Set_statementContext {
		var _localctx: Set_statementContext = Set_statementContext(_ctx, getState())
		try enterRule(_localctx, 220, tsqlParser.RULE_set_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2623)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,361, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2584)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(2585)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 		setState(2588)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.DOT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2586)
		 			try match(tsqlParser.Tokens.DOT.rawValue)
		 			setState(2587)
		 			try {
		 					let assignmentValue = try id()
		 					_localctx.castdown(Set_statementContext.self).member_name = assignmentValue
		 			     }()


		 		}

		 		setState(2590)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2591)
		 		try expression(0)
		 		setState(2593)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,355,_ctx)) {
		 		case 1:
		 			setState(2592)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2595)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(2596)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 		setState(2597)
		 		try assignment_operator()
		 		setState(2598)
		 		try expression(0)
		 		setState(2600)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,356,_ctx)) {
		 		case 1:
		 			setState(2599)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2602)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(2603)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 		setState(2604)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2605)
		 		try match(tsqlParser.Tokens.CURSOR.rawValue)
		 		setState(2606)
		 		try declare_set_cursor_common()
		 		setState(2617)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.FOR.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2607)
		 			try match(tsqlParser.Tokens.FOR.rawValue)
		 			setState(2615)
		 			try _errHandler.sync(self)
		 			switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .READ:
		 				setState(2608)
		 				try match(tsqlParser.Tokens.READ.rawValue)
		 				setState(2609)
		 				try match(tsqlParser.Tokens.ONLY.rawValue)

		 				break

		 			case .UPDATE:
		 				setState(2610)
		 				try match(tsqlParser.Tokens.UPDATE.rawValue)
		 				setState(2613)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (//closure
		 				 { () -> Bool in
		 				      let testSet: Bool = _la == tsqlParser.Tokens.OF.rawValue
		 				      return testSet
		 				 }()) {
		 					setState(2611)
		 					try match(tsqlParser.Tokens.OF.rawValue)
		 					setState(2612)
		 					try column_name_list()

		 				}


		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 		}

		 		setState(2620)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,360,_ctx)) {
		 		case 1:
		 			setState(2619)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2622)
		 		try set_special()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Transaction_statementContext:ParserRuleContext {
		open func BEGIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.BEGIN.rawValue, 0) }
		open func DISTRIBUTED() -> TerminalNode? { return getToken(tsqlParser.Tokens.DISTRIBUTED.rawValue, 0) }
		open func TRAN() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRAN.rawValue, 0) }
		open func TRANSACTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRANSACTION.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func MARK() -> TerminalNode? { return getToken(tsqlParser.Tokens.MARK.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func COMMIT() -> TerminalNode? { return getToken(tsqlParser.Tokens.COMMIT.rawValue, 0) }
		open func DELAYED_DURABILITY() -> TerminalNode? { return getToken(tsqlParser.Tokens.DELAYED_DURABILITY.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func WORK() -> TerminalNode? { return getToken(tsqlParser.Tokens.WORK.rawValue, 0) }
		open func ROLLBACK() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROLLBACK.rawValue, 0) }
		open func SAVE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SAVE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_transaction_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTransaction_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTransaction_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTransaction_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTransaction_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func transaction_statement() throws -> Transaction_statementContext {
		var _localctx: Transaction_statementContext = Transaction_statementContext(_ctx, getState())
		try enterRule(_localctx, 222, tsqlParser.RULE_transaction_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2702)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,380, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2625)
		 		try match(tsqlParser.Tokens.BEGIN.rawValue)
		 		setState(2626)
		 		try match(tsqlParser.Tokens.DISTRIBUTED.rawValue)
		 		setState(2627)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.TRAN.rawValue || _la == tsqlParser.Tokens.TRANSACTION.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2630)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,362,_ctx)) {
		 		case 1:
		 			setState(2628)
		 			try id()

		 			break
		 		case 2:
		 			setState(2629)
		 			try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2633)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,363,_ctx)) {
		 		case 1:
		 			setState(2632)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2635)
		 		try match(tsqlParser.Tokens.BEGIN.rawValue)
		 		setState(2636)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.TRAN.rawValue || _la == tsqlParser.Tokens.TRANSACTION.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2646)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,366,_ctx)) {
		 		case 1:
		 			setState(2639)
		 			try _errHandler.sync(self)
		 			switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .CALLED:fallthrough
		 			case .DATA_COMPRESSION:fallthrough
		 			case .EVENTDATA:fallthrough
		 			case .FILLFACTOR:fallthrough
		 			case .FORCESEEK:fallthrough
		 			case .OFFSETS:fallthrough
		 			case .PAGE:fallthrough
		 			case .PUBLIC:fallthrough
		 			case .RAW:fallthrough
		 			case .RETURN:fallthrough
		 			case .RETURNS:fallthrough
		 			case .ROWCOUNT:fallthrough
		 			case .SERVER:fallthrough
		 			case .SOURCE:fallthrough
		 			case .TARGET:fallthrough
		 			case .ABSOLUTE:fallthrough
		 			case .APPLY:fallthrough
		 			case .AUTO:fallthrough
		 			case .AVG:fallthrough
		 			case .CALLER:fallthrough
		 			case .CAST:fallthrough
		 			case .CATCH:fallthrough
		 			case .CHECKSUM_AGG:fallthrough
		 			case .COMMITTED:fallthrough
		 			case .CONCAT:fallthrough
		 			case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 			case .CONTROL:fallthrough
		 			case .COOKIE:fallthrough
		 			case .COUNT:fallthrough
		 			case .COUNT_BIG:fallthrough
		 			case .DELAY:fallthrough
		 			case .DELETED:fallthrough
		 			case .DENSE_RANK:fallthrough
		 			case .DISABLE:fallthrough
		 			case .DYNAMIC:fallthrough
		 			case .ENCRYPTION:fallthrough
		 			case .EXPAND:fallthrough
		 			case .FAST:fallthrough
		 			case .FAST_FORWARD:fallthrough
		 			case .FIRST:fallthrough
		 			case .FOLLOWING:fallthrough
		 			case .FORCE:fallthrough
		 			case .FORCED:fallthrough
		 			case .FORWARD_ONLY:fallthrough
		 			case .FULLSCAN:fallthrough
		 			case .GLOBAL:fallthrough
		 			case .GROUPING:fallthrough
		 			case .GROUPING_ID:fallthrough
		 			case .HASH:fallthrough
		 			case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 			case .IMPERSONATE:fallthrough
		 			case .INPUT:fallthrough
		 			case .INSENSITIVE:fallthrough
		 			case .INSERTED:fallthrough
		 			case .ISOLATION:fallthrough
		 			case .KEEP:fallthrough
		 			case .KEEPFIXED:fallthrough
		 			case .KEYSET:fallthrough
		 			case .LAST:fallthrough
		 			case .LEVEL:fallthrough
		 			case .LOCAL:fallthrough
		 			case .LOCK_ESCALATION:fallthrough
		 			case .LOGIN:fallthrough
		 			case .LOOP:fallthrough
		 			case .MARK:fallthrough
		 			case .MAX:fallthrough
		 			case .MAXDOP:fallthrough
		 			case .MAXRECURSION:fallthrough
		 			case .MIN:fallthrough
		 			case .MODIFY:fallthrough
		 			case .NAME:fallthrough
		 			case .NEXT:fallthrough
		 			case .NOCOUNT:fallthrough
		 			case .NOEXPAND:fallthrough
		 			case .NORECOMPUTE:fallthrough
		 			case .NTILE:fallthrough
		 			case .NUMBER:fallthrough
		 			case .OFFSET:fallthrough
		 			case .ONLINE:fallthrough
		 			case .ONLY:fallthrough
		 			case .OPTIMISTIC:fallthrough
		 			case .OPTIMIZE:fallthrough
		 			case .OUT:fallthrough
		 			case .OUTPUT:fallthrough
		 			case .OWNER:fallthrough
		 			case .PARAMETERIZATION:fallthrough
		 			case .PARTITION:fallthrough
		 			case .PATH:fallthrough
		 			case .PRECEDING:fallthrough
		 			case .PRIOR:fallthrough
		 			case .PRIVILEGES:fallthrough
		 			case .RANGE:fallthrough
		 			case .RANK:fallthrough
		 			case .READONLY:fallthrough
		 			case .READ_ONLY:fallthrough
		 			case .RECOMPILE:fallthrough
		 			case .RELATIVE:fallthrough
		 			case .REMOTE:fallthrough
		 			case .REPEATABLE:fallthrough
		 			case .ROBUST:fallthrough
		 			case .ROOT:fallthrough
		 			case .ROW:fallthrough
		 			case .ROWGUID:fallthrough
		 			case .ROWS:fallthrough
		 			case .ROW_NUMBER:fallthrough
		 			case .SAMPLE:fallthrough
		 			case .SCHEMABINDING:fallthrough
		 			case .SCROLL:fallthrough
		 			case .SCROLL_LOCKS:fallthrough
		 			case .SELF:fallthrough
		 			case .SERIALIZABLE:fallthrough
		 			case .SIMPLE:fallthrough
		 			case .SIZE:fallthrough
		 			case .SNAPSHOT:fallthrough
		 			case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 			case .STATIC:fallthrough
		 			case .STATS_STREAM:fallthrough
		 			case .STDEV:fallthrough
		 			case .STDEVP:fallthrough
		 			case .SUM:fallthrough
		 			case .TEXTIMAGE_ON:fallthrough
		 			case .THROW:fallthrough
		 			case .TIES:fallthrough
		 			case .TIME:fallthrough
		 			case .TRY:fallthrough
		 			case .TYPE:fallthrough
		 			case .TYPE_WARNING:fallthrough
		 			case .UNBOUNDED:fallthrough
		 			case .UNCOMMITTED:fallthrough
		 			case .UNKNOWN:fallthrough
		 			case .USING:fallthrough
		 			case .VAR:fallthrough
		 			case .VARP:fallthrough
		 			case .VIEWS:fallthrough
		 			case .VIEW_METADATA:fallthrough
		 			case .WORK:fallthrough
		 			case .XML:fallthrough
		 			case .XMLNAMESPACES:fallthrough
		 			case .DOUBLE_QUOTE_ID:fallthrough
		 			case .SQUARE_BRACKET_ID:fallthrough
		 			case .ID:
		 				setState(2637)
		 				try id()

		 				break

		 			case .LOCAL_ID:
		 				setState(2638)
		 				try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(2644)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,365,_ctx)) {
		 			case 1:
		 				setState(2641)
		 				try match(tsqlParser.Tokens.WITH.rawValue)
		 				setState(2642)
		 				try match(tsqlParser.Tokens.MARK.rawValue)
		 				setState(2643)
		 				try match(tsqlParser.Tokens.STRING.rawValue)

		 				break
		 			default: break
		 			}

		 			break
		 		default: break
		 		}
		 		setState(2649)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,367,_ctx)) {
		 		case 1:
		 			setState(2648)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2651)
		 		try match(tsqlParser.Tokens.COMMIT.rawValue)
		 		setState(2652)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.TRAN.rawValue || _la == tsqlParser.Tokens.TRANSACTION.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2665)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,370,_ctx)) {
		 		case 1:
		 			setState(2655)
		 			try _errHandler.sync(self)
		 			switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .CALLED:fallthrough
		 			case .DATA_COMPRESSION:fallthrough
		 			case .EVENTDATA:fallthrough
		 			case .FILLFACTOR:fallthrough
		 			case .FORCESEEK:fallthrough
		 			case .OFFSETS:fallthrough
		 			case .PAGE:fallthrough
		 			case .PUBLIC:fallthrough
		 			case .RAW:fallthrough
		 			case .RETURN:fallthrough
		 			case .RETURNS:fallthrough
		 			case .ROWCOUNT:fallthrough
		 			case .SERVER:fallthrough
		 			case .SOURCE:fallthrough
		 			case .TARGET:fallthrough
		 			case .ABSOLUTE:fallthrough
		 			case .APPLY:fallthrough
		 			case .AUTO:fallthrough
		 			case .AVG:fallthrough
		 			case .CALLER:fallthrough
		 			case .CAST:fallthrough
		 			case .CATCH:fallthrough
		 			case .CHECKSUM_AGG:fallthrough
		 			case .COMMITTED:fallthrough
		 			case .CONCAT:fallthrough
		 			case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 			case .CONTROL:fallthrough
		 			case .COOKIE:fallthrough
		 			case .COUNT:fallthrough
		 			case .COUNT_BIG:fallthrough
		 			case .DELAY:fallthrough
		 			case .DELETED:fallthrough
		 			case .DENSE_RANK:fallthrough
		 			case .DISABLE:fallthrough
		 			case .DYNAMIC:fallthrough
		 			case .ENCRYPTION:fallthrough
		 			case .EXPAND:fallthrough
		 			case .FAST:fallthrough
		 			case .FAST_FORWARD:fallthrough
		 			case .FIRST:fallthrough
		 			case .FOLLOWING:fallthrough
		 			case .FORCE:fallthrough
		 			case .FORCED:fallthrough
		 			case .FORWARD_ONLY:fallthrough
		 			case .FULLSCAN:fallthrough
		 			case .GLOBAL:fallthrough
		 			case .GROUPING:fallthrough
		 			case .GROUPING_ID:fallthrough
		 			case .HASH:fallthrough
		 			case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 			case .IMPERSONATE:fallthrough
		 			case .INPUT:fallthrough
		 			case .INSENSITIVE:fallthrough
		 			case .INSERTED:fallthrough
		 			case .ISOLATION:fallthrough
		 			case .KEEP:fallthrough
		 			case .KEEPFIXED:fallthrough
		 			case .KEYSET:fallthrough
		 			case .LAST:fallthrough
		 			case .LEVEL:fallthrough
		 			case .LOCAL:fallthrough
		 			case .LOCK_ESCALATION:fallthrough
		 			case .LOGIN:fallthrough
		 			case .LOOP:fallthrough
		 			case .MARK:fallthrough
		 			case .MAX:fallthrough
		 			case .MAXDOP:fallthrough
		 			case .MAXRECURSION:fallthrough
		 			case .MIN:fallthrough
		 			case .MODIFY:fallthrough
		 			case .NAME:fallthrough
		 			case .NEXT:fallthrough
		 			case .NOCOUNT:fallthrough
		 			case .NOEXPAND:fallthrough
		 			case .NORECOMPUTE:fallthrough
		 			case .NTILE:fallthrough
		 			case .NUMBER:fallthrough
		 			case .OFFSET:fallthrough
		 			case .ONLINE:fallthrough
		 			case .ONLY:fallthrough
		 			case .OPTIMISTIC:fallthrough
		 			case .OPTIMIZE:fallthrough
		 			case .OUT:fallthrough
		 			case .OUTPUT:fallthrough
		 			case .OWNER:fallthrough
		 			case .PARAMETERIZATION:fallthrough
		 			case .PARTITION:fallthrough
		 			case .PATH:fallthrough
		 			case .PRECEDING:fallthrough
		 			case .PRIOR:fallthrough
		 			case .PRIVILEGES:fallthrough
		 			case .RANGE:fallthrough
		 			case .RANK:fallthrough
		 			case .READONLY:fallthrough
		 			case .READ_ONLY:fallthrough
		 			case .RECOMPILE:fallthrough
		 			case .RELATIVE:fallthrough
		 			case .REMOTE:fallthrough
		 			case .REPEATABLE:fallthrough
		 			case .ROBUST:fallthrough
		 			case .ROOT:fallthrough
		 			case .ROW:fallthrough
		 			case .ROWGUID:fallthrough
		 			case .ROWS:fallthrough
		 			case .ROW_NUMBER:fallthrough
		 			case .SAMPLE:fallthrough
		 			case .SCHEMABINDING:fallthrough
		 			case .SCROLL:fallthrough
		 			case .SCROLL_LOCKS:fallthrough
		 			case .SELF:fallthrough
		 			case .SERIALIZABLE:fallthrough
		 			case .SIMPLE:fallthrough
		 			case .SIZE:fallthrough
		 			case .SNAPSHOT:fallthrough
		 			case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 			case .STATIC:fallthrough
		 			case .STATS_STREAM:fallthrough
		 			case .STDEV:fallthrough
		 			case .STDEVP:fallthrough
		 			case .SUM:fallthrough
		 			case .TEXTIMAGE_ON:fallthrough
		 			case .THROW:fallthrough
		 			case .TIES:fallthrough
		 			case .TIME:fallthrough
		 			case .TRY:fallthrough
		 			case .TYPE:fallthrough
		 			case .TYPE_WARNING:fallthrough
		 			case .UNBOUNDED:fallthrough
		 			case .UNCOMMITTED:fallthrough
		 			case .UNKNOWN:fallthrough
		 			case .USING:fallthrough
		 			case .VAR:fallthrough
		 			case .VARP:fallthrough
		 			case .VIEWS:fallthrough
		 			case .VIEW_METADATA:fallthrough
		 			case .WORK:fallthrough
		 			case .XML:fallthrough
		 			case .XMLNAMESPACES:fallthrough
		 			case .DOUBLE_QUOTE_ID:fallthrough
		 			case .SQUARE_BRACKET_ID:fallthrough
		 			case .ID:
		 				setState(2653)
		 				try id()

		 				break

		 			case .LOCAL_ID:
		 				setState(2654)
		 				try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(2663)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,369,_ctx)) {
		 			case 1:
		 				setState(2657)
		 				try match(tsqlParser.Tokens.WITH.rawValue)
		 				setState(2658)
		 				try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 				setState(2659)
		 				try match(tsqlParser.Tokens.DELAYED_DURABILITY.rawValue)
		 				setState(2660)
		 				try match(tsqlParser.Tokens.EQUAL.rawValue)
		 				setState(2661)
		 				_la = try _input.LA(1)
		 				if (!(//closure
		 				 { () -> Bool in
		 				      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 				      return testSet
		 				 }())) {
		 				try _errHandler.recoverInline(self)
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}
		 				setState(2662)
		 				try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 				break
		 			default: break
		 			}

		 			break
		 		default: break
		 		}
		 		setState(2668)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,371,_ctx)) {
		 		case 1:
		 			setState(2667)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2670)
		 		try match(tsqlParser.Tokens.COMMIT.rawValue)
		 		setState(2672)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,372,_ctx)) {
		 		case 1:
		 			setState(2671)
		 			try match(tsqlParser.Tokens.WORK.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2675)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,373,_ctx)) {
		 		case 1:
		 			setState(2674)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2677)
		 		try match(tsqlParser.Tokens.ROLLBACK.rawValue)
		 		setState(2678)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.TRAN.rawValue || _la == tsqlParser.Tokens.TRANSACTION.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2681)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,374,_ctx)) {
		 		case 1:
		 			setState(2679)
		 			try id()

		 			break
		 		case 2:
		 			setState(2680)
		 			try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2684)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,375,_ctx)) {
		 		case 1:
		 			setState(2683)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2686)
		 		try match(tsqlParser.Tokens.ROLLBACK.rawValue)
		 		setState(2688)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,376,_ctx)) {
		 		case 1:
		 			setState(2687)
		 			try match(tsqlParser.Tokens.WORK.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2691)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,377,_ctx)) {
		 		case 1:
		 			setState(2690)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2693)
		 		try match(tsqlParser.Tokens.SAVE.rawValue)
		 		setState(2694)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.TRAN.rawValue || _la == tsqlParser.Tokens.TRANSACTION.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2697)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,378,_ctx)) {
		 		case 1:
		 			setState(2695)
		 			try id()

		 			break
		 		case 2:
		 			setState(2696)
		 			try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2700)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,379,_ctx)) {
		 		case 1:
		 			setState(2699)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Go_statementContext:ParserRuleContext {
		public var count: Token!
		open func GO() -> TerminalNode? { return getToken(tsqlParser.Tokens.GO.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_go_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterGo_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitGo_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitGo_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitGo_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func go_statement() throws -> Go_statementContext {
		var _localctx: Go_statementContext = Go_statementContext(_ctx, getState())
		try enterRule(_localctx, 224, tsqlParser.RULE_go_statement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2704)
		 	try match(tsqlParser.Tokens.GO.rawValue)
		 	setState(2706)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.DECIMAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2705)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 				_localctx.castdown(Go_statementContext.self).count = assignmentValue
		 		     }()


		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Use_statementContext:ParserRuleContext {
		public var database: IdContext!
		open func USE() -> TerminalNode? { return getToken(tsqlParser.Tokens.USE.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_use_statement }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterUse_statement(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitUse_statement(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitUse_statement(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitUse_statement(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func use_statement() throws -> Use_statementContext {
		var _localctx: Use_statementContext = Use_statementContext(_ctx, getState())
		try enterRule(_localctx, 226, tsqlParser.RULE_use_statement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2708)
		 	try match(tsqlParser.Tokens.USE.rawValue)
		 	setState(2709)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(Use_statementContext.self).database = assignmentValue
		 	     }()

		 	setState(2711)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,382,_ctx)) {
		 	case 1:
		 		setState(2710)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dbcc_clauseContext:ParserRuleContext {
		public var name: Simple_idContext!
		open func DBCC() -> TerminalNode? { return getToken(tsqlParser.Tokens.DBCC.rawValue, 0) }
		open func simple_id() -> Simple_idContext? {
			return getRuleContext(Simple_idContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func dbcc_options() -> Dbcc_optionsContext? {
			return getRuleContext(Dbcc_optionsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_dbcc_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDbcc_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDbcc_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDbcc_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDbcc_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dbcc_clause() throws -> Dbcc_clauseContext {
		var _localctx: Dbcc_clauseContext = Dbcc_clauseContext(_ctx, getState())
		try enterRule(_localctx, 228, tsqlParser.RULE_dbcc_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2713)
		 	try match(tsqlParser.Tokens.DBCC.rawValue)
		 	setState(2714)
		 	try {
		 			let assignmentValue = try simple_id()
		 			_localctx.castdown(Dbcc_clauseContext.self).name = assignmentValue
		 	     }()

		 	setState(2719)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,383,_ctx)) {
		 	case 1:
		 		setState(2715)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2716)
		 		try expression_list()
		 		setState(2717)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(2723)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,384,_ctx)) {
		 	case 1:
		 		setState(2721)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(2722)
		 		try dbcc_options()

		 		break
		 	default: break
		 	}
		 	setState(2726)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,385,_ctx)) {
		 	case 1:
		 		setState(2725)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Dbcc_optionsContext:ParserRuleContext {
		open func simple_id() -> Array<Simple_idContext> {
			return getRuleContexts(Simple_idContext.self)
		}
		open func simple_id(_ i: Int) -> Simple_idContext? {
			return getRuleContext(Simple_idContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_dbcc_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDbcc_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDbcc_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDbcc_options(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDbcc_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func dbcc_options() throws -> Dbcc_optionsContext {
		var _localctx: Dbcc_optionsContext = Dbcc_optionsContext(_ctx, getState())
		try enterRule(_localctx, 230, tsqlParser.RULE_dbcc_options)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2728)
		 	try simple_id()
		 	setState(2731)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2729)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(2730)
		 		try simple_id()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Execute_clauseContext:ParserRuleContext {
		public var clause: Token!
		open func EXECUTE() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXECUTE.rawValue, 0) }
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func CALLER() -> TerminalNode? { return getToken(tsqlParser.Tokens.CALLER.rawValue, 0) }
		open func SELF() -> TerminalNode? { return getToken(tsqlParser.Tokens.SELF.rawValue, 0) }
		open func OWNER() -> TerminalNode? { return getToken(tsqlParser.Tokens.OWNER.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_execute_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterExecute_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitExecute_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitExecute_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitExecute_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func execute_clause() throws -> Execute_clauseContext {
		var _localctx: Execute_clauseContext = Execute_clauseContext(_ctx, getState())
		try enterRule(_localctx, 232, tsqlParser.RULE_execute_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2733)
		 	try match(tsqlParser.Tokens.EXECUTE.rawValue)
		 	setState(2734)
		 	try match(tsqlParser.Tokens.AS.rawValue)
		 	setState(2735)
		 	_localctx.castdown(Execute_clauseContext.self).clause = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.CALLER.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.OWNER.rawValue || _la == tsqlParser.Tokens.SELF.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.STRING.rawValue
		 	      return testSet
		 	 }())) {
		 		_localctx.castdown(Execute_clauseContext.self).clause = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Declare_localContext:ParserRuleContext {
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func data_type() -> Data_typeContext? {
			return getRuleContext(Data_typeContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_declare_local }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDeclare_local(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDeclare_local(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDeclare_local(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDeclare_local(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func declare_local() throws -> Declare_localContext {
		var _localctx: Declare_localContext = Declare_localContext(_ctx, getState())
		try enterRule(_localctx, 234, tsqlParser.RULE_declare_local)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2737)
		 	try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 	setState(2739)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2738)
		 		try match(tsqlParser.Tokens.AS.rawValue)

		 	}

		 	setState(2741)
		 	try data_type()
		 	setState(2744)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.EQUAL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2742)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(2743)
		 		try expression(0)

		 	}

		 	setState(2747)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,389,_ctx)) {
		 	case 1:
		 		setState(2746)
		 		try expression(0)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_type_definitionContext:ParserRuleContext {
		open func TABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TABLE.rawValue, 0) }
		open func column_def_table_constraints() -> Column_def_table_constraintsContext? {
			return getRuleContext(Column_def_table_constraintsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_type_definition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_type_definition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_type_definition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_type_definition(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_type_definition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_type_definition() throws -> Table_type_definitionContext {
		var _localctx: Table_type_definitionContext = Table_type_definitionContext(_ctx, getState())
		try enterRule(_localctx, 236, tsqlParser.RULE_table_type_definition)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2749)
		 	try match(tsqlParser.Tokens.TABLE.rawValue)
		 	setState(2750)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(2751)
		 	try column_def_table_constraints()
		 	setState(2752)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_type_definitionContext:ParserRuleContext {
		open func XML() -> TerminalNode? { return getToken(tsqlParser.Tokens.XML.rawValue, 0) }
		open func xml_schema_collection() -> Xml_schema_collectionContext? {
			return getRuleContext(Xml_schema_collectionContext.self,0)
		}
		open func CONTENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONTENT.rawValue, 0) }
		open func DOCUMENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DOCUMENT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_xml_type_definition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterXml_type_definition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitXml_type_definition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitXml_type_definition(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitXml_type_definition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_type_definition() throws -> Xml_type_definitionContext {
		var _localctx: Xml_type_definitionContext = Xml_type_definitionContext(_ctx, getState())
		try enterRule(_localctx, 238, tsqlParser.RULE_xml_type_definition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2754)
		 	try match(tsqlParser.Tokens.XML.rawValue)
		 	setState(2755)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(2757)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.CONTENT.rawValue || _la == tsqlParser.Tokens.DOCUMENT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2756)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.CONTENT.rawValue || _la == tsqlParser.Tokens.DOCUMENT.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(2759)
		 	try xml_schema_collection()
		 	setState(2760)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_schema_collectionContext:ParserRuleContext {
		open func ID() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ID.rawValue) }
		open func ID(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ID.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_xml_schema_collection }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterXml_schema_collection(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitXml_schema_collection(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitXml_schema_collection(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitXml_schema_collection(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_schema_collection() throws -> Xml_schema_collectionContext {
		var _localctx: Xml_schema_collectionContext = Xml_schema_collectionContext(_ctx, getState())
		try enterRule(_localctx, 240, tsqlParser.RULE_xml_schema_collection)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2762)
		 	try match(tsqlParser.Tokens.ID.rawValue)
		 	setState(2763)
		 	try match(tsqlParser.Tokens.DOT.rawValue)
		 	setState(2764)
		 	try match(tsqlParser.Tokens.ID.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_def_table_constraintsContext:ParserRuleContext {
		open func column_def_table_constraint() -> Array<Column_def_table_constraintContext> {
			return getRuleContexts(Column_def_table_constraintContext.self)
		}
		open func column_def_table_constraint(_ i: Int) -> Column_def_table_constraintContext? {
			return getRuleContext(Column_def_table_constraintContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_column_def_table_constraints }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterColumn_def_table_constraints(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitColumn_def_table_constraints(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitColumn_def_table_constraints(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitColumn_def_table_constraints(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_def_table_constraints() throws -> Column_def_table_constraintsContext {
		var _localctx: Column_def_table_constraintsContext = Column_def_table_constraintsContext(_ctx, getState())
		try enterRule(_localctx, 242, tsqlParser.RULE_column_def_table_constraints)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2766)
		 	try column_def_table_constraint()
		 	setState(2773)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,392,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2768)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(2767)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)

		 			}

		 			setState(2770)
		 			try column_def_table_constraint()

		 	 
		 		}
		 		setState(2775)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,392,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_def_table_constraintContext:ParserRuleContext {
		open func column_definition() -> Column_definitionContext? {
			return getRuleContext(Column_definitionContext.self,0)
		}
		open func table_constraint() -> Table_constraintContext? {
			return getRuleContext(Table_constraintContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_column_def_table_constraint }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterColumn_def_table_constraint(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitColumn_def_table_constraint(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitColumn_def_table_constraint(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitColumn_def_table_constraint(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_def_table_constraint() throws -> Column_def_table_constraintContext {
		var _localctx: Column_def_table_constraintContext = Column_def_table_constraintContext(_ctx, getState())
		try enterRule(_localctx, 244, tsqlParser.RULE_column_def_table_constraint)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2778)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2776)
		 		try column_definition()

		 		break
		 	case .CHECK:fallthrough
		 	case .CONSTRAINT:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .FOREIGN:fallthrough
		 	case .PRIMARY:fallthrough
		 	case .UNIQUE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2777)
		 		try table_constraint()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_definitionContext:ParserRuleContext {
		public var constraint: IdContext!
		public var seed: Token!
		public var increment: Token!
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func data_type() -> Data_typeContext? {
			return getRuleContext(Data_typeContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func COLLATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.COLLATE.rawValue, 0) }
		open func null_notnull() -> Null_notnullContext? {
			return getRuleContext(Null_notnullContext.self,0)
		}
		open func null_or_default() -> Array<Null_or_defaultContext> {
			return getRuleContexts(Null_or_defaultContext.self)
		}
		open func null_or_default(_ i: Int) -> Null_or_defaultContext? {
			return getRuleContext(Null_or_defaultContext.self,i)
		}
		open func IDENTITY() -> TerminalNode? { return getToken(tsqlParser.Tokens.IDENTITY.rawValue, 0) }
		open func ROWGUIDCOL() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROWGUIDCOL.rawValue, 0) }
		open func column_constraint() -> Array<Column_constraintContext> {
			return getRuleContexts(Column_constraintContext.self)
		}
		open func column_constraint(_ i: Int) -> Column_constraintContext? {
			return getRuleContext(Column_constraintContext.self,i)
		}
		open func CONSTRAINT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONSTRAINT.rawValue, 0) }
		open func NOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NOT.rawValue, 0) }
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func REPLICATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.REPLICATION.rawValue, 0) }
		open func DECIMAL() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.DECIMAL.rawValue) }
		open func DECIMAL(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.DECIMAL.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_column_definition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterColumn_definition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitColumn_definition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitColumn_definition(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitColumn_definition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_definition() throws -> Column_definitionContext {
		var _localctx: Column_definitionContext = Column_definitionContext(_ctx, getState())
		try enterRule(_localctx, 246, tsqlParser.RULE_column_definition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2780)
		 	try id()
		 	setState(2784)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .ID:
		 		setState(2781)
		 		try data_type()

		 		break

		 	case .AS:
		 		setState(2782)
		 		try match(tsqlParser.Tokens.AS.rawValue)
		 		setState(2783)
		 		try expression(0)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(2788)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COLLATE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2786)
		 		try match(tsqlParser.Tokens.COLLATE.rawValue)
		 		setState(2787)
		 		try id()

		 	}

		 	setState(2791)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,396,_ctx)) {
		 	case 1:
		 		setState(2790)
		 		try null_notnull()

		 		break
		 	default: break
		 	}
		 	setState(2814)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,401,_ctx)) {
		 	case 1:
		 		setState(2795)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.CONSTRAINT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2793)
		 			try match(tsqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(2794)
		 			try {
		 					let assignmentValue = try id()
		 					_localctx.castdown(Column_definitionContext.self).constraint = assignmentValue
		 			     }()


		 		}

		 		setState(2797)
		 		try null_or_default()
		 		setState(2799)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,398,_ctx)) {
		 		case 1:
		 			setState(2798)
		 			try null_or_default()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		setState(2801)
		 		try match(tsqlParser.Tokens.IDENTITY.rawValue)
		 		setState(2807)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,399,_ctx)) {
		 		case 1:
		 			setState(2802)
		 			try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2803)
		 			try {
		 					let assignmentValue = try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 					_localctx.castdown(Column_definitionContext.self).seed = assignmentValue
		 			     }()

		 			setState(2804)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(2805)
		 			try {
		 					let assignmentValue = try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 					_localctx.castdown(Column_definitionContext.self).increment = assignmentValue
		 			     }()

		 			setState(2806)
		 			try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2812)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,400,_ctx)) {
		 		case 1:
		 			setState(2809)
		 			try match(tsqlParser.Tokens.NOT.rawValue)
		 			setState(2810)
		 			try match(tsqlParser.Tokens.FOR.rawValue)
		 			setState(2811)
		 			try match(tsqlParser.Tokens.REPLICATION.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		 	setState(2817)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ROWGUIDCOL.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2816)
		 		try match(tsqlParser.Tokens.ROWGUIDCOL.rawValue)

		 	}

		 	setState(2822)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,403,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(2819)
		 			try column_constraint()

		 	 
		 		}
		 		setState(2824)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,403,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_constraintContext:ParserRuleContext {
		public var constraint: IdContext!
		public var pk: Column_name_listContext!
		open func CHECK() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHECK.rawValue, 0) }
		open func search_condition() -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,0)
		}
		open func REFERENCES() -> TerminalNode? { return getToken(tsqlParser.Tokens.REFERENCES.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func null_notnull() -> Null_notnullContext? {
			return getRuleContext(Null_notnullContext.self,0)
		}
		open func CONSTRAINT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONSTRAINT.rawValue, 0) }
		open func column_name_list() -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,0)
		}
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func PRIMARY() -> TerminalNode? { return getToken(tsqlParser.Tokens.PRIMARY.rawValue, 0) }
		open func KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEY.rawValue, 0) }
		open func UNIQUE() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNIQUE.rawValue, 0) }
		open func clustered() -> ClusteredContext? {
			return getRuleContext(ClusteredContext.self,0)
		}
		open func index_options() -> Index_optionsContext? {
			return getRuleContext(Index_optionsContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NOT.rawValue, 0) }
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func REPLICATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.REPLICATION.rawValue, 0) }
		open func FOREIGN() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOREIGN.rawValue, 0) }
		open func on_delete() -> On_deleteContext? {
			return getRuleContext(On_deleteContext.self,0)
		}
		open func on_update() -> On_updateContext? {
			return getRuleContext(On_updateContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_column_constraint }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterColumn_constraint(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitColumn_constraint(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitColumn_constraint(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitColumn_constraint(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_constraint() throws -> Column_constraintContext {
		var _localctx: Column_constraintContext = Column_constraintContext(_ctx, getState())
		try enterRule(_localctx, 248, tsqlParser.RULE_column_constraint)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2827)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.CONSTRAINT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2825)
		 		try match(tsqlParser.Tokens.CONSTRAINT.rawValue)
		 		setState(2826)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Column_constraintContext.self).constraint = assignmentValue
		 		     }()


		 	}

		 	setState(2866)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .PRIMARY:fallthrough
		 	case .UNIQUE:
		 		setState(2832)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .PRIMARY:
		 			setState(2829)
		 			try match(tsqlParser.Tokens.PRIMARY.rawValue)
		 			setState(2830)
		 			try match(tsqlParser.Tokens.KEY.rawValue)

		 			break

		 		case .UNIQUE:
		 			setState(2831)
		 			try match(tsqlParser.Tokens.UNIQUE.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(2835)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.CLUSTERED.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.NONCLUSTERED.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2834)
		 			try clustered()

		 		}

		 		setState(2838)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,407,_ctx)) {
		 		case 1:
		 			setState(2837)
		 			try index_options()

		 			break
		 		default: break
		 		}

		 		break

		 	case .CHECK:
		 		setState(2840)
		 		try match(tsqlParser.Tokens.CHECK.rawValue)
		 		setState(2844)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.NOT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2841)
		 			try match(tsqlParser.Tokens.NOT.rawValue)
		 			setState(2842)
		 			try match(tsqlParser.Tokens.FOR.rawValue)
		 			setState(2843)
		 			try match(tsqlParser.Tokens.REPLICATION.rawValue)

		 		}

		 		setState(2846)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2847)
		 		try search_condition()
		 		setState(2848)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case .FOREIGN:fallthrough
		 	case .REFERENCES:
		 		setState(2852)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.FOREIGN.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2850)
		 			try match(tsqlParser.Tokens.FOREIGN.rawValue)
		 			setState(2851)
		 			try match(tsqlParser.Tokens.KEY.rawValue)

		 		}

		 		setState(2854)
		 		try match(tsqlParser.Tokens.REFERENCES.rawValue)
		 		setState(2855)
		 		try table_name()
		 		setState(2856)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2857)
		 		try {
		 				let assignmentValue = try column_name_list()
		 				_localctx.castdown(Column_constraintContext.self).pk = assignmentValue
		 		     }()

		 		setState(2858)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(2860)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,410,_ctx)) {
		 		case 1:
		 			setState(2859)
		 			try on_delete()

		 			break
		 		default: break
		 		}
		 		setState(2863)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2862)
		 			try on_update()

		 		}


		 		break
		 	case .NOT:fallthrough
		 	case .NULL:
		 		setState(2865)
		 		try null_notnull()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_constraintContext:ParserRuleContext {
		public var constraint: IdContext!
		public var fk: Column_name_listContext!
		public var pk: Column_name_listContext!
		open func column_name_list_with_order() -> Column_name_list_with_orderContext? {
			return getRuleContext(Column_name_list_with_orderContext.self,0)
		}
		open func CHECK() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHECK.rawValue, 0) }
		open func search_condition() -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,0)
		}
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func FOREIGN() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOREIGN.rawValue, 0) }
		open func KEY() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEY.rawValue, 0) }
		open func REFERENCES() -> TerminalNode? { return getToken(tsqlParser.Tokens.REFERENCES.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func CONSTRAINT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONSTRAINT.rawValue, 0) }
		open func column_name_list() -> Array<Column_name_listContext> {
			return getRuleContexts(Column_name_listContext.self)
		}
		open func column_name_list(_ i: Int) -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,i)
		}
		open func PRIMARY() -> TerminalNode? { return getToken(tsqlParser.Tokens.PRIMARY.rawValue, 0) }
		open func UNIQUE() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNIQUE.rawValue, 0) }
		open func clustered() -> ClusteredContext? {
			return getRuleContext(ClusteredContext.self,0)
		}
		open func index_options() -> Index_optionsContext? {
			return getRuleContext(Index_optionsContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func NOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NOT.rawValue, 0) }
		open func REPLICATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.REPLICATION.rawValue, 0) }
		open func STRING() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.STRING.rawValue) }
		open func STRING(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.STRING.rawValue, i)
		}
		open func PLUS() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.PLUS.rawValue) }
		open func PLUS(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.PLUS.rawValue, i)
		}
		open func function_call() -> Array<Function_callContext> {
			return getRuleContexts(Function_callContext.self)
		}
		open func function_call(_ i: Int) -> Function_callContext? {
			return getRuleContext(Function_callContext.self,i)
		}
		open func DECIMAL() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.DECIMAL.rawValue) }
		open func DECIMAL(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.DECIMAL.rawValue, i)
		}
		open func on_delete() -> On_deleteContext? {
			return getRuleContext(On_deleteContext.self,0)
		}
		open func on_update() -> On_updateContext? {
			return getRuleContext(On_updateContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_constraint }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_constraint(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_constraint(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_constraint(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_constraint(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_constraint() throws -> Table_constraintContext {
		var _localctx: Table_constraintContext = Table_constraintContext(_ctx, getState())
		try enterRule(_localctx, 250, tsqlParser.RULE_table_constraint)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2870)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.CONSTRAINT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2868)
		 		try match(tsqlParser.Tokens.CONSTRAINT.rawValue)
		 		setState(2869)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Table_constraintContext.self).constraint = assignmentValue
		 		     }()


		 	}

		 	setState(2933)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .PRIMARY:fallthrough
		 	case .UNIQUE:
		 		setState(2875)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .PRIMARY:
		 			setState(2872)
		 			try match(tsqlParser.Tokens.PRIMARY.rawValue)
		 			setState(2873)
		 			try match(tsqlParser.Tokens.KEY.rawValue)

		 			break

		 		case .UNIQUE:
		 			setState(2874)
		 			try match(tsqlParser.Tokens.UNIQUE.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(2878)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.CLUSTERED.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.NONCLUSTERED.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2877)
		 			try clustered()

		 		}

		 		setState(2880)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2881)
		 		try column_name_list_with_order()
		 		setState(2882)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(2884)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,416,_ctx)) {
		 		case 1:
		 			setState(2883)
		 			try index_options()

		 			break
		 		default: break
		 		}
		 		setState(2888)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2886)
		 			try match(tsqlParser.Tokens.ON.rawValue)
		 			setState(2887)
		 			try id()

		 		}


		 		break

		 	case .CHECK:
		 		setState(2890)
		 		try match(tsqlParser.Tokens.CHECK.rawValue)
		 		setState(2894)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.NOT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2891)
		 			try match(tsqlParser.Tokens.NOT.rawValue)
		 			setState(2892)
		 			try match(tsqlParser.Tokens.FOR.rawValue)
		 			setState(2893)
		 			try match(tsqlParser.Tokens.REPLICATION.rawValue)

		 		}

		 		setState(2896)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2897)
		 		try search_condition()
		 		setState(2898)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break

		 	case .DEFAULT:
		 		setState(2900)
		 		try match(tsqlParser.Tokens.DEFAULT.rawValue)
		 		setState(2902)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.LR_BRACKET.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2901)
		 			try match(tsqlParser.Tokens.LR_BRACKET.rawValue)

		 		}

		 		setState(2908) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2908)
		 			try _errHandler.sync(self)
		 			switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .STRING:
		 				setState(2904)
		 				try match(tsqlParser.Tokens.STRING.rawValue)

		 				break

		 			case .PLUS:
		 				setState(2905)
		 				try match(tsqlParser.Tokens.PLUS.rawValue)

		 				break
		 			case .CALLED:fallthrough
		 			case .COALESCE:fallthrough
		 			case .CONVERT:fallthrough
		 			case .CURRENT_TIMESTAMP:fallthrough
		 			case .CURRENT_USER:fallthrough
		 			case .DATA_COMPRESSION:fallthrough
		 			case .EVENTDATA:fallthrough
		 			case .FILLFACTOR:fallthrough
		 			case .FORCESEEK:fallthrough
		 			case .IDENTITY:fallthrough
		 			case .ISNULL:fallthrough
		 			case .LEFT:fallthrough
		 			case .NULLIF:fallthrough
		 			case .OFFSETS:fallthrough
		 			case .PAGE:fallthrough
		 			case .PUBLIC:fallthrough
		 			case .RAW:fallthrough
		 			case .RETURN:fallthrough
		 			case .RETURNS:fallthrough
		 			case .RIGHT:fallthrough
		 			case .ROWCOUNT:fallthrough
		 			case .SERVER:fallthrough
		 			case .SESSION_USER:fallthrough
		 			case .SOURCE:fallthrough
		 			case .SYSTEM_USER:fallthrough
		 			case .TARGET:fallthrough
		 			case .ABSOLUTE:fallthrough
		 			case .APPLY:fallthrough
		 			case .AUTO:fallthrough
		 			case .AVG:fallthrough
		 			case .BINARY_CHECKSUM:fallthrough
		 			case .CALLER:fallthrough
		 			case .CAST:fallthrough
		 			case .CATCH:fallthrough
		 			case .CHECKSUM:fallthrough
		 			case .CHECKSUM_AGG:fallthrough
		 			case .COMMITTED:fallthrough
		 			case .CONCAT:fallthrough
		 			case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 			case .CONTROL:fallthrough
		 			case .COOKIE:fallthrough
		 			case .COUNT:fallthrough
		 			case .COUNT_BIG:fallthrough
		 			case .DATEADD:fallthrough
		 			case .DATEDIFF:fallthrough
		 			case .DATENAME:fallthrough
		 			case .DATEPART:fallthrough
		 			case .DELAY:fallthrough
		 			case .DELETED:fallthrough
		 			case .DENSE_RANK:fallthrough
		 			case .DISABLE:fallthrough
		 			case .DYNAMIC:fallthrough
		 			case .ENCRYPTION:fallthrough
		 			case .EXPAND:fallthrough
		 			case .FAST:fallthrough
		 			case .FAST_FORWARD:fallthrough
		 			case .FIRST:fallthrough
		 			case .FOLLOWING:fallthrough
		 			case .FORCE:fallthrough
		 			case .FORCED:fallthrough
		 			case .FORWARD_ONLY:fallthrough
		 			case .FULLSCAN:fallthrough
		 			case .GETDATE:fallthrough
		 			case .GETUTCDATE:fallthrough
		 			case .GLOBAL:fallthrough
		 			case .GROUPING:fallthrough
		 			case .GROUPING_ID:fallthrough
		 			case .HASH:fallthrough
		 			case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 			case .IMPERSONATE:fallthrough
		 			case .INPUT:fallthrough
		 			case .INSENSITIVE:fallthrough
		 			case .INSERTED:fallthrough
		 			case .ISOLATION:fallthrough
		 			case .KEEP:fallthrough
		 			case .KEEPFIXED:fallthrough
		 			case .KEYSET:fallthrough
		 			case .LAST:fallthrough
		 			case .LEVEL:fallthrough
		 			case .LOCAL:fallthrough
		 			case .LOCK_ESCALATION:fallthrough
		 			case .LOGIN:fallthrough
		 			case .LOOP:fallthrough
		 			case .MARK:fallthrough
		 			case .MAX:fallthrough
		 			case .MAXDOP:fallthrough
		 			case .MAXRECURSION:fallthrough
		 			case .MIN:fallthrough
		 			case .MIN_ACTIVE_ROWVERSION:fallthrough
		 			case .MODIFY:fallthrough
		 			case .NAME:fallthrough
		 			case .NEXT:fallthrough
		 			case .NOCOUNT:fallthrough
		 			case .NOEXPAND:fallthrough
		 			case .NORECOMPUTE:fallthrough
		 			case .NTILE:fallthrough
		 			case .NUMBER:fallthrough
		 			case .OFFSET:fallthrough
		 			case .ONLINE:fallthrough
		 			case .ONLY:fallthrough
		 			case .OPTIMISTIC:fallthrough
		 			case .OPTIMIZE:fallthrough
		 			case .OUT:fallthrough
		 			case .OUTPUT:fallthrough
		 			case .OWNER:fallthrough
		 			case .PARAMETERIZATION:fallthrough
		 			case .PARTITION:fallthrough
		 			case .PATH:fallthrough
		 			case .PRECEDING:fallthrough
		 			case .PRIOR:fallthrough
		 			case .PRIVILEGES:fallthrough
		 			case .RANGE:fallthrough
		 			case .RANK:fallthrough
		 			case .READONLY:fallthrough
		 			case .READ_ONLY:fallthrough
		 			case .RECOMPILE:fallthrough
		 			case .RELATIVE:fallthrough
		 			case .REMOTE:fallthrough
		 			case .REPEATABLE:fallthrough
		 			case .ROBUST:fallthrough
		 			case .ROOT:fallthrough
		 			case .ROW:fallthrough
		 			case .ROWGUID:fallthrough
		 			case .ROWS:fallthrough
		 			case .ROW_NUMBER:fallthrough
		 			case .SAMPLE:fallthrough
		 			case .SCHEMABINDING:fallthrough
		 			case .SCROLL:fallthrough
		 			case .SCROLL_LOCKS:fallthrough
		 			case .SELF:fallthrough
		 			case .SERIALIZABLE:fallthrough
		 			case .SIMPLE:fallthrough
		 			case .SIZE:fallthrough
		 			case .SNAPSHOT:fallthrough
		 			case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 			case .STATIC:fallthrough
		 			case .STATS_STREAM:fallthrough
		 			case .STDEV:fallthrough
		 			case .STDEVP:fallthrough
		 			case .STUFF:fallthrough
		 			case .SUM:fallthrough
		 			case .TEXTIMAGE_ON:fallthrough
		 			case .THROW:fallthrough
		 			case .TIES:fallthrough
		 			case .TIME:fallthrough
		 			case .TRY:fallthrough
		 			case .TYPE:fallthrough
		 			case .TYPE_WARNING:fallthrough
		 			case .UNBOUNDED:fallthrough
		 			case .UNCOMMITTED:fallthrough
		 			case .UNKNOWN:fallthrough
		 			case .USING:fallthrough
		 			case .VAR:fallthrough
		 			case .VARP:fallthrough
		 			case .VIEWS:fallthrough
		 			case .VIEW_METADATA:fallthrough
		 			case .WORK:fallthrough
		 			case .XML:fallthrough
		 			case .XMLNAMESPACES:fallthrough
		 			case .DOUBLE_QUOTE_ID:fallthrough
		 			case .SQUARE_BRACKET_ID:fallthrough
		 			case .LOCAL_ID:fallthrough
		 			case .ID:
		 				setState(2906)
		 				try function_call()

		 				break

		 			case .DECIMAL:
		 				setState(2907)
		 				try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			setState(2910); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.COALESCE.rawValue,tsqlParser.Tokens.CONVERT.rawValue,tsqlParser.Tokens.CURRENT_TIMESTAMP.rawValue,tsqlParser.Tokens.CURRENT_USER.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 34)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.IDENTITY.rawValue,tsqlParser.Tokens.ISNULL.rawValue,tsqlParser.Tokens.LEFT.rawValue,tsqlParser.Tokens.NULLIF.rawValue,tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 108)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.RIGHT.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SESSION_USER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.SYSTEM_USER.rawValue,tsqlParser.Tokens.TARGET.rawValue,tsqlParser.Tokens.ABSOLUTE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 177)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.BINARY_CHECKSUM.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DATEADD.rawValue,tsqlParser.Tokens.DATEDIFF.rawValue,tsqlParser.Tokens.DATENAME.rawValue,tsqlParser.Tokens.DATEPART.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue,tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 244)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GETDATE.rawValue,tsqlParser.Tokens.GETUTCDATE.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue,tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MIN_ACTIVE_ROWVERSION.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 310)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue,tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 375)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.STUFF.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue,tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.LOCAL_ID.rawValue,tsqlParser.Tokens.DECIMAL.rawValue,tsqlParser.Tokens.ID.rawValue,tsqlParser.Tokens.STRING.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 440)
		 		          }()
		 		          testSet = testSet || _la == tsqlParser.Tokens.PLUS.rawValue
		 		      return testSet
		 		 }())
		 		setState(2913)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.RR_BRACKET.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2912)
		 			try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		}

		 		setState(2915)
		 		try match(tsqlParser.Tokens.FOR.rawValue)
		 		setState(2916)
		 		try id()

		 		break

		 	case .FOREIGN:
		 		setState(2917)
		 		try match(tsqlParser.Tokens.FOREIGN.rawValue)
		 		setState(2918)
		 		try match(tsqlParser.Tokens.KEY.rawValue)
		 		setState(2919)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2920)
		 		try {
		 				let assignmentValue = try column_name_list()
		 				_localctx.castdown(Table_constraintContext.self).fk = assignmentValue
		 		     }()

		 		setState(2921)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(2922)
		 		try match(tsqlParser.Tokens.REFERENCES.rawValue)
		 		setState(2923)
		 		try table_name()
		 		setState(2924)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2925)
		 		try {
		 				let assignmentValue = try column_name_list()
		 				_localctx.castdown(Table_constraintContext.self).pk = assignmentValue
		 		     }()

		 		setState(2926)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(2928)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,423,_ctx)) {
		 		case 1:
		 			setState(2927)
		 			try on_delete()

		 			break
		 		default: break
		 		}
		 		setState(2931)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2930)
		 			try on_update()

		 		}


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class On_deleteContext:ParserRuleContext {
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func DELETE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DELETE.rawValue, 0) }
		open func NO() -> TerminalNode? { return getToken(tsqlParser.Tokens.NO.rawValue, 0) }
		open func ACTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ACTION.rawValue, 0) }
		open func CASCADE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CASCADE.rawValue, 0) }
		open func SET() -> TerminalNode? { return getToken(tsqlParser.Tokens.SET.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.NULL.rawValue, 0) }
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_on_delete }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOn_delete(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOn_delete(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOn_delete(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOn_delete(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func on_delete() throws -> On_deleteContext {
		var _localctx: On_deleteContext = On_deleteContext(_ctx, getState())
		try enterRule(_localctx, 252, tsqlParser.RULE_on_delete)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2935)
		 	try match(tsqlParser.Tokens.ON.rawValue)
		 	setState(2936)
		 	try match(tsqlParser.Tokens.DELETE.rawValue)
		 	setState(2944)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,426, _ctx)) {
		 	case 1:
		 		setState(2937)
		 		try match(tsqlParser.Tokens.NO.rawValue)
		 		setState(2938)
		 		try match(tsqlParser.Tokens.ACTION.rawValue)

		 		break
		 	case 2:
		 		setState(2939)
		 		try match(tsqlParser.Tokens.CASCADE.rawValue)

		 		break
		 	case 3:
		 		setState(2940)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(2941)
		 		try match(tsqlParser.Tokens.NULL.rawValue)

		 		break
		 	case 4:
		 		setState(2942)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(2943)
		 		try match(tsqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class On_updateContext:ParserRuleContext {
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func NO() -> TerminalNode? { return getToken(tsqlParser.Tokens.NO.rawValue, 0) }
		open func ACTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ACTION.rawValue, 0) }
		open func CASCADE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CASCADE.rawValue, 0) }
		open func SET() -> TerminalNode? { return getToken(tsqlParser.Tokens.SET.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.NULL.rawValue, 0) }
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_on_update }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOn_update(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOn_update(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOn_update(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOn_update(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func on_update() throws -> On_updateContext {
		var _localctx: On_updateContext = On_updateContext(_ctx, getState())
		try enterRule(_localctx, 254, tsqlParser.RULE_on_update)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2946)
		 	try match(tsqlParser.Tokens.ON.rawValue)
		 	setState(2947)
		 	try match(tsqlParser.Tokens.UPDATE.rawValue)
		 	setState(2955)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,427, _ctx)) {
		 	case 1:
		 		setState(2948)
		 		try match(tsqlParser.Tokens.NO.rawValue)
		 		setState(2949)
		 		try match(tsqlParser.Tokens.ACTION.rawValue)

		 		break
		 	case 2:
		 		setState(2950)
		 		try match(tsqlParser.Tokens.CASCADE.rawValue)

		 		break
		 	case 3:
		 		setState(2951)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(2952)
		 		try match(tsqlParser.Tokens.NULL.rawValue)

		 		break
		 	case 4:
		 		setState(2953)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(2954)
		 		try match(tsqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Index_optionsContext:ParserRuleContext {
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func index_option() -> Array<Index_optionContext> {
			return getRuleContexts(Index_optionContext.self)
		}
		open func index_option(_ i: Int) -> Index_optionContext? {
			return getRuleContext(Index_optionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_index_options }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterIndex_options(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitIndex_options(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitIndex_options(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitIndex_options(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func index_options() throws -> Index_optionsContext {
		var _localctx: Index_optionsContext = Index_optionsContext(_ctx, getState())
		try enterRule(_localctx, 256, tsqlParser.RULE_index_options)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2957)
		 	try match(tsqlParser.Tokens.WITH.rawValue)
		 	setState(2958)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(2959)
		 	try index_option()
		 	setState(2964)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(2960)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(2961)
		 		try index_option()


		 		setState(2966)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2967)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Index_optionContext:ParserRuleContext {
		open func simple_id() -> Array<Simple_idContext> {
			return getRuleContexts(Simple_idContext.self)
		}
		open func simple_id(_ i: Int) -> Simple_idContext? {
			return getRuleContext(Simple_idContext.self,i)
		}
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_index_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterIndex_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitIndex_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitIndex_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitIndex_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func index_option() throws -> Index_optionContext {
		var _localctx: Index_optionContext = Index_optionContext(_ctx, getState())
		try enterRule(_localctx, 258, tsqlParser.RULE_index_option)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2969)
		 	try simple_id()
		 	setState(2970)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(2974)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .ID:
		 		setState(2971)
		 		try simple_id()

		 		break
		 	case .OFF:fallthrough
		 	case .ON:
		 		setState(2972)
		 		try on_off()

		 		break

		 	case .DECIMAL:
		 		setState(2973)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Declare_cursorContext:ParserRuleContext {
		open func DECLARE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECLARE.rawValue, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func CURSOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.CURSOR.rawValue, 0) }
		open func FOR() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.FOR.rawValue) }
		open func FOR(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.FOR.rawValue, i)
		}
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func declare_set_cursor_common() -> Declare_set_cursor_commonContext? {
			return getRuleContext(Declare_set_cursor_commonContext.self,0)
		}
		open func INSENSITIVE() -> TerminalNode? { return getToken(tsqlParser.Tokens.INSENSITIVE.rawValue, 0) }
		open func SCROLL() -> TerminalNode? { return getToken(tsqlParser.Tokens.SCROLL.rawValue, 0) }
		open func READ() -> TerminalNode? { return getToken(tsqlParser.Tokens.READ.rawValue, 0) }
		open func ONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.ONLY.rawValue, 0) }
		open func UPDATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.UPDATE.rawValue, 0) }
		open func OF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OF.rawValue, 0) }
		open func column_name_list() -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_declare_cursor }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDeclare_cursor(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDeclare_cursor(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDeclare_cursor(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDeclare_cursor(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func declare_cursor() throws -> Declare_cursorContext {
		var _localctx: Declare_cursorContext = Declare_cursorContext(_ctx, getState())
		try enterRule(_localctx, 260, tsqlParser.RULE_declare_cursor)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2976)
		 	try match(tsqlParser.Tokens.DECLARE.rawValue)
		 	setState(2977)
		 	try cursor_name()
		 	setState(3009)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,437, _ctx)) {
		 	case 1:
		 		setState(2978)
		 		try match(tsqlParser.Tokens.CURSOR.rawValue)
		 		setState(2988)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,432,_ctx)) {
		 		case 1:
		 			setState(2979)
		 			try declare_set_cursor_common()
		 			setState(2986)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.FOR.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(2980)
		 				try match(tsqlParser.Tokens.FOR.rawValue)
		 				setState(2981)
		 				try match(tsqlParser.Tokens.UPDATE.rawValue)
		 				setState(2984)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (//closure
		 				 { () -> Bool in
		 				      let testSet: Bool = _la == tsqlParser.Tokens.OF.rawValue
		 				      return testSet
		 				 }()) {
		 					setState(2982)
		 					try match(tsqlParser.Tokens.OF.rawValue)
		 					setState(2983)
		 					try column_name_list()

		 				}


		 			}


		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		setState(2991)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.INSENSITIVE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2990)
		 			try match(tsqlParser.Tokens.INSENSITIVE.rawValue)

		 		}

		 		setState(2994)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.SCROLL.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2993)
		 			try match(tsqlParser.Tokens.SCROLL.rawValue)

		 		}

		 		setState(2996)
		 		try match(tsqlParser.Tokens.CURSOR.rawValue)
		 		setState(2997)
		 		try match(tsqlParser.Tokens.FOR.rawValue)
		 		setState(2998)
		 		try select_statement()
		 		setState(3007)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.FOR.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(2999)
		 			try match(tsqlParser.Tokens.FOR.rawValue)
		 			setState(3005)
		 			try _errHandler.sync(self)
		 			switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .READ:
		 				setState(3000)
		 				try match(tsqlParser.Tokens.READ.rawValue)
		 				setState(3001)
		 				try match(tsqlParser.Tokens.ONLY.rawValue)

		 				break

		 			case .UPDATE:
		 				setState(3002)
		 				try match(tsqlParser.Tokens.UPDATE.rawValue)

		 				break

		 			case .OF:
		 				setState(3003)
		 				try match(tsqlParser.Tokens.OF.rawValue)
		 				setState(3004)
		 				try column_name_list()


		 				break
		 			default:
		 				throw try ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 		}


		 		break
		 	default: break
		 	}
		 	setState(3012)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,438,_ctx)) {
		 	case 1:
		 		setState(3011)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Declare_set_cursor_commonContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func declare_set_cursor_common_partial() -> Array<Declare_set_cursor_common_partialContext> {
			return getRuleContexts(Declare_set_cursor_common_partialContext.self)
		}
		open func declare_set_cursor_common_partial(_ i: Int) -> Declare_set_cursor_common_partialContext? {
			return getRuleContext(Declare_set_cursor_common_partialContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_declare_set_cursor_common }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDeclare_set_cursor_common(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDeclare_set_cursor_common(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDeclare_set_cursor_common(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDeclare_set_cursor_common(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func declare_set_cursor_common() throws -> Declare_set_cursor_commonContext {
		var _localctx: Declare_set_cursor_commonContext = Declare_set_cursor_commonContext(_ctx, getState())
		try enterRule(_localctx, 262, tsqlParser.RULE_declare_set_cursor_common)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3017)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LOCAL.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 300)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.STATIC.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 390)
		 	          }()
		 	          testSet = testSet || _la == tsqlParser.Tokens.TYPE_WARNING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3014)
		 		try declare_set_cursor_common_partial()


		 		setState(3019)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3020)
		 	try match(tsqlParser.Tokens.FOR.rawValue)
		 	setState(3021)
		 	try select_statement()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Declare_set_cursor_common_partialContext:ParserRuleContext {
		open func LOCAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL.rawValue, 0) }
		open func GLOBAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.GLOBAL.rawValue, 0) }
		open func FORWARD_ONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.FORWARD_ONLY.rawValue, 0) }
		open func SCROLL() -> TerminalNode? { return getToken(tsqlParser.Tokens.SCROLL.rawValue, 0) }
		open func STATIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.STATIC.rawValue, 0) }
		open func KEYSET() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEYSET.rawValue, 0) }
		open func DYNAMIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.DYNAMIC.rawValue, 0) }
		open func FAST_FORWARD() -> TerminalNode? { return getToken(tsqlParser.Tokens.FAST_FORWARD.rawValue, 0) }
		open func READ_ONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.READ_ONLY.rawValue, 0) }
		open func SCROLL_LOCKS() -> TerminalNode? { return getToken(tsqlParser.Tokens.SCROLL_LOCKS.rawValue, 0) }
		open func OPTIMISTIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPTIMISTIC.rawValue, 0) }
		open func TYPE_WARNING() -> TerminalNode? { return getToken(tsqlParser.Tokens.TYPE_WARNING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_declare_set_cursor_common_partial }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDeclare_set_cursor_common_partial(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDeclare_set_cursor_common_partial(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDeclare_set_cursor_common_partial(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDeclare_set_cursor_common_partial(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func declare_set_cursor_common_partial() throws -> Declare_set_cursor_common_partialContext {
		var _localctx: Declare_set_cursor_common_partialContext = Declare_set_cursor_common_partialContext(_ctx, getState())
		try enterRule(_localctx, 264, tsqlParser.RULE_declare_set_cursor_common_partial)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3028)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .GLOBAL:fallthrough
		 	case .LOCAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3023)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.GLOBAL.rawValue || _la == tsqlParser.Tokens.LOCAL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case .FORWARD_ONLY:fallthrough
		 	case .SCROLL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3024)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.FORWARD_ONLY.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.SCROLL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case .DYNAMIC:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .KEYSET:fallthrough
		 	case .STATIC:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3025)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.KEYSET.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 300)
		 		}()
		 		          testSet = testSet || _la == tsqlParser.Tokens.STATIC.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case .OPTIMISTIC:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .SCROLL_LOCKS:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3026)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 390)
		 		}()
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .TYPE_WARNING:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3027)
		 		try match(tsqlParser.Tokens.TYPE_WARNING.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Fetch_cursorContext:ParserRuleContext {
		open func FETCH() -> TerminalNode? { return getToken(tsqlParser.Tokens.FETCH.rawValue, 0) }
		open func cursor_name() -> Cursor_nameContext? {
			return getRuleContext(Cursor_nameContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FROM.rawValue, 0) }
		open func GLOBAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.GLOBAL.rawValue, 0) }
		open func INTO() -> TerminalNode? { return getToken(tsqlParser.Tokens.INTO.rawValue, 0) }
		open func LOCAL_ID() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.LOCAL_ID.rawValue) }
		open func LOCAL_ID(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, i)
		}
		open func NEXT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NEXT.rawValue, 0) }
		open func PRIOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.PRIOR.rawValue, 0) }
		open func FIRST() -> TerminalNode? { return getToken(tsqlParser.Tokens.FIRST.rawValue, 0) }
		open func LAST() -> TerminalNode? { return getToken(tsqlParser.Tokens.LAST.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func ABSOLUTE() -> TerminalNode? { return getToken(tsqlParser.Tokens.ABSOLUTE.rawValue, 0) }
		open func RELATIVE() -> TerminalNode? { return getToken(tsqlParser.Tokens.RELATIVE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_fetch_cursor }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFetch_cursor(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFetch_cursor(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFetch_cursor(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFetch_cursor(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func fetch_cursor() throws -> Fetch_cursorContext {
		var _localctx: Fetch_cursorContext = Fetch_cursorContext(_ctx, getState())
		try enterRule(_localctx, 266, tsqlParser.RULE_fetch_cursor)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3030)
		 	try match(tsqlParser.Tokens.FETCH.rawValue)
		 	setState(3040)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,442,_ctx)) {
		 	case 1:
		 		setState(3037)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .NEXT:
		 		 	setState(3031)
		 		 	try match(tsqlParser.Tokens.NEXT.rawValue)

		 			break

		 		case .PRIOR:
		 		 	setState(3032)
		 		 	try match(tsqlParser.Tokens.PRIOR.rawValue)

		 			break

		 		case .FIRST:
		 		 	setState(3033)
		 		 	try match(tsqlParser.Tokens.FIRST.rawValue)

		 			break

		 		case .LAST:
		 		 	setState(3034)
		 		 	try match(tsqlParser.Tokens.LAST.rawValue)

		 			break
		 		case .ABSOLUTE:fallthrough
		 		case .RELATIVE:
		 		 	setState(3035)
		 		 	_la = try _input.LA(1)
		 		 	if (!(//closure
		 		 	 { () -> Bool in
		 		 	      var testSet: Bool = _la == tsqlParser.Tokens.ABSOLUTE.rawValue
		 		 	          testSet = testSet || _la == tsqlParser.Tokens.RELATIVE.rawValue
		 		 	      return testSet
		 		 	 }())) {
		 		 	try _errHandler.recoverInline(self)
		 		 	}
		 		 	else {
		 		 		_errHandler.reportMatch(self)
		 		 		try consume()
		 		 	}
		 		 	setState(3036)
		 		 	try expression(0)

		 			break

		 		case .FROM:
		 			break
		 		default:
		 			break
		 		}
		 		setState(3039)
		 		try match(tsqlParser.Tokens.FROM.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(3043)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,443,_ctx)) {
		 	case 1:
		 		setState(3042)
		 		try match(tsqlParser.Tokens.GLOBAL.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(3045)
		 	try cursor_name()
		 	setState(3055)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3046)
		 		try match(tsqlParser.Tokens.INTO.rawValue)
		 		setState(3047)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 		setState(3052)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3048)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(3049)
		 			try match(tsqlParser.Tokens.LOCAL_ID.rawValue)


		 			setState(3054)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(3058)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,446,_ctx)) {
		 	case 1:
		 		setState(3057)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Set_specialContext:ParserRuleContext {
		open func SET() -> TerminalNode? { return getToken(tsqlParser.Tokens.SET.rawValue, 0) }
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func constant_LOCAL_ID() -> Constant_LOCAL_IDContext? {
			return getRuleContext(Constant_LOCAL_IDContext.self,0)
		}
		open func on_off() -> On_offContext? {
			return getRuleContext(On_offContext.self,0)
		}
		open func TRANSACTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRANSACTION.rawValue, 0) }
		open func ISOLATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ISOLATION.rawValue, 0) }
		open func LEVEL() -> TerminalNode? { return getToken(tsqlParser.Tokens.LEVEL.rawValue, 0) }
		open func READ() -> TerminalNode? { return getToken(tsqlParser.Tokens.READ.rawValue, 0) }
		open func UNCOMMITTED() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNCOMMITTED.rawValue, 0) }
		open func COMMITTED() -> TerminalNode? { return getToken(tsqlParser.Tokens.COMMITTED.rawValue, 0) }
		open func REPEATABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.REPEATABLE.rawValue, 0) }
		open func SNAPSHOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.SNAPSHOT.rawValue, 0) }
		open func SERIALIZABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SERIALIZABLE.rawValue, 0) }
		open func IDENTITY_INSERT() -> TerminalNode? { return getToken(tsqlParser.Tokens.IDENTITY_INSERT.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func ANSI_NULLS() -> TerminalNode? { return getToken(tsqlParser.Tokens.ANSI_NULLS.rawValue, 0) }
		open func QUOTED_IDENTIFIER() -> TerminalNode? { return getToken(tsqlParser.Tokens.QUOTED_IDENTIFIER.rawValue, 0) }
		open func ANSI_PADDING() -> TerminalNode? { return getToken(tsqlParser.Tokens.ANSI_PADDING.rawValue, 0) }
		open func ANSI_WARNINGS() -> TerminalNode? { return getToken(tsqlParser.Tokens.ANSI_WARNINGS.rawValue, 0) }
		open func modify_method() -> Modify_methodContext? {
			return getRuleContext(Modify_methodContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_set_special }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSet_special(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSet_special(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSet_special(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSet_special(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func set_special() throws -> Set_specialContext {
		var _localctx: Set_specialContext = Set_specialContext(_ctx, getState())
		try enterRule(_localctx, 268, tsqlParser.RULE_set_special)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3108)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,452, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3060)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(3061)
		 		try id()
		 		setState(3065)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CALLED:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .ID:
		 			setState(3062)
		 			try id()

		 			break
		 		case .LOCAL_ID:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .STRING:fallthrough
		 		case .BINARY:fallthrough
		 		case .FLOAT:fallthrough
		 		case .REAL:fallthrough
		 		case .DOLLAR:fallthrough
		 		case .PLUS:fallthrough
		 		case .MINUS:
		 			setState(3063)
		 			try constant_LOCAL_ID()

		 			break
		 		case .OFF:fallthrough
		 		case .ON:
		 			setState(3064)
		 			try on_off()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3068)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,448,_ctx)) {
		 		case 1:
		 			setState(3067)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3070)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(3071)
		 		try match(tsqlParser.Tokens.TRANSACTION.rawValue)
		 		setState(3072)
		 		try match(tsqlParser.Tokens.ISOLATION.rawValue)
		 		setState(3073)
		 		try match(tsqlParser.Tokens.LEVEL.rawValue)
		 		setState(3082)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,449, _ctx)) {
		 		case 1:
		 			setState(3074)
		 			try match(tsqlParser.Tokens.READ.rawValue)
		 			setState(3075)
		 			try match(tsqlParser.Tokens.UNCOMMITTED.rawValue)

		 			break
		 		case 2:
		 			setState(3076)
		 			try match(tsqlParser.Tokens.READ.rawValue)
		 			setState(3077)
		 			try match(tsqlParser.Tokens.COMMITTED.rawValue)

		 			break
		 		case 3:
		 			setState(3078)
		 			try match(tsqlParser.Tokens.REPEATABLE.rawValue)
		 			setState(3079)
		 			try match(tsqlParser.Tokens.READ.rawValue)

		 			break
		 		case 4:
		 			setState(3080)
		 			try match(tsqlParser.Tokens.SNAPSHOT.rawValue)

		 			break
		 		case 5:
		 			setState(3081)
		 			try match(tsqlParser.Tokens.SERIALIZABLE.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(3085)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,450,_ctx)) {
		 		case 1:
		 			setState(3084)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3087)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(3088)
		 		try match(tsqlParser.Tokens.IDENTITY_INSERT.rawValue)
		 		setState(3089)
		 		try table_name()
		 		setState(3090)
		 		try on_off()
		 		setState(3092)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,451,_ctx)) {
		 		case 1:
		 			setState(3091)
		 			try match(tsqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3094)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(3095)
		 		try match(tsqlParser.Tokens.ANSI_NULLS.rawValue)
		 		setState(3096)
		 		try on_off()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3097)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(3098)
		 		try match(tsqlParser.Tokens.QUOTED_IDENTIFIER.rawValue)
		 		setState(3099)
		 		try on_off()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3100)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(3101)
		 		try match(tsqlParser.Tokens.ANSI_PADDING.rawValue)
		 		setState(3102)
		 		try on_off()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(3103)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(3104)
		 		try match(tsqlParser.Tokens.ANSI_WARNINGS.rawValue)
		 		setState(3105)
		 		try on_off()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(3106)
		 		try match(tsqlParser.Tokens.SET.rawValue)
		 		setState(3107)
		 		try modify_method()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Constant_LOCAL_IDContext:ParserRuleContext {
		open func constant() -> ConstantContext? {
			return getRuleContext(ConstantContext.self,0)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_constant_LOCAL_ID }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterConstant_LOCAL_ID(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitConstant_LOCAL_ID(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitConstant_LOCAL_ID(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitConstant_LOCAL_ID(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func constant_LOCAL_ID() throws -> Constant_LOCAL_IDContext {
		var _localctx: Constant_LOCAL_IDContext = Constant_LOCAL_IDContext(_ctx, getState())
		try enterRule(_localctx, 270, tsqlParser.RULE_constant_LOCAL_ID)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3112)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DECIMAL:fallthrough
		 	case .STRING:fallthrough
		 	case .BINARY:fallthrough
		 	case .FLOAT:fallthrough
		 	case .REAL:fallthrough
		 	case .DOLLAR:fallthrough
		 	case .PLUS:fallthrough
		 	case .MINUS:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3110)
		 		try constant()

		 		break

		 	case .LOCAL_ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3111)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	open class ExpressionContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_expression }
	 
		public  func copyFrom(_ ctx: ExpressionContext) {
			super.copyFrom(ctx)
		}
	}
	public  final class Binary_operator_expressionContext: ExpressionContext {
		public var op: Token!
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func comparison_operator() -> Comparison_operatorContext? {
			return getRuleContext(Comparison_operatorContext.self,0)
		}
		public init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterBinary_operator_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitBinary_operator_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitBinary_operator_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitBinary_operator_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Primitive_expressionContext: ExpressionContext {
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open func NULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.NULL.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func constant() -> ConstantContext? {
			return getRuleContext(ConstantContext.self,0)
		}
		public init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterPrimitive_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitPrimitive_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitPrimitive_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitPrimitive_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Asssignment_operator_expressionContext: ExpressionContext {
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func assignment_operator() -> Assignment_operatorContext? {
			return getRuleContext(Assignment_operatorContext.self,0)
		}
		public init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterAsssignment_operator_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitAsssignment_operator_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitAsssignment_operator_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitAsssignment_operator_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Bracket_expressionContext: ExpressionContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		public init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterBracket_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitBracket_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitBracket_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitBracket_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Unary_operator_expressionContext: ExpressionContext {
		public var op: Token!
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		public init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterUnary_operator_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitUnary_operator_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitUnary_operator_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitUnary_operator_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Function_call_expressionContext: ExpressionContext {
		open func function_call() -> Function_callContext? {
			return getRuleContext(Function_callContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func COLLATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.COLLATE.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		public init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFunction_call_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFunction_call_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFunction_call_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFunction_call_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Case_expressionContext: ExpressionContext {
		public var caseExpr: ExpressionContext!
		public var elseExpr: ExpressionContext!
		open func CASE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CASE.rawValue, 0) }
		open func END() -> TerminalNode? { return getToken(tsqlParser.Tokens.END.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func switch_section() -> Array<Switch_sectionContext> {
			return getRuleContexts(Switch_sectionContext.self)
		}
		open func switch_section(_ i: Int) -> Switch_sectionContext? {
			return getRuleContext(Switch_sectionContext.self,i)
		}
		open func ELSE() -> TerminalNode? { return getToken(tsqlParser.Tokens.ELSE.rawValue, 0) }
		open func switch_search_condition_section() -> Array<Switch_search_condition_sectionContext> {
			return getRuleContexts(Switch_search_condition_sectionContext.self)
		}
		open func switch_search_condition_section(_ i: Int) -> Switch_search_condition_sectionContext? {
			return getRuleContext(Switch_search_condition_sectionContext.self,i)
		}
		public init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCase_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCase_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCase_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCase_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Column_ref_expressionContext: ExpressionContext {
		open func full_column_name() -> Full_column_nameContext? {
			return getRuleContext(Full_column_nameContext.self,0)
		}
		public init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterColumn_ref_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitColumn_ref_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitColumn_ref_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitColumn_ref_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Subquery_expressionContext: ExpressionContext {
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		public init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSubquery_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSubquery_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSubquery_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSubquery_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	public  final class Over_clause_expressionContext: ExpressionContext {
		open func over_clause() -> Over_clauseContext? {
			return getRuleContext(Over_clauseContext.self,0)
		}
		public init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOver_clause_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOver_clause_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOver_clause_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOver_clause_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}

	public final  func expression( ) throws -> ExpressionContext   {
		return try expression(0)
	}
	@discardableResult
	private func expression(_ _p: Int) throws -> ExpressionContext   {
		let _parentctx: ParserRuleContext? = _ctx
		var _parentState: Int = getState()
		var _localctx: ExpressionContext = ExpressionContext(_ctx, _parentState)
		var  _prevctx: ExpressionContext = _localctx
		var _startState: Int = 272
		try enterRecursionRule(_localctx, 272, tsqlParser.RULE_expression, _p)
		var _la: Int = 0
		defer {
	    		try! unrollRecursionContexts(_parentctx)
	    }
		do {
			var _alt: Int
			try enterOuterAlt(_localctx, 1)
			setState(3159)
			try _errHandler.sync(self)
			switch(try getInterpreter().adaptivePredict(_input,458, _ctx)) {
			case 1:
				_localctx = Primitive_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx

				setState(3115)
				try match(tsqlParser.Tokens.DEFAULT.rawValue)

				break
			case 2:
				_localctx = Primitive_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3116)
				try match(tsqlParser.Tokens.NULL.rawValue)

				break
			case 3:
				_localctx = Primitive_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3117)
				try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

				break
			case 4:
				_localctx = Primitive_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3118)
				try constant()

				break
			case 5:
				_localctx = Function_call_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3119)
				try function_call()

				break
			case 6:
				_localctx = Case_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3120)
				try match(tsqlParser.Tokens.CASE.rawValue)
				setState(3121)
				try {
						let assignmentValue = try expression(0)
						_localctx.castdown(Case_expressionContext.self).caseExpr = assignmentValue
				     }()

				setState(3123) 
				try _errHandler.sync(self)
				_la = try _input.LA(1)
				repeat {
					setState(3122)
					try switch_section()


					setState(3125); 
					try _errHandler.sync(self)
					_la = try _input.LA(1)
				} while (//closure
				 { () -> Bool in
				      let testSet: Bool = _la == tsqlParser.Tokens.WHEN.rawValue
				      return testSet
				 }())
				setState(3129)
				try _errHandler.sync(self)
				_la = try _input.LA(1)
				if (//closure
				 { () -> Bool in
				      let testSet: Bool = _la == tsqlParser.Tokens.ELSE.rawValue
				      return testSet
				 }()) {
					setState(3127)
					try match(tsqlParser.Tokens.ELSE.rawValue)
					setState(3128)
					try {
							let assignmentValue = try expression(0)
							_localctx.castdown(Case_expressionContext.self).elseExpr = assignmentValue
					     }()


				}

				setState(3131)
				try match(tsqlParser.Tokens.END.rawValue)

				break
			case 7:
				_localctx = Case_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3133)
				try match(tsqlParser.Tokens.CASE.rawValue)
				setState(3135) 
				try _errHandler.sync(self)
				_la = try _input.LA(1)
				repeat {
					setState(3134)
					try switch_search_condition_section()


					setState(3137); 
					try _errHandler.sync(self)
					_la = try _input.LA(1)
				} while (//closure
				 { () -> Bool in
				      let testSet: Bool = _la == tsqlParser.Tokens.WHEN.rawValue
				      return testSet
				 }())
				setState(3141)
				try _errHandler.sync(self)
				_la = try _input.LA(1)
				if (//closure
				 { () -> Bool in
				      let testSet: Bool = _la == tsqlParser.Tokens.ELSE.rawValue
				      return testSet
				 }()) {
					setState(3139)
					try match(tsqlParser.Tokens.ELSE.rawValue)
					setState(3140)
					try {
							let assignmentValue = try expression(0)
							_localctx.castdown(Case_expressionContext.self).elseExpr = assignmentValue
					     }()


				}

				setState(3143)
				try match(tsqlParser.Tokens.END.rawValue)

				break
			case 8:
				_localctx = Column_ref_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3145)
				try full_column_name()

				break
			case 9:
				_localctx = Bracket_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3146)
				try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
				setState(3147)
				try expression(0)
				setState(3148)
				try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

				break
			case 10:
				_localctx = Subquery_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3150)
				try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
				setState(3151)
				try subquery()
				setState(3152)
				try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

				break
			case 11:
				_localctx = Unary_operator_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3154)
				try match(tsqlParser.Tokens.BIT_NOT.rawValue)
				setState(3155)
				try expression(7)

				break
			case 12:
				_localctx = Unary_operator_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3156)
				_localctx.castdown(Unary_operator_expressionContext.self).op = try _input.LT(1)
				_la = try _input.LA(1)
				if (!(//closure
				 { () -> Bool in
				      let testSet: Bool = _la == tsqlParser.Tokens.PLUS.rawValue || _la == tsqlParser.Tokens.MINUS.rawValue
				      return testSet
				 }())) {
					_localctx.castdown(Unary_operator_expressionContext.self).op = try _errHandler.recoverInline(self) as Token
				}
				else {
					_errHandler.reportMatch(self)
					try consume()
				}
				setState(3157)
				try expression(5)

				break
			case 13:
				_localctx = Over_clause_expressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(3158)
				try over_clause()

				break
			default: break
			}
			_ctx!.stop = try _input.LT(-1)
			setState(3180)
			try _errHandler.sync(self)
			_alt = try getInterpreter().adaptivePredict(_input,460,_ctx)
			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
				if ( _alt==1 ) {
					if _parseListeners != nil {
					   try triggerExitRuleEvent()
					}
					_prevctx = _localctx
					setState(3178)
					try _errHandler.sync(self)
					switch(try getInterpreter().adaptivePredict(_input,459, _ctx)) {
					case 1:
						_localctx = Binary_operator_expressionContext(  ExpressionContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, tsqlParser.RULE_expression)
						setState(3161)
						if (!(precpred(_ctx, 6))) {
						    throw try ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 6)"))
						}
						setState(3162)
						_localctx.castdown(Binary_operator_expressionContext.self).op = try _input.LT(1)
						_la = try _input.LA(1)
						if (!(//closure
						 { () -> Bool in
						      let testSet: Bool = {  () -> Bool in
						   let testArray: [Int] = [_la, tsqlParser.Tokens.STAR.rawValue,tsqlParser.Tokens.DIVIDE.rawValue,tsqlParser.Tokens.MODULE.rawValue]
						    return  Utils.testBitLeftShiftArray(testArray, 524)
						}()
						      return testSet
						 }())) {
							_localctx.castdown(Binary_operator_expressionContext.self).op = try _errHandler.recoverInline(self) as Token
						}
						else {
							_errHandler.reportMatch(self)
							try consume()
						}
						setState(3163)
						try expression(7)

						break
					case 2:
						_localctx = Binary_operator_expressionContext(  ExpressionContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, tsqlParser.RULE_expression)
						setState(3164)
						if (!(precpred(_ctx, 4))) {
						    throw try ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 4)"))
						}
						setState(3165)
						_localctx.castdown(Binary_operator_expressionContext.self).op = try _input.LT(1)
						_la = try _input.LA(1)
						if (!(//closure
						 { () -> Bool in
						      let testSet: Bool = {  () -> Bool in
						   let testArray: [Int] = [_la, tsqlParser.Tokens.PLUS.rawValue,tsqlParser.Tokens.MINUS.rawValue,tsqlParser.Tokens.BIT_OR.rawValue,tsqlParser.Tokens.BIT_AND.rawValue,tsqlParser.Tokens.BIT_XOR.rawValue]
						    return  Utils.testBitLeftShiftArray(testArray, 527)
						}()
						      return testSet
						 }())) {
							_localctx.castdown(Binary_operator_expressionContext.self).op = try _errHandler.recoverInline(self) as Token
						}
						else {
							_errHandler.reportMatch(self)
							try consume()
						}
						setState(3166)
						try expression(5)

						break
					case 3:
						_localctx = Binary_operator_expressionContext(  ExpressionContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, tsqlParser.RULE_expression)
						setState(3167)
						if (!(precpred(_ctx, 3))) {
						    throw try ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 3)"))
						}
						setState(3168)
						try comparison_operator()
						setState(3169)
						try expression(4)

						break
					case 4:
						_localctx = Asssignment_operator_expressionContext(  ExpressionContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, tsqlParser.RULE_expression)
						setState(3171)
						if (!(precpred(_ctx, 2))) {
						    throw try ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 2)"))
						}
						setState(3172)
						try assignment_operator()
						setState(3173)
						try expression(3)

						break
					case 5:
						_localctx = Function_call_expressionContext(  ExpressionContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, tsqlParser.RULE_expression)
						setState(3175)
						if (!(precpred(_ctx, 13))) {
						    throw try ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 13)"))
						}
						setState(3176)
						try match(tsqlParser.Tokens.COLLATE.rawValue)
						setState(3177)
						try id()

						break
					default: break
					}
			 
				}
				setState(3182)
				try _errHandler.sync(self)
				_alt = try getInterpreter().adaptivePredict(_input,460,_ctx)
			}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx;
	}
	open class Constant_expressionContext:ParserRuleContext {
		open func NULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.NULL.rawValue, 0) }
		open func constant() -> ConstantContext? {
			return getRuleContext(ConstantContext.self,0)
		}
		open func function_call() -> Function_callContext? {
			return getRuleContext(Function_callContext.self,0)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func constant_expression() -> Constant_expressionContext? {
			return getRuleContext(Constant_expressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_constant_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterConstant_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitConstant_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitConstant_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitConstant_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func constant_expression() throws -> Constant_expressionContext {
		var _localctx: Constant_expressionContext = Constant_expressionContext(_ctx, getState())
		try enterRule(_localctx, 274, tsqlParser.RULE_constant_expression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3191)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,461, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3183)
		 		try match(tsqlParser.Tokens.NULL.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3184)
		 		try constant()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3185)
		 		try function_call()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3186)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3187)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3188)
		 		try constant_expression()
		 		setState(3189)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SubqueryContext:ParserRuleContext {
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_subquery }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSubquery(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSubquery(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSubquery(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSubquery(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func subquery() throws -> SubqueryContext {
		var _localctx: SubqueryContext = SubqueryContext(_ctx, getState())
		try enterRule(_localctx, 276, tsqlParser.RULE_subquery)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3193)
		 	try select_statement()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class With_expressionContext:ParserRuleContext {
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func common_table_expression() -> Array<Common_table_expressionContext> {
			return getRuleContexts(Common_table_expressionContext.self)
		}
		open func common_table_expression(_ i: Int) -> Common_table_expressionContext? {
			return getRuleContext(Common_table_expressionContext.self,i)
		}
		open func XMLNAMESPACES() -> TerminalNode? { return getToken(tsqlParser.Tokens.XMLNAMESPACES.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_with_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterWith_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitWith_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitWith_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitWith_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func with_expression() throws -> With_expressionContext {
		var _localctx: With_expressionContext = With_expressionContext(_ctx, getState())
		try enterRule(_localctx, 278, tsqlParser.RULE_with_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3195)
		 	try match(tsqlParser.Tokens.WITH.rawValue)
		 	setState(3198)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,462,_ctx)) {
		 	case 1:
		 		setState(3196)
		 		try match(tsqlParser.Tokens.XMLNAMESPACES.rawValue)
		 		setState(3197)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(3200)
		 	try common_table_expression()
		 	setState(3205)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3201)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3202)
		 		try common_table_expression()


		 		setState(3207)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Common_table_expressionContext:ParserRuleContext {
		public var expression_name: IdContext!
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func select_statement() -> Select_statementContext? {
			return getRuleContext(Select_statementContext.self,0)
		}
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func column_name_list() -> Column_name_listContext? {
			return getRuleContext(Column_name_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_common_table_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCommon_table_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCommon_table_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCommon_table_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCommon_table_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func common_table_expression() throws -> Common_table_expressionContext {
		var _localctx: Common_table_expressionContext = Common_table_expressionContext(_ctx, getState())
		try enterRule(_localctx, 280, tsqlParser.RULE_common_table_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3208)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(Common_table_expressionContext.self).expression_name = assignmentValue
		 	     }()

		 	setState(3213)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LR_BRACKET.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3209)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3210)
		 		try column_name_list()
		 		setState(3211)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(3215)
		 	try match(tsqlParser.Tokens.AS.rawValue)
		 	setState(3216)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(3217)
		 	try select_statement()
		 	setState(3218)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Update_elemContext:ParserRuleContext {
		public var udt_column_name: IdContext!
		public var method_name: IdContext!
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func full_column_name() -> Full_column_nameContext? {
			return getRuleContext(Full_column_nameContext.self,0)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func assignment_operator() -> Assignment_operatorContext? {
			return getRuleContext(Assignment_operatorContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_update_elem }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterUpdate_elem(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitUpdate_elem(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitUpdate_elem(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitUpdate_elem(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func update_elem() throws -> Update_elemContext {
		var _localctx: Update_elemContext = Update_elemContext(_ctx, getState())
		try enterRule(_localctx, 282, tsqlParser.RULE_update_elem)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3236)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,467, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3222)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CALLED:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .ID:
		 			setState(3220)
		 			try full_column_name()

		 			break

		 		case .LOCAL_ID:
		 			setState(3221)
		 			try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3226)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .EQUAL:
		 			setState(3224)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)

		 			break
		 		case .PLUS_ASSIGN:fallthrough
		 		case .MINUS_ASSIGN:fallthrough
		 		case .MULT_ASSIGN:fallthrough
		 		case .DIV_ASSIGN:fallthrough
		 		case .MOD_ASSIGN:fallthrough
		 		case .AND_ASSIGN:fallthrough
		 		case .XOR_ASSIGN:fallthrough
		 		case .OR_ASSIGN:
		 			setState(3225)
		 			try assignment_operator()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3228)
		 		try expression(0)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3229)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Update_elemContext.self).udt_column_name = assignmentValue
		 		     }()

		 		setState(3230)
		 		try match(tsqlParser.Tokens.DOT.rawValue)
		 		setState(3231)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Update_elemContext.self).method_name = assignmentValue
		 		     }()

		 		setState(3232)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3233)
		 		try expression_list()
		 		setState(3234)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Search_condition_listContext:ParserRuleContext {
		open func search_condition() -> Array<Search_conditionContext> {
			return getRuleContexts(Search_conditionContext.self)
		}
		open func search_condition(_ i: Int) -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_search_condition_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSearch_condition_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSearch_condition_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSearch_condition_list(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSearch_condition_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func search_condition_list() throws -> Search_condition_listContext {
		var _localctx: Search_condition_listContext = Search_condition_listContext(_ctx, getState())
		try enterRule(_localctx, 284, tsqlParser.RULE_search_condition_list)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3238)
		 	try search_condition()
		 	setState(3243)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3239)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3240)
		 		try search_condition()


		 		setState(3245)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Search_conditionContext:ParserRuleContext {
		open func search_condition_and() -> Array<Search_condition_andContext> {
			return getRuleContexts(Search_condition_andContext.self)
		}
		open func search_condition_and(_ i: Int) -> Search_condition_andContext? {
			return getRuleContext(Search_condition_andContext.self,i)
		}
		open func OR() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.OR.rawValue) }
		open func OR(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.OR.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_search_condition }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSearch_condition(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSearch_condition(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSearch_condition(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSearch_condition(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func search_condition() throws -> Search_conditionContext {
		var _localctx: Search_conditionContext = Search_conditionContext(_ctx, getState())
		try enterRule(_localctx, 286, tsqlParser.RULE_search_condition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3246)
		 	try search_condition_and()
		 	setState(3251)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.OR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3247)
		 		try match(tsqlParser.Tokens.OR.rawValue)
		 		setState(3248)
		 		try search_condition_and()


		 		setState(3253)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Search_condition_andContext:ParserRuleContext {
		open func search_condition_not() -> Array<Search_condition_notContext> {
			return getRuleContexts(Search_condition_notContext.self)
		}
		open func search_condition_not(_ i: Int) -> Search_condition_notContext? {
			return getRuleContext(Search_condition_notContext.self,i)
		}
		open func AND() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.AND.rawValue) }
		open func AND(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.AND.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_search_condition_and }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSearch_condition_and(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSearch_condition_and(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSearch_condition_and(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSearch_condition_and(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func search_condition_and() throws -> Search_condition_andContext {
		var _localctx: Search_condition_andContext = Search_condition_andContext(_ctx, getState())
		try enterRule(_localctx, 288, tsqlParser.RULE_search_condition_and)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3254)
		 	try search_condition_not()
		 	setState(3259)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.AND.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3255)
		 		try match(tsqlParser.Tokens.AND.rawValue)
		 		setState(3256)
		 		try search_condition_not()


		 		setState(3261)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Search_condition_notContext:ParserRuleContext {
		open func predicate() -> PredicateContext? {
			return getRuleContext(PredicateContext.self,0)
		}
		open func NOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NOT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_search_condition_not }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSearch_condition_not(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSearch_condition_not(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSearch_condition_not(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSearch_condition_not(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func search_condition_not() throws -> Search_condition_notContext {
		var _localctx: Search_condition_notContext = Search_condition_notContext(_ctx, getState())
		try enterRule(_localctx, 290, tsqlParser.RULE_search_condition_not)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3263)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.NOT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3262)
		 		try match(tsqlParser.Tokens.NOT.rawValue)

		 	}

		 	setState(3265)
		 	try predicate()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class PredicateContext:ParserRuleContext {
		open func EXISTS() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXISTS.rawValue, 0) }
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func comparison_operator() -> Comparison_operatorContext? {
			return getRuleContext(Comparison_operatorContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALL.rawValue, 0) }
		open func SOME() -> TerminalNode? { return getToken(tsqlParser.Tokens.SOME.rawValue, 0) }
		open func ANY() -> TerminalNode? { return getToken(tsqlParser.Tokens.ANY.rawValue, 0) }
		open func BETWEEN() -> TerminalNode? { return getToken(tsqlParser.Tokens.BETWEEN.rawValue, 0) }
		open func AND() -> TerminalNode? { return getToken(tsqlParser.Tokens.AND.rawValue, 0) }
		open func NOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NOT.rawValue, 0) }
		open func IN() -> TerminalNode? { return getToken(tsqlParser.Tokens.IN.rawValue, 0) }
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func LIKE() -> TerminalNode? { return getToken(tsqlParser.Tokens.LIKE.rawValue, 0) }
		open func ESCAPE() -> TerminalNode? { return getToken(tsqlParser.Tokens.ESCAPE.rawValue, 0) }
		open func IS() -> TerminalNode? { return getToken(tsqlParser.Tokens.IS.rawValue, 0) }
		open func null_notnull() -> Null_notnullContext? {
			return getRuleContext(Null_notnullContext.self,0)
		}
		open func search_condition() -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_predicate }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterPredicate(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitPredicate(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitPredicate(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitPredicate(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func predicate() throws -> PredicateContext {
		var _localctx: PredicateContext = PredicateContext(_ctx, getState())
		try enterRule(_localctx, 292, tsqlParser.RULE_predicate)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3322)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,477, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3267)
		 		try match(tsqlParser.Tokens.EXISTS.rawValue)
		 		setState(3268)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3269)
		 		try subquery()
		 		setState(3270)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3272)
		 		try expression(0)
		 		setState(3273)
		 		try comparison_operator()
		 		setState(3274)
		 		try expression(0)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3276)
		 		try expression(0)
		 		setState(3277)
		 		try comparison_operator()
		 		setState(3278)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.ALL.rawValue || _la == tsqlParser.Tokens.ANY.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.SOME.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3279)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3280)
		 		try subquery()
		 		setState(3281)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3283)
		 		try expression(0)
		 		setState(3285)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.NOT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3284)
		 			try match(tsqlParser.Tokens.NOT.rawValue)

		 		}

		 		setState(3287)
		 		try match(tsqlParser.Tokens.BETWEEN.rawValue)
		 		setState(3288)
		 		try expression(0)
		 		setState(3289)
		 		try match(tsqlParser.Tokens.AND.rawValue)
		 		setState(3290)
		 		try expression(0)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3292)
		 		try expression(0)
		 		setState(3294)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.NOT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3293)
		 			try match(tsqlParser.Tokens.NOT.rawValue)

		 		}

		 		setState(3296)
		 		try match(tsqlParser.Tokens.IN.rawValue)
		 		setState(3297)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3300)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,474, _ctx)) {
		 		case 1:
		 			setState(3298)
		 			try subquery()

		 			break
		 		case 2:
		 			setState(3299)
		 			try expression_list()

		 			break
		 		default: break
		 		}
		 		setState(3302)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3304)
		 		try expression(0)
		 		setState(3306)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.NOT.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3305)
		 			try match(tsqlParser.Tokens.NOT.rawValue)

		 		}

		 		setState(3308)
		 		try match(tsqlParser.Tokens.LIKE.rawValue)
		 		setState(3309)
		 		try expression(0)
		 		setState(3312)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ESCAPE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3310)
		 			try match(tsqlParser.Tokens.ESCAPE.rawValue)
		 			setState(3311)
		 			try expression(0)

		 		}


		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(3314)
		 		try expression(0)
		 		setState(3315)
		 		try match(tsqlParser.Tokens.IS.rawValue)
		 		setState(3316)
		 		try null_notnull()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(3318)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3319)
		 		try search_condition()
		 		setState(3320)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Query_expressionContext:ParserRuleContext {
		open func query_specification() -> Query_specificationContext? {
			return getRuleContext(Query_specificationContext.self,0)
		}
		open func query_expression() -> Query_expressionContext? {
			return getRuleContext(Query_expressionContext.self,0)
		}
		open func union() -> Array<UnionContext> {
			return getRuleContexts(UnionContext.self)
		}
		open func union(_ i: Int) -> UnionContext? {
			return getRuleContext(UnionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_query_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterQuery_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitQuery_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitQuery_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitQuery_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func query_expression() throws -> Query_expressionContext {
		var _localctx: Query_expressionContext = Query_expressionContext(_ctx, getState())
		try enterRule(_localctx, 294, tsqlParser.RULE_query_expression)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3329)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SELECT:
		 		setState(3324)
		 		try query_specification()

		 		break

		 	case .LR_BRACKET:
		 		setState(3325)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3326)
		 		try query_expression()
		 		setState(3327)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3334)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,479,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3331)
		 			try union()

		 	 
		 		}
		 		setState(3336)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,479,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class UnionContext:ParserRuleContext {
		open func UNION() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNION.rawValue, 0) }
		open func EXCEPT() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXCEPT.rawValue, 0) }
		open func INTERSECT() -> TerminalNode? { return getToken(tsqlParser.Tokens.INTERSECT.rawValue, 0) }
		open func query_specification() -> Query_specificationContext? {
			return getRuleContext(Query_specificationContext.self,0)
		}
		open func query_expression() -> Query_expressionContext? {
			return getRuleContext(Query_expressionContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_union }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterUnion(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitUnion(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitUnion(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitUnion(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func union() throws -> UnionContext {
		var _localctx: UnionContext = UnionContext(_ctx, getState())
		try enterRule(_localctx, 296, tsqlParser.RULE_union)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3343)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .UNION:
		 		setState(3337)
		 		try match(tsqlParser.Tokens.UNION.rawValue)
		 		setState(3339)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ALL.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3338)
		 			try match(tsqlParser.Tokens.ALL.rawValue)

		 		}


		 		break

		 	case .EXCEPT:
		 		setState(3341)
		 		try match(tsqlParser.Tokens.EXCEPT.rawValue)

		 		break

		 	case .INTERSECT:
		 		setState(3342)
		 		try match(tsqlParser.Tokens.INTERSECT.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3350)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SELECT:
		 		setState(3345)
		 		try query_specification()

		 		break

		 	case .LR_BRACKET:
		 		setState(3346)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3347)
		 		try query_expression()
		 		setState(3348)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Query_specificationContext:ParserRuleContext {
		public var where: Search_conditionContext!
		public var having: Search_conditionContext!
		open func SELECT() -> TerminalNode? { return getToken(tsqlParser.Tokens.SELECT.rawValue, 0) }
		open func select_list() -> Select_listContext? {
			return getRuleContext(Select_listContext.self,0)
		}
		open func top_clause() -> Top_clauseContext? {
			return getRuleContext(Top_clauseContext.self,0)
		}
		open func INTO() -> TerminalNode? { return getToken(tsqlParser.Tokens.INTO.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func FROM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FROM.rawValue, 0) }
		open func table_sources() -> Table_sourcesContext? {
			return getRuleContext(Table_sourcesContext.self,0)
		}
		open func WHERE() -> TerminalNode? { return getToken(tsqlParser.Tokens.WHERE.rawValue, 0) }
		open func GROUP() -> TerminalNode? { return getToken(tsqlParser.Tokens.GROUP.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(tsqlParser.Tokens.BY.rawValue, 0) }
		open func group_by_item() -> Array<Group_by_itemContext> {
			return getRuleContexts(Group_by_itemContext.self)
		}
		open func group_by_item(_ i: Int) -> Group_by_itemContext? {
			return getRuleContext(Group_by_itemContext.self,i)
		}
		open func HAVING() -> TerminalNode? { return getToken(tsqlParser.Tokens.HAVING.rawValue, 0) }
		open func ALL() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ALL.rawValue) }
		open func ALL(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ALL.rawValue, i)
		}
		open func DISTINCT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DISTINCT.rawValue, 0) }
		open func search_condition() -> Array<Search_conditionContext> {
			return getRuleContexts(Search_conditionContext.self)
		}
		open func search_condition(_ i: Int) -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_query_specification }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterQuery_specification(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitQuery_specification(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitQuery_specification(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitQuery_specification(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func query_specification() throws -> Query_specificationContext {
		var _localctx: Query_specificationContext = Query_specificationContext(_ctx, getState())
		try enterRule(_localctx, 298, tsqlParser.RULE_query_specification)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3352)
		 	try match(tsqlParser.Tokens.SELECT.rawValue)
		 	setState(3354)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ALL.rawValue || _la == tsqlParser.Tokens.DISTINCT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3353)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ALL.rawValue || _la == tsqlParser.Tokens.DISTINCT.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3357)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.TOP.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3356)
		 		try top_clause()

		 	}

		 	setState(3359)
		 	try select_list()
		 	setState(3362)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.INTO.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3360)
		 		try match(tsqlParser.Tokens.INTO.rawValue)
		 		setState(3361)
		 		try table_name()

		 	}

		 	setState(3366)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.FROM.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3364)
		 		try match(tsqlParser.Tokens.FROM.rawValue)
		 		setState(3365)
		 		try table_sources()

		 	}

		 	setState(3370)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,487,_ctx)) {
		 	case 1:
		 		setState(3368)
		 		try match(tsqlParser.Tokens.WHERE.rawValue)
		 		setState(3369)
		 		try {
		 				let assignmentValue = try search_condition()
		 				_localctx.castdown(Query_specificationContext.self).where = assignmentValue
		 		     }()


		 		break
		 	default: break
		 	}
		 	setState(3385)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,490,_ctx)) {
		 	case 1:
		 		setState(3372)
		 		try match(tsqlParser.Tokens.GROUP.rawValue)
		 		setState(3373)
		 		try match(tsqlParser.Tokens.BY.rawValue)
		 		setState(3375)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ALL.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3374)
		 			try match(tsqlParser.Tokens.ALL.rawValue)

		 		}

		 		setState(3377)
		 		try group_by_item()
		 		setState(3382)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,489,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(3378)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)
		 				setState(3379)
		 				try group_by_item()

		 		 
		 			}
		 			setState(3384)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,489,_ctx)
		 		}

		 		break
		 	default: break
		 	}
		 	setState(3389)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,491,_ctx)) {
		 	case 1:
		 		setState(3387)
		 		try match(tsqlParser.Tokens.HAVING.rawValue)
		 		setState(3388)
		 		try {
		 				let assignmentValue = try search_condition()
		 				_localctx.castdown(Query_specificationContext.self).having = assignmentValue
		 		     }()


		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Top_clauseContext:ParserRuleContext {
		open func TOP() -> TerminalNode? { return getToken(tsqlParser.Tokens.TOP.rawValue, 0) }
		open func top_percent() -> Top_percentContext? {
			return getRuleContext(Top_percentContext.self,0)
		}
		open func top_count() -> Top_countContext? {
			return getRuleContext(Top_countContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func TIES() -> TerminalNode? { return getToken(tsqlParser.Tokens.TIES.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_top_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTop_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTop_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTop_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTop_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func top_clause() throws -> Top_clauseContext {
		var _localctx: Top_clauseContext = Top_clauseContext(_ctx, getState())
		try enterRule(_localctx, 300, tsqlParser.RULE_top_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3391)
		 	try match(tsqlParser.Tokens.TOP.rawValue)
		 	setState(3394)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,492, _ctx)) {
		 	case 1:
		 		setState(3392)
		 		try top_percent()

		 		break
		 	case 2:
		 		setState(3393)
		 		try top_count()

		 		break
		 	default: break
		 	}
		 	setState(3398)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3396)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(3397)
		 		try match(tsqlParser.Tokens.TIES.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Top_percentContext:ParserRuleContext {
		open func PERCENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.PERCENT.rawValue, 0) }
		open func REAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.REAL.rawValue, 0) }
		open func FLOAT() -> TerminalNode? { return getToken(tsqlParser.Tokens.FLOAT.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_top_percent }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTop_percent(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTop_percent(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTop_percent(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTop_percent(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func top_percent() throws -> Top_percentContext {
		var _localctx: Top_percentContext = Top_percentContext(_ctx, getState())
		try enterRule(_localctx, 302, tsqlParser.RULE_top_percent)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3407)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FLOAT:fallthrough
		 	case .REAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3400)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.FLOAT.rawValue || _la == tsqlParser.Tokens.REAL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3401)
		 		try match(tsqlParser.Tokens.PERCENT.rawValue)

		 		break

		 	case .LR_BRACKET:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3402)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3403)
		 		try expression(0)
		 		setState(3404)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(3405)
		 		try match(tsqlParser.Tokens.PERCENT.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Top_countContext:ParserRuleContext {
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_top_count }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTop_count(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTop_count(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTop_count(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTop_count(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func top_count() throws -> Top_countContext {
		var _localctx: Top_countContext = Top_countContext(_ctx, getState())
		try enterRule(_localctx, 304, tsqlParser.RULE_top_count)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3414)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DECIMAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3409)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 		break

		 	case .LR_BRACKET:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3410)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3411)
		 		try expression(0)
		 		setState(3412)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Order_by_clauseContext:ParserRuleContext {
		open func ORDER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ORDER.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(tsqlParser.Tokens.BY.rawValue, 0) }
		open func order_by_expression() -> Array<Order_by_expressionContext> {
			return getRuleContexts(Order_by_expressionContext.self)
		}
		open func order_by_expression(_ i: Int) -> Order_by_expressionContext? {
			return getRuleContext(Order_by_expressionContext.self,i)
		}
		open func OFFSET() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFFSET.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func ROW() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ROW.rawValue) }
		open func ROW(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ROW.rawValue, i)
		}
		open func ROWS() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ROWS.rawValue) }
		open func ROWS(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ROWS.rawValue, i)
		}
		open func FETCH() -> TerminalNode? { return getToken(tsqlParser.Tokens.FETCH.rawValue, 0) }
		open func ONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.ONLY.rawValue, 0) }
		open func FIRST() -> TerminalNode? { return getToken(tsqlParser.Tokens.FIRST.rawValue, 0) }
		open func NEXT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NEXT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_order_by_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOrder_by_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOrder_by_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOrder_by_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOrder_by_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func order_by_clause() throws -> Order_by_clauseContext {
		var _localctx: Order_by_clauseContext = Order_by_clauseContext(_ctx, getState())
		try enterRule(_localctx, 306, tsqlParser.RULE_order_by_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3416)
		 	try match(tsqlParser.Tokens.ORDER.rawValue)
		 	setState(3417)
		 	try match(tsqlParser.Tokens.BY.rawValue)
		 	setState(3418)
		 	try order_by_expression()
		 	setState(3423)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,496,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3419)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(3420)
		 			try order_by_expression()

		 	 
		 		}
		 		setState(3425)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,496,_ctx)
		 	}
		 	setState(3437)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,498,_ctx)) {
		 	case 1:
		 		setState(3426)
		 		try match(tsqlParser.Tokens.OFFSET.rawValue)
		 		setState(3427)
		 		try expression(0)
		 		setState(3428)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ROW.rawValue || _la == tsqlParser.Tokens.ROWS.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3435)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,497,_ctx)) {
		 		case 1:
		 			setState(3429)
		 			try match(tsqlParser.Tokens.FETCH.rawValue)
		 			setState(3430)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.FIRST.rawValue || _la == tsqlParser.Tokens.NEXT.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(3431)
		 			try expression(0)
		 			setState(3432)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.ROW.rawValue || _la == tsqlParser.Tokens.ROWS.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(3433)
		 			try match(tsqlParser.Tokens.ONLY.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class For_clauseContext:ParserRuleContext {
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func BROWSE() -> TerminalNode? { return getToken(tsqlParser.Tokens.BROWSE.rawValue, 0) }
		open func XML() -> TerminalNode? { return getToken(tsqlParser.Tokens.XML.rawValue, 0) }
		open func xml_common_directives() -> Array<Xml_common_directivesContext> {
			return getRuleContexts(Xml_common_directivesContext.self)
		}
		open func xml_common_directives(_ i: Int) -> Xml_common_directivesContext? {
			return getRuleContext(Xml_common_directivesContext.self,i)
		}
		open func AUTO() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTO.rawValue, 0) }
		open func RAW() -> TerminalNode? { return getToken(tsqlParser.Tokens.RAW.rawValue, 0) }
		open func PATH() -> TerminalNode? { return getToken(tsqlParser.Tokens.PATH.rawValue, 0) }
		open func EXPLICIT() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXPLICIT.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_for_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFor_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFor_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFor_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFor_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func for_clause() throws -> For_clauseContext {
		var _localctx: For_clauseContext = For_clauseContext(_ctx, getState())
		try enterRule(_localctx, 308, tsqlParser.RULE_for_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(3463)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,503, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3439)
		 		try match(tsqlParser.Tokens.FOR.rawValue)
		 		setState(3440)
		 		try match(tsqlParser.Tokens.BROWSE.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3441)
		 		try match(tsqlParser.Tokens.FOR.rawValue)
		 		setState(3442)
		 		try match(tsqlParser.Tokens.XML.rawValue)
		 		setState(3444)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,499,_ctx)) {
		 		case 1:
		 			setState(3443)
		 			try xml_common_directives()

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3446)
		 		try match(tsqlParser.Tokens.FOR.rawValue)
		 		setState(3447)
		 		try match(tsqlParser.Tokens.XML.rawValue)
		 		setState(3448)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.RAW.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.AUTO.rawValue || _la == tsqlParser.Tokens.EXPLICIT.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.PATH.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3450)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,500,_ctx)) {
		 		case 1:
		 			setState(3449)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(3455)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,501,_ctx)) {
		 		case 1:
		 			setState(3452)
		 			try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(3453)
		 			try match(tsqlParser.Tokens.STRING.rawValue)
		 			setState(3454)
		 			try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(3460)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,502,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(3457)
		 				try xml_common_directives()

		 		 
		 			}
		 			setState(3462)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,502,_ctx)
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_common_directivesContext:ParserRuleContext {
		open func BINARY_BASE64() -> TerminalNode? { return getToken(tsqlParser.Tokens.BINARY_BASE64.rawValue, 0) }
		open func TYPE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TYPE.rawValue, 0) }
		open func ROOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROOT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_xml_common_directives }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterXml_common_directives(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitXml_common_directives(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitXml_common_directives(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitXml_common_directives(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_common_directives() throws -> Xml_common_directivesContext {
		var _localctx: Xml_common_directivesContext = Xml_common_directivesContext(_ctx, getState())
		try enterRule(_localctx, 310, tsqlParser.RULE_xml_common_directives)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3465)
		 	try match(tsqlParser.Tokens.COMMA.rawValue)
		 	setState(3466)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.BINARY_BASE64.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.ROOT.rawValue || _la == tsqlParser.Tokens.TYPE.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Order_by_expressionContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func ASC() -> TerminalNode? { return getToken(tsqlParser.Tokens.ASC.rawValue, 0) }
		open func DESC() -> TerminalNode? { return getToken(tsqlParser.Tokens.DESC.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_order_by_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOrder_by_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOrder_by_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOrder_by_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOrder_by_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func order_by_expression() throws -> Order_by_expressionContext {
		var _localctx: Order_by_expressionContext = Order_by_expressionContext(_ctx, getState())
		try enterRule(_localctx, 312, tsqlParser.RULE_order_by_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3468)
		 	try expression(0)
		 	setState(3470)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ASC.rawValue || _la == tsqlParser.Tokens.DESC.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3469)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ASC.rawValue || _la == tsqlParser.Tokens.DESC.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Group_by_itemContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_group_by_item }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterGroup_by_item(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitGroup_by_item(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitGroup_by_item(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitGroup_by_item(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func group_by_item() throws -> Group_by_itemContext {
		var _localctx: Group_by_itemContext = Group_by_itemContext(_ctx, getState())
		try enterRule(_localctx, 314, tsqlParser.RULE_group_by_item)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3472)
		 	try expression(0)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Option_clauseContext:ParserRuleContext {
		open func OPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPTION.rawValue, 0) }
		open func option() -> Array<OptionContext> {
			return getRuleContexts(OptionContext.self)
		}
		open func option(_ i: Int) -> OptionContext? {
			return getRuleContext(OptionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_option_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOption_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOption_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOption_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOption_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func option_clause() throws -> Option_clauseContext {
		var _localctx: Option_clauseContext = Option_clauseContext(_ctx, getState())
		try enterRule(_localctx, 316, tsqlParser.RULE_option_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3474)
		 	try match(tsqlParser.Tokens.OPTION.rawValue)
		 	setState(3475)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(3476)
		 	try option()
		 	setState(3481)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3477)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3478)
		 		try option()


		 		setState(3483)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3484)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class OptionContext:ParserRuleContext {
		public var number_rows: Token!
		public var number_of_processors: Token!
		public var number_recursion: Token!
		open func FAST() -> TerminalNode? { return getToken(tsqlParser.Tokens.FAST.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func GROUP() -> TerminalNode? { return getToken(tsqlParser.Tokens.GROUP.rawValue, 0) }
		open func HASH() -> TerminalNode? { return getToken(tsqlParser.Tokens.HASH.rawValue, 0) }
		open func ORDER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ORDER.rawValue, 0) }
		open func UNION() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNION.rawValue, 0) }
		open func MERGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.MERGE.rawValue, 0) }
		open func CONCAT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONCAT.rawValue, 0) }
		open func JOIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.JOIN.rawValue, 0) }
		open func LOOP() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOOP.rawValue, 0) }
		open func EXPAND() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXPAND.rawValue, 0) }
		open func VIEWS() -> TerminalNode? { return getToken(tsqlParser.Tokens.VIEWS.rawValue, 0) }
		open func FORCE() -> TerminalNode? { return getToken(tsqlParser.Tokens.FORCE.rawValue, 0) }
		open func IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX() -> TerminalNode? { return getToken(tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue, 0) }
		open func KEEP() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEEP.rawValue, 0) }
		open func PLAN() -> TerminalNode? { return getToken(tsqlParser.Tokens.PLAN.rawValue, 0) }
		open func KEEPFIXED() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEEPFIXED.rawValue, 0) }
		open func MAXDOP() -> TerminalNode? { return getToken(tsqlParser.Tokens.MAXDOP.rawValue, 0) }
		open func MAXRECURSION() -> TerminalNode? { return getToken(tsqlParser.Tokens.MAXRECURSION.rawValue, 0) }
		open func OPTIMIZE() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPTIMIZE.rawValue, 0) }
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func optimize_for_arg() -> Array<Optimize_for_argContext> {
			return getRuleContexts(Optimize_for_argContext.self)
		}
		open func optimize_for_arg(_ i: Int) -> Optimize_for_argContext? {
			return getRuleContext(Optimize_for_argContext.self,i)
		}
		open func UNKNOWN() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNKNOWN.rawValue, 0) }
		open func PARAMETERIZATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.PARAMETERIZATION.rawValue, 0) }
		open func SIMPLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SIMPLE.rawValue, 0) }
		open func FORCED() -> TerminalNode? { return getToken(tsqlParser.Tokens.FORCED.rawValue, 0) }
		open func RECOMPILE() -> TerminalNode? { return getToken(tsqlParser.Tokens.RECOMPILE.rawValue, 0) }
		open func ROBUST() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROBUST.rawValue, 0) }
		open func USE() -> TerminalNode? { return getToken(tsqlParser.Tokens.USE.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOption(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOption(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOption(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOption(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func option() throws -> OptionContext {
		var _localctx: OptionContext = OptionContext(_ctx, getState())
		try enterRule(_localctx, 318, tsqlParser.RULE_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3531)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,507, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3486)
		 		try match(tsqlParser.Tokens.FAST.rawValue)
		 		setState(3487)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 				_localctx.castdown(OptionContext.self).number_rows = assignmentValue
		 		     }()


		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3488)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.ORDER.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.HASH.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3489)
		 		try match(tsqlParser.Tokens.GROUP.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3490)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.MERGE.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.CONCAT.rawValue || _la == tsqlParser.Tokens.HASH.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3491)
		 		try match(tsqlParser.Tokens.UNION.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3492)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.MERGE.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.HASH.rawValue || _la == tsqlParser.Tokens.LOOP.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3493)
		 		try match(tsqlParser.Tokens.JOIN.rawValue)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3494)
		 		try match(tsqlParser.Tokens.EXPAND.rawValue)
		 		setState(3495)
		 		try match(tsqlParser.Tokens.VIEWS.rawValue)

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3496)
		 		try match(tsqlParser.Tokens.FORCE.rawValue)
		 		setState(3497)
		 		try match(tsqlParser.Tokens.ORDER.rawValue)

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(3498)
		 		try match(tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue)

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(3499)
		 		try match(tsqlParser.Tokens.KEEP.rawValue)
		 		setState(3500)
		 		try match(tsqlParser.Tokens.PLAN.rawValue)

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(3501)
		 		try match(tsqlParser.Tokens.KEEPFIXED.rawValue)
		 		setState(3502)
		 		try match(tsqlParser.Tokens.PLAN.rawValue)

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(3503)
		 		try match(tsqlParser.Tokens.MAXDOP.rawValue)
		 		setState(3504)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 				_localctx.castdown(OptionContext.self).number_of_processors = assignmentValue
		 		     }()


		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(3505)
		 		try match(tsqlParser.Tokens.MAXRECURSION.rawValue)
		 		setState(3506)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 				_localctx.castdown(OptionContext.self).number_recursion = assignmentValue
		 		     }()


		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(3507)
		 		try match(tsqlParser.Tokens.OPTIMIZE.rawValue)
		 		setState(3508)
		 		try match(tsqlParser.Tokens.FOR.rawValue)
		 		setState(3509)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3510)
		 		try optimize_for_arg()
		 		setState(3515)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3511)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(3512)
		 			try optimize_for_arg()


		 			setState(3517)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3518)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(3520)
		 		try match(tsqlParser.Tokens.OPTIMIZE.rawValue)
		 		setState(3521)
		 		try match(tsqlParser.Tokens.FOR.rawValue)
		 		setState(3522)
		 		try match(tsqlParser.Tokens.UNKNOWN.rawValue)

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(3523)
		 		try match(tsqlParser.Tokens.PARAMETERIZATION.rawValue)
		 		setState(3524)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.FORCED.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.SIMPLE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(3525)
		 		try match(tsqlParser.Tokens.RECOMPILE.rawValue)

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(3526)
		 		try match(tsqlParser.Tokens.ROBUST.rawValue)
		 		setState(3527)
		 		try match(tsqlParser.Tokens.PLAN.rawValue)

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(3528)
		 		try match(tsqlParser.Tokens.USE.rawValue)
		 		setState(3529)
		 		try match(tsqlParser.Tokens.PLAN.rawValue)
		 		setState(3530)
		 		try match(tsqlParser.Tokens.STRING.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Optimize_for_argContext:ParserRuleContext {
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func UNKNOWN() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNKNOWN.rawValue, 0) }
		open func constant() -> ConstantContext? {
			return getRuleContext(ConstantContext.self,0)
		}
		open func NULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.NULL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_optimize_for_arg }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOptimize_for_arg(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOptimize_for_arg(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOptimize_for_arg(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOptimize_for_arg(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func optimize_for_arg() throws -> Optimize_for_argContext {
		var _localctx: Optimize_for_argContext = Optimize_for_argContext(_ctx, getState())
		try enterRule(_localctx, 320, tsqlParser.RULE_optimize_for_arg)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3533)
		 	try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 	setState(3540)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .UNKNOWN:
		 		setState(3534)
		 		try match(tsqlParser.Tokens.UNKNOWN.rawValue)

		 		break

		 	case .EQUAL:
		 		setState(3535)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(3538)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .DECIMAL:fallthrough
		 		case .STRING:fallthrough
		 		case .BINARY:fallthrough
		 		case .FLOAT:fallthrough
		 		case .REAL:fallthrough
		 		case .DOLLAR:fallthrough
		 		case .PLUS:fallthrough
		 		case .MINUS:
		 			setState(3536)
		 			try constant()

		 			break

		 		case .NULL:
		 			setState(3537)
		 			try match(tsqlParser.Tokens.NULL.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Select_listContext:ParserRuleContext {
		open func select_list_elem() -> Array<Select_list_elemContext> {
			return getRuleContexts(Select_list_elemContext.self)
		}
		open func select_list_elem(_ i: Int) -> Select_list_elemContext? {
			return getRuleContext(Select_list_elemContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_select_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSelect_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSelect_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSelect_list(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSelect_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func select_list() throws -> Select_listContext {
		var _localctx: Select_listContext = Select_listContext(_ctx, getState())
		try enterRule(_localctx, 322, tsqlParser.RULE_select_list)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3542)
		 	try select_list_elem()
		 	setState(3547)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,510,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3543)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(3544)
		 			try select_list_elem()

		 	 
		 		}
		 		setState(3549)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,510,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Select_list_elemContext:ParserRuleContext {
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func IDENTITY() -> TerminalNode? { return getToken(tsqlParser.Tokens.IDENTITY.rawValue, 0) }
		open func ROWGUID() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROWGUID.rawValue, 0) }
		open func column_alias() -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_select_list_elem }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSelect_list_elem(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSelect_list_elem(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSelect_list_elem(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSelect_list_elem(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func select_list_elem() throws -> Select_list_elemContext {
		var _localctx: Select_list_elemContext = Select_list_elemContext(_ctx, getState())
		try enterRule(_localctx, 324, tsqlParser.RULE_select_list_elem)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3571)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,515, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3553)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 34)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue,tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.TARGET.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 142)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ABSOLUTE.rawValue,tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 232)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue,tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 296)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue,tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 360)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue,tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 426)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 493)
		 		          }()
		 		      return testSet
		 		 }()) {
		 			setState(3550)
		 			try table_name()
		 			setState(3551)
		 			try match(tsqlParser.Tokens.DOT.rawValue)

		 		}

		 		setState(3558)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .STAR:
		 			setState(3555)
		 			try match(tsqlParser.Tokens.STAR.rawValue)

		 			break

		 		case .DOLLAR:
		 			setState(3556)
		 			try match(tsqlParser.Tokens.DOLLAR.rawValue)
		 			setState(3557)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == tsqlParser.Tokens.IDENTITY.rawValue
		 			          testSet = testSet || _la == tsqlParser.Tokens.ROWGUID.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3560)
		 		try column_alias()
		 		setState(3561)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(3562)
		 		try expression(0)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3564)
		 		try expression(0)
		 		setState(3569)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,514,_ctx)) {
		 		case 1:
		 			setState(3566)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(3565)
		 				try match(tsqlParser.Tokens.AS.rawValue)

		 			}

		 			setState(3568)
		 			try column_alias()

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_sourcesContext:ParserRuleContext {
		open func table_source() -> Array<Table_sourceContext> {
			return getRuleContexts(Table_sourceContext.self)
		}
		open func table_source(_ i: Int) -> Table_sourceContext? {
			return getRuleContext(Table_sourceContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_sources }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_sources(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_sources(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_sources(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_sources(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_sources() throws -> Table_sourcesContext {
		var _localctx: Table_sourcesContext = Table_sourcesContext(_ctx, getState())
		try enterRule(_localctx, 326, tsqlParser.RULE_table_sources)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3573)
		 	try table_source()
		 	setState(3578)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,516,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3574)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(3575)
		 			try table_source()

		 	 
		 		}
		 		setState(3580)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,516,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_sourceContext:ParserRuleContext {
		open func table_source_item_joined() -> Table_source_item_joinedContext? {
			return getRuleContext(Table_source_item_joinedContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_source }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_source(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_source(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_source(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_source(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_source() throws -> Table_sourceContext {
		var _localctx: Table_sourceContext = Table_sourceContext(_ctx, getState())
		try enterRule(_localctx, 328, tsqlParser.RULE_table_source)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3586)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,517, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3581)
		 		try table_source_item_joined()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3582)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3583)
		 		try table_source_item_joined()
		 		setState(3584)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_source_item_joinedContext:ParserRuleContext {
		open func table_source_item() -> Table_source_itemContext? {
			return getRuleContext(Table_source_itemContext.self,0)
		}
		open func join_part() -> Array<Join_partContext> {
			return getRuleContexts(Join_partContext.self)
		}
		open func join_part(_ i: Int) -> Join_partContext? {
			return getRuleContext(Join_partContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_source_item_joined }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_source_item_joined(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_source_item_joined(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_source_item_joined(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_source_item_joined(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_source_item_joined() throws -> Table_source_item_joinedContext {
		var _localctx: Table_source_item_joinedContext = Table_source_item_joinedContext(_ctx, getState())
		try enterRule(_localctx, 330, tsqlParser.RULE_table_source_item_joined)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3588)
		 	try table_source_item()
		 	setState(3592)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,518,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3589)
		 			try join_part()

		 	 
		 		}
		 		setState(3594)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,518,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_source_itemContext:ParserRuleContext {
		open func table_name_with_hint() -> Table_name_with_hintContext? {
			return getRuleContext(Table_name_with_hintContext.self,0)
		}
		open func as_table_alias() -> As_table_aliasContext? {
			return getRuleContext(As_table_aliasContext.self,0)
		}
		open func full_table_name() -> Full_table_nameContext? {
			return getRuleContext(Full_table_nameContext.self,0)
		}
		open func rowset_function() -> Rowset_functionContext? {
			return getRuleContext(Rowset_functionContext.self,0)
		}
		open func derived_table() -> Derived_tableContext? {
			return getRuleContext(Derived_tableContext.self,0)
		}
		open func column_alias_list() -> Column_alias_listContext? {
			return getRuleContext(Column_alias_listContext.self,0)
		}
		open func change_table() -> Change_tableContext? {
			return getRuleContext(Change_tableContext.self,0)
		}
		open func function_call() -> Function_callContext? {
			return getRuleContext(Function_callContext.self,0)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func open_xml() -> Open_xmlContext? {
			return getRuleContext(Open_xmlContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_source_item }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_source_item(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_source_item(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_source_item(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_source_item(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_source_item() throws -> Table_source_itemContext {
		var _localctx: Table_source_itemContext = Table_source_itemContext(_ctx, getState())
		try enterRule(_localctx, 332, tsqlParser.RULE_table_source_item)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3641)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,529, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3595)
		 		try table_name_with_hint()
		 		setState(3597)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,519,_ctx)) {
		 		case 1:
		 			setState(3596)
		 			try as_table_alias()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3599)
		 		try full_table_name()
		 		setState(3601)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,520,_ctx)) {
		 		case 1:
		 			setState(3600)
		 			try as_table_alias()

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3603)
		 		try rowset_function()
		 		setState(3605)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,521,_ctx)) {
		 		case 1:
		 			setState(3604)
		 			try as_table_alias()

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3607)
		 		try derived_table()
		 		setState(3612)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,523,_ctx)) {
		 		case 1:
		 			setState(3608)
		 			try as_table_alias()
		 			setState(3610)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,522,_ctx)) {
		 			case 1:
		 				setState(3609)
		 				try column_alias_list()

		 				break
		 			default: break
		 			}

		 			break
		 		default: break
		 		}

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3614)
		 		try change_table()
		 		setState(3615)
		 		try as_table_alias()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3617)
		 		try function_call()
		 		setState(3619)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,524,_ctx)) {
		 		case 1:
		 			setState(3618)
		 			try as_table_alias()

		 			break
		 		default: break
		 		}

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(3621)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 		setState(3623)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,525,_ctx)) {
		 		case 1:
		 			setState(3622)
		 			try as_table_alias()

		 			break
		 		default: break
		 		}

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(3625)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 		setState(3626)
		 		try match(tsqlParser.Tokens.DOT.rawValue)
		 		setState(3627)
		 		try function_call()
		 		setState(3632)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,527,_ctx)) {
		 		case 1:
		 			setState(3628)
		 			try as_table_alias()
		 			setState(3630)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,526,_ctx)) {
		 			case 1:
		 				setState(3629)
		 				try column_alias_list()

		 				break
		 			default: break
		 			}

		 			break
		 		default: break
		 		}

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(3634)
		 		try open_xml()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(3635)
		 		try match(tsqlParser.Tokens.COLON.rawValue)
		 		setState(3636)
		 		try match(tsqlParser.Tokens.COLON.rawValue)
		 		setState(3637)
		 		try function_call()
		 		setState(3639)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,528,_ctx)) {
		 		case 1:
		 			setState(3638)
		 			try as_table_alias()

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Open_xmlContext:ParserRuleContext {
		open func OPENXML() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPENXML.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func schema_declaration() -> Schema_declarationContext? {
			return getRuleContext(Schema_declarationContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_open_xml }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOpen_xml(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOpen_xml(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOpen_xml(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOpen_xml(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func open_xml() throws -> Open_xmlContext {
		var _localctx: Open_xmlContext = Open_xmlContext(_ctx, getState())
		try enterRule(_localctx, 334, tsqlParser.RULE_open_xml)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3643)
		 	try match(tsqlParser.Tokens.OPENXML.rawValue)
		 	setState(3644)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(3645)
		 	try expression(0)
		 	setState(3646)
		 	try match(tsqlParser.Tokens.COMMA.rawValue)
		 	setState(3647)
		 	try expression(0)
		 	setState(3650)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3648)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3649)
		 		try expression(0)

		 	}

		 	setState(3652)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(3658)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,531,_ctx)) {
		 	case 1:
		 		setState(3653)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(3654)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3655)
		 		try schema_declaration()
		 		setState(3656)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Schema_declarationContext:ParserRuleContext {
		open func column_declaration() -> Array<Column_declarationContext> {
			return getRuleContexts(Column_declarationContext.self)
		}
		open func column_declaration(_ i: Int) -> Column_declarationContext? {
			return getRuleContext(Column_declarationContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_schema_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSchema_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSchema_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSchema_declaration(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSchema_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func schema_declaration() throws -> Schema_declarationContext {
		var _localctx: Schema_declarationContext = Schema_declarationContext(_ctx, getState())
		try enterRule(_localctx, 336, tsqlParser.RULE_schema_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3660)
		 	try column_declaration()
		 	setState(3665)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3661)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3662)
		 		try column_declaration()


		 		setState(3667)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_declarationContext:ParserRuleContext {
		open func ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.ID.rawValue, 0) }
		open func data_type() -> Data_typeContext? {
			return getRuleContext(Data_typeContext.self,0)
		}
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_column_declaration }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterColumn_declaration(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitColumn_declaration(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitColumn_declaration(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitColumn_declaration(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_declaration() throws -> Column_declarationContext {
		var _localctx: Column_declarationContext = Column_declarationContext(_ctx, getState())
		try enterRule(_localctx, 338, tsqlParser.RULE_column_declaration)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3668)
		 	try match(tsqlParser.Tokens.ID.rawValue)
		 	setState(3669)
		 	try data_type()
		 	setState(3671)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.STRING.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3670)
		 		try match(tsqlParser.Tokens.STRING.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Change_tableContext:ParserRuleContext {
		open func CHANGETABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHANGETABLE.rawValue, 0) }
		open func CHANGES() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHANGES.rawValue, 0) }
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func NULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.NULL.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_change_table }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterChange_table(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitChange_table(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitChange_table(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitChange_table(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func change_table() throws -> Change_tableContext {
		var _localctx: Change_tableContext = Change_tableContext(_ctx, getState())
		try enterRule(_localctx, 340, tsqlParser.RULE_change_table)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3673)
		 	try match(tsqlParser.Tokens.CHANGETABLE.rawValue)
		 	setState(3674)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(3675)
		 	try match(tsqlParser.Tokens.CHANGES.rawValue)
		 	setState(3676)
		 	try table_name()
		 	setState(3677)
		 	try match(tsqlParser.Tokens.COMMA.rawValue)
		 	setState(3678)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.NULL.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.DECIMAL.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3679)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Join_partContext:ParserRuleContext {
		public var join_type: Token!
		public var join_hint: Token!
		open func JOIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.JOIN.rawValue, 0) }
		open func table_source() -> Table_sourceContext? {
			return getRuleContext(Table_sourceContext.self,0)
		}
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func search_condition() -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,0)
		}
		open func LEFT() -> TerminalNode? { return getToken(tsqlParser.Tokens.LEFT.rawValue, 0) }
		open func RIGHT() -> TerminalNode? { return getToken(tsqlParser.Tokens.RIGHT.rawValue, 0) }
		open func FULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.FULL.rawValue, 0) }
		open func INNER() -> TerminalNode? { return getToken(tsqlParser.Tokens.INNER.rawValue, 0) }
		open func OUTER() -> TerminalNode? { return getToken(tsqlParser.Tokens.OUTER.rawValue, 0) }
		open func LOOP() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOOP.rawValue, 0) }
		open func HASH() -> TerminalNode? { return getToken(tsqlParser.Tokens.HASH.rawValue, 0) }
		open func MERGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.MERGE.rawValue, 0) }
		open func REMOTE() -> TerminalNode? { return getToken(tsqlParser.Tokens.REMOTE.rawValue, 0) }
		open func CROSS() -> TerminalNode? { return getToken(tsqlParser.Tokens.CROSS.rawValue, 0) }
		open func APPLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.APPLY.rawValue, 0) }
		open func PIVOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.PIVOT.rawValue, 0) }
		open func pivot_clause() -> Pivot_clauseContext? {
			return getRuleContext(Pivot_clauseContext.self,0)
		}
		open func as_table_alias() -> As_table_aliasContext? {
			return getRuleContext(As_table_aliasContext.self,0)
		}
		open func UNPIVOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNPIVOT.rawValue, 0) }
		open func unpivot_clause() -> Unpivot_clauseContext? {
			return getRuleContext(Unpivot_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_join_part }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterJoin_part(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitJoin_part(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitJoin_part(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitJoin_part(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func join_part() throws -> Join_partContext {
		var _localctx: Join_partContext = Join_partContext(_ctx, getState())
		try enterRule(_localctx, 342, tsqlParser.RULE_join_part)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3715)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,538, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3688)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .INNER:fallthrough
		 		case .JOIN:fallthrough
		 		case .MERGE:fallthrough
		 		case .HASH:fallthrough
		 		case .LOOP:fallthrough
		 		case .REMOTE:
		 			setState(3682)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.INNER.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(3681)
		 				try match(tsqlParser.Tokens.INNER.rawValue)

		 			}


		 			break
		 		case .FULL:fallthrough
		 		case .LEFT:fallthrough
		 		case .RIGHT:
		 			setState(3684)
		 			_localctx.castdown(Join_partContext.self).join_type = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == tsqlParser.Tokens.FULL.rawValue || _la == tsqlParser.Tokens.LEFT.rawValue
		 			          testSet = testSet || _la == tsqlParser.Tokens.RIGHT.rawValue
		 			      return testSet
		 			 }())) {
		 				_localctx.castdown(Join_partContext.self).join_type = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(3686)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.OUTER.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(3685)
		 				try match(tsqlParser.Tokens.OUTER.rawValue)

		 			}


		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3691)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.MERGE.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.HASH.rawValue || _la == tsqlParser.Tokens.LOOP.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.REMOTE.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3690)
		 			_localctx.castdown(Join_partContext.self).join_hint = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      var testSet: Bool = _la == tsqlParser.Tokens.MERGE.rawValue
		 			          testSet = testSet || _la == tsqlParser.Tokens.HASH.rawValue || _la == tsqlParser.Tokens.LOOP.rawValue
		 			          testSet = testSet || _la == tsqlParser.Tokens.REMOTE.rawValue
		 			      return testSet
		 			 }())) {
		 				_localctx.castdown(Join_partContext.self).join_hint = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(3693)
		 		try match(tsqlParser.Tokens.JOIN.rawValue)
		 		setState(3694)
		 		try table_source()
		 		setState(3695)
		 		try match(tsqlParser.Tokens.ON.rawValue)
		 		setState(3696)
		 		try search_condition()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3698)
		 		try match(tsqlParser.Tokens.CROSS.rawValue)
		 		setState(3699)
		 		try match(tsqlParser.Tokens.JOIN.rawValue)
		 		setState(3700)
		 		try table_source()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3701)
		 		try match(tsqlParser.Tokens.CROSS.rawValue)
		 		setState(3702)
		 		try match(tsqlParser.Tokens.APPLY.rawValue)
		 		setState(3703)
		 		try table_source()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3704)
		 		try match(tsqlParser.Tokens.OUTER.rawValue)
		 		setState(3705)
		 		try match(tsqlParser.Tokens.APPLY.rawValue)
		 		setState(3706)
		 		try table_source()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3707)
		 		try match(tsqlParser.Tokens.PIVOT.rawValue)
		 		setState(3708)
		 		try pivot_clause()
		 		setState(3709)
		 		try as_table_alias()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3711)
		 		try match(tsqlParser.Tokens.UNPIVOT.rawValue)
		 		setState(3712)
		 		try unpivot_clause()
		 		setState(3713)
		 		try as_table_alias()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Pivot_clauseContext:ParserRuleContext {
		open func aggregate_windowed_function() -> Aggregate_windowed_functionContext? {
			return getRuleContext(Aggregate_windowed_functionContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func full_column_name() -> Full_column_nameContext? {
			return getRuleContext(Full_column_nameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(tsqlParser.Tokens.IN.rawValue, 0) }
		open func column_alias_list() -> Column_alias_listContext? {
			return getRuleContext(Column_alias_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_pivot_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterPivot_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitPivot_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitPivot_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitPivot_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func pivot_clause() throws -> Pivot_clauseContext {
		var _localctx: Pivot_clauseContext = Pivot_clauseContext(_ctx, getState())
		try enterRule(_localctx, 344, tsqlParser.RULE_pivot_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3717)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(3718)
		 	try aggregate_windowed_function()
		 	setState(3719)
		 	try match(tsqlParser.Tokens.FOR.rawValue)
		 	setState(3720)
		 	try full_column_name()
		 	setState(3721)
		 	try match(tsqlParser.Tokens.IN.rawValue)
		 	setState(3722)
		 	try column_alias_list()
		 	setState(3723)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Unpivot_clauseContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func FOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOR.rawValue, 0) }
		open func full_column_name() -> Full_column_nameContext? {
			return getRuleContext(Full_column_nameContext.self,0)
		}
		open func IN() -> TerminalNode? { return getToken(tsqlParser.Tokens.IN.rawValue, 0) }
		open func full_column_name_list() -> Full_column_name_listContext? {
			return getRuleContext(Full_column_name_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_unpivot_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterUnpivot_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitUnpivot_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitUnpivot_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitUnpivot_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func unpivot_clause() throws -> Unpivot_clauseContext {
		var _localctx: Unpivot_clauseContext = Unpivot_clauseContext(_ctx, getState())
		try enterRule(_localctx, 346, tsqlParser.RULE_unpivot_clause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3725)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(3726)
		 	try expression(0)
		 	setState(3727)
		 	try match(tsqlParser.Tokens.FOR.rawValue)
		 	setState(3728)
		 	try full_column_name()
		 	setState(3729)
		 	try match(tsqlParser.Tokens.IN.rawValue)
		 	setState(3730)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(3731)
		 	try full_column_name_list()
		 	setState(3732)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(3733)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Full_column_name_listContext:ParserRuleContext {
		open func full_column_name() -> Array<Full_column_nameContext> {
			return getRuleContexts(Full_column_nameContext.self)
		}
		open func full_column_name(_ i: Int) -> Full_column_nameContext? {
			return getRuleContext(Full_column_nameContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_full_column_name_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFull_column_name_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFull_column_name_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFull_column_name_list(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFull_column_name_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func full_column_name_list() throws -> Full_column_name_listContext {
		var _localctx: Full_column_name_listContext = Full_column_name_listContext(_ctx, getState())
		try enterRule(_localctx, 348, tsqlParser.RULE_full_column_name_list)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3735)
		 	try full_column_name()
		 	setState(3740)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3736)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3737)
		 		try full_column_name()


		 		setState(3742)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_name_with_hintContext:ParserRuleContext {
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open func with_table_hints() -> With_table_hintsContext? {
			return getRuleContext(With_table_hintsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_name_with_hint }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_name_with_hint(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_name_with_hint(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_name_with_hint(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_name_with_hint(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_name_with_hint() throws -> Table_name_with_hintContext {
		var _localctx: Table_name_with_hintContext = Table_name_with_hintContext(_ctx, getState())
		try enterRule(_localctx, 350, tsqlParser.RULE_table_name_with_hint)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3743)
		 	try table_name()
		 	setState(3745)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,540,_ctx)) {
		 	case 1:
		 		setState(3744)
		 		try with_table_hints()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Rowset_functionContext:ParserRuleContext {
		public var provider_name: Token!
		public var connectionString: Token!
		public var sql: Token!
		public var data_file: Token!
		open func OPENROWSET() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPENROWSET.rawValue, 0) }
		open func LR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.LR_BRACKET.rawValue, 0) }
		open func COMMA() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.COMMA.rawValue) }
		open func COMMA(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.COMMA.rawValue, i)
		}
		open func RR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.RR_BRACKET.rawValue, 0) }
		open func STRING() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.STRING.rawValue) }
		open func STRING(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.STRING.rawValue, i)
		}
		open func BULK() -> TerminalNode? { return getToken(tsqlParser.Tokens.BULK.rawValue, 0) }
		open func bulk_option() -> Array<Bulk_optionContext> {
			return getRuleContexts(Bulk_optionContext.self)
		}
		open func bulk_option(_ i: Int) -> Bulk_optionContext? {
			return getRuleContext(Bulk_optionContext.self,i)
		}
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_rowset_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterRowset_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitRowset_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitRowset_function(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitRowset_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func rowset_function() throws -> Rowset_functionContext {
		var _localctx: Rowset_functionContext = Rowset_functionContext(_ctx, getState())
		try enterRule(_localctx, 352, tsqlParser.RULE_rowset_function)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3773)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,543, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3747)
		 		try match(tsqlParser.Tokens.OPENROWSET.rawValue)
		 		setState(3748)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3749)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Rowset_functionContext.self).provider_name = assignmentValue
		 		     }()

		 		setState(3750)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3751)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Rowset_functionContext.self).connectionString = assignmentValue
		 		     }()

		 		setState(3752)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3753)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Rowset_functionContext.self).sql = assignmentValue
		 		     }()

		 		setState(3754)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)


		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3755)
		 		try match(tsqlParser.Tokens.OPENROWSET.rawValue)
		 		setState(3756)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3757)
		 		try match(tsqlParser.Tokens.BULK.rawValue)
		 		setState(3758)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Rowset_functionContext.self).data_file = assignmentValue
		 		     }()

		 		setState(3759)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3769)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,542, _ctx)) {
		 		case 1:
		 			setState(3760)
		 			try bulk_option()
		 			setState(3765)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(3761)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)
		 				setState(3762)
		 				try bulk_option()


		 				setState(3767)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}

		 			break
		 		case 2:
		 			setState(3768)
		 			try id()

		 			break
		 		default: break
		 		}
		 		setState(3771)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)


		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Bulk_optionContext:ParserRuleContext {
		public var bulk_option_value: Token!
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_bulk_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterBulk_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitBulk_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitBulk_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitBulk_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func bulk_option() throws -> Bulk_optionContext {
		var _localctx: Bulk_optionContext = Bulk_optionContext(_ctx, getState())
		try enterRule(_localctx, 354, tsqlParser.RULE_bulk_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3775)
		 	try id()
		 	setState(3776)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(3777)
		 	_localctx.castdown(Bulk_optionContext.self).bulk_option_value = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.DECIMAL.rawValue || _la == tsqlParser.Tokens.STRING.rawValue
		 	      return testSet
		 	 }())) {
		 		_localctx.castdown(Bulk_optionContext.self).bulk_option_value = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Derived_tableContext:ParserRuleContext {
		open func subquery() -> SubqueryContext? {
			return getRuleContext(SubqueryContext.self,0)
		}
		open func table_value_constructor() -> Table_value_constructorContext? {
			return getRuleContext(Table_value_constructorContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_derived_table }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDerived_table(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDerived_table(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDerived_table(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDerived_table(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func derived_table() throws -> Derived_tableContext {
		var _localctx: Derived_tableContext = Derived_tableContext(_ctx, getState())
		try enterRule(_localctx, 356, tsqlParser.RULE_derived_table)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3789)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,544, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3779)
		 		try subquery()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3780)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3781)
		 		try subquery()
		 		setState(3782)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3784)
		 		try table_value_constructor()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3785)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3786)
		 		try table_value_constructor()
		 		setState(3787)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Function_callContext:ParserRuleContext {
		public var style: ExpressionContext!
		public var seed: Token!
		public var increment: Token!
		open func ranking_windowed_function() -> Ranking_windowed_functionContext? {
			return getRuleContext(Ranking_windowed_functionContext.self,0)
		}
		open func aggregate_windowed_function() -> Aggregate_windowed_functionContext? {
			return getRuleContext(Aggregate_windowed_functionContext.self,0)
		}
		open func scalar_function_name() -> Scalar_function_nameContext? {
			return getRuleContext(Scalar_function_nameContext.self,0)
		}
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func BINARY_CHECKSUM() -> TerminalNode? { return getToken(tsqlParser.Tokens.BINARY_CHECKSUM.rawValue, 0) }
		open func CAST() -> TerminalNode? { return getToken(tsqlParser.Tokens.CAST.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open func data_type() -> Data_typeContext? {
			return getRuleContext(Data_typeContext.self,0)
		}
		open func CONVERT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONVERT.rawValue, 0) }
		open func CHECKSUM() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHECKSUM.rawValue, 0) }
		open func COALESCE() -> TerminalNode? { return getToken(tsqlParser.Tokens.COALESCE.rawValue, 0) }
		open func CURRENT_TIMESTAMP() -> TerminalNode? { return getToken(tsqlParser.Tokens.CURRENT_TIMESTAMP.rawValue, 0) }
		open func CURRENT_USER() -> TerminalNode? { return getToken(tsqlParser.Tokens.CURRENT_USER.rawValue, 0) }
		open func DATEADD() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATEADD.rawValue, 0) }
		open func ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.ID.rawValue, 0) }
		open func DATEDIFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATEDIFF.rawValue, 0) }
		open func DATENAME() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATENAME.rawValue, 0) }
		open func DATEPART() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATEPART.rawValue, 0) }
		open func GETDATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.GETDATE.rawValue, 0) }
		open func GETUTCDATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.GETUTCDATE.rawValue, 0) }
		open func IDENTITY() -> TerminalNode? { return getToken(tsqlParser.Tokens.IDENTITY.rawValue, 0) }
		open func DECIMAL() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.DECIMAL.rawValue) }
		open func DECIMAL(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.DECIMAL.rawValue, i)
		}
		open func MIN_ACTIVE_ROWVERSION() -> TerminalNode? { return getToken(tsqlParser.Tokens.MIN_ACTIVE_ROWVERSION.rawValue, 0) }
		open func NULLIF() -> TerminalNode? { return getToken(tsqlParser.Tokens.NULLIF.rawValue, 0) }
		open func STUFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.STUFF.rawValue, 0) }
		open func SESSION_USER() -> TerminalNode? { return getToken(tsqlParser.Tokens.SESSION_USER.rawValue, 0) }
		open func SYSTEM_USER() -> TerminalNode? { return getToken(tsqlParser.Tokens.SYSTEM_USER.rawValue, 0) }
		open func ISNULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.ISNULL.rawValue, 0) }
		open func xml_data_type_methods() -> Xml_data_type_methodsContext? {
			return getRuleContext(Xml_data_type_methodsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_function_call }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFunction_call(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFunction_call(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFunction_call(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFunction_call(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func function_call() throws -> Function_callContext {
		var _localctx: Function_callContext = Function_callContext(_ctx, getState())
		try enterRule(_localctx, 358, tsqlParser.RULE_function_call)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3913)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,549, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3791)
		 		try ranking_windowed_function()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3792)
		 		try aggregate_windowed_function()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3793)
		 		try scalar_function_name()
		 		setState(3794)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3796)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.CASE.rawValue,tsqlParser.Tokens.COALESCE.rawValue,tsqlParser.Tokens.CONVERT.rawValue,tsqlParser.Tokens.CURRENT_TIMESTAMP.rawValue,tsqlParser.Tokens.CURRENT_USER.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.DEFAULT.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 34)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.IDENTITY.rawValue,tsqlParser.Tokens.ISNULL.rawValue,tsqlParser.Tokens.LEFT.rawValue,tsqlParser.Tokens.NULL.rawValue,tsqlParser.Tokens.NULLIF.rawValue,tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.OVER.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 108)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.RIGHT.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SESSION_USER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.SYSTEM_USER.rawValue,tsqlParser.Tokens.TARGET.rawValue,tsqlParser.Tokens.ABSOLUTE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 177)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.BINARY_CHECKSUM.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DATEADD.rawValue,tsqlParser.Tokens.DATEDIFF.rawValue,tsqlParser.Tokens.DATENAME.rawValue,tsqlParser.Tokens.DATEPART.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue,tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 244)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GETDATE.rawValue,tsqlParser.Tokens.GETUTCDATE.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue,tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MIN_ACTIVE_ROWVERSION.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 310)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue,tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 375)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.STUFF.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue,tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.LOCAL_ID.rawValue,tsqlParser.Tokens.DECIMAL.rawValue,tsqlParser.Tokens.ID.rawValue,tsqlParser.Tokens.STRING.rawValue,tsqlParser.Tokens.BINARY.rawValue,tsqlParser.Tokens.FLOAT.rawValue,tsqlParser.Tokens.REAL.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 440)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DOLLAR.rawValue,tsqlParser.Tokens.LR_BRACKET.rawValue,tsqlParser.Tokens.PLUS.rawValue,tsqlParser.Tokens.MINUS.rawValue,tsqlParser.Tokens.BIT_NOT.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 518)
		 		          }()
		 		      return testSet
		 		 }()) {
		 			setState(3795)
		 			try expression_list()

		 		}

		 		setState(3798)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3800)
		 		try match(tsqlParser.Tokens.BINARY_CHECKSUM.rawValue)
		 		setState(3801)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3802)
		 		try match(tsqlParser.Tokens.STAR.rawValue)
		 		setState(3803)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3804)
		 		try match(tsqlParser.Tokens.CAST.rawValue)
		 		setState(3805)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3806)
		 		try expression(0)
		 		setState(3807)
		 		try match(tsqlParser.Tokens.AS.rawValue)
		 		setState(3808)
		 		try data_type()
		 		setState(3809)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(3811)
		 		try match(tsqlParser.Tokens.CONVERT.rawValue)
		 		setState(3812)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3813)
		 		try data_type()
		 		setState(3814)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3815)
		 		try expression(0)
		 		setState(3818)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3816)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(3817)
		 			try {
		 					let assignmentValue = try expression(0)
		 					_localctx.castdown(Function_callContext.self).style = assignmentValue
		 			     }()


		 		}

		 		setState(3820)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(3822)
		 		try match(tsqlParser.Tokens.CHECKSUM.rawValue)
		 		setState(3823)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3824)
		 		try match(tsqlParser.Tokens.STAR.rawValue)
		 		setState(3825)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(3826)
		 		try match(tsqlParser.Tokens.COALESCE.rawValue)
		 		setState(3827)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3828)
		 		try expression_list()
		 		setState(3829)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(3831)
		 		try match(tsqlParser.Tokens.CURRENT_TIMESTAMP.rawValue)

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(3832)
		 		try match(tsqlParser.Tokens.CURRENT_USER.rawValue)

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(3833)
		 		try match(tsqlParser.Tokens.DATEADD.rawValue)
		 		setState(3834)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3835)
		 		try match(tsqlParser.Tokens.ID.rawValue)
		 		setState(3836)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3837)
		 		try expression(0)
		 		setState(3838)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3839)
		 		try expression(0)
		 		setState(3840)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(3842)
		 		try match(tsqlParser.Tokens.DATEDIFF.rawValue)
		 		setState(3843)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3844)
		 		try match(tsqlParser.Tokens.ID.rawValue)
		 		setState(3845)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3846)
		 		try expression(0)
		 		setState(3847)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3848)
		 		try expression(0)
		 		setState(3849)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(3851)
		 		try match(tsqlParser.Tokens.DATENAME.rawValue)
		 		setState(3852)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3853)
		 		try match(tsqlParser.Tokens.ID.rawValue)
		 		setState(3854)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3855)
		 		try expression(0)
		 		setState(3856)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(3858)
		 		try match(tsqlParser.Tokens.DATEPART.rawValue)
		 		setState(3859)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3860)
		 		try match(tsqlParser.Tokens.ID.rawValue)
		 		setState(3861)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3862)
		 		try expression(0)
		 		setState(3863)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(3865)
		 		try match(tsqlParser.Tokens.GETDATE.rawValue)
		 		setState(3866)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3867)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(3868)
		 		try match(tsqlParser.Tokens.GETUTCDATE.rawValue)
		 		setState(3869)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3870)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(3871)
		 		try match(tsqlParser.Tokens.IDENTITY.rawValue)
		 		setState(3872)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3873)
		 		try data_type()
		 		setState(3876)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,547,_ctx)) {
		 		case 1:
		 			setState(3874)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(3875)
		 			try {
		 					let assignmentValue = try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 					_localctx.castdown(Function_callContext.self).seed = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(3880)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3878)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(3879)
		 			try {
		 					let assignmentValue = try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 					_localctx.castdown(Function_callContext.self).increment = assignmentValue
		 			     }()


		 		}

		 		setState(3882)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(3884)
		 		try match(tsqlParser.Tokens.MIN_ACTIVE_ROWVERSION.rawValue)

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(3885)
		 		try match(tsqlParser.Tokens.NULLIF.rawValue)
		 		setState(3886)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3887)
		 		try expression(0)
		 		setState(3888)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3889)
		 		try expression(0)
		 		setState(3890)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 20:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(3892)
		 		try match(tsqlParser.Tokens.STUFF.rawValue)
		 		setState(3893)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3894)
		 		try expression(0)
		 		setState(3895)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3896)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 		setState(3897)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3898)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 		setState(3899)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3900)
		 		try expression(0)
		 		setState(3901)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 21:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(3903)
		 		try match(tsqlParser.Tokens.SESSION_USER.rawValue)

		 		break
		 	case 22:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(3904)
		 		try match(tsqlParser.Tokens.SYSTEM_USER.rawValue)

		 		break
		 	case 23:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(3905)
		 		try match(tsqlParser.Tokens.ISNULL.rawValue)
		 		setState(3906)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3907)
		 		try expression(0)
		 		setState(3908)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(3909)
		 		try expression(0)
		 		setState(3910)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 24:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(3912)
		 		try xml_data_type_methods()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Xml_data_type_methodsContext:ParserRuleContext {
		open func value_method() -> Value_methodContext? {
			return getRuleContext(Value_methodContext.self,0)
		}
		open func query_method() -> Query_methodContext? {
			return getRuleContext(Query_methodContext.self,0)
		}
		open func exist_method() -> Exist_methodContext? {
			return getRuleContext(Exist_methodContext.self,0)
		}
		open func modify_method() -> Modify_methodContext? {
			return getRuleContext(Modify_methodContext.self,0)
		}
		open func nodes_method() -> Nodes_methodContext? {
			return getRuleContext(Nodes_methodContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_xml_data_type_methods }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterXml_data_type_methods(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitXml_data_type_methods(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitXml_data_type_methods(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitXml_data_type_methods(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func xml_data_type_methods() throws -> Xml_data_type_methodsContext {
		var _localctx: Xml_data_type_methodsContext = Xml_data_type_methodsContext(_ctx, getState())
		try enterRule(_localctx, 360, tsqlParser.RULE_xml_data_type_methods)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3920)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,550, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3915)
		 		try value_method()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3916)
		 		try query_method()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3917)
		 		try exist_method()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3918)
		 		try modify_method()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3919)
		 		try nodes_method()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Value_methodContext:ParserRuleContext {
		public var xquery: Token!
		public var sqltype: Token!
		open func STRING() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.STRING.rawValue) }
		open func STRING(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.STRING.rawValue, i)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.ID.rawValue, 0) }
		open func EVENTDATA() -> TerminalNode? { return getToken(tsqlParser.Tokens.EVENTDATA.rawValue, 0) }
		open func query_method() -> Query_methodContext? {
			return getRuleContext(Query_methodContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_value_method }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterValue_method(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitValue_method(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitValue_method(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitValue_method(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func value_method() throws -> Value_methodContext {
		var _localctx: Value_methodContext = Value_methodContext(_ctx, getState())
		try enterRule(_localctx, 362, tsqlParser.RULE_value_method)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3926)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,551, _ctx)) {
		 	case 1:
		 		setState(3922)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 		break
		 	case 2:
		 		setState(3923)
		 		try match(tsqlParser.Tokens.ID.rawValue)

		 		break
		 	case 3:
		 		setState(3924)
		 		try match(tsqlParser.Tokens.EVENTDATA.rawValue)

		 		break
		 	case 4:
		 		setState(3925)
		 		try query_method()

		 		break
		 	default: break
		 	}
		 	setState(3928)
		 	try match(tsqlParser.Tokens.T__10.rawValue)
		 	setState(3929)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(Value_methodContext.self).xquery = assignmentValue
		 	     }()

		 	setState(3930)
		 	try match(tsqlParser.Tokens.COMMA.rawValue)
		 	setState(3931)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(Value_methodContext.self).sqltype = assignmentValue
		 	     }()

		 	setState(3932)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Query_methodContext:ParserRuleContext {
		public var xquery: Token!
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.ID.rawValue, 0) }
		open func full_table_name() -> Full_table_nameContext? {
			return getRuleContext(Full_table_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_query_method }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterQuery_method(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitQuery_method(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitQuery_method(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitQuery_method(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func query_method() throws -> Query_methodContext {
		var _localctx: Query_methodContext = Query_methodContext(_ctx, getState())
		try enterRule(_localctx, 364, tsqlParser.RULE_query_method)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3937)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,552, _ctx)) {
		 	case 1:
		 		setState(3934)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 		break
		 	case 2:
		 		setState(3935)
		 		try match(tsqlParser.Tokens.ID.rawValue)

		 		break
		 	case 3:
		 		setState(3936)
		 		try full_table_name()

		 		break
		 	default: break
		 	}
		 	setState(3939)
		 	try match(tsqlParser.Tokens.T__11.rawValue)
		 	setState(3940)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(Query_methodContext.self).xquery = assignmentValue
		 	     }()

		 	setState(3941)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Exist_methodContext:ParserRuleContext {
		public var xquery: Token!
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.ID.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_exist_method }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterExist_method(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitExist_method(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitExist_method(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitExist_method(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func exist_method() throws -> Exist_methodContext {
		var _localctx: Exist_methodContext = Exist_methodContext(_ctx, getState())
		try enterRule(_localctx, 366, tsqlParser.RULE_exist_method)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3943)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.ID.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3944)
		 	try match(tsqlParser.Tokens.T__12.rawValue)
		 	setState(3945)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(Exist_methodContext.self).xquery = assignmentValue
		 	     }()

		 	setState(3946)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Modify_methodContext:ParserRuleContext {
		public var xml_dml: Token!
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.ID.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_modify_method }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterModify_method(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitModify_method(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitModify_method(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitModify_method(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func modify_method() throws -> Modify_methodContext {
		var _localctx: Modify_methodContext = Modify_methodContext(_ctx, getState())
		try enterRule(_localctx, 368, tsqlParser.RULE_modify_method)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3948)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.ID.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3949)
		 	try match(tsqlParser.Tokens.T__13.rawValue)
		 	setState(3950)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(Modify_methodContext.self).xml_dml = assignmentValue
		 	     }()

		 	setState(3951)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Nodes_methodContext:ParserRuleContext {
		public var xquery: Token!
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.ID.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_nodes_method }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterNodes_method(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitNodes_method(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitNodes_method(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitNodes_method(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func nodes_method() throws -> Nodes_methodContext {
		var _localctx: Nodes_methodContext = Nodes_methodContext(_ctx, getState())
		try enterRule(_localctx, 370, tsqlParser.RULE_nodes_method)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3953)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.ID.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3954)
		 	try match(tsqlParser.Tokens.T__14.rawValue)
		 	setState(3955)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(Nodes_methodContext.self).xquery = assignmentValue
		 	     }()

		 	setState(3956)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Switch_sectionContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(tsqlParser.Tokens.WHEN.rawValue, 0) }
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open func THEN() -> TerminalNode? { return getToken(tsqlParser.Tokens.THEN.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_switch_section }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSwitch_section(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSwitch_section(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSwitch_section(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSwitch_section(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func switch_section() throws -> Switch_sectionContext {
		var _localctx: Switch_sectionContext = Switch_sectionContext(_ctx, getState())
		try enterRule(_localctx, 372, tsqlParser.RULE_switch_section)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3958)
		 	try match(tsqlParser.Tokens.WHEN.rawValue)
		 	setState(3959)
		 	try expression(0)
		 	setState(3960)
		 	try match(tsqlParser.Tokens.THEN.rawValue)
		 	setState(3961)
		 	try expression(0)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Switch_search_condition_sectionContext:ParserRuleContext {
		open func WHEN() -> TerminalNode? { return getToken(tsqlParser.Tokens.WHEN.rawValue, 0) }
		open func search_condition() -> Search_conditionContext? {
			return getRuleContext(Search_conditionContext.self,0)
		}
		open func THEN() -> TerminalNode? { return getToken(tsqlParser.Tokens.THEN.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_switch_search_condition_section }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSwitch_search_condition_section(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSwitch_search_condition_section(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSwitch_search_condition_section(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSwitch_search_condition_section(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func switch_search_condition_section() throws -> Switch_search_condition_sectionContext {
		var _localctx: Switch_search_condition_sectionContext = Switch_search_condition_sectionContext(_ctx, getState())
		try enterRule(_localctx, 374, tsqlParser.RULE_switch_search_condition_section)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3963)
		 	try match(tsqlParser.Tokens.WHEN.rawValue)
		 	setState(3964)
		 	try search_condition()
		 	setState(3965)
		 	try match(tsqlParser.Tokens.THEN.rawValue)
		 	setState(3966)
		 	try expression(0)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class As_table_aliasContext:ParserRuleContext {
		open func table_alias() -> Table_aliasContext? {
			return getRuleContext(Table_aliasContext.self,0)
		}
		open func AS() -> TerminalNode? { return getToken(tsqlParser.Tokens.AS.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_as_table_alias }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterAs_table_alias(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitAs_table_alias(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitAs_table_alias(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitAs_table_alias(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func as_table_alias() throws -> As_table_aliasContext {
		var _localctx: As_table_aliasContext = As_table_aliasContext(_ctx, getState())
		try enterRule(_localctx, 376, tsqlParser.RULE_as_table_alias)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3969)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.AS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3968)
		 		try match(tsqlParser.Tokens.AS.rawValue)

		 	}

		 	setState(3971)
		 	try table_alias()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_aliasContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func with_table_hints() -> With_table_hintsContext? {
			return getRuleContext(With_table_hintsContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_alias }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_alias(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_alias(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_alias(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_alias(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_alias() throws -> Table_aliasContext {
		var _localctx: Table_aliasContext = Table_aliasContext(_ctx, getState())
		try enterRule(_localctx, 378, tsqlParser.RULE_table_alias)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3973)
		 	try id()
		 	setState(3975)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,554,_ctx)) {
		 	case 1:
		 		setState(3974)
		 		try with_table_hints()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class With_table_hintsContext:ParserRuleContext {
		open func table_hint() -> Array<Table_hintContext> {
			return getRuleContexts(Table_hintContext.self)
		}
		open func table_hint(_ i: Int) -> Table_hintContext? {
			return getRuleContext(Table_hintContext.self,i)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_with_table_hints }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterWith_table_hints(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitWith_table_hints(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitWith_table_hints(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitWith_table_hints(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func with_table_hints() throws -> With_table_hintsContext {
		var _localctx: With_table_hintsContext = With_table_hintsContext(_ctx, getState())
		try enterRule(_localctx, 380, tsqlParser.RULE_with_table_hints)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3978)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WITH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3977)
		 		try match(tsqlParser.Tokens.WITH.rawValue)

		 	}

		 	setState(3980)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(3981)
		 	try table_hint()
		 	setState(3988)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.FORCESEEK.rawValue || _la == tsqlParser.Tokens.INDEX.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.NOEXPAND.rawValue || _la == tsqlParser.Tokens.SERIALIZABLE.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 446)
		 	          }()
		 	          testSet = testSet || _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3983)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3982)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}

		 		setState(3985)
		 		try table_hint()


		 		setState(3990)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3991)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Insert_with_table_hintsContext:ParserRuleContext {
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func table_hint() -> Array<Table_hintContext> {
			return getRuleContexts(Table_hintContext.self)
		}
		open func table_hint(_ i: Int) -> Table_hintContext? {
			return getRuleContext(Table_hintContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_insert_with_table_hints }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterInsert_with_table_hints(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitInsert_with_table_hints(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitInsert_with_table_hints(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitInsert_with_table_hints(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func insert_with_table_hints() throws -> Insert_with_table_hintsContext {
		var _localctx: Insert_with_table_hintsContext = Insert_with_table_hintsContext(_ctx, getState())
		try enterRule(_localctx, 382, tsqlParser.RULE_insert_with_table_hints)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3993)
		 	try match(tsqlParser.Tokens.WITH.rawValue)
		 	setState(3994)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(3995)
		 	try table_hint()
		 	setState(4002)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.FORCESEEK.rawValue || _la == tsqlParser.Tokens.INDEX.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.NOEXPAND.rawValue || _la == tsqlParser.Tokens.SERIALIZABLE.rawValue
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.ID.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 446)
		 	          }()
		 	          testSet = testSet || _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(3997)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(3996)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}

		 		setState(3999)
		 		try table_hint()


		 		setState(4004)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4005)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_hintContext:ParserRuleContext {
		open func INDEX() -> TerminalNode? { return getToken(tsqlParser.Tokens.INDEX.rawValue, 0) }
		open func index_value() -> Array<Index_valueContext> {
			return getRuleContexts(Index_valueContext.self)
		}
		open func index_value(_ i: Int) -> Index_valueContext? {
			return getRuleContext(Index_valueContext.self,i)
		}
		open func FORCESEEK() -> TerminalNode? { return getToken(tsqlParser.Tokens.FORCESEEK.rawValue, 0) }
		open func SERIALIZABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SERIALIZABLE.rawValue, 0) }
		open func SNAPSHOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.SNAPSHOT.rawValue, 0) }
		open func SPATIAL_WINDOW_MAX_CELLS() -> TerminalNode? { return getToken(tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func ID() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ID.rawValue) }
		open func ID(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ID.rawValue, i)
		}
		open func NOEXPAND() -> TerminalNode? { return getToken(tsqlParser.Tokens.NOEXPAND.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_hint }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_hint(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_hint(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_hint(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_hint(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_hint() throws -> Table_hintContext {
		var _localctx: Table_hintContext = Table_hintContext(_ctx, getState())
		try enterRule(_localctx, 384, tsqlParser.RULE_table_hint)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4008)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.NOEXPAND.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4007)
		 		try match(tsqlParser.Tokens.NOEXPAND.rawValue)

		 	}

		 	setState(4048)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,564, _ctx)) {
		 	case 1:
		 		setState(4010)
		 		try match(tsqlParser.Tokens.INDEX.rawValue)
		 		setState(4011)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4012)
		 		try index_value()
		 		setState(4017)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4013)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(4014)
		 			try index_value()


		 			setState(4019)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4020)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 2:
		 		setState(4022)
		 		try match(tsqlParser.Tokens.INDEX.rawValue)
		 		setState(4023)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4024)
		 		try index_value()

		 		break
		 	case 3:
		 		setState(4025)
		 		try match(tsqlParser.Tokens.FORCESEEK.rawValue)
		 		setState(4040)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.LR_BRACKET.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4026)
		 			try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(4027)
		 			try index_value()
		 			setState(4028)
		 			try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(4029)
		 			try match(tsqlParser.Tokens.ID.rawValue)
		 			setState(4034)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(4030)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)
		 				setState(4031)
		 				try match(tsqlParser.Tokens.ID.rawValue)


		 				setState(4036)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(4037)
		 			try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 			setState(4038)
		 			try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		}


		 		break
		 	case 4:
		 		setState(4042)
		 		try match(tsqlParser.Tokens.SERIALIZABLE.rawValue)

		 		break
		 	case 5:
		 		setState(4043)
		 		try match(tsqlParser.Tokens.SNAPSHOT.rawValue)

		 		break
		 	case 6:
		 		setState(4044)
		 		try match(tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue)
		 		setState(4045)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4046)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 		break
		 	case 7:
		 		setState(4047)
		 		try match(tsqlParser.Tokens.ID.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Index_valueContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_index_value }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterIndex_value(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitIndex_value(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitIndex_value(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitIndex_value(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func index_value() throws -> Index_valueContext {
		var _localctx: Index_valueContext = Index_valueContext(_ctx, getState())
		try enterRule(_localctx, 386, tsqlParser.RULE_index_value)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4052)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4050)
		 		try id()

		 		break

		 	case .DECIMAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4051)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_alias_listContext:ParserRuleContext {
		open func column_alias() -> Array<Column_aliasContext> {
			return getRuleContexts(Column_aliasContext.self)
		}
		open func column_alias(_ i: Int) -> Column_aliasContext? {
			return getRuleContext(Column_aliasContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_column_alias_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterColumn_alias_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitColumn_alias_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitColumn_alias_list(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitColumn_alias_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_alias_list() throws -> Column_alias_listContext {
		var _localctx: Column_alias_listContext = Column_alias_listContext(_ctx, getState())
		try enterRule(_localctx, 388, tsqlParser.RULE_column_alias_list)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4054)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(4055)
		 	try column_alias()
		 	setState(4060)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4056)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(4057)
		 		try column_alias()


		 		setState(4062)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4063)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_aliasContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_column_alias }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterColumn_alias(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitColumn_alias(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitColumn_alias(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitColumn_alias(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_alias() throws -> Column_aliasContext {
		var _localctx: Column_aliasContext = Column_aliasContext(_ctx, getState())
		try enterRule(_localctx, 390, tsqlParser.RULE_column_alias)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4067)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4065)
		 		try id()

		 		break

		 	case .STRING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4066)
		 		try match(tsqlParser.Tokens.STRING.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_value_constructorContext:ParserRuleContext {
		open func VALUES() -> TerminalNode? { return getToken(tsqlParser.Tokens.VALUES.rawValue, 0) }
		open func expression_list() -> Array<Expression_listContext> {
			return getRuleContexts(Expression_listContext.self)
		}
		open func expression_list(_ i: Int) -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_value_constructor }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_value_constructor(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_value_constructor(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_value_constructor(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_value_constructor(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_value_constructor() throws -> Table_value_constructorContext {
		var _localctx: Table_value_constructorContext = Table_value_constructorContext(_ctx, getState())
		try enterRule(_localctx, 392, tsqlParser.RULE_table_value_constructor)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4069)
		 	try match(tsqlParser.Tokens.VALUES.rawValue)
		 	setState(4070)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(4071)
		 	try expression_list()
		 	setState(4072)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(4080)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,568,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4073)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(4074)
		 			try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(4075)
		 			try expression_list()
		 			setState(4076)
		 			try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 	 
		 		}
		 		setState(4082)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,568,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Expression_listContext:ParserRuleContext {
		open func expression() -> Array<ExpressionContext> {
			return getRuleContexts(ExpressionContext.self)
		}
		open func expression(_ i: Int) -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_expression_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterExpression_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitExpression_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitExpression_list(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitExpression_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func expression_list() throws -> Expression_listContext {
		var _localctx: Expression_listContext = Expression_listContext(_ctx, getState())
		try enterRule(_localctx, 394, tsqlParser.RULE_expression_list)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4083)
		 	try expression(0)
		 	setState(4088)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4084)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(4085)
		 		try expression(0)


		 		setState(4090)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Ranking_windowed_functionContext:ParserRuleContext {
		open func over_clause() -> Over_clauseContext? {
			return getRuleContext(Over_clauseContext.self,0)
		}
		open func RANK() -> TerminalNode? { return getToken(tsqlParser.Tokens.RANK.rawValue, 0) }
		open func DENSE_RANK() -> TerminalNode? { return getToken(tsqlParser.Tokens.DENSE_RANK.rawValue, 0) }
		open func ROW_NUMBER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROW_NUMBER.rawValue, 0) }
		open func NTILE() -> TerminalNode? { return getToken(tsqlParser.Tokens.NTILE.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_ranking_windowed_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterRanking_windowed_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitRanking_windowed_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitRanking_windowed_function(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitRanking_windowed_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func ranking_windowed_function() throws -> Ranking_windowed_functionContext {
		var _localctx: Ranking_windowed_functionContext = Ranking_windowed_functionContext(_ctx, getState())
		try enterRule(_localctx, 396, tsqlParser.RULE_ranking_windowed_function)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4101)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DENSE_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4091)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.DENSE_RANK.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.RANK.rawValue || _la == tsqlParser.Tokens.ROW_NUMBER.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4092)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4093)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(4094)
		 		try over_clause()

		 		break

		 	case .NTILE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4095)
		 		try match(tsqlParser.Tokens.NTILE.rawValue)
		 		setState(4096)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4097)
		 		try expression(0)
		 		setState(4098)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(4099)
		 		try over_clause()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Aggregate_windowed_functionContext:ParserRuleContext {
		open func all_distinct_expression() -> All_distinct_expressionContext? {
			return getRuleContext(All_distinct_expressionContext.self,0)
		}
		open func AVG() -> TerminalNode? { return getToken(tsqlParser.Tokens.AVG.rawValue, 0) }
		open func MAX() -> TerminalNode? { return getToken(tsqlParser.Tokens.MAX.rawValue, 0) }
		open func MIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.MIN.rawValue, 0) }
		open func SUM() -> TerminalNode? { return getToken(tsqlParser.Tokens.SUM.rawValue, 0) }
		open func STDEV() -> TerminalNode? { return getToken(tsqlParser.Tokens.STDEV.rawValue, 0) }
		open func STDEVP() -> TerminalNode? { return getToken(tsqlParser.Tokens.STDEVP.rawValue, 0) }
		open func VAR() -> TerminalNode? { return getToken(tsqlParser.Tokens.VAR.rawValue, 0) }
		open func VARP() -> TerminalNode? { return getToken(tsqlParser.Tokens.VARP.rawValue, 0) }
		open func over_clause() -> Over_clauseContext? {
			return getRuleContext(Over_clauseContext.self,0)
		}
		open func COUNT() -> TerminalNode? { return getToken(tsqlParser.Tokens.COUNT.rawValue, 0) }
		open func COUNT_BIG() -> TerminalNode? { return getToken(tsqlParser.Tokens.COUNT_BIG.rawValue, 0) }
		open func CHECKSUM_AGG() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHECKSUM_AGG.rawValue, 0) }
		open func GROUPING() -> TerminalNode? { return getToken(tsqlParser.Tokens.GROUPING.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func GROUPING_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.GROUPING_ID.rawValue, 0) }
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_aggregate_windowed_function }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterAggregate_windowed_function(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitAggregate_windowed_function(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitAggregate_windowed_function(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitAggregate_windowed_function(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func aggregate_windowed_function() throws -> Aggregate_windowed_functionContext {
		var _localctx: Aggregate_windowed_functionContext = Aggregate_windowed_functionContext(_ctx, getState())
		try enterRule(_localctx, 398, tsqlParser.RULE_aggregate_windowed_function)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4135)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .AVG:fallthrough
		 	case .MAX:fallthrough
		 	case .MIN:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4103)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.AVG.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.MAX.rawValue || _la == tsqlParser.Tokens.MIN.rawValue
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 452)
		 		          }()
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4104)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4105)
		 		try all_distinct_expression()
		 		setState(4106)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(4108)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,571,_ctx)) {
		 		case 1:
		 			setState(4107)
		 			try over_clause()

		 			break
		 		default: break
		 		}

		 		break
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4110)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COUNT.rawValue || _la == tsqlParser.Tokens.COUNT_BIG.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4111)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4114)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .STAR:
		 			setState(4112)
		 			try match(tsqlParser.Tokens.STAR.rawValue)

		 			break
		 		case .ALL:fallthrough
		 		case .CALLED:fallthrough
		 		case .CASE:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CONVERT:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DISTINCT:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .IDENTITY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NULL:fallthrough
		 		case .NULLIF:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .OVER:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .RIGHT:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .BINARY_CHECKSUM:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DATEADD:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATENAME:fallthrough
		 		case .DATEPART:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GETDATE:fallthrough
		 		case .GETUTCDATE:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MIN_ACTIVE_ROWVERSION:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .STUFF:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .LOCAL_ID:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .ID:fallthrough
		 		case .STRING:fallthrough
		 		case .BINARY:fallthrough
		 		case .FLOAT:fallthrough
		 		case .REAL:fallthrough
		 		case .DOLLAR:fallthrough
		 		case .LR_BRACKET:fallthrough
		 		case .PLUS:fallthrough
		 		case .MINUS:fallthrough
		 		case .BIT_NOT:
		 			setState(4113)
		 			try all_distinct_expression()

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4116)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(4118)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,573,_ctx)) {
		 		case 1:
		 			setState(4117)
		 			try over_clause()

		 			break
		 		default: break
		 		}

		 		break

		 	case .CHECKSUM_AGG:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4120)
		 		try match(tsqlParser.Tokens.CHECKSUM_AGG.rawValue)
		 		setState(4121)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4122)
		 		try all_distinct_expression()
		 		setState(4123)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break

		 	case .GROUPING:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4125)
		 		try match(tsqlParser.Tokens.GROUPING.rawValue)
		 		setState(4126)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4127)
		 		try expression(0)
		 		setState(4128)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break

		 	case .GROUPING_ID:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4130)
		 		try match(tsqlParser.Tokens.GROUPING_ID.rawValue)
		 		setState(4131)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4132)
		 		try expression_list()
		 		setState(4133)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class All_distinct_expressionContext:ParserRuleContext {
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func ALL() -> TerminalNode? { return getToken(tsqlParser.Tokens.ALL.rawValue, 0) }
		open func DISTINCT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DISTINCT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_all_distinct_expression }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterAll_distinct_expression(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitAll_distinct_expression(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitAll_distinct_expression(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitAll_distinct_expression(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func all_distinct_expression() throws -> All_distinct_expressionContext {
		var _localctx: All_distinct_expressionContext = All_distinct_expressionContext(_ctx, getState())
		try enterRule(_localctx, 400, tsqlParser.RULE_all_distinct_expression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4138)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ALL.rawValue || _la == tsqlParser.Tokens.DISTINCT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4137)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ALL.rawValue || _la == tsqlParser.Tokens.DISTINCT.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(4140)
		 	try expression(0)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Over_clauseContext:ParserRuleContext {
		open func OVER() -> TerminalNode? { return getToken(tsqlParser.Tokens.OVER.rawValue, 0) }
		open func PARTITION() -> TerminalNode? { return getToken(tsqlParser.Tokens.PARTITION.rawValue, 0) }
		open func BY() -> TerminalNode? { return getToken(tsqlParser.Tokens.BY.rawValue, 0) }
		open func expression_list() -> Expression_listContext? {
			return getRuleContext(Expression_listContext.self,0)
		}
		open func order_by_clause() -> Order_by_clauseContext? {
			return getRuleContext(Order_by_clauseContext.self,0)
		}
		open func row_or_range_clause() -> Row_or_range_clauseContext? {
			return getRuleContext(Row_or_range_clauseContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_over_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOver_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOver_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOver_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOver_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func over_clause() throws -> Over_clauseContext {
		var _localctx: Over_clauseContext = Over_clauseContext(_ctx, getState())
		try enterRule(_localctx, 402, tsqlParser.RULE_over_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4142)
		 	try match(tsqlParser.Tokens.OVER.rawValue)
		 	setState(4143)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(4147)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.PARTITION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4144)
		 		try match(tsqlParser.Tokens.PARTITION.rawValue)
		 		setState(4145)
		 		try match(tsqlParser.Tokens.BY.rawValue)
		 		setState(4146)
		 		try expression_list()

		 	}

		 	setState(4150)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ORDER.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4149)
		 		try order_by_clause()

		 	}

		 	setState(4153)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.RANGE.rawValue || _la == tsqlParser.Tokens.ROWS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4152)
		 		try row_or_range_clause()

		 	}

		 	setState(4155)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Row_or_range_clauseContext:ParserRuleContext {
		open func window_frame_extent() -> Window_frame_extentContext? {
			return getRuleContext(Window_frame_extentContext.self,0)
		}
		open func ROWS() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROWS.rawValue, 0) }
		open func RANGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.RANGE.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_row_or_range_clause }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterRow_or_range_clause(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitRow_or_range_clause(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitRow_or_range_clause(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitRow_or_range_clause(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func row_or_range_clause() throws -> Row_or_range_clauseContext {
		var _localctx: Row_or_range_clauseContext = Row_or_range_clauseContext(_ctx, getState())
		try enterRule(_localctx, 404, tsqlParser.RULE_row_or_range_clause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4157)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.RANGE.rawValue || _la == tsqlParser.Tokens.ROWS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4158)
		 	try window_frame_extent()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Window_frame_extentContext:ParserRuleContext {
		open func window_frame_preceding() -> Window_frame_precedingContext? {
			return getRuleContext(Window_frame_precedingContext.self,0)
		}
		open func BETWEEN() -> TerminalNode? { return getToken(tsqlParser.Tokens.BETWEEN.rawValue, 0) }
		open func window_frame_bound() -> Array<Window_frame_boundContext> {
			return getRuleContexts(Window_frame_boundContext.self)
		}
		open func window_frame_bound(_ i: Int) -> Window_frame_boundContext? {
			return getRuleContext(Window_frame_boundContext.self,i)
		}
		open func AND() -> TerminalNode? { return getToken(tsqlParser.Tokens.AND.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_window_frame_extent }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterWindow_frame_extent(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitWindow_frame_extent(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitWindow_frame_extent(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitWindow_frame_extent(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func window_frame_extent() throws -> Window_frame_extentContext {
		var _localctx: Window_frame_extentContext = Window_frame_extentContext(_ctx, getState())
		try enterRule(_localctx, 406, tsqlParser.RULE_window_frame_extent)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4166)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CURRENT:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .DECIMAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4160)
		 		try window_frame_preceding()

		 		break

		 	case .BETWEEN:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4161)
		 		try match(tsqlParser.Tokens.BETWEEN.rawValue)
		 		setState(4162)
		 		try window_frame_bound()
		 		setState(4163)
		 		try match(tsqlParser.Tokens.AND.rawValue)
		 		setState(4164)
		 		try window_frame_bound()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Window_frame_boundContext:ParserRuleContext {
		open func window_frame_preceding() -> Window_frame_precedingContext? {
			return getRuleContext(Window_frame_precedingContext.self,0)
		}
		open func window_frame_following() -> Window_frame_followingContext? {
			return getRuleContext(Window_frame_followingContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_window_frame_bound }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterWindow_frame_bound(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitWindow_frame_bound(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitWindow_frame_bound(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitWindow_frame_bound(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func window_frame_bound() throws -> Window_frame_boundContext {
		var _localctx: Window_frame_boundContext = Window_frame_boundContext(_ctx, getState())
		try enterRule(_localctx, 408, tsqlParser.RULE_window_frame_bound)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4170)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,580, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4168)
		 		try window_frame_preceding()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4169)
		 		try window_frame_following()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Window_frame_precedingContext:ParserRuleContext {
		open func UNBOUNDED() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNBOUNDED.rawValue, 0) }
		open func PRECEDING() -> TerminalNode? { return getToken(tsqlParser.Tokens.PRECEDING.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func CURRENT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CURRENT.rawValue, 0) }
		open func ROW() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROW.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_window_frame_preceding }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterWindow_frame_preceding(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitWindow_frame_preceding(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitWindow_frame_preceding(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitWindow_frame_preceding(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func window_frame_preceding() throws -> Window_frame_precedingContext {
		var _localctx: Window_frame_precedingContext = Window_frame_precedingContext(_ctx, getState())
		try enterRule(_localctx, 410, tsqlParser.RULE_window_frame_preceding)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4178)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .UNBOUNDED:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4172)
		 		try match(tsqlParser.Tokens.UNBOUNDED.rawValue)
		 		setState(4173)
		 		try match(tsqlParser.Tokens.PRECEDING.rawValue)

		 		break

		 	case .DECIMAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4174)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 		setState(4175)
		 		try match(tsqlParser.Tokens.PRECEDING.rawValue)

		 		break

		 	case .CURRENT:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4176)
		 		try match(tsqlParser.Tokens.CURRENT.rawValue)
		 		setState(4177)
		 		try match(tsqlParser.Tokens.ROW.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Window_frame_followingContext:ParserRuleContext {
		open func UNBOUNDED() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNBOUNDED.rawValue, 0) }
		open func FOLLOWING() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOLLOWING.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_window_frame_following }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterWindow_frame_following(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitWindow_frame_following(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitWindow_frame_following(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitWindow_frame_following(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func window_frame_following() throws -> Window_frame_followingContext {
		var _localctx: Window_frame_followingContext = Window_frame_followingContext(_ctx, getState())
		try enterRule(_localctx, 412, tsqlParser.RULE_window_frame_following)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4184)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .UNBOUNDED:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4180)
		 		try match(tsqlParser.Tokens.UNBOUNDED.rawValue)
		 		setState(4181)
		 		try match(tsqlParser.Tokens.FOLLOWING.rawValue)

		 		break

		 	case .DECIMAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4182)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 		setState(4183)
		 		try match(tsqlParser.Tokens.FOLLOWING.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Create_database_optionContext:ParserRuleContext {
		open func FILESTREAM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FILESTREAM.rawValue, 0) }
		open func database_filestream_option() -> Array<Database_filestream_optionContext> {
			return getRuleContexts(Database_filestream_optionContext.self)
		}
		open func database_filestream_option(_ i: Int) -> Database_filestream_optionContext? {
			return getRuleContext(Database_filestream_optionContext.self,i)
		}
		open func DEFAULT_LANGUAGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT_LANGUAGE.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func DEFAULT_FULLTEXT_LANGUAGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT_FULLTEXT_LANGUAGE.rawValue, 0) }
		open func NESTED_TRIGGERS() -> TerminalNode? { return getToken(tsqlParser.Tokens.NESTED_TRIGGERS.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func TRANSFORM_NOISE_WORDS() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRANSFORM_NOISE_WORDS.rawValue, 0) }
		open func TWO_DIGIT_YEAR_CUTOFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.TWO_DIGIT_YEAR_CUTOFF.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func DB_CHAINING() -> TerminalNode? { return getToken(tsqlParser.Tokens.DB_CHAINING.rawValue, 0) }
		open func TRUSTWORTHY() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRUSTWORTHY.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_create_database_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCreate_database_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCreate_database_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCreate_database_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCreate_database_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func create_database_option() throws -> Create_database_optionContext {
		var _localctx: Create_database_optionContext = Create_database_optionContext(_ctx, getState())
		try enterRule(_localctx, 414, tsqlParser.RULE_create_database_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(4220)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FILESTREAM:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4186)
		 		try match(tsqlParser.Tokens.FILESTREAM.rawValue)

		 		setState(4187)
		 		try database_filestream_option()
		 		setState(4192)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,583,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(4188)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)
		 				setState(4189)
		 				try database_filestream_option()

		 		 
		 			}
		 			setState(4194)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,583,_ctx)
		 		}


		 		break

		 	case .DEFAULT_LANGUAGE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4195)
		 		try match(tsqlParser.Tokens.DEFAULT_LANGUAGE.rawValue)
		 		setState(4196)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4199)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CALLED:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .ID:
		 			setState(4197)
		 			try id()

		 			break

		 		case .STRING:
		 			setState(4198)
		 			try match(tsqlParser.Tokens.STRING.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .DEFAULT_FULLTEXT_LANGUAGE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4201)
		 		try match(tsqlParser.Tokens.DEFAULT_FULLTEXT_LANGUAGE.rawValue)
		 		setState(4202)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4205)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CALLED:fallthrough
		 		case .DATA_COMPRESSION:fallthrough
		 		case .EVENTDATA:fallthrough
		 		case .FILLFACTOR:fallthrough
		 		case .FORCESEEK:fallthrough
		 		case .OFFSETS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PUBLIC:fallthrough
		 		case .RAW:fallthrough
		 		case .RETURN:fallthrough
		 		case .RETURNS:fallthrough
		 		case .ROWCOUNT:fallthrough
		 		case .SERVER:fallthrough
		 		case .SOURCE:fallthrough
		 		case .TARGET:fallthrough
		 		case .ABSOLUTE:fallthrough
		 		case .APPLY:fallthrough
		 		case .AUTO:fallthrough
		 		case .AVG:fallthrough
		 		case .CALLER:fallthrough
		 		case .CAST:fallthrough
		 		case .CATCH:fallthrough
		 		case .CHECKSUM_AGG:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 		case .CONTROL:fallthrough
		 		case .COOKIE:fallthrough
		 		case .COUNT:fallthrough
		 		case .COUNT_BIG:fallthrough
		 		case .DELAY:fallthrough
		 		case .DELETED:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .EXPAND:fallthrough
		 		case .FAST:fallthrough
		 		case .FAST_FORWARD:fallthrough
		 		case .FIRST:fallthrough
		 		case .FOLLOWING:fallthrough
		 		case .FORCE:fallthrough
		 		case .FORCED:fallthrough
		 		case .FORWARD_ONLY:fallthrough
		 		case .FULLSCAN:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GROUPING:fallthrough
		 		case .GROUPING_ID:fallthrough
		 		case .HASH:fallthrough
		 		case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 		case .IMPERSONATE:fallthrough
		 		case .INPUT:fallthrough
		 		case .INSENSITIVE:fallthrough
		 		case .INSERTED:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .KEEP:fallthrough
		 		case .KEEPFIXED:fallthrough
		 		case .KEYSET:fallthrough
		 		case .LAST:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOCK_ESCALATION:fallthrough
		 		case .LOGIN:fallthrough
		 		case .LOOP:fallthrough
		 		case .MARK:fallthrough
		 		case .MAX:fallthrough
		 		case .MAXDOP:fallthrough
		 		case .MAXRECURSION:fallthrough
		 		case .MIN:fallthrough
		 		case .MODIFY:fallthrough
		 		case .NAME:fallthrough
		 		case .NEXT:fallthrough
		 		case .NOCOUNT:fallthrough
		 		case .NOEXPAND:fallthrough
		 		case .NORECOMPUTE:fallthrough
		 		case .NTILE:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OFFSET:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPTIMISTIC:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .OUT:fallthrough
		 		case .OUTPUT:fallthrough
		 		case .OWNER:fallthrough
		 		case .PARAMETERIZATION:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PATH:fallthrough
		 		case .PRECEDING:fallthrough
		 		case .PRIOR:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .RANGE:fallthrough
		 		case .RANK:fallthrough
		 		case .READONLY:fallthrough
		 		case .READ_ONLY:fallthrough
		 		case .RECOMPILE:fallthrough
		 		case .RELATIVE:fallthrough
		 		case .REMOTE:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .ROBUST:fallthrough
		 		case .ROOT:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWGUID:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .SAMPLE:fallthrough
		 		case .SCHEMABINDING:fallthrough
		 		case .SCROLL:fallthrough
		 		case .SCROLL_LOCKS:fallthrough
		 		case .SELF:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SIZE:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 		case .STATIC:fallthrough
		 		case .STATS_STREAM:fallthrough
		 		case .STDEV:fallthrough
		 		case .STDEVP:fallthrough
		 		case .SUM:fallthrough
		 		case .TEXTIMAGE_ON:fallthrough
		 		case .THROW:fallthrough
		 		case .TIES:fallthrough
		 		case .TIME:fallthrough
		 		case .TRY:fallthrough
		 		case .TYPE:fallthrough
		 		case .TYPE_WARNING:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .USING:fallthrough
		 		case .VAR:fallthrough
		 		case .VARP:fallthrough
		 		case .VIEWS:fallthrough
		 		case .VIEW_METADATA:fallthrough
		 		case .WORK:fallthrough
		 		case .XML:fallthrough
		 		case .XMLNAMESPACES:fallthrough
		 		case .DOUBLE_QUOTE_ID:fallthrough
		 		case .SQUARE_BRACKET_ID:fallthrough
		 		case .ID:
		 			setState(4203)
		 			try id()

		 			break

		 		case .STRING:
		 			setState(4204)
		 			try match(tsqlParser.Tokens.STRING.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .NESTED_TRIGGERS:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4207)
		 		try match(tsqlParser.Tokens.NESTED_TRIGGERS.rawValue)
		 		setState(4208)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4209)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .TRANSFORM_NOISE_WORDS:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4210)
		 		try match(tsqlParser.Tokens.TRANSFORM_NOISE_WORDS.rawValue)
		 		setState(4211)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4212)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .TWO_DIGIT_YEAR_CUTOFF:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(4213)
		 		try match(tsqlParser.Tokens.TWO_DIGIT_YEAR_CUTOFF.rawValue)
		 		setState(4214)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4215)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 		break

		 	case .DB_CHAINING:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(4216)
		 		try match(tsqlParser.Tokens.DB_CHAINING.rawValue)
		 		setState(4217)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .TRUSTWORTHY:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(4218)
		 		try match(tsqlParser.Tokens.TRUSTWORTHY.rawValue)
		 		setState(4219)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Database_filestream_optionContext:ParserRuleContext {
		open func LR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.LR_BRACKET.rawValue, 0) }
		open func RR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.RR_BRACKET.rawValue, 0) }
		open func NON_TRANSACTED_ACCESS() -> TerminalNode? { return getToken(tsqlParser.Tokens.NON_TRANSACTED_ACCESS.rawValue, 0) }
		open func EQUAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.EQUAL.rawValue, 0) }
		open func DIRECTORY_NAME() -> TerminalNode? { return getToken(tsqlParser.Tokens.DIRECTORY_NAME.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open func READ_ONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.READ_ONLY.rawValue, 0) }
		open func FULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.FULL.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_database_filestream_option }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDatabase_filestream_option(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDatabase_filestream_option(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDatabase_filestream_option(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDatabase_filestream_option(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func database_filestream_option() throws -> Database_filestream_optionContext {
		var _localctx: Database_filestream_optionContext = Database_filestream_optionContext(_ctx, getState())
		try enterRule(_localctx, 416, tsqlParser.RULE_database_filestream_option)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4222)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(4229)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NON_TRANSACTED_ACCESS:
		 		setState(4223)
		 		try match(tsqlParser.Tokens.NON_TRANSACTED_ACCESS.rawValue)
		 		setState(4224)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4225)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.FULL.rawValue || _la == tsqlParser.Tokens.OFF.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.READ_ONLY.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}


		 		break

		 	case .DIRECTORY_NAME:
		 		setState(4226)
		 		try match(tsqlParser.Tokens.DIRECTORY_NAME.rawValue)
		 		setState(4227)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4228)
		 		try match(tsqlParser.Tokens.STRING.rawValue)


		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4231)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Database_file_specContext:ParserRuleContext {
		open func file_group() -> File_groupContext? {
			return getRuleContext(File_groupContext.self,0)
		}
		open func file_spec() -> File_specContext? {
			return getRuleContext(File_specContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_database_file_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDatabase_file_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDatabase_file_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDatabase_file_spec(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDatabase_file_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func database_file_spec() throws -> Database_file_specContext {
		var _localctx: Database_file_specContext = Database_file_specContext(_ctx, getState())
		try enterRule(_localctx, 418, tsqlParser.RULE_database_file_spec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4235)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FILEGROUP:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4233)
		 		try file_group()

		 		break

		 	case .LR_BRACKET:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4234)
		 		try file_spec()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class File_groupContext:ParserRuleContext {
		open func FILEGROUP() -> TerminalNode? { return getToken(tsqlParser.Tokens.FILEGROUP.rawValue, 0) }
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func file_spec() -> Array<File_specContext> {
			return getRuleContexts(File_specContext.self)
		}
		open func file_spec(_ i: Int) -> File_specContext? {
			return getRuleContext(File_specContext.self,i)
		}
		open func CONTAINS() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.CONTAINS.rawValue) }
		open func CONTAINS(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.CONTAINS.rawValue, i)
		}
		open func FILESTREAM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FILESTREAM.rawValue, 0) }
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open func MEMORY_OPTIMIZED_DATA() -> TerminalNode? { return getToken(tsqlParser.Tokens.MEMORY_OPTIMIZED_DATA.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_file_group }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFile_group(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFile_group(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFile_group(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFile_group(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func file_group() throws -> File_groupContext {
		var _localctx: File_groupContext = File_groupContext(_ctx, getState())
		try enterRule(_localctx, 420, tsqlParser.RULE_file_group)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4237)
		 	try match(tsqlParser.Tokens.FILEGROUP.rawValue)
		 	setState(4238)
		 	try id()
		 	setState(4241)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,589,_ctx)) {
		 	case 1:
		 		setState(4239)
		 		try match(tsqlParser.Tokens.CONTAINS.rawValue)
		 		setState(4240)
		 		try match(tsqlParser.Tokens.FILESTREAM.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4244)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.DEFAULT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4243)
		 		try match(tsqlParser.Tokens.DEFAULT.rawValue)

		 	}

		 	setState(4248)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.CONTAINS.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4246)
		 		try match(tsqlParser.Tokens.CONTAINS.rawValue)
		 		setState(4247)
		 		try match(tsqlParser.Tokens.MEMORY_OPTIMIZED_DATA.rawValue)

		 	}

		 	setState(4250)
		 	try file_spec()
		 	setState(4255)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,592,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4251)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(4252)
		 			try file_spec()

		 	 
		 		}
		 		setState(4257)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,592,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class File_specContext:ParserRuleContext {
		public var file: Token!
		open func LR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.LR_BRACKET.rawValue, 0) }
		open func NAME() -> TerminalNode? { return getToken(tsqlParser.Tokens.NAME.rawValue, 0) }
		open func EQUAL() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.EQUAL.rawValue) }
		open func EQUAL(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.EQUAL.rawValue, i)
		}
		open func FILENAME() -> TerminalNode? { return getToken(tsqlParser.Tokens.FILENAME.rawValue, 0) }
		open func RR_BRACKET() -> TerminalNode? { return getToken(tsqlParser.Tokens.RR_BRACKET.rawValue, 0) }
		open func STRING() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.STRING.rawValue) }
		open func STRING(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.STRING.rawValue, i)
		}
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func SIZE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SIZE.rawValue, 0) }
		open func file_size() -> Array<File_sizeContext> {
			return getRuleContexts(File_sizeContext.self)
		}
		open func file_size(_ i: Int) -> File_sizeContext? {
			return getRuleContext(File_sizeContext.self,i)
		}
		open func MAXSIZE() -> TerminalNode? { return getToken(tsqlParser.Tokens.MAXSIZE.rawValue, 0) }
		open func FILEGROWTH() -> TerminalNode? { return getToken(tsqlParser.Tokens.FILEGROWTH.rawValue, 0) }
		open func UNLIMITED() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNLIMITED.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_file_spec }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFile_spec(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFile_spec(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFile_spec(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFile_spec(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func file_spec() throws -> File_specContext {
		var _localctx: File_specContext = File_specContext(_ctx, getState())
		try enterRule(_localctx, 422, tsqlParser.RULE_file_spec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4258)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(4259)
		 	try match(tsqlParser.Tokens.NAME.rawValue)
		 	setState(4260)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(4263)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .ID:
		 		setState(4261)
		 		try id()

		 		break

		 	case .STRING:
		 		setState(4262)
		 		try match(tsqlParser.Tokens.STRING.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4266)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4265)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)

		 	}

		 	setState(4268)
		 	try match(tsqlParser.Tokens.FILENAME.rawValue)
		 	setState(4269)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(4270)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 			_localctx.castdown(File_specContext.self).file = assignmentValue
		 	     }()

		 	setState(4272)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4271)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)

		 	}

		 	setState(4280)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.SIZE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4274)
		 		try match(tsqlParser.Tokens.SIZE.rawValue)
		 		setState(4275)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4276)
		 		try file_size()
		 		setState(4278)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4277)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}


		 	}

		 	setState(4291)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.MAXSIZE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4282)
		 		try match(tsqlParser.Tokens.MAXSIZE.rawValue)
		 		setState(4283)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4286)
		 		try _errHandler.sync(self)
		 		switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .DECIMAL:
		 			setState(4284)
		 			try file_size()

		 			break

		 		case .UNLIMITED:
		 			setState(4285)
		 			try match(tsqlParser.Tokens.UNLIMITED.rawValue)

		 			break
		 		default:
		 			throw try ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4289)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4288)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}


		 	}

		 	setState(4299)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.FILEGROWTH.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4293)
		 		try match(tsqlParser.Tokens.FILEGROWTH.rawValue)
		 		setState(4294)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)
		 		setState(4295)
		 		try file_size()
		 		setState(4297)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4296)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}


		 	}

		 	setState(4301)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Full_table_nameContext:ParserRuleContext {
		public var server: IdContext!
		public var database: IdContext!
		public var schema: IdContext!
		public var table: IdContext!
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_full_table_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFull_table_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFull_table_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFull_table_name(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFull_table_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func full_table_name() throws -> Full_table_nameContext {
		var _localctx: Full_table_nameContext = Full_table_nameContext(_ctx, getState())
		try enterRule(_localctx, 424, tsqlParser.RULE_full_table_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4320)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,604,_ctx)) {
		 	case 1:
		 		setState(4303)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Full_table_nameContext.self).server = assignmentValue
		 		     }()

		 		setState(4304)
		 		try match(tsqlParser.Tokens.DOT.rawValue)
		 		setState(4305)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Full_table_nameContext.self).database = assignmentValue
		 		     }()

		 		setState(4306)
		 		try match(tsqlParser.Tokens.DOT.rawValue)
		 		setState(4307)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Full_table_nameContext.self).schema = assignmentValue
		 		     }()

		 		setState(4308)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		break
		 	case 2:
		 		setState(4310)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Full_table_nameContext.self).database = assignmentValue
		 		     }()

		 		setState(4311)
		 		try match(tsqlParser.Tokens.DOT.rawValue)
		 		setState(4313)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 34)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue,tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.TARGET.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 142)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ABSOLUTE.rawValue,tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 232)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue,tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 296)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue,tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 360)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue,tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 426)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 493)
		 		          }()
		 		      return testSet
		 		 }()) {
		 			setState(4312)
		 			try {
		 					let assignmentValue = try id()
		 					_localctx.castdown(Full_table_nameContext.self).schema = assignmentValue
		 			     }()


		 		}

		 		setState(4315)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		break
		 	case 3:
		 		setState(4317)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Full_table_nameContext.self).schema = assignmentValue
		 		     }()

		 		setState(4318)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4322)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(Full_table_nameContext.self).table = assignmentValue
		 	     }()


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Table_nameContext:ParserRuleContext {
		public var database: IdContext!
		public var schema: IdContext!
		public var table: IdContext!
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_table_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterTable_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitTable_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitTable_name(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitTable_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func table_name() throws -> Table_nameContext {
		var _localctx: Table_nameContext = Table_nameContext(_ctx, getState())
		try enterRule(_localctx, 426, tsqlParser.RULE_table_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4334)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,606,_ctx)) {
		 	case 1:
		 		setState(4324)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Table_nameContext.self).database = assignmentValue
		 		     }()

		 		setState(4325)
		 		try match(tsqlParser.Tokens.DOT.rawValue)
		 		setState(4327)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 34)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue,tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.TARGET.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 142)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ABSOLUTE.rawValue,tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 232)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue,tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 296)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue,tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 360)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue,tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 426)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 493)
		 		          }()
		 		      return testSet
		 		 }()) {
		 			setState(4326)
		 			try {
		 					let assignmentValue = try id()
		 					_localctx.castdown(Table_nameContext.self).schema = assignmentValue
		 			     }()


		 		}

		 		setState(4329)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		break
		 	case 2:
		 		setState(4331)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Table_nameContext.self).schema = assignmentValue
		 		     }()

		 		setState(4332)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4336)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(Table_nameContext.self).table = assignmentValue
		 	     }()


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Simple_nameContext:ParserRuleContext {
		public var schema: IdContext!
		public var name: IdContext!
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_simple_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSimple_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSimple_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSimple_name(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSimple_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func simple_name() throws -> Simple_nameContext {
		var _localctx: Simple_nameContext = Simple_nameContext(_ctx, getState())
		try enterRule(_localctx, 428, tsqlParser.RULE_simple_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4341)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,607,_ctx)) {
		 	case 1:
		 		setState(4338)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Simple_nameContext.self).schema = assignmentValue
		 		     }()

		 		setState(4339)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4343)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(Simple_nameContext.self).name = assignmentValue
		 	     }()


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Func_proc_nameContext:ParserRuleContext {
		public var database: IdContext!
		public var schema: IdContext!
		public var procedure: IdContext!
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_func_proc_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFunc_proc_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFunc_proc_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFunc_proc_name(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFunc_proc_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func func_proc_name() throws -> Func_proc_nameContext {
		var _localctx: Func_proc_nameContext = Func_proc_nameContext(_ctx, getState())
		try enterRule(_localctx, 430, tsqlParser.RULE_func_proc_name)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4355)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,609,_ctx)) {
		 	case 1:
		 		setState(4345)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Func_proc_nameContext.self).database = assignmentValue
		 		     }()

		 		setState(4346)
		 		try match(tsqlParser.Tokens.DOT.rawValue)
		 		setState(4348)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 34)
		 		}()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue,tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.TARGET.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 142)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ABSOLUTE.rawValue,tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 232)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue,tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 296)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue,tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 360)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue,tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 426)
		 		          }()
		 		          testSet = testSet || {  () -> Bool in
		 		             let testArray: [Int] = [_la, tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue,tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue,tsqlParser.Tokens.ID.rawValue]
		 		              return  Utils.testBitLeftShiftArray(testArray, 493)
		 		          }()
		 		      return testSet
		 		 }()) {
		 			setState(4347)
		 			try {
		 					let assignmentValue = try id()
		 					_localctx.castdown(Func_proc_nameContext.self).schema = assignmentValue
		 			     }()


		 		}

		 		setState(4350)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		break
		 	case 2:
		 		setState(4352)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Func_proc_nameContext.self).schema = assignmentValue
		 		     }()


		 		setState(4353)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4357)
		 	try {
		 			let assignmentValue = try id()
		 			_localctx.castdown(Func_proc_nameContext.self).procedure = assignmentValue
		 	     }()


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Ddl_objectContext:ParserRuleContext {
		open func full_table_name() -> Full_table_nameContext? {
			return getRuleContext(Full_table_nameContext.self,0)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_ddl_object }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDdl_object(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDdl_object(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDdl_object(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDdl_object(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func ddl_object() throws -> Ddl_objectContext {
		var _localctx: Ddl_objectContext = Ddl_objectContext(_ctx, getState())
		try enterRule(_localctx, 432, tsqlParser.RULE_ddl_object)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4361)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4359)
		 		try full_table_name()

		 		break

		 	case .LOCAL_ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4360)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Full_column_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func table_name() -> Table_nameContext? {
			return getRuleContext(Table_nameContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_full_column_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFull_column_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFull_column_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFull_column_name(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFull_column_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func full_column_name() throws -> Full_column_nameContext {
		var _localctx: Full_column_nameContext = Full_column_nameContext(_ctx, getState())
		try enterRule(_localctx, 434, tsqlParser.RULE_full_column_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4366)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,611,_ctx)) {
		 	case 1:
		 		setState(4363)
		 		try table_name()
		 		setState(4364)
		 		try match(tsqlParser.Tokens.DOT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4368)
		 	try id()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_name_list_with_orderContext:ParserRuleContext {
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open func ASC() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ASC.rawValue) }
		open func ASC(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ASC.rawValue, i)
		}
		open func DESC() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.DESC.rawValue) }
		open func DESC(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.DESC.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_column_name_list_with_order }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterColumn_name_list_with_order(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitColumn_name_list_with_order(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitColumn_name_list_with_order(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitColumn_name_list_with_order(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_name_list_with_order() throws -> Column_name_list_with_orderContext {
		var _localctx: Column_name_list_with_orderContext = Column_name_list_with_orderContext(_ctx, getState())
		try enterRule(_localctx, 436, tsqlParser.RULE_column_name_list_with_order)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4370)
		 	try id()
		 	setState(4372)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.ASC.rawValue || _la == tsqlParser.Tokens.DESC.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4371)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ASC.rawValue || _la == tsqlParser.Tokens.DESC.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(4381)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4374)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(4375)
		 		try id()
		 		setState(4377)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ASC.rawValue || _la == tsqlParser.Tokens.DESC.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4376)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.ASC.rawValue || _la == tsqlParser.Tokens.DESC.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}



		 		setState(4383)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Column_name_listContext:ParserRuleContext {
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_column_name_list }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterColumn_name_list(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitColumn_name_list(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitColumn_name_list(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitColumn_name_list(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func column_name_list() throws -> Column_name_listContext {
		var _localctx: Column_name_listContext = Column_name_listContext(_ctx, getState())
		try enterRule(_localctx, 438, tsqlParser.RULE_column_name_list)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4384)
		 	try id()
		 	setState(4389)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4385)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(4386)
		 		try id()


		 		setState(4391)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Cursor_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_cursor_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterCursor_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitCursor_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitCursor_name(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitCursor_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func cursor_name() throws -> Cursor_nameContext {
		var _localctx: Cursor_nameContext = Cursor_nameContext(_ctx, getState())
		try enterRule(_localctx, 440, tsqlParser.RULE_cursor_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4394)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4392)
		 		try id()

		 		break

		 	case .LOCAL_ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4393)
		 		try match(tsqlParser.Tokens.LOCAL_ID.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class On_offContext:ParserRuleContext {
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_on_off }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterOn_off(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitOn_off(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitOn_off(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitOn_off(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func on_off() throws -> On_offContext {
		var _localctx: On_offContext = On_offContext(_ctx, getState())
		try enterRule(_localctx, 442, tsqlParser.RULE_on_off)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4396)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ClusteredContext:ParserRuleContext {
		open func CLUSTERED() -> TerminalNode? { return getToken(tsqlParser.Tokens.CLUSTERED.rawValue, 0) }
		open func NONCLUSTERED() -> TerminalNode? { return getToken(tsqlParser.Tokens.NONCLUSTERED.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_clustered }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterClustered(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitClustered(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitClustered(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitClustered(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func clustered() throws -> ClusteredContext {
		var _localctx: ClusteredContext = ClusteredContext(_ctx, getState())
		try enterRule(_localctx, 444, tsqlParser.RULE_clustered)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4398)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = _la == tsqlParser.Tokens.CLUSTERED.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.NONCLUSTERED.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Null_notnullContext:ParserRuleContext {
		open func NULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.NULL.rawValue, 0) }
		open func NOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NOT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_null_notnull }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterNull_notnull(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitNull_notnull(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitNull_notnull(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitNull_notnull(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func null_notnull() throws -> Null_notnullContext {
		var _localctx: Null_notnullContext = Null_notnullContext(_ctx, getState())
		try enterRule(_localctx, 446, tsqlParser.RULE_null_notnull)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4401)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.NOT.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4400)
		 		try match(tsqlParser.Tokens.NOT.rawValue)

		 	}

		 	setState(4403)
		 	try match(tsqlParser.Tokens.NULL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Null_or_defaultContext:ParserRuleContext {
		open func null_notnull() -> Null_notnullContext? {
			return getRuleContext(Null_notnullContext.self,0)
		}
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open func constant_expression() -> Constant_expressionContext? {
			return getRuleContext(Constant_expressionContext.self,0)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func VALUES() -> TerminalNode? { return getToken(tsqlParser.Tokens.VALUES.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_null_or_default }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterNull_or_default(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitNull_or_default(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitNull_or_default(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitNull_or_default(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func null_or_default() throws -> Null_or_defaultContext {
		var _localctx: Null_or_defaultContext = Null_or_defaultContext(_ctx, getState())
		try enterRule(_localctx, 448, tsqlParser.RULE_null_or_default)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4412)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NOT:fallthrough
		 	case .NULL:
		 		setState(4405)
		 		try null_notnull()

		 		break

		 	case .DEFAULT:
		 		setState(4406)
		 		try match(tsqlParser.Tokens.DEFAULT.rawValue)
		 		setState(4407)
		 		try constant_expression()
		 		setState(4410)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,618,_ctx)) {
		 		case 1:
		 			setState(4408)
		 			try match(tsqlParser.Tokens.WITH.rawValue)
		 			setState(4409)
		 			try match(tsqlParser.Tokens.VALUES.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Scalar_function_nameContext:ParserRuleContext {
		open func func_proc_name() -> Func_proc_nameContext? {
			return getRuleContext(Func_proc_nameContext.self,0)
		}
		open func RIGHT() -> TerminalNode? { return getToken(tsqlParser.Tokens.RIGHT.rawValue, 0) }
		open func LEFT() -> TerminalNode? { return getToken(tsqlParser.Tokens.LEFT.rawValue, 0) }
		open func BINARY_CHECKSUM() -> TerminalNode? { return getToken(tsqlParser.Tokens.BINARY_CHECKSUM.rawValue, 0) }
		open func CHECKSUM() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHECKSUM.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_scalar_function_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterScalar_function_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitScalar_function_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitScalar_function_name(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitScalar_function_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func scalar_function_name() throws -> Scalar_function_nameContext {
		var _localctx: Scalar_function_nameContext = Scalar_function_nameContext(_ctx, getState())
		try enterRule(_localctx, 450, tsqlParser.RULE_scalar_function_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4419)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .DOUBLE_QUOTE_ID:fallthrough
		 	case .SQUARE_BRACKET_ID:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4414)
		 		try func_proc_name()

		 		break

		 	case .RIGHT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4415)
		 		try match(tsqlParser.Tokens.RIGHT.rawValue)

		 		break

		 	case .LEFT:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4416)
		 		try match(tsqlParser.Tokens.LEFT.rawValue)

		 		break

		 	case .BINARY_CHECKSUM:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4417)
		 		try match(tsqlParser.Tokens.BINARY_CHECKSUM.rawValue)

		 		break

		 	case .CHECKSUM:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4418)
		 		try match(tsqlParser.Tokens.CHECKSUM.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Begin_conversation_timerContext:ParserRuleContext {
		open func BEGIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.BEGIN.rawValue, 0) }
		open func CONVERSATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONVERSATION.rawValue, 0) }
		open func TIMER() -> TerminalNode? { return getToken(tsqlParser.Tokens.TIMER.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open func TIMEOUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.TIMEOUT.rawValue, 0) }
		open func time() -> TimeContext? {
			return getRuleContext(TimeContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_begin_conversation_timer }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterBegin_conversation_timer(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitBegin_conversation_timer(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitBegin_conversation_timer(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitBegin_conversation_timer(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func begin_conversation_timer() throws -> Begin_conversation_timerContext {
		var _localctx: Begin_conversation_timerContext = Begin_conversation_timerContext(_ctx, getState())
		try enterRule(_localctx, 452, tsqlParser.RULE_begin_conversation_timer)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4421)
		 	try match(tsqlParser.Tokens.BEGIN.rawValue)
		 	setState(4422)
		 	try match(tsqlParser.Tokens.CONVERSATION.rawValue)
		 	setState(4423)
		 	try match(tsqlParser.Tokens.TIMER.rawValue)
		 	setState(4424)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(4425)
		 	try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 	setState(4426)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(4427)
		 	try match(tsqlParser.Tokens.TIMEOUT.rawValue)
		 	setState(4428)
		 	try match(tsqlParser.Tokens.EQUAL.rawValue)
		 	setState(4429)
		 	try time()
		 	setState(4431)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,621,_ctx)) {
		 	case 1:
		 		setState(4430)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Begin_conversation_dialogContext:ParserRuleContext {
		public var dialog_handle: Token!
		public var initiator_service_name: Service_nameContext!
		public var target_service_name: Service_nameContext!
		public var service_broker_guid: Token!
		open func BEGIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.BEGIN.rawValue, 0) }
		open func DIALOG() -> TerminalNode? { return getToken(tsqlParser.Tokens.DIALOG.rawValue, 0) }
		open func FROM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FROM.rawValue, 0) }
		open func SERVICE() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.SERVICE.rawValue) }
		open func SERVICE(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.SERVICE.rawValue, i)
		}
		open func TO() -> TerminalNode? { return getToken(tsqlParser.Tokens.TO.rawValue, 0) }
		open func ON() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.ON.rawValue) }
		open func ON(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.ON.rawValue, i)
		}
		open func CONTRACT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONTRACT.rawValue, 0) }
		open func contract_name() -> Contract_nameContext? {
			return getRuleContext(Contract_nameContext.self,0)
		}
		open func LOCAL_ID() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.LOCAL_ID.rawValue) }
		open func LOCAL_ID(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, i)
		}
		open func service_name() -> Array<Service_nameContext> {
			return getRuleContexts(Service_nameContext.self)
		}
		open func service_name(_ i: Int) -> Service_nameContext? {
			return getRuleContext(Service_nameContext.self,i)
		}
		open func CONVERSATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONVERSATION.rawValue, 0) }
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func LIFETIME() -> TerminalNode? { return getToken(tsqlParser.Tokens.LIFETIME.rawValue, 0) }
		open func ENCRYPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ENCRYPTION.rawValue, 0) }
		open func RELATED_CONVERSATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.RELATED_CONVERSATION.rawValue, 0) }
		open func RELATED_CONVERSATION_GROUP() -> TerminalNode? { return getToken(tsqlParser.Tokens.RELATED_CONVERSATION_GROUP.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func OFF() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFF.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_begin_conversation_dialog }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterBegin_conversation_dialog(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitBegin_conversation_dialog(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitBegin_conversation_dialog(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitBegin_conversation_dialog(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func begin_conversation_dialog() throws -> Begin_conversation_dialogContext {
		var _localctx: Begin_conversation_dialogContext = Begin_conversation_dialogContext(_ctx, getState())
		try enterRule(_localctx, 454, tsqlParser.RULE_begin_conversation_dialog)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4433)
		 	try match(tsqlParser.Tokens.BEGIN.rawValue)
		 	setState(4434)
		 	try match(tsqlParser.Tokens.DIALOG.rawValue)
		 	setState(4436)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.CONVERSATION.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4435)
		 		try match(tsqlParser.Tokens.CONVERSATION.rawValue)

		 	}

		 	setState(4438)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 			_localctx.castdown(Begin_conversation_dialogContext.self).dialog_handle = assignmentValue
		 	     }()

		 	setState(4439)
		 	try match(tsqlParser.Tokens.FROM.rawValue)
		 	setState(4440)
		 	try match(tsqlParser.Tokens.SERVICE.rawValue)
		 	setState(4441)
		 	try {
		 			let assignmentValue = try service_name()
		 			_localctx.castdown(Begin_conversation_dialogContext.self).initiator_service_name = assignmentValue
		 	     }()

		 	setState(4442)
		 	try match(tsqlParser.Tokens.TO.rawValue)
		 	setState(4443)
		 	try match(tsqlParser.Tokens.SERVICE.rawValue)
		 	setState(4444)
		 	try {
		 			let assignmentValue = try service_name()
		 			_localctx.castdown(Begin_conversation_dialogContext.self).target_service_name = assignmentValue
		 	     }()

		 	setState(4447)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4445)
		 		try match(tsqlParser.Tokens.COMMA.rawValue)
		 		setState(4446)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.STRING.rawValue)
		 				_localctx.castdown(Begin_conversation_dialogContext.self).service_broker_guid = assignmentValue
		 		     }()


		 	}

		 	setState(4449)
		 	try match(tsqlParser.Tokens.ON.rawValue)
		 	setState(4450)
		 	try match(tsqlParser.Tokens.CONTRACT.rawValue)
		 	setState(4451)
		 	try contract_name()
		 	setState(4474)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,629,_ctx)) {
		 	case 1:
		 		setState(4452)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(4459)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.RELATED_CONVERSATION.rawValue || _la == tsqlParser.Tokens.RELATED_CONVERSATION_GROUP.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4453)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.RELATED_CONVERSATION.rawValue || _la == tsqlParser.Tokens.RELATED_CONVERSATION_GROUP.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(4454)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(4455)
		 			try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 			setState(4457)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(4456)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)

		 			}


		 		}

		 		setState(4467)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.LIFETIME.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4461)
		 			try match(tsqlParser.Tokens.LIFETIME.rawValue)
		 			setState(4462)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(4463)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.DECIMAL.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(4465)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 			      return testSet
		 			 }()) {
		 				setState(4464)
		 				try match(tsqlParser.Tokens.COMMA.rawValue)

		 			}


		 		}

		 		setState(4472)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,628,_ctx)) {
		 		case 1:
		 			setState(4469)
		 			try match(tsqlParser.Tokens.ENCRYPTION.rawValue)
		 			setState(4470)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(4471)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.OFF.rawValue || _la == tsqlParser.Tokens.ON.rawValue
		 			      return testSet
		 			 }())) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		 	setState(4477)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,630,_ctx)) {
		 	case 1:
		 		setState(4476)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Contract_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_contract_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterContract_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitContract_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitContract_name(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitContract_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func contract_name() throws -> Contract_nameContext {
		var _localctx: Contract_nameContext = Contract_nameContext(_ctx, getState())
		try enterRule(_localctx, 456, tsqlParser.RULE_contract_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4481)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,631, _ctx)) {
		 	case 1:
		 		setState(4479)
		 		try id()

		 		break
		 	case 2:
		 		setState(4480)
		 		try expression(0)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Service_nameContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_service_name }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterService_name(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitService_name(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitService_name(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitService_name(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func service_name() throws -> Service_nameContext {
		var _localctx: Service_nameContext = Service_nameContext(_ctx, getState())
		try enterRule(_localctx, 458, tsqlParser.RULE_service_name)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4485)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,632, _ctx)) {
		 	case 1:
		 		setState(4483)
		 		try id()

		 		break
		 	case 2:
		 		setState(4484)
		 		try expression(0)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class End_conversationContext:ParserRuleContext {
		public var conversation_handle: Token!
		public var faliure_code: Token!
		public var failure_text: Token!
		open func END() -> TerminalNode? { return getToken(tsqlParser.Tokens.END.rawValue, 0) }
		open func CONVERSATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONVERSATION.rawValue, 0) }
		open func LOCAL_ID() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.LOCAL_ID.rawValue) }
		open func LOCAL_ID(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, i)
		}
		open func WITH() -> TerminalNode? { return getToken(tsqlParser.Tokens.WITH.rawValue, 0) }
		open func ERROR() -> TerminalNode? { return getToken(tsqlParser.Tokens.ERROR.rawValue, 0) }
		open func CLEANUP() -> TerminalNode? { return getToken(tsqlParser.Tokens.CLEANUP.rawValue, 0) }
		open func STRING() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.STRING.rawValue) }
		open func STRING(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.STRING.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_end_conversation }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterEnd_conversation(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitEnd_conversation(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitEnd_conversation(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitEnd_conversation(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func end_conversation() throws -> End_conversationContext {
		var _localctx: End_conversationContext = End_conversationContext(_ctx, getState())
		try enterRule(_localctx, 460, tsqlParser.RULE_end_conversation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4487)
		 	try match(tsqlParser.Tokens.END.rawValue)
		 	setState(4488)
		 	try match(tsqlParser.Tokens.CONVERSATION.rawValue)
		 	setState(4489)
		 	try {
		 			let assignmentValue = try match(tsqlParser.Tokens.LOCAL_ID.rawValue)
		 			_localctx.castdown(End_conversationContext.self).conversation_handle = assignmentValue
		 	     }()

		 	setState(4491)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,633,_ctx)) {
		 	case 1:
		 		setState(4490)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4505)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,636,_ctx)) {
		 	case 1:
		 		setState(4493)
		 		try match(tsqlParser.Tokens.WITH.rawValue)
		 		setState(4500)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.ERROR.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4494)
		 			try match(tsqlParser.Tokens.ERROR.rawValue)
		 			setState(4495)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(4496)
		 			_localctx.castdown(End_conversationContext.self).faliure_code = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.STRING.rawValue
		 			      return testSet
		 			 }())) {
		 				_localctx.castdown(End_conversationContext.self).faliure_code = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(4497)
		 			try match(tsqlParser.Tokens.T__15.rawValue)
		 			setState(4498)
		 			try match(tsqlParser.Tokens.EQUAL.rawValue)
		 			setState(4499)
		 			_localctx.castdown(End_conversationContext.self).failure_text = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(//closure
		 			 { () -> Bool in
		 			      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.STRING.rawValue
		 			      return testSet
		 			 }())) {
		 				_localctx.castdown(End_conversationContext.self).failure_text = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(4503)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.CLEANUP.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4502)
		 			try match(tsqlParser.Tokens.CLEANUP.rawValue)

		 		}


		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Waitfor_conversationContext:ParserRuleContext {
		public var timeout: TimeContext!
		open func get_conversation() -> Get_conversationContext? {
			return getRuleContext(Get_conversationContext.self,0)
		}
		open func WAITFOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.WAITFOR.rawValue, 0) }
		open func TIMEOUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.TIMEOUT.rawValue, 0) }
		open func time() -> TimeContext? {
			return getRuleContext(TimeContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_waitfor_conversation }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterWaitfor_conversation(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitWaitfor_conversation(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitWaitfor_conversation(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitWaitfor_conversation(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func waitfor_conversation() throws -> Waitfor_conversationContext {
		var _localctx: Waitfor_conversationContext = Waitfor_conversationContext(_ctx, getState())
		try enterRule(_localctx, 462, tsqlParser.RULE_waitfor_conversation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4508)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.WAITFOR.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4507)
		 		try match(tsqlParser.Tokens.WAITFOR.rawValue)

		 	}

		 	setState(4510)
		 	try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(4511)
		 	try get_conversation()
		 	setState(4512)
		 	try match(tsqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(4518)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.TIMEOUT.rawValue || _la == tsqlParser.Tokens.COMMA.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4514)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4513)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)

		 		}

		 		setState(4516)
		 		try match(tsqlParser.Tokens.TIMEOUT.rawValue)
		 		setState(4517)
		 		try {
		 				let assignmentValue = try time()
		 				_localctx.castdown(Waitfor_conversationContext.self).timeout = assignmentValue
		 		     }()


		 	}

		 	setState(4521)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,640,_ctx)) {
		 	case 1:
		 		setState(4520)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Get_conversationContext:ParserRuleContext {
		public var conversation_group_id: Token!
		public var queue: Queue_idContext!
		open func GET() -> TerminalNode? { return getToken(tsqlParser.Tokens.GET.rawValue, 0) }
		open func CONVERSATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONVERSATION.rawValue, 0) }
		open func GROUP() -> TerminalNode? { return getToken(tsqlParser.Tokens.GROUP.rawValue, 0) }
		open func FROM() -> TerminalNode? { return getToken(tsqlParser.Tokens.FROM.rawValue, 0) }
		open func queue_id() -> Queue_idContext? {
			return getRuleContext(Queue_idContext.self,0)
		}
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func LOCAL_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_get_conversation }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterGet_conversation(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitGet_conversation(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitGet_conversation(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitGet_conversation(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func get_conversation() throws -> Get_conversationContext {
		var _localctx: Get_conversationContext = Get_conversationContext(_ctx, getState())
		try enterRule(_localctx, 464, tsqlParser.RULE_get_conversation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4523)
		 	try match(tsqlParser.Tokens.GET.rawValue)
		 	setState(4524)
		 	try match(tsqlParser.Tokens.CONVERSATION.rawValue)
		 	setState(4525)
		 	try match(tsqlParser.Tokens.GROUP.rawValue)
		 	setState(4526)
		 	_localctx.castdown(Get_conversationContext.self).conversation_group_id = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.STRING.rawValue
		 	      return testSet
		 	 }())) {
		 		_localctx.castdown(Get_conversationContext.self).conversation_group_id = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4527)
		 	try match(tsqlParser.Tokens.FROM.rawValue)
		 	setState(4528)
		 	try {
		 			let assignmentValue = try queue_id()
		 			_localctx.castdown(Get_conversationContext.self).queue = assignmentValue
		 	     }()

		 	setState(4530)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,641,_ctx)) {
		 	case 1:
		 		setState(4529)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Queue_idContext:ParserRuleContext {
		public var database_name: IdContext!
		public var schema_name: IdContext!
		public var name: IdContext!
		open func id() -> Array<IdContext> {
			return getRuleContexts(IdContext.self)
		}
		open func id(_ i: Int) -> IdContext? {
			return getRuleContext(IdContext.self,i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_queue_id }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterQueue_id(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitQueue_id(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitQueue_id(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitQueue_id(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func queue_id() throws -> Queue_idContext {
		var _localctx: Queue_idContext = Queue_idContext(_ctx, getState())
		try enterRule(_localctx, 466, tsqlParser.RULE_queue_id)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4539)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,642, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4532)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Queue_idContext.self).database_name = assignmentValue
		 		     }()

		 		setState(4533)
		 		try match(tsqlParser.Tokens.DOT.rawValue)
		 		setState(4534)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Queue_idContext.self).schema_name = assignmentValue
		 		     }()

		 		setState(4535)
		 		try match(tsqlParser.Tokens.DOT.rawValue)
		 		setState(4536)
		 		try {
		 				let assignmentValue = try id()
		 				_localctx.castdown(Queue_idContext.self).name = assignmentValue
		 		     }()



		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4538)
		 		try id()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Send_conversationContext:ParserRuleContext {
		public var conversation_handle: Token!
		public var message_type_name: ExpressionContext!
		public var message_body_expression: Token!
		open func SEND() -> TerminalNode? { return getToken(tsqlParser.Tokens.SEND.rawValue, 0) }
		open func ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.ON.rawValue, 0) }
		open func CONVERSATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONVERSATION.rawValue, 0) }
		open func MESSAGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.MESSAGE.rawValue, 0) }
		open func TYPE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TYPE.rawValue, 0) }
		open func expression() -> ExpressionContext? {
			return getRuleContext(ExpressionContext.self,0)
		}
		open func STRING() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.STRING.rawValue) }
		open func STRING(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.STRING.rawValue, i)
		}
		open func LOCAL_ID() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.LOCAL_ID.rawValue) }
		open func LOCAL_ID(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.LOCAL_ID.rawValue, i)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_send_conversation }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSend_conversation(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSend_conversation(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSend_conversation(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSend_conversation(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func send_conversation() throws -> Send_conversationContext {
		var _localctx: Send_conversationContext = Send_conversationContext(_ctx, getState())
		try enterRule(_localctx, 468, tsqlParser.RULE_send_conversation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4541)
		 	try match(tsqlParser.Tokens.SEND.rawValue)
		 	setState(4542)
		 	try match(tsqlParser.Tokens.ON.rawValue)
		 	setState(4543)
		 	try match(tsqlParser.Tokens.CONVERSATION.rawValue)
		 	setState(4544)
		 	_localctx.castdown(Send_conversationContext.self).conversation_handle = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.STRING.rawValue
		 	      return testSet
		 	 }())) {
		 		_localctx.castdown(Send_conversationContext.self).conversation_handle = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4545)
		 	try match(tsqlParser.Tokens.MESSAGE.rawValue)
		 	setState(4546)
		 	try match(tsqlParser.Tokens.TYPE.rawValue)
		 	setState(4547)
		 	try {
		 			let assignmentValue = try expression(0)
		 			_localctx.castdown(Send_conversationContext.self).message_type_name = assignmentValue
		 	     }()

		 	setState(4551)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,643,_ctx)) {
		 	case 1:
		 		setState(4548)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4549)
		 		_localctx.castdown(Send_conversationContext.self).message_body_expression = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.LOCAL_ID.rawValue || _la == tsqlParser.Tokens.STRING.rawValue
		 		      return testSet
		 		 }())) {
		 			_localctx.castdown(Send_conversationContext.self).message_body_expression = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4550)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4554)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,644,_ctx)) {
		 	case 1:
		 		setState(4553)
		 		try match(tsqlParser.Tokens.SEMI.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Data_typeContext:ParserRuleContext {
		open func id() -> IdContext? {
			return getRuleContext(IdContext.self,0)
		}
		open func IDENTITY() -> TerminalNode? { return getToken(tsqlParser.Tokens.IDENTITY.rawValue, 0) }
		open func DECIMAL() -> Array<TerminalNode> { return getTokens(tsqlParser.Tokens.DECIMAL.rawValue) }
		open func DECIMAL(_ i:Int) -> TerminalNode?{
			return getToken(tsqlParser.Tokens.DECIMAL.rawValue, i)
		}
		open func MAX() -> TerminalNode? { return getToken(tsqlParser.Tokens.MAX.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_data_type }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterData_type(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitData_type(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitData_type(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitData_type(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func data_type() throws -> Data_typeContext {
		var _localctx: Data_typeContext = Data_typeContext(_ctx, getState())
		try enterRule(_localctx, 470, tsqlParser.RULE_data_type)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4556)
		 	try id()
		 	setState(4558)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,645,_ctx)) {
		 	case 1:
		 		setState(4557)
		 		try match(tsqlParser.Tokens.IDENTITY.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4567)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,647,_ctx)) {
		 	case 1:
		 		setState(4560)
		 		try match(tsqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4561)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = _la == tsqlParser.Tokens.MAX.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.DECIMAL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4564)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.COMMA.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4562)
		 			try match(tsqlParser.Tokens.COMMA.rawValue)
		 			setState(4563)
		 			try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 		}

		 		setState(4566)
		 		try match(tsqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Default_valueContext:ParserRuleContext {
		open func NULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.NULL.rawValue, 0) }
		open func DEFAULT() -> TerminalNode? { return getToken(tsqlParser.Tokens.DEFAULT.rawValue, 0) }
		open func constant() -> ConstantContext? {
			return getRuleContext(ConstantContext.self,0)
		}
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_default_value }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterDefault_value(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitDefault_value(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitDefault_value(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitDefault_value(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func default_value() throws -> Default_valueContext {
		var _localctx: Default_valueContext = Default_valueContext(_ctx, getState())
		try enterRule(_localctx, 472, tsqlParser.RULE_default_value)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4572)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NULL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4569)
		 		try match(tsqlParser.Tokens.NULL.rawValue)

		 		break

		 	case .DEFAULT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4570)
		 		try match(tsqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	case .DECIMAL:fallthrough
		 	case .STRING:fallthrough
		 	case .BINARY:fallthrough
		 	case .FLOAT:fallthrough
		 	case .REAL:fallthrough
		 	case .DOLLAR:fallthrough
		 	case .PLUS:fallthrough
		 	case .MINUS:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4571)
		 		try constant()

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class ConstantContext:ParserRuleContext {
		public var dollar: Token!
		open func STRING() -> TerminalNode? { return getToken(tsqlParser.Tokens.STRING.rawValue, 0) }
		open func BINARY() -> TerminalNode? { return getToken(tsqlParser.Tokens.BINARY.rawValue, 0) }
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func sign() -> SignContext? {
			return getRuleContext(SignContext.self,0)
		}
		open func REAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.REAL.rawValue, 0) }
		open func FLOAT() -> TerminalNode? { return getToken(tsqlParser.Tokens.FLOAT.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_constant }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterConstant(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitConstant(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitConstant(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitConstant(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func constant() throws -> ConstantContext {
		var _localctx: ConstantContext = ConstantContext(_ctx, getState())
		try enterRule(_localctx, 474, tsqlParser.RULE_constant)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4589)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,652, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4574)
		 		try match(tsqlParser.Tokens.STRING.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4575)
		 		try match(tsqlParser.Tokens.BINARY.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4577)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.PLUS.rawValue || _la == tsqlParser.Tokens.MINUS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4576)
		 			try sign()

		 		}

		 		setState(4579)
		 		try match(tsqlParser.Tokens.DECIMAL.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4581)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.PLUS.rawValue || _la == tsqlParser.Tokens.MINUS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4580)
		 			try sign()

		 		}

		 		setState(4583)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.FLOAT.rawValue || _la == tsqlParser.Tokens.REAL.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4585)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.PLUS.rawValue || _la == tsqlParser.Tokens.MINUS.rawValue
		 		      return testSet
		 		 }()) {
		 			setState(4584)
		 			try sign()

		 		}

		 		setState(4587)
		 		try {
		 				let assignmentValue = try match(tsqlParser.Tokens.DOLLAR.rawValue)
		 				_localctx.castdown(ConstantContext.self).dollar = assignmentValue
		 		     }()

		 		setState(4588)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      let testSet: Bool = _la == tsqlParser.Tokens.DECIMAL.rawValue || _la == tsqlParser.Tokens.FLOAT.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class SignContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_sign }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSign(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSign(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSign(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSign(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func sign() throws -> SignContext {
		var _localctx: SignContext = SignContext(_ctx, getState())
		try enterRule(_localctx, 476, tsqlParser.RULE_sign)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4591)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = _la == tsqlParser.Tokens.PLUS.rawValue || _la == tsqlParser.Tokens.MINUS.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class IdContext:ParserRuleContext {
		open func simple_id() -> Simple_idContext? {
			return getRuleContext(Simple_idContext.self,0)
		}
		open func DOUBLE_QUOTE_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue, 0) }
		open func SQUARE_BRACKET_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_id }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterId(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitId(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitId(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitId(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func id() throws -> IdContext {
		var _localctx: IdContext = IdContext(_ctx, getState())
		try enterRule(_localctx, 478, tsqlParser.RULE_id)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4596)
		 	try _errHandler.sync(self)
		 	switch (tsqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CALLED:fallthrough
		 	case .DATA_COMPRESSION:fallthrough
		 	case .EVENTDATA:fallthrough
		 	case .FILLFACTOR:fallthrough
		 	case .FORCESEEK:fallthrough
		 	case .OFFSETS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PUBLIC:fallthrough
		 	case .RAW:fallthrough
		 	case .RETURN:fallthrough
		 	case .RETURNS:fallthrough
		 	case .ROWCOUNT:fallthrough
		 	case .SERVER:fallthrough
		 	case .SOURCE:fallthrough
		 	case .TARGET:fallthrough
		 	case .ABSOLUTE:fallthrough
		 	case .APPLY:fallthrough
		 	case .AUTO:fallthrough
		 	case .AVG:fallthrough
		 	case .CALLER:fallthrough
		 	case .CAST:fallthrough
		 	case .CATCH:fallthrough
		 	case .CHECKSUM_AGG:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_NULL_YIELDS_NULL:fallthrough
		 	case .CONTROL:fallthrough
		 	case .COOKIE:fallthrough
		 	case .COUNT:fallthrough
		 	case .COUNT_BIG:fallthrough
		 	case .DELAY:fallthrough
		 	case .DELETED:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .EXPAND:fallthrough
		 	case .FAST:fallthrough
		 	case .FAST_FORWARD:fallthrough
		 	case .FIRST:fallthrough
		 	case .FOLLOWING:fallthrough
		 	case .FORCE:fallthrough
		 	case .FORCED:fallthrough
		 	case .FORWARD_ONLY:fallthrough
		 	case .FULLSCAN:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GROUPING:fallthrough
		 	case .GROUPING_ID:fallthrough
		 	case .HASH:fallthrough
		 	case .IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX:fallthrough
		 	case .IMPERSONATE:fallthrough
		 	case .INPUT:fallthrough
		 	case .INSENSITIVE:fallthrough
		 	case .INSERTED:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .KEEP:fallthrough
		 	case .KEEPFIXED:fallthrough
		 	case .KEYSET:fallthrough
		 	case .LAST:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOCK_ESCALATION:fallthrough
		 	case .LOGIN:fallthrough
		 	case .LOOP:fallthrough
		 	case .MARK:fallthrough
		 	case .MAX:fallthrough
		 	case .MAXDOP:fallthrough
		 	case .MAXRECURSION:fallthrough
		 	case .MIN:fallthrough
		 	case .MODIFY:fallthrough
		 	case .NAME:fallthrough
		 	case .NEXT:fallthrough
		 	case .NOCOUNT:fallthrough
		 	case .NOEXPAND:fallthrough
		 	case .NORECOMPUTE:fallthrough
		 	case .NTILE:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OFFSET:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPTIMISTIC:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OUT:fallthrough
		 	case .OUTPUT:fallthrough
		 	case .OWNER:fallthrough
		 	case .PARAMETERIZATION:fallthrough
		 	case .PARTITION:fallthrough
		 	case .PATH:fallthrough
		 	case .PRECEDING:fallthrough
		 	case .PRIOR:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .RANGE:fallthrough
		 	case .RANK:fallthrough
		 	case .READONLY:fallthrough
		 	case .READ_ONLY:fallthrough
		 	case .RECOMPILE:fallthrough
		 	case .RELATIVE:fallthrough
		 	case .REMOTE:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .ROBUST:fallthrough
		 	case .ROOT:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWGUID:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .SAMPLE:fallthrough
		 	case .SCHEMABINDING:fallthrough
		 	case .SCROLL:fallthrough
		 	case .SCROLL_LOCKS:fallthrough
		 	case .SELF:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SIZE:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SPATIAL_WINDOW_MAX_CELLS:fallthrough
		 	case .STATIC:fallthrough
		 	case .STATS_STREAM:fallthrough
		 	case .STDEV:fallthrough
		 	case .STDEVP:fallthrough
		 	case .SUM:fallthrough
		 	case .TEXTIMAGE_ON:fallthrough
		 	case .THROW:fallthrough
		 	case .TIES:fallthrough
		 	case .TIME:fallthrough
		 	case .TRY:fallthrough
		 	case .TYPE:fallthrough
		 	case .TYPE_WARNING:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .USING:fallthrough
		 	case .VAR:fallthrough
		 	case .VARP:fallthrough
		 	case .VIEWS:fallthrough
		 	case .VIEW_METADATA:fallthrough
		 	case .WORK:fallthrough
		 	case .XML:fallthrough
		 	case .XMLNAMESPACES:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4593)
		 		try simple_id()

		 		break

		 	case .DOUBLE_QUOTE_ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4594)
		 		try match(tsqlParser.Tokens.DOUBLE_QUOTE_ID.rawValue)

		 		break

		 	case .SQUARE_BRACKET_ID:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4595)
		 		try match(tsqlParser.Tokens.SQUARE_BRACKET_ID.rawValue)

		 		break
		 	default:
		 		throw try ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Simple_idContext:ParserRuleContext {
		open func ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.ID.rawValue, 0) }
		open func ABSOLUTE() -> TerminalNode? { return getToken(tsqlParser.Tokens.ABSOLUTE.rawValue, 0) }
		open func APPLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.APPLY.rawValue, 0) }
		open func AUTO() -> TerminalNode? { return getToken(tsqlParser.Tokens.AUTO.rawValue, 0) }
		open func AVG() -> TerminalNode? { return getToken(tsqlParser.Tokens.AVG.rawValue, 0) }
		open func CALLED() -> TerminalNode? { return getToken(tsqlParser.Tokens.CALLED.rawValue, 0) }
		open func CALLER() -> TerminalNode? { return getToken(tsqlParser.Tokens.CALLER.rawValue, 0) }
		open func CAST() -> TerminalNode? { return getToken(tsqlParser.Tokens.CAST.rawValue, 0) }
		open func CATCH() -> TerminalNode? { return getToken(tsqlParser.Tokens.CATCH.rawValue, 0) }
		open func CHECKSUM_AGG() -> TerminalNode? { return getToken(tsqlParser.Tokens.CHECKSUM_AGG.rawValue, 0) }
		open func COMMITTED() -> TerminalNode? { return getToken(tsqlParser.Tokens.COMMITTED.rawValue, 0) }
		open func CONCAT() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONCAT.rawValue, 0) }
		open func CONCAT_NULL_YIELDS_NULL() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue, 0) }
		open func CONTROL() -> TerminalNode? { return getToken(tsqlParser.Tokens.CONTROL.rawValue, 0) }
		open func COOKIE() -> TerminalNode? { return getToken(tsqlParser.Tokens.COOKIE.rawValue, 0) }
		open func COUNT() -> TerminalNode? { return getToken(tsqlParser.Tokens.COUNT.rawValue, 0) }
		open func COUNT_BIG() -> TerminalNode? { return getToken(tsqlParser.Tokens.COUNT_BIG.rawValue, 0) }
		open func DATA_COMPRESSION() -> TerminalNode? { return getToken(tsqlParser.Tokens.DATA_COMPRESSION.rawValue, 0) }
		open func DELAY() -> TerminalNode? { return getToken(tsqlParser.Tokens.DELAY.rawValue, 0) }
		open func DELETED() -> TerminalNode? { return getToken(tsqlParser.Tokens.DELETED.rawValue, 0) }
		open func DENSE_RANK() -> TerminalNode? { return getToken(tsqlParser.Tokens.DENSE_RANK.rawValue, 0) }
		open func DISABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.DISABLE.rawValue, 0) }
		open func DYNAMIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.DYNAMIC.rawValue, 0) }
		open func ENCRYPTION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ENCRYPTION.rawValue, 0) }
		open func EVENTDATA() -> TerminalNode? { return getToken(tsqlParser.Tokens.EVENTDATA.rawValue, 0) }
		open func EXPAND() -> TerminalNode? { return getToken(tsqlParser.Tokens.EXPAND.rawValue, 0) }
		open func FAST() -> TerminalNode? { return getToken(tsqlParser.Tokens.FAST.rawValue, 0) }
		open func FAST_FORWARD() -> TerminalNode? { return getToken(tsqlParser.Tokens.FAST_FORWARD.rawValue, 0) }
		open func FILLFACTOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.FILLFACTOR.rawValue, 0) }
		open func FIRST() -> TerminalNode? { return getToken(tsqlParser.Tokens.FIRST.rawValue, 0) }
		open func FOLLOWING() -> TerminalNode? { return getToken(tsqlParser.Tokens.FOLLOWING.rawValue, 0) }
		open func FORCE() -> TerminalNode? { return getToken(tsqlParser.Tokens.FORCE.rawValue, 0) }
		open func FORCESEEK() -> TerminalNode? { return getToken(tsqlParser.Tokens.FORCESEEK.rawValue, 0) }
		open func FORWARD_ONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.FORWARD_ONLY.rawValue, 0) }
		open func FULLSCAN() -> TerminalNode? { return getToken(tsqlParser.Tokens.FULLSCAN.rawValue, 0) }
		open func GLOBAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.GLOBAL.rawValue, 0) }
		open func GROUPING() -> TerminalNode? { return getToken(tsqlParser.Tokens.GROUPING.rawValue, 0) }
		open func GROUPING_ID() -> TerminalNode? { return getToken(tsqlParser.Tokens.GROUPING_ID.rawValue, 0) }
		open func HASH() -> TerminalNode? { return getToken(tsqlParser.Tokens.HASH.rawValue, 0) }
		open func IMPERSONATE() -> TerminalNode? { return getToken(tsqlParser.Tokens.IMPERSONATE.rawValue, 0) }
		open func INSENSITIVE() -> TerminalNode? { return getToken(tsqlParser.Tokens.INSENSITIVE.rawValue, 0) }
		open func INSERTED() -> TerminalNode? { return getToken(tsqlParser.Tokens.INSERTED.rawValue, 0) }
		open func ISOLATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.ISOLATION.rawValue, 0) }
		open func KEEP() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEEP.rawValue, 0) }
		open func KEEPFIXED() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEEPFIXED.rawValue, 0) }
		open func FORCED() -> TerminalNode? { return getToken(tsqlParser.Tokens.FORCED.rawValue, 0) }
		open func KEYSET() -> TerminalNode? { return getToken(tsqlParser.Tokens.KEYSET.rawValue, 0) }
		open func IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX() -> TerminalNode? { return getToken(tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue, 0) }
		open func INPUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.INPUT.rawValue, 0) }
		open func LAST() -> TerminalNode? { return getToken(tsqlParser.Tokens.LAST.rawValue, 0) }
		open func LEVEL() -> TerminalNode? { return getToken(tsqlParser.Tokens.LEVEL.rawValue, 0) }
		open func LOCAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCAL.rawValue, 0) }
		open func LOCK_ESCALATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOCK_ESCALATION.rawValue, 0) }
		open func LOGIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOGIN.rawValue, 0) }
		open func LOOP() -> TerminalNode? { return getToken(tsqlParser.Tokens.LOOP.rawValue, 0) }
		open func MARK() -> TerminalNode? { return getToken(tsqlParser.Tokens.MARK.rawValue, 0) }
		open func MAX() -> TerminalNode? { return getToken(tsqlParser.Tokens.MAX.rawValue, 0) }
		open func MAXDOP() -> TerminalNode? { return getToken(tsqlParser.Tokens.MAXDOP.rawValue, 0) }
		open func MAXRECURSION() -> TerminalNode? { return getToken(tsqlParser.Tokens.MAXRECURSION.rawValue, 0) }
		open func MIN() -> TerminalNode? { return getToken(tsqlParser.Tokens.MIN.rawValue, 0) }
		open func MODIFY() -> TerminalNode? { return getToken(tsqlParser.Tokens.MODIFY.rawValue, 0) }
		open func NAME() -> TerminalNode? { return getToken(tsqlParser.Tokens.NAME.rawValue, 0) }
		open func NEXT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NEXT.rawValue, 0) }
		open func NOCOUNT() -> TerminalNode? { return getToken(tsqlParser.Tokens.NOCOUNT.rawValue, 0) }
		open func NOEXPAND() -> TerminalNode? { return getToken(tsqlParser.Tokens.NOEXPAND.rawValue, 0) }
		open func NORECOMPUTE() -> TerminalNode? { return getToken(tsqlParser.Tokens.NORECOMPUTE.rawValue, 0) }
		open func NTILE() -> TerminalNode? { return getToken(tsqlParser.Tokens.NTILE.rawValue, 0) }
		open func NUMBER() -> TerminalNode? { return getToken(tsqlParser.Tokens.NUMBER.rawValue, 0) }
		open func OFFSET() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFFSET.rawValue, 0) }
		open func OFFSETS() -> TerminalNode? { return getToken(tsqlParser.Tokens.OFFSETS.rawValue, 0) }
		open func ONLINE() -> TerminalNode? { return getToken(tsqlParser.Tokens.ONLINE.rawValue, 0) }
		open func ONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.ONLY.rawValue, 0) }
		open func OPTIMISTIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPTIMISTIC.rawValue, 0) }
		open func OPTIMIZE() -> TerminalNode? { return getToken(tsqlParser.Tokens.OPTIMIZE.rawValue, 0) }
		open func OUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.OUT.rawValue, 0) }
		open func OUTPUT() -> TerminalNode? { return getToken(tsqlParser.Tokens.OUTPUT.rawValue, 0) }
		open func OWNER() -> TerminalNode? { return getToken(tsqlParser.Tokens.OWNER.rawValue, 0) }
		open func PAGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.PAGE.rawValue, 0) }
		open func PARAMETERIZATION() -> TerminalNode? { return getToken(tsqlParser.Tokens.PARAMETERIZATION.rawValue, 0) }
		open func PARTITION() -> TerminalNode? { return getToken(tsqlParser.Tokens.PARTITION.rawValue, 0) }
		open func PATH() -> TerminalNode? { return getToken(tsqlParser.Tokens.PATH.rawValue, 0) }
		open func PRECEDING() -> TerminalNode? { return getToken(tsqlParser.Tokens.PRECEDING.rawValue, 0) }
		open func PRIOR() -> TerminalNode? { return getToken(tsqlParser.Tokens.PRIOR.rawValue, 0) }
		open func PRIVILEGES() -> TerminalNode? { return getToken(tsqlParser.Tokens.PRIVILEGES.rawValue, 0) }
		open func PUBLIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.PUBLIC.rawValue, 0) }
		open func RANGE() -> TerminalNode? { return getToken(tsqlParser.Tokens.RANGE.rawValue, 0) }
		open func RANK() -> TerminalNode? { return getToken(tsqlParser.Tokens.RANK.rawValue, 0) }
		open func RAW() -> TerminalNode? { return getToken(tsqlParser.Tokens.RAW.rawValue, 0) }
		open func READONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.READONLY.rawValue, 0) }
		open func READ_ONLY() -> TerminalNode? { return getToken(tsqlParser.Tokens.READ_ONLY.rawValue, 0) }
		open func RECOMPILE() -> TerminalNode? { return getToken(tsqlParser.Tokens.RECOMPILE.rawValue, 0) }
		open func RELATIVE() -> TerminalNode? { return getToken(tsqlParser.Tokens.RELATIVE.rawValue, 0) }
		open func REMOTE() -> TerminalNode? { return getToken(tsqlParser.Tokens.REMOTE.rawValue, 0) }
		open func REPEATABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.REPEATABLE.rawValue, 0) }
		open func RETURN() -> TerminalNode? { return getToken(tsqlParser.Tokens.RETURN.rawValue, 0) }
		open func RETURNS() -> TerminalNode? { return getToken(tsqlParser.Tokens.RETURNS.rawValue, 0) }
		open func ROBUST() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROBUST.rawValue, 0) }
		open func ROOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROOT.rawValue, 0) }
		open func ROW() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROW.rawValue, 0) }
		open func ROWCOUNT() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROWCOUNT.rawValue, 0) }
		open func ROWGUID() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROWGUID.rawValue, 0) }
		open func ROWS() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROWS.rawValue, 0) }
		open func ROW_NUMBER() -> TerminalNode? { return getToken(tsqlParser.Tokens.ROW_NUMBER.rawValue, 0) }
		open func SAMPLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SAMPLE.rawValue, 0) }
		open func SIZE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SIZE.rawValue, 0) }
		open func SCHEMABINDING() -> TerminalNode? { return getToken(tsqlParser.Tokens.SCHEMABINDING.rawValue, 0) }
		open func SCROLL() -> TerminalNode? { return getToken(tsqlParser.Tokens.SCROLL.rawValue, 0) }
		open func SCROLL_LOCKS() -> TerminalNode? { return getToken(tsqlParser.Tokens.SCROLL_LOCKS.rawValue, 0) }
		open func SELF() -> TerminalNode? { return getToken(tsqlParser.Tokens.SELF.rawValue, 0) }
		open func SERIALIZABLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SERIALIZABLE.rawValue, 0) }
		open func SERVER() -> TerminalNode? { return getToken(tsqlParser.Tokens.SERVER.rawValue, 0) }
		open func SIMPLE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SIMPLE.rawValue, 0) }
		open func SNAPSHOT() -> TerminalNode? { return getToken(tsqlParser.Tokens.SNAPSHOT.rawValue, 0) }
		open func SOURCE() -> TerminalNode? { return getToken(tsqlParser.Tokens.SOURCE.rawValue, 0) }
		open func SPATIAL_WINDOW_MAX_CELLS() -> TerminalNode? { return getToken(tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue, 0) }
		open func STATIC() -> TerminalNode? { return getToken(tsqlParser.Tokens.STATIC.rawValue, 0) }
		open func STATS_STREAM() -> TerminalNode? { return getToken(tsqlParser.Tokens.STATS_STREAM.rawValue, 0) }
		open func STDEV() -> TerminalNode? { return getToken(tsqlParser.Tokens.STDEV.rawValue, 0) }
		open func STDEVP() -> TerminalNode? { return getToken(tsqlParser.Tokens.STDEVP.rawValue, 0) }
		open func SUM() -> TerminalNode? { return getToken(tsqlParser.Tokens.SUM.rawValue, 0) }
		open func TARGET() -> TerminalNode? { return getToken(tsqlParser.Tokens.TARGET.rawValue, 0) }
		open func TEXTIMAGE_ON() -> TerminalNode? { return getToken(tsqlParser.Tokens.TEXTIMAGE_ON.rawValue, 0) }
		open func THROW() -> TerminalNode? { return getToken(tsqlParser.Tokens.THROW.rawValue, 0) }
		open func TIES() -> TerminalNode? { return getToken(tsqlParser.Tokens.TIES.rawValue, 0) }
		open func TIME() -> TerminalNode? { return getToken(tsqlParser.Tokens.TIME.rawValue, 0) }
		open func TRY() -> TerminalNode? { return getToken(tsqlParser.Tokens.TRY.rawValue, 0) }
		open func TYPE() -> TerminalNode? { return getToken(tsqlParser.Tokens.TYPE.rawValue, 0) }
		open func TYPE_WARNING() -> TerminalNode? { return getToken(tsqlParser.Tokens.TYPE_WARNING.rawValue, 0) }
		open func UNBOUNDED() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNBOUNDED.rawValue, 0) }
		open func UNCOMMITTED() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNCOMMITTED.rawValue, 0) }
		open func UNKNOWN() -> TerminalNode? { return getToken(tsqlParser.Tokens.UNKNOWN.rawValue, 0) }
		open func USING() -> TerminalNode? { return getToken(tsqlParser.Tokens.USING.rawValue, 0) }
		open func VAR() -> TerminalNode? { return getToken(tsqlParser.Tokens.VAR.rawValue, 0) }
		open func VARP() -> TerminalNode? { return getToken(tsqlParser.Tokens.VARP.rawValue, 0) }
		open func VIEW_METADATA() -> TerminalNode? { return getToken(tsqlParser.Tokens.VIEW_METADATA.rawValue, 0) }
		open func VIEWS() -> TerminalNode? { return getToken(tsqlParser.Tokens.VIEWS.rawValue, 0) }
		open func WORK() -> TerminalNode? { return getToken(tsqlParser.Tokens.WORK.rawValue, 0) }
		open func XML() -> TerminalNode? { return getToken(tsqlParser.Tokens.XML.rawValue, 0) }
		open func XMLNAMESPACES() -> TerminalNode? { return getToken(tsqlParser.Tokens.XMLNAMESPACES.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_simple_id }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterSimple_id(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitSimple_id(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitSimple_id(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitSimple_id(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func simple_id() throws -> Simple_idContext {
		var _localctx: Simple_idContext = Simple_idContext(_ctx, getState())
		try enterRule(_localctx, 480, tsqlParser.RULE_simple_id)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4598)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, tsqlParser.Tokens.CALLED.rawValue,tsqlParser.Tokens.DATA_COMPRESSION.rawValue,tsqlParser.Tokens.EVENTDATA.rawValue,tsqlParser.Tokens.FILLFACTOR.rawValue,tsqlParser.Tokens.FORCESEEK.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 34)
		 	}()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.OFFSETS.rawValue,tsqlParser.Tokens.PAGE.rawValue,tsqlParser.Tokens.PUBLIC.rawValue,tsqlParser.Tokens.RAW.rawValue,tsqlParser.Tokens.RETURN.rawValue,tsqlParser.Tokens.RETURNS.rawValue,tsqlParser.Tokens.ROWCOUNT.rawValue,tsqlParser.Tokens.SERVER.rawValue,tsqlParser.Tokens.SOURCE.rawValue,tsqlParser.Tokens.TARGET.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 142)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.ABSOLUTE.rawValue,tsqlParser.Tokens.APPLY.rawValue,tsqlParser.Tokens.AUTO.rawValue,tsqlParser.Tokens.AVG.rawValue,tsqlParser.Tokens.CALLER.rawValue,tsqlParser.Tokens.CAST.rawValue,tsqlParser.Tokens.CATCH.rawValue,tsqlParser.Tokens.CHECKSUM_AGG.rawValue,tsqlParser.Tokens.COMMITTED.rawValue,tsqlParser.Tokens.CONCAT.rawValue,tsqlParser.Tokens.CONCAT_NULL_YIELDS_NULL.rawValue,tsqlParser.Tokens.CONTROL.rawValue,tsqlParser.Tokens.COOKIE.rawValue,tsqlParser.Tokens.COUNT.rawValue,tsqlParser.Tokens.COUNT_BIG.rawValue,tsqlParser.Tokens.DELAY.rawValue,tsqlParser.Tokens.DELETED.rawValue,tsqlParser.Tokens.DENSE_RANK.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 232)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.DISABLE.rawValue,tsqlParser.Tokens.DYNAMIC.rawValue,tsqlParser.Tokens.ENCRYPTION.rawValue,tsqlParser.Tokens.EXPAND.rawValue,tsqlParser.Tokens.FAST.rawValue,tsqlParser.Tokens.FAST_FORWARD.rawValue,tsqlParser.Tokens.FIRST.rawValue,tsqlParser.Tokens.FOLLOWING.rawValue,tsqlParser.Tokens.FORCE.rawValue,tsqlParser.Tokens.FORCED.rawValue,tsqlParser.Tokens.FORWARD_ONLY.rawValue,tsqlParser.Tokens.FULLSCAN.rawValue,tsqlParser.Tokens.GLOBAL.rawValue,tsqlParser.Tokens.GROUPING.rawValue,tsqlParser.Tokens.GROUPING_ID.rawValue,tsqlParser.Tokens.HASH.rawValue,tsqlParser.Tokens.IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX.rawValue,tsqlParser.Tokens.IMPERSONATE.rawValue,tsqlParser.Tokens.INPUT.rawValue,tsqlParser.Tokens.INSENSITIVE.rawValue,tsqlParser.Tokens.INSERTED.rawValue,tsqlParser.Tokens.ISOLATION.rawValue,tsqlParser.Tokens.KEEP.rawValue,tsqlParser.Tokens.KEEPFIXED.rawValue,tsqlParser.Tokens.KEYSET.rawValue,tsqlParser.Tokens.LAST.rawValue,tsqlParser.Tokens.LEVEL.rawValue,tsqlParser.Tokens.LOCAL.rawValue,tsqlParser.Tokens.LOCK_ESCALATION.rawValue,tsqlParser.Tokens.LOGIN.rawValue,tsqlParser.Tokens.LOOP.rawValue,tsqlParser.Tokens.MARK.rawValue,tsqlParser.Tokens.MAX.rawValue,tsqlParser.Tokens.MAXDOP.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 296)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.MAXRECURSION.rawValue,tsqlParser.Tokens.MIN.rawValue,tsqlParser.Tokens.MODIFY.rawValue,tsqlParser.Tokens.NAME.rawValue,tsqlParser.Tokens.NEXT.rawValue,tsqlParser.Tokens.NOCOUNT.rawValue,tsqlParser.Tokens.NOEXPAND.rawValue,tsqlParser.Tokens.NORECOMPUTE.rawValue,tsqlParser.Tokens.NTILE.rawValue,tsqlParser.Tokens.NUMBER.rawValue,tsqlParser.Tokens.OFFSET.rawValue,tsqlParser.Tokens.ONLINE.rawValue,tsqlParser.Tokens.ONLY.rawValue,tsqlParser.Tokens.OPTIMISTIC.rawValue,tsqlParser.Tokens.OPTIMIZE.rawValue,tsqlParser.Tokens.OUT.rawValue,tsqlParser.Tokens.OUTPUT.rawValue,tsqlParser.Tokens.OWNER.rawValue,tsqlParser.Tokens.PARAMETERIZATION.rawValue,tsqlParser.Tokens.PARTITION.rawValue,tsqlParser.Tokens.PATH.rawValue,tsqlParser.Tokens.PRECEDING.rawValue,tsqlParser.Tokens.PRIOR.rawValue,tsqlParser.Tokens.PRIVILEGES.rawValue,tsqlParser.Tokens.RANGE.rawValue,tsqlParser.Tokens.RANK.rawValue,tsqlParser.Tokens.READONLY.rawValue,tsqlParser.Tokens.READ_ONLY.rawValue,tsqlParser.Tokens.RECOMPILE.rawValue,tsqlParser.Tokens.RELATIVE.rawValue,tsqlParser.Tokens.REMOTE.rawValue,tsqlParser.Tokens.REPEATABLE.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 360)
		 	          }()
		 	          testSet = testSet || {  () -> Bool in
		 	             let testArray: [Int] = [_la, tsqlParser.Tokens.ROBUST.rawValue,tsqlParser.Tokens.ROOT.rawValue,tsqlParser.Tokens.ROW.rawValue,tsqlParser.Tokens.ROWGUID.rawValue,tsqlParser.Tokens.ROWS.rawValue,tsqlParser.Tokens.ROW_NUMBER.rawValue,tsqlParser.Tokens.SAMPLE.rawValue,tsqlParser.Tokens.SCHEMABINDING.rawValue,tsqlParser.Tokens.SCROLL.rawValue,tsqlParser.Tokens.SCROLL_LOCKS.rawValue,tsqlParser.Tokens.SELF.rawValue,tsqlParser.Tokens.SERIALIZABLE.rawValue,tsqlParser.Tokens.SIMPLE.rawValue,tsqlParser.Tokens.SIZE.rawValue,tsqlParser.Tokens.SNAPSHOT.rawValue,tsqlParser.Tokens.SPATIAL_WINDOW_MAX_CELLS.rawValue,tsqlParser.Tokens.STATIC.rawValue,tsqlParser.Tokens.STATS_STREAM.rawValue,tsqlParser.Tokens.STDEV.rawValue,tsqlParser.Tokens.STDEVP.rawValue,tsqlParser.Tokens.SUM.rawValue,tsqlParser.Tokens.TEXTIMAGE_ON.rawValue,tsqlParser.Tokens.THROW.rawValue,tsqlParser.Tokens.TIES.rawValue,tsqlParser.Tokens.TIME.rawValue,tsqlParser.Tokens.TRY.rawValue,tsqlParser.Tokens.TYPE.rawValue,tsqlParser.Tokens.TYPE_WARNING.rawValue,tsqlParser.Tokens.UNBOUNDED.rawValue,tsqlParser.Tokens.UNCOMMITTED.rawValue,tsqlParser.Tokens.UNKNOWN.rawValue,tsqlParser.Tokens.USING.rawValue,tsqlParser.Tokens.VAR.rawValue,tsqlParser.Tokens.VARP.rawValue,tsqlParser.Tokens.VIEWS.rawValue,tsqlParser.Tokens.VIEW_METADATA.rawValue,tsqlParser.Tokens.WORK.rawValue,tsqlParser.Tokens.XML.rawValue,tsqlParser.Tokens.XMLNAMESPACES.rawValue]
		 	              return  Utils.testBitLeftShiftArray(testArray, 426)
		 	          }()
		 	          testSet = testSet || _la == tsqlParser.Tokens.ID.rawValue
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Comparison_operatorContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_comparison_operator }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterComparison_operator(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitComparison_operator(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitComparison_operator(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitComparison_operator(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func comparison_operator() throws -> Comparison_operatorContext {
		var _localctx: Comparison_operatorContext = Comparison_operatorContext(_ctx, getState())
		try enterRule(_localctx, 482, tsqlParser.RULE_comparison_operator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4615)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,654, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4600)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4601)
		 		try match(tsqlParser.Tokens.GREATER.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4602)
		 		try match(tsqlParser.Tokens.LESS.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4603)
		 		try match(tsqlParser.Tokens.LESS.rawValue)
		 		setState(4604)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4605)
		 		try match(tsqlParser.Tokens.GREATER.rawValue)
		 		setState(4606)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(4607)
		 		try match(tsqlParser.Tokens.LESS.rawValue)
		 		setState(4608)
		 		try match(tsqlParser.Tokens.GREATER.rawValue)

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(4609)
		 		try match(tsqlParser.Tokens.EXCLAMATION.rawValue)
		 		setState(4610)
		 		try match(tsqlParser.Tokens.EQUAL.rawValue)

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(4611)
		 		try match(tsqlParser.Tokens.EXCLAMATION.rawValue)
		 		setState(4612)
		 		try match(tsqlParser.Tokens.GREATER.rawValue)

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(4613)
		 		try match(tsqlParser.Tokens.EXCLAMATION.rawValue)
		 		setState(4614)
		 		try match(tsqlParser.Tokens.LESS.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class Assignment_operatorContext:ParserRuleContext {
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_assignment_operator }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterAssignment_operator(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitAssignment_operator(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitAssignment_operator(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitAssignment_operator(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func assignment_operator() throws -> Assignment_operatorContext {
		var _localctx: Assignment_operatorContext = Assignment_operatorContext(_ctx, getState())
		try enterRule(_localctx, 484, tsqlParser.RULE_assignment_operator)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4617)
		 	_la = try _input.LA(1)
		 	if (!(//closure
		 	 { () -> Bool in
		 	      let testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, tsqlParser.Tokens.PLUS_ASSIGN.rawValue,tsqlParser.Tokens.MINUS_ASSIGN.rawValue,tsqlParser.Tokens.MULT_ASSIGN.rawValue,tsqlParser.Tokens.DIV_ASSIGN.rawValue,tsqlParser.Tokens.MOD_ASSIGN.rawValue,tsqlParser.Tokens.AND_ASSIGN.rawValue,tsqlParser.Tokens.XOR_ASSIGN.rawValue,tsqlParser.Tokens.OR_ASSIGN.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 506)
		 	}()
		 	      return testSet
		 	 }())) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}
	open class File_sizeContext:ParserRuleContext {
		open func DECIMAL() -> TerminalNode? { return getToken(tsqlParser.Tokens.DECIMAL.rawValue, 0) }
		open func KB() -> TerminalNode? { return getToken(tsqlParser.Tokens.KB.rawValue, 0) }
		open func MB() -> TerminalNode? { return getToken(tsqlParser.Tokens.MB.rawValue, 0) }
		open func GB() -> TerminalNode? { return getToken(tsqlParser.Tokens.GB.rawValue, 0) }
		open func TB() -> TerminalNode? { return getToken(tsqlParser.Tokens.TB.rawValue, 0) }
		open override func getRuleIndex() -> Int { return tsqlParser.RULE_file_size }
		override
		open func enterRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).enterFile_size(self)
			}
		}
		override
		open func exitRule(_ listener: ParseTreeListener) {
			if listener is tsqlListener {
			 	(listener as! tsqlListener).exitFile_size(self)
			}
		}
		override
		open func accept<T>(_ visitor: ParseTreeVisitor<T>) -> T? {
			if visitor is tsqlVisitor {
			     return (visitor as! tsqlVisitor<T>).visitFile_size(self)
			}else if visitor is tsqlBaseVisitor {
		    	 return (visitor as! tsqlBaseVisitor<T>).visitFile_size(self)
		    }
			else {
			     return visitor.visitChildren(self)
			}
		}
	}
	@discardableResult
	open func file_size() throws -> File_sizeContext {
		var _localctx: File_sizeContext = File_sizeContext(_ctx, getState())
		try enterRule(_localctx, 486, tsqlParser.RULE_file_size)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4619)
		 	try match(tsqlParser.Tokens.DECIMAL.rawValue)
		 	setState(4621)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (//closure
		 	 { () -> Bool in
		 	      var testSet: Bool = {  () -> Bool in
		 	   let testArray: [Int] = [_la, tsqlParser.Tokens.GB.rawValue,tsqlParser.Tokens.KB.rawValue,tsqlParser.Tokens.MB.rawValue]
		 	    return  Utils.testBitLeftShiftArray(testArray, 321)
		 	}()
		 	          testSet = testSet || _la == tsqlParser.Tokens.TB.rawValue
		 	          testSet = testSet || _la == tsqlParser.Tokens.MODULE.rawValue
		 	      return testSet
		 	 }()) {
		 		setState(4620)
		 		_la = try _input.LA(1)
		 		if (!(//closure
		 		 { () -> Bool in
		 		      var testSet: Bool = {  () -> Bool in
		 		   let testArray: [Int] = [_la, tsqlParser.Tokens.GB.rawValue,tsqlParser.Tokens.KB.rawValue,tsqlParser.Tokens.MB.rawValue]
		 		    return  Utils.testBitLeftShiftArray(testArray, 321)
		 		}()
		 		          testSet = testSet || _la == tsqlParser.Tokens.TB.rawValue
		 		          testSet = testSet || _la == tsqlParser.Tokens.MODULE.rawValue
		 		      return testSet
		 		 }())) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

    override
	open func sempred(_ _localctx: RuleContext?, _ ruleIndex: Int,  _ predIndex: Int)throws -> Bool {
		switch (ruleIndex) {
		case  136:
			return try expression_sempred(_localctx?.castdown(ExpressionContext.self), predIndex)
	    default: return true
		}
	}
	private func expression_sempred(_ _localctx: ExpressionContext!,  _ predIndex: Int) throws -> Bool {
		switch (predIndex) {
		    case 0:return precpred(_ctx, 6)
		    case 1:return precpred(_ctx, 4)
		    case 2:return precpred(_ctx, 3)
		    case 3:return precpred(_ctx, 2)
		    case 4:return precpred(_ctx, 13)
		    default: return true
		}
	}

   public static let _serializedATN : String = tsqlParserATN().jsonString
   public static let _ATN: ATN = ATNDeserializer().deserializeFromJson(_serializedATN)
}